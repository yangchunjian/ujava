<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.1" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://ujava.cn/principle/first.html"><meta property="og:site_name" content="UJava"><meta property="og:title" content="第一性原理:结构化抽象"><meta property="og:description" content="软件设计的第一性原理，是结构化抽象。术生于道，技术生于原理。 简介 所谓的第一性原理，就是无论使用什么方法论，都无法绕过的那最最基础的部分。无论是 DDD 设计，还是面向模式的架构设计，或 微服务架构，均建基于结构化抽象。 何为结构化抽象 ？ 先回答 “何为抽象” 与 “何为结构化” 两个问题。 何为抽象 ？ “设计原理:抽象” 一文阐述了什么是抽象及在编程与计算中的意义； “设计原理:代码抽象与分层” 则列举了从代码中提炼出来的六类抽象，涵盖了编程开发中常见的实体及处理。"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-03-03T03:00:03.000Z"><meta property="article:author" content="UJava"><meta property="article:modified_time" content="2024-03-03T03:00:03.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第一性原理:结构化抽象","image":[""],"dateModified":"2024-03-03T03:00:03.000Z","author":[{"@type":"Person","name":"UJava","url":"https://ujava.cn/article/"}]}</script><meta name="robots" content="all"><meta name="author" content="ujava"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="keywords" content="Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"><meta name="apple-mobile-web-app-capable" content="yes"><script>var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?d44ac18afe199d84cbb99448b4b9baec";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();</script><link rel="alternate" type="application/atom+xml" href="https://ujava.cn/atom.xml" title="UJava Atom Feed"><link rel="alternate" type="application/json" href="https://ujava.cn/feed.json" title="UJava JSON Feed"><link rel="alternate" type="application/rss+xml" href="https://ujava.cn/rss.xml" title="UJava RSS Feed"><link rel="icon" href="/favicon.ico"><title>第一性原理:结构化抽象 | UJava</title><meta name="description" content="软件设计的第一性原理，是结构化抽象。术生于道，技术生于原理。 简介 所谓的第一性原理，就是无论使用什么方法论，都无法绕过的那最最基础的部分。无论是 DDD 设计，还是面向模式的架构设计，或 微服务架构，均建基于结构化抽象。 何为结构化抽象 ？ 先回答 “何为抽象” 与 “何为结构化” 两个问题。 何为抽象 ？ “设计原理:抽象” 一文阐述了什么是抽象及在编程与计算中的意义； “设计原理:代码抽象与分层” 则列举了从代码中提炼出来的六类抽象，涵盖了编程开发中常见的实体及处理。">
    <link rel="preload" href="/assets/style-JZCuSqCM.css" as="style"><link rel="stylesheet" href="/assets/style-JZCuSqCM.css">
    <link rel="modulepreload" href="/assets/app-_4IpmVeT.js"><link rel="modulepreload" href="/assets/first.html-1TrnfMus.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js"><link rel="modulepreload" href="/assets/first.html-DPVk60E4.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="/logo/logo.svg" alt="UJava"><!----><span class="vp-site-name hide-in-pad">UJava</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="快速上手" class="vp-link nav-link nav-link" href="/required/"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span>快速上手<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="设计思想" class="vp-link nav-link nav-link" href="/mind/"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span>设计思想<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="设计模式" class="vp-link nav-link nav-link" href="/design/"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span>设计模式<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="网站相关"><span class="title"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span>网站相关</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="关于作者" class="vp-link nav-link nav-link" href="/author/"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span>关于作者<!----></a></li><li class="dropdown-item"><a aria-label="更新历史" class="vp-link nav-link nav-link" href="/timeline/"><span class="font-icon icon fa-fw fa-sm fas fa-history" style=""></span>更新历史<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><!----><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">必读</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计思想</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计原理</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="第一性原理:结构化抽象" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/principle/first.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>第一性原理:结构化抽象<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="理念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/principle/first.html#理念"><!---->理念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="实践" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/principle/first.html#实践"><!---->实践<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="经验与洞见" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/principle/first.html#经验与洞见"><!---->经验与洞见<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a aria-label="设计原理:UML图" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/uml.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:UML图<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:从指令到软件" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/five.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:从指令到软件<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:代码可复用性问题兼谈团队协作" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/eight.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:代码可复用性问题兼谈团队协作<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:代码抽象与分层" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/third.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:代码抽象与分层<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:六大设计原则" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/theory.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:六大设计原则<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:回调" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/callback.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:回调<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:基本陷阱、原理及解决方案" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/concurrency-faq.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:基本陷阱、原理及解决方案<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:如何表达和维护大型逻辑" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/seven.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:如何表达和维护大型逻辑<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:定时器" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/nine.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:定时器<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:对象与并发" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/obj.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:对象与并发<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:并发" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/concurrency.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:并发<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:抽象" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/second.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:抽象<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:架构模式" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/six.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:架构模式<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-label="设计原理:编程概要" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/principle/four.html"><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>设计原理:编程概要<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计模式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计规范</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计高频</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计算法</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon fa-fw fa-sm fas fa-star" style=""></span><span class="vp-sidebar-title">设计Java</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span>第一性原理:结构化抽象</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://ujava.cn/article/" target="_blank" rel="noopener noreferrer">UJava</a></span><span property="author" content="UJava"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-10-31T11:10:45.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 16 分钟</span><meta property="timeRequired" content="PT16M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category5 clickable" role="navigation">设计原理</span><!--]--><meta property="articleSection" content="设计原理"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#理念">理念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#实践">实践</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#经验与洞见">经验与洞见</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><blockquote><p>软件设计的第一性原理，是结构化抽象。术生于道，技术生于原理。</p></blockquote><h1 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h1><p>所谓的第一性原理，就是无论使用什么方法论，都无法绕过的那最最基础的部分。无论是 DDD 设计，还是面向模式的架构设计，或<br> 微服务架构，均建基于结构化抽象。</p><p>何为结构化抽象 ？ 先回答 “何为抽象” 与 “何为结构化” 两个问题。</p><p>何为抽象 ？ “<a href="/principle/second.html" class="">设计原理:抽象</a>” 一文阐述了什么是抽象及在编程与计算中的意义； “<a href="/principle/third.html" class="">设计原理:代码抽象与分层</a>”<br> 则列举了从代码中提炼出来的六类抽象，涵盖了编程开发中常见的实体及处理。</p><p>何为结构化 ？ 结构，是事物的组成元素及关联和作用。 “<a href="/principle/four.html" class="">设计原理:编程概要</a>” 一文阐述了编程中的各种数据结构及控制结构，“<a href="/principle/five.html" class="">设计原理:从指令到软件</a>”<br> 则阐述了组合元素的方法与结构。结构化，分为数据结构化和控制结构化。数据结构化指海量数据的组织和存储及需要满足的约束（比如一致性、完整性等）；控制结构化，是指，操作的组织和执行以及需要满足的约束。</p><p>软件，本质上是一种可动态而弹性变化的逻辑装置。结构化，即是将逻辑进行抽象、提炼、分离、聚合，构建成更加缜密、动态、弹性的结构流。</p><p>逻辑，是思维意识的一种形式。软件设计与开发，是与自己的思维意识进行抗争与和解。</p><h2 id="理念" tabindex="-1"><a class="header-anchor" href="#理念" aria-hidden="true">#</a> 理念</h2><h4 id="设计与开发" tabindex="-1"><a class="header-anchor" href="#设计与开发" aria-hidden="true">#</a> 设计与开发</h4><p>软件设计与开发工作渗透着结构化抽象的思想。譬如：</p><ul><li>软件建模。是对大量原始数据进行结构化组织，使之更加有序、有意义、可交互。</li><li>数据存取。在建立对数据的组织抽象之后，就要进行数据的存取操作。数据是规则的还是不规则的 ？ 数据量有多少及增长速度如何 ？</li><li>是否要进行缓存 ？ 选取合适的数据存储组件。数据存储组件是对海量数据存储和访问的结构化抽象。</li><li>流程构造。在确定数据存取方案后，需要构建完整的流程。流程可以使用时序图来表示。流程包含前置、操作与契约。前置，是进行操作需要满足的条件；操作则是获取数据或请求某种执行；契约，是在完成操作之后，必须满足的一系列断言。完整流程通常是：“前置-操作-契约”的子流程的有序组合。</li><li>编程实现。需要评估潜在变化的部分，将通用的部分与易变化的部分相分离。</li></ul><h4 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h4><p>设计模式是对象职责及交互的结构化抽象，是体现结构化抽象思想的基本单元。可参阅：“<a href="/design/" class="">设计模式</a>” 。</p><p>架构模式是基于设计模式的更高层次的结构化抽象。可参阅：“<a href="/principle/six.html" class="">设计原理:架构模式</a>” 。</p><p>设计模式和架构模式主要应对软件的业务可扩展性难题。</p><h4 id="技术机制" tabindex="-1"><a class="header-anchor" href="#技术机制" aria-hidden="true">#</a> 技术机制</h4><p>在软件设计中，技术是绕不开的一道槛。技术的作用在于，在指定的场景下，所执行的操作效果必须满足某种约束。技术机制，是将多个相关联的结构化抽象进行聚合后的成品。</p><h4 id="异步" tabindex="-1"><a class="header-anchor" href="#异步" aria-hidden="true">#</a> 异步</h4><p>比如先快速响应客户端，再进行请求处理。其结构化抽象是，操作相对于主进程的执行耗时与实际执行耗时无关。</p><h4 id="幂等" tabindex="-1"><a class="header-anchor" href="#幂等" aria-hidden="true">#</a> 幂等</h4><p>比如处理资金问题，必须考虑幂等问题，即同一个请求，执行多次的效果必须与执行一次的效果等同。幂等的结构化抽象是，操作的主效果与操作次数无关。</p><h4 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h4><p>比如多个关联数据的插入、更新和删除，必须保证原子性。要么全部执行，要么一个都不执行。需要使用事务来保证。事务的特性是ACID，结构化抽象是关联数据集合在操作前后必须满足某种一致性约束。确定“关联数据集的一致性约束”是关键，其实现是还原点、快照与回滚日志。</p><h4 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h4><p>大量请求或数据集的处理，使用串行的方式效率难以满足性能或吞吐量要求，需使用并发的方式，充分利用多核CPU资源。结构化抽象是，多个相互独立的执行单元。这些执行单元拥有独立的CPU和缓存，所使用的内存可以为共享内存型和独立内存型。</p><h4 id="同步" tabindex="-1"><a class="header-anchor" href="#同步" aria-hidden="true">#</a> 同步</h4><p>在并发场景下，要保证多个执行单元（比如线程、进程等）能够看到共享内存的最新更新值。同步的本质是确保指定顺序执行，避免不确定的执行顺序带来不确定性的结果。其结构化抽象是临界区。临界区是约束执行顺序的一种结构。</p><h4 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h4><p>应用的组件、配置与启动，可以做成通用的框架和脚手架反复使用，快速启动和部署一项工程，减少不必要的重复工作量。框架的结构化抽象是，将工程中的配置、部署与启动、运行结构、通用任务进行提炼并形成固定的模式，应用只需要关注可变的业务部分。</p><h4 id="限流" tabindex="-1"><a class="header-anchor" href="#限流" aria-hidden="true">#</a> 限流</h4><p>突发的峰值流量，为了避免瞬间占满和击垮服务器的资源和服务能力，需要进行限流。其结构化抽象是，在指定时间间隔内的通过许可数必须满足指定规格。</p><h4 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h4><p>对于热点数据，为了避免反复从源存储获取，增大对存储的访问压力，可以使用缓存来存储热点数据，增大命中率，提升性能，减少对存储的不必要的访问压力。缓存的结构化抽象是，使用少而精的空间优先于大而全的空间的搜索。“少而精”是指聚焦应用的经常被访问的热点数据。缓存的衡量指标是命中率和过期时间，操作是缓存与源存储的读写同步。</p><h4 id="降级" tabindex="-1"><a class="header-anchor" href="#降级" aria-hidden="true">#</a> 降级</h4><p>当非核心的依赖不可用时，可以及时切断依赖，舍小取大，保证整体服务正常运行，不受局部影响。降级的结构化抽象是，是主备策略的设计与切换机制。</p><h4 id="重试" tabindex="-1"><a class="header-anchor" href="#重试" aria-hidden="true">#</a> 重试</h4><p>当处理数据发生错误时，可以进行重试来进行补偿和恢复。 重试的结构化抽象是，至少（且通常只需）保证一次操作成功。</p><h4 id="切面" tabindex="-1"><a class="header-anchor" href="#切面" aria-hidden="true">#</a> 切面</h4><p>比如耗时统计。耗时统计与操作的执行内容无关，仅关注操作的耗时。切面的结构化抽象是，操作的非功能属性与功能本身的解耦。</p><h4 id="代理" tabindex="-1"><a class="header-anchor" href="#代理" aria-hidden="true">#</a> 代理</h4><p>比如请求的负载均衡。不是直接执行目标操作，而是创建一个代理，由这个代理转发请求和执行目标操作。代理的结构化抽象是，隐藏目标操作。</p><h4 id="版本号" tabindex="-1"><a class="header-anchor" href="#版本号" aria-hidden="true">#</a> 版本号</h4><p>版本号通常用于实现非阻塞式并发，即乐观锁。其结构化抽象是，一个严格保证特征数值单调递增的机制。</p><h2 id="实践" tabindex="-1"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2><h4 id="示例分析" tabindex="-1"><a class="header-anchor" href="#示例分析" aria-hidden="true">#</a> 示例分析</h4><p>要对问题进行结构化抽象，需要先提取问题的结构特征。可以分别从数据结构化和操作结构化两个角度来思考。</p><h4 id="分页" tabindex="-1"><a class="header-anchor" href="#分页" aria-hidden="true">#</a> 分页</h4><p>比如分页功能是大多数信息系统管理的必备功能之一。 怎么实现一个通用的分页功能呢 ？</p><p>从数据结构化来思考，其结构要素为：偏移量、页大小、起始和结束位置。 分页本身和获取何种对象无关。</p><p>从操作结构化来思考，其结构要素为：1. select columns from table where condition limit offset, size ; 2. count distinct(id)<br> from table where condition limit offset, size .</p><p>columns , table, condition 都是可以根据具体业务来动态生成的，而整个 SQL 的骨架是固定的。 table 不一定指 DB , select ,<br> count 也不一定是 DB 的 sql ，它只是表示在指定搜索条件下进行对象选择与统计的操作语义。 columns , table, cond<br> 的动态生成，可以使用泛型和回调函数来传入和处理。</p><h4 id="限购" tabindex="-1"><a class="header-anchor" href="#限购" aria-hidden="true">#</a> 限购</h4><p>限购，是指定时间内，指定 key 的实体允许通过的许可数量。与限流是同一类结构化抽象。 许可数量，是一个全局性约束。</p><p>假设去掉“指定时间”的约束，只限制许可数量， 其结构化抽象是，dec if total - count(key) &gt; 0. 并发的场景下，total - count(key) &gt;<br> 0 的值需要进行全局同步。</p><p>如果加上“指定时间”的约束，还需要考虑高并发场景下 dec if total - count(key) &gt; 0 的操作耗时。如果指定时间内不允许超过限购数量（强约束），则必须对<br> dec if total - count(key) &gt; 0 进行加锁，吞吐量取决于操作耗时而不是指定的限购数；如果指定时间内可允许暂时地超过限购数量（弱约束），则可参考限流算法。</p><h4 id="数据同步" tabindex="-1"><a class="header-anchor" href="#数据同步" aria-hidden="true">#</a> 数据同步</h4><p>数据同步的结构化抽象是，将源存储 S1, S2, ..., Sn 的数据复制到目标存储 D 。</p><p>数据同步分为两种不同的场景，有实时同步和离线同步。实时同步对数据延迟性容忍非常低，离线同步则要求更快的吞吐量。</p><p>实时同步通常采用流式同步，通过接收消息流来处理。 操作的结构化是，Receiver (msg) -&gt; Format(msg) -&gt; Save for each msg . msg<br> 是源存储中的一条数据或一个单位数据集。</p><p>离线同步通常采用批量处理，实现方式是批量获取数据并批量格式化后存储。 操作的结构化是，Divide(S) into N part(S) ; Select<br> part(S) Then Format part(S) and Save for each part(S) 。 可以根据业务唯一 ID 实现一个通用的 Divide 算法。</p><p>离线同步要注意 format<br> 的超时和健壮性处理，记录下异常以便重试，同时不因单个数据处理失败而中断整体流程；流式同步则要注意控制好并发情形下的准确性。由于对吞吐量要求比较高，往往采用乐观锁的方式，找到某种能够控制全局版本号单调递增的机制，或者尽量避免“多表同步到单表”的场景【并发场景下会带来更多复杂性】。</p><p>积累抽象</p><p>在实际工作中，可以反思和提炼设计中所用到的结构化抽象。如果现有的结构化抽象及组合难以解决问题，是否需要新的结构化抽象<br> ？创建新的结构化抽象，并使之与已有的进行组合和集成。</p><h4 id="规模化挑战" tabindex="-1"><a class="header-anchor" href="#规模化挑战" aria-hidden="true">#</a> 规模化挑战</h4><p>如果程序媛猿面对的是几万的数据量，那是可以夜夜笙歌的。然而，现实情况是，面对的是亿级以上规模的数据量，且数据量仍然在指数级增长。为了人类社会的无理性发展，程序媛猿们真是费尽了心思花白了头。</p><p>为了应对亿级规模的数据量，并发、分布式等方案层出不穷，结合变化的业务场景，又衍生出更多的挠人烧脑的复杂问题。如何应对呢？</p><p>规模化挑战的结构化抽象是，在指定时间内，每秒处理的请求/单位数据集的吞吐量，处理一个请求或单位数据集的平均响应时间，以及在流量剧烈变化时的弹性扩展能力。</p><h4 id="并发-1" tabindex="-1"><a class="header-anchor" href="#并发-1" aria-hidden="true">#</a> 并发</h4><p>并发和并行机制取代了串行机制。单CPU和单机的性能基本抵达瓶颈，只能从多核CPU和多机上想办法。将要处理的数据量分解为多个相互独立的子数据集，并在不同的执行实体里相互独立地执行。比如线程池，Fork/Join ，<br> Map-Reduce 执行模型。 并发和并行虽然解决了单机性能不足的问题，却引发了更多的问题。</p><h4 id="同步-1" tabindex="-1"><a class="header-anchor" href="#同步-1" aria-hidden="true">#</a> 同步</h4><p>有了并发执行之后，由于有些资源是共享的，而一些热点数据往往被多个执行实体同时读取和修改，又产生了竞争问题。<br> 为了解决竞争，引入了同步机制。大量对同一资源、数据的操作进行同步，引起性能问题。</p><h4 id="缓存-1" tabindex="-1"><a class="header-anchor" href="#缓存-1" aria-hidden="true">#</a> 缓存</h4><p>对于热点数据的读取和操作，通过“空间换时间”的策略，使用缓存来提升性能，降低对源存储的访问压力。</p><h4 id="限流-1" tabindex="-1"><a class="header-anchor" href="#限流-1" aria-hidden="true">#</a> 限流</h4><p>由于允许并发请求进入，则必须应对瞬间的峰值流量（可见世态）。限流必须有度，不能因噎废食。<br> 需要对系统承载的负荷及极限负荷进行测量，根据测量值来确定一个可动态调整的限流值。极限负荷测量即是压测。</p><h4 id="降级-1" tabindex="-1"><a class="header-anchor" href="#降级-1" aria-hidden="true">#</a> 降级</h4><p>由于业务特性的不同，环境的不稳定波动，以及采用方案的局限性，依赖服务有可能出现部分失败，对于调用极其频繁的服务来说，依赖服务的少许失败可能导致上层的雪崩效应。因此在依赖服务出现问题时，必须进行适当的降级熔断。</p><h4 id="测量" tabindex="-1"><a class="header-anchor" href="#测量" aria-hidden="true">#</a> 测量</h4><p>为了避免大流量或大数据结构导致软件运行出现问题，降低维护成本，不能仅仅停留在定性分析上，还要进行量化。需要对系统进行仔细的测量。服务接口的<br> RT 和 吞吐量 如何 ？存取操作耗时如何 ？ 消息处理耗时和吞吐量如何 ？ 内存占用如何 ？ 大数据对象占用内存多大<br> ？能够承载的极限流量有多大 ？ 能够承载的极限对象大小是多大 ？ 指定时间段的失败数和失败率有多大 ？</p><h4 id="集群" tabindex="-1"><a class="header-anchor" href="#集群" aria-hidden="true">#</a> 集群</h4><p>若以单机视角去考虑问题，就会殚精竭虑地在“并发、同步、缓存、限流、降级”等上做到极致，就像在单核时代将CPU主频做到极致一样。然而，即使做到极致，为了峰值流量所构建的机器资源，在平均流量场景下会造成很大的浪费；并且，很难预估峰值流量会在什么时候来到。如果有一个超级大的聚合的池化资源，总可以提供足够强大而弹性的CPU计算能力、内存能力、磁盘空间，那么以上规模化引起的问题也将迎刃而解。这个超级大的聚合的池化资源，就来自于构成集群的分布式系统的资源虚拟化后的能力，即云计算能力。</p><h4 id="可视化" tabindex="-1"><a class="header-anchor" href="#可视化" aria-hidden="true">#</a> 可视化</h4><p>为了从数据集中发现整体性的规律和趋势，通过将大量数据集进行可视化，拥有一个简明的全局视角。</p><h4 id="ai" tabindex="-1"><a class="header-anchor" href="#ai" aria-hidden="true">#</a> AI</h4><p>以数据为基础，以规则集为准绳，训练机器通过基本的规则集与数据的计算而获得某种“学习”能力，从而能够分析更多的数据集，调整现实活动和方式，获得人力所无法得到的见解和经济效益。</p><h2 id="经验与洞见" tabindex="-1"><a class="header-anchor" href="#经验与洞见" aria-hidden="true">#</a> 经验与洞见</h2><p>招聘或找工作的人，常常说要“工作经验多少年才行”，然而，在软件设计中，却容易“有经验而无洞见”。</p><p>经验是什么？ 经验是工作中遇到的问题及解决方案。有些问题，只有在规模达到足够大的时候才会出现；而大多数问题，只要根据原理就能推导出来。在软件世界里，并没有一成不变的最佳经验。</p><p>洞见是什么？ 洞见来自于究根追源，从最基本的公理进行推导得出定理和定律，从而能够预知问题。逻辑，本质上是一种数学结构，而数学正是能够进行推导的严密思维体系。</p><p>软件设计的洞见来自哪里 ？ 究根追源，软件逻辑建始于两条公理：</p><ul><li>1 + 1 = 2</li><li>机器的字长有限，内存有限； 执行指令需要 CPU 时钟周期</li></ul><p>几乎所有软件问题都是这两个基本要素的组合和叠加而产生的。软件设计崇尚“自顶向下”的方式，然而，要获得洞见，却需要“自底向上”的思考和推导，通过多个层次的结构化抽象来建立。万变不离其宗。</p><p>注意到，第二条公理描述了现实系统的局限性。 局限性，正是经验的用武之地。</p><p>在初期，可以 80% 依据经验，20% 依据原理；而在后期，则应该 80% 依靠原理，20% 依靠经验。 那么，不依靠经验应该怎么做呢 ？ 举一个<br> API 调用的例子。 可以测量这个 API 的平均耗时，耗时分布，大体了解这个 API 的对外输出指标。API 超时是因为什么呢<br> ？可能是网络环境波动导致。很难通过设计和开发优化环境的波动。如果不是，从 API 的实现层面来说，很可能是因为并发的大流量导致了竞争加剧，线程死锁或者大量线程阻塞。API<br> 超时又会导致多个子系统间数据不一致。 可见，并发与大流量，是系统必须要面对的“对手”。 并发与大流量一定需要通过工作经验来获得吗？非也。并发与大流量的场景是可以模拟的。</p><p>可以通过原理推导，结合实验，来模拟各种现实场景，测量数据， 并制订应对方案。 这是细功夫，也是洞见的产生之源。</p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>本文阐述了软件设计中的结构化抽象的理念及实践方法，涉及设计与开发、设计模式、技术机制、示例分析、规模化挑战，及设计中的经验与洞见。结构化，即是将逻辑进行抽象、提炼、分离、聚合，构建成更加缜密、动态、弹性的结构流。</p><p>做软件设计，要同时看到骷髅与美人。论理，要看到骷髅；论情，要看到美人。理，即是结构化抽象。</p></div><!--[--><!----><!--]--><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1091938307@qq.com">yangchunjian</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><!----><a aria-label="设计原理:UML图" class="vp-link nav-link next nav-link next" href="/principle/uml.html"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">设计原理:UML图<span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2024 UJava</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-_4IpmVeT.js" defer></script>
  </body>
</html>
