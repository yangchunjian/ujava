<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://ujava.cn/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://ujava.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>UJava</title>
    <link>https://ujava.cn/</link>
    <description> 【Java学习 + Java面试】首选UJava！  </description>
    <language>zh-CN</language>
    <pubDate>Mon, 04 Mar 2024 03:08:06 GMT</pubDate>
    <lastBuildDate>Mon, 04 Mar 2024 03:08:06 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>设计模式</category>
    <category>设计高频</category>
    <category>Java</category>
    <item>
      <title>页面对象(Page Object)模式</title>
      <link>https://ujava.cn/design/other/pageobject.html</link>
      <guid>https://ujava.cn/design/other/pageobject.html</guid>
      <source url="https://ujava.cn/rss.xml">页面对象(Page Object)模式</source>
      <description>概述 Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI 组件。这样一来，它允许测试类本身专注于测试逻辑。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>
组件。这样一来，它允许测试类本身专注于测试逻辑。</p>
]]></content:encoded>
    </item>
    <item>
      <title>参数对象(Parameter Object)模式</title>
      <link>https://ujava.cn/design/other/parameterobject.html</link>
      <guid>https://ujava.cn/design/other/parameterobject.html</guid>
      <source url="https://ujava.cn/rss.xml">参数对象(Parameter Object)模式</source>
      <description>概述 Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>
]]></content:encoded>
    </item>
    <item>
      <title>部分响应(Partial Response)模式</title>
      <link>https://ujava.cn/design/other/partialresponse.html</link>
      <guid>https://ujava.cn/design/other/partialresponse.html</guid>
      <source url="https://ujava.cn/rss.xml">部分响应(Partial Response)模式</source>
      <description>概述 根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title>管道(Pipeline)模式</title>
      <link>https://ujava.cn/design/other/pipeline.html</link>
      <guid>https://ujava.cn/design/other/pipeline.html</guid>
      <source url="https://ujava.cn/rss.xml">管道(Pipeline)模式</source>
      <description>概述 通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>
]]></content:encoded>
    </item>
    <item>
      <title>毒丸(Poison Pill)模式</title>
      <link>https://ujava.cn/design/other/poisonpill.html</link>
      <guid>https://ujava.cn/design/other/poisonpill.html</guid>
      <source url="https://ujava.cn/rss.xml">毒丸(Poison Pill)模式</source>
      <description>概述 毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>
]]></content:encoded>
    </item>
    <item>
      <title>演示模型(Presentation Model)模式</title>
      <link>https://ujava.cn/design/other/presentationmodel.html</link>
      <guid>https://ujava.cn/design/other/presentationmodel.html</guid>
      <source url="https://ujava.cn/rss.xml">演示模型(Presentation Model)模式</source>
      <description>概述 演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>优先级队列(Priority Queue)模式</title>
      <link>https://ujava.cn/design/other/priorityqueue.html</link>
      <guid>https://ujava.cn/design/other/priorityqueue.html</guid>
      <source url="https://ujava.cn/rss.xml">优先级队列(Priority Queue)模式</source>
      <description>概述 对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>私有类数据(Private Class Data)模式</title>
      <link>https://ujava.cn/design/other/privateclassdata.html</link>
      <guid>https://ujava.cn/design/other/privateclassdata.html</guid>
      <source url="https://ujava.cn/rss.xml">私有类数据(Private Class Data)模式</source>
      <description>概述 私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>
]]></content:encoded>
    </item>
    <item>
      <title>生产者消费者(Producer Consumer)模式</title>
      <link>https://ujava.cn/design/other/producerconsumer.html</link>
      <guid>https://ujava.cn/design/other/producerconsumer.html</guid>
      <source url="https://ujava.cn/rss.xml">生产者消费者(Producer Consumer)模式</source>
      <description>概述 生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>
]]></content:encoded>
    </item>
    <item>
      <title>承诺(Promise)模式</title>
      <link>https://ujava.cn/design/other/promise.html</link>
      <guid>https://ujava.cn/design/other/promise.html</guid>
      <source url="https://ujava.cn/rss.xml">承诺(Promise)模式</source>
      <description>概述 Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>属性(Property)模式</title>
      <link>https://ujava.cn/design/other/property.html</link>
      <guid>https://ujava.cn/design/other/property.html</guid>
      <source url="https://ujava.cn/rss.xml">属性(Property)模式</source>
      <description>概述 使用现有对象作为父对象创建对象和新对象的层次结构。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>
]]></content:encoded>
    </item>
    <item>
      <title>基于队列的负载均衡(Queue based load leveling)模式</title>
      <link>https://ujava.cn/design/other/queuebasedloadlevel.html</link>
      <guid>https://ujava.cn/design/other/queuebasedloadlevel.html</guid>
      <source url="https://ujava.cn/rss.xml">基于队列的负载均衡(Queue based load leveling)模式</source>
      <description>概述 使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 03:06:02 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>
]]></content:encoded>
    </item>
    <item>
      <title>页面控制(Page Controller)模式</title>
      <link>https://ujava.cn/design/other/pagecontroller.html</link>
      <guid>https://ujava.cn/design/other/pagecontroller.html</guid>
      <source url="https://ujava.cn/rss.xml">页面控制(Page Controller)模式</source>
      <description>概述 这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 02:16:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>
]]></content:encoded>
    </item>
    <item>
      <title>层模式</title>
      <link>https://ujava.cn/design/other/layers.html</link>
      <guid>https://ujava.cn/design/other/layers.html</guid>
      <source url="https://ujava.cn/rss.xml">层模式</source>
      <description>概述 层是一种体系结构模式，其中软件职责在不同的 应用程序的层。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>层是一种体系结构模式，其中软件职责在不同的</p>
<p>应用程序的层。</p>
]]></content:encoded>
    </item>
    <item>
      <title>懒加载模式</title>
      <link>https://ujava.cn/design/other/lazyloading.html</link>
      <guid>https://ujava.cn/design/other/lazyloading.html</guid>
      <source url="https://ujava.cn/rss.xml">懒加载模式</source>
      <description>概述 延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>
]]></content:encoded>
    </item>
    <item>
      <title>领导者选举模式</title>
      <link>https://ujava.cn/design/other/leaderelection.html</link>
      <guid>https://ujava.cn/design/other/leaderelection.html</guid>
      <source url="https://ujava.cn/rss.xml">领导者选举模式</source>
      <description>概述 领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>
]]></content:encoded>
    </item>
    <item>
      <title>领导者跟随者模式</title>
      <link>https://ujava.cn/design/other/leaderfollowers.html</link>
      <guid>https://ujava.cn/design/other/leaderfollowers.html</guid>
      <source url="https://ujava.cn/rss.xml">领导者跟随者模式</source>
      <description>概述 领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>
]]></content:encoded>
    </item>
    <item>
      <title>锁定对象模式</title>
      <link>https://ujava.cn/design/other/lockableobject.html</link>
      <guid>https://ujava.cn/design/other/lockableobject.html</guid>
      <source url="https://ujava.cn/rss.xml">锁定对象模式</source>
      <description>概述 可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>
]]></content:encoded>
    </item>
    <item>
      <title>日志整合模式</title>
      <link>https://ujava.cn/design/other/logaggregation.html</link>
      <guid>https://ujava.cn/design/other/logaggregation.html</guid>
      <source url="https://ujava.cn/rss.xml">日志整合模式</source>
      <description>概述 集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>
]]></content:encoded>
    </item>
    <item>
      <title>标记接口模式</title>
      <link>https://ujava.cn/design/other/markerinterface.html</link>
      <guid>https://ujava.cn/design/other/markerinterface.html</guid>
      <source url="https://ujava.cn/rss.xml">标记接口模式</source>
      <description>概述 使用空界面作为标记来区分经过特殊处理的对象。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>使用空界面作为标记来区分经过特殊处理的对象。</p>
]]></content:encoded>
    </item>
    <item>
      <title>主从模式</title>
      <link>https://ujava.cn/design/other/masterworker.html</link>
      <guid>https://ujava.cn/design/other/masterworker.html</guid>
      <source url="https://ujava.cn/rss.xml">主从模式</source>
      <description>概述 当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>
]]></content:encoded>
    </item>
    <item>
      <title>元数据对象关系映射模式</title>
      <link>https://ujava.cn/design/other/metadatamapping.html</link>
      <guid>https://ujava.cn/design/other/metadatamapping.html</guid>
      <source url="https://ujava.cn/rss.xml">元数据对象关系映射模式</source>
      <description>概述 保存元数据中对象关系映射的详细信息。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>保存元数据中对象关系映射的详细信息。</p>
]]></content:encoded>
    </item>
    <item>
      <title></title>
      <link>https://ujava.cn/design/other/module.html</link>
      <guid>https://ujava.cn/design/other/module.html</guid>
      <source url="https://ujava.cn/rss.xml"></source>
      <description>title: 模块模式 icon: laptop-code category: 设计模式 tag: 设计模式 概述 模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</description>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<p>title: 模块模式<br>
icon: laptop-code<br>
category:</p>
<ul>
<li>设计模式<br>
tag:</li>
<li>设计模式</li>
</ul>
<hr>
<h2> 概述</h2>
<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>单体(monad)模式</title>
      <link>https://ujava.cn/design/other/monad.html</link>
      <guid>https://ujava.cn/design/other/monad.html</guid>
      <source url="https://ujava.cn/rss.xml">单体(monad)模式</source>
      <description>概述 基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。 从形式上讲，monad 由一个类型构造函数 M 和两个操作组成： bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>
<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>
<ul>
<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>
<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>单态(MonoState)模式</title>
      <link>https://ujava.cn/design/other/monostate.html</link>
      <guid>https://ujava.cn/design/other/monostate.html</guid>
      <source url="https://ujava.cn/rss.xml">单态(MonoState)模式</source>
      <description>概述 强制执行一种行为，例如在所有实例之间共享相同的状态。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>
]]></content:encoded>
    </item>
    <item>
      <title>多态(Multiton)模式</title>
      <link>https://ujava.cn/design/other/multiton.html</link>
      <guid>https://ujava.cn/design/other/multiton.html</guid>
      <source url="https://ujava.cn/rss.xml">多态(Multiton)模式</source>
      <description>概述 确保类只有有限数量的实例，并提供对它们的全局访问点。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>
]]></content:encoded>
    </item>
    <item>
      <title>静音(Mute Idiom)模式</title>
      <link>https://ujava.cn/design/other/muteidiom.html</link>
      <guid>https://ujava.cn/design/other/muteidiom.html</guid>
      <source url="https://ujava.cn/rss.xml">静音(Mute Idiom)模式</source>
      <description>概述 提供一个模板来抑制任何已声明但不能发生或只应记录的异常； 同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>
同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>
]]></content:encoded>
    </item>
    <item>
      <title>模型视图控制器(MVC)模式</title>
      <link>https://ujava.cn/design/other/mvc.html</link>
      <guid>https://ujava.cn/design/other/mvc.html</guid>
      <source url="https://ujava.cn/rss.xml">模型视图控制器(MVC)模式</source>
      <description>概述 将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>
]]></content:encoded>
    </item>
    <item>
      <title>模型视图反应(MVI)模式</title>
      <link>https://ujava.cn/design/other/mvi.html</link>
      <guid>https://ujava.cn/design/other/mvi.html</guid>
      <source url="https://ujava.cn/rss.xml">模型视图反应(MVI)模式</source>
      <description>概述 MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>模型视图分离(MVP)模式</title>
      <link>https://ujava.cn/design/other/mvp.html</link>
      <guid>https://ujava.cn/design/other/mvp.html</guid>
      <source url="https://ujava.cn/rss.xml">模型视图分离(MVP)模式</source>
      <description>概述 应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>
]]></content:encoded>
    </item>
    <item>
      <title>模型视图视图模型(MVVM)模式</title>
      <link>https://ujava.cn/design/other/mvvm.html</link>
      <guid>https://ujava.cn/design/other/mvvm.html</guid>
      <source url="https://ujava.cn/rss.xml">模型视图视图模型(MVVM)模式</source>
      <description>概述 应用“关注点分离”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>应用“<a href="https://java-design-patterns.comprinciplesseparate-of-concerns" target="_blank" rel="noopener noreferrer">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>
]]></content:encoded>
    </item>
    <item>
      <title>裸对象(Naked Objects)模式</title>
      <link>https://ujava.cn/design/other/nakedobjects.html</link>
      <guid>https://ujava.cn/design/other/nakedobjects.html</guid>
      <source url="https://ujava.cn/rss.xml">裸对象(Naked Objects)模式</source>
      <description>概述 裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。 裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。 裸对象模式具有许多优点，包括： 1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。 2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。 3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<ul>
<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>
<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>
<li>裸对象模式具有许多优点，包括：
<ul>
<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>
<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>
<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>对象母亲(Object Mother)模式</title>
      <link>https://ujava.cn/design/other/objectmother.html</link>
      <guid>https://ujava.cn/design/other/objectmother.html</guid>
      <source url="https://ujava.cn/rss.xml">对象母亲(Object Mother)模式</source>
      <description>概述 它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>
]]></content:encoded>
    </item>
    <item>
      <title>对象池(Object Pool)模式</title>
      <link>https://ujava.cn/design/other/objectpool.html</link>
      <guid>https://ujava.cn/design/other/objectpool.html</guid>
      <source url="https://ujava.cn/rss.xml">对象池(Object Pool)模式</source>
      <description>概述 当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>乐观线下锁(Optimistic Offline Lock)模式</title>
      <link>https://ujava.cn/design/other/optimisticofflinelock.html</link>
      <guid>https://ujava.cn/design/other/optimisticofflinelock.html</guid>
      <source url="https://ujava.cn/rss.xml">乐观线下锁(Optimistic Offline Lock)模式</source>
      <description>概述 提供避免在关系数据库中同时更改一条记录的能力。</description>
      <category>设计模式</category>
      <pubDate>Mon, 04 Mar 2024 01:48:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>提供避免在关系数据库中同时更改一条记录的能力。</p>
]]></content:encoded>
    </item>
    <item>
      <title>flux模式</title>
      <link>https://ujava.cn/design/other/flux.html</link>
      <guid>https://ujava.cn/design/other/flux.html</guid>
      <source url="https://ujava.cn/rss.xml">flux模式</source>
      <description>概述 Flux避开MVC，转而支持单向数据流。当 用户与视图交互，视图通过中心传播动作 调度器，到保存应用程序数据和业务的各种存储 逻辑，更新所有受影响的视图。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>Flux避开MVC，转而支持单向数据流。当<br>
用户与视图交互，视图通过中心传播动作<br>
调度器，到保存应用程序数据和业务的各种存储<br>
逻辑，更新所有受影响的视图。</p>
]]></content:encoded>
    </item>
    <item>
      <title>flyweight模式</title>
      <link>https://ujava.cn/design/other/flyweight.html</link>
      <guid>https://ujava.cn/design/other/flyweight.html</guid>
      <source url="https://ujava.cn/rss.xml">flyweight模式</source>
      <description>概述 使用共享可以有效地支持大量细粒度对象。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>使用共享可以有效地支持大量细粒度对象。</p>
]]></content:encoded>
    </item>
    <item>
      <title>前端控制器模式</title>
      <link>https://ujava.cn/design/other/frontcontroller.html</link>
      <guid>https://ujava.cn/design/other/frontcontroller.html</guid>
      <source url="https://ujava.cn/rss.xml">前端控制器模式</source>
      <description>概述 为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>
]]></content:encoded>
    </item>
    <item>
      <title>游戏循环模式</title>
      <link>https://ujava.cn/design/other/gameloop.html</link>
      <guid>https://ujava.cn/design/other/gameloop.html</guid>
      <source url="https://ujava.cn/rss.xml">游戏循环模式</source>
      <description>概述 游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入 无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝 控制游戏的速率。 这种模式将游戏时间的进展与用户输入和处理器速度解耦。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>
<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>
<p>控制游戏的速率。</p>
<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>
]]></content:encoded>
    </item>
    <item>
      <title>保护性暂停模式</title>
      <link>https://ujava.cn/design/other/guardedsuspension.html</link>
      <guid>https://ujava.cn/design/other/guardedsuspension.html</guid>
      <source url="https://ujava.cn/rss.xml">保护性暂停模式</source>
      <description>概述 当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>
]]></content:encoded>
    </item>
    <item>
      <title>半同步半异步模式</title>
      <link>https://ujava.cn/design/other/halfsyncasync.html</link>
      <guid>https://ujava.cn/design/other/halfsyncasync.html</guid>
      <source url="https://ujava.cn/rss.xml">半同步半异步模式</source>
      <description>概述 半同步/半异步模式将同步I/O与 系统中的异步I/O，以简化并发编程工作，而不需要 从而降低执行效率。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>半同步/半异步模式将同步I/O与</p>
<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>
<p>从而降低执行效率。</p>
]]></content:encoded>
    </item>
    <item>
      <title>健康检查模式</title>
      <link>https://ujava.cn/design/other/healthcheck.html</link>
      <guid>https://ujava.cn/design/other/healthcheck.html</guid>
      <source url="https://ujava.cn/rss.xml">健康检查模式</source>
      <description>概述 通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>六边形体系结构模式</title>
      <link>https://ujava.cn/design/other/hexagonalarchitecture.html</link>
      <guid>https://ujava.cn/design/other/hexagonalarchitecture.html</guid>
      <source url="https://ujava.cn/rss.xml">六边形体系结构模式</source>
      <description>概述 允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>
]]></content:encoded>
    </item>
    <item>
      <title>同一性映射模式</title>
      <link>https://ujava.cn/design/other/identitymap.html</link>
      <guid>https://ujava.cn/design/other/identitymap.html</guid>
      <source url="https://ujava.cn/rss.xml">同一性映射模式</source>
      <description>概述 通过将每个加载的对象保持在地图中，确保每个对象只加载一次。 引用对象时使用地图查找对象。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>
<p>引用对象时使用地图查找对象。</p>
]]></content:encoded>
    </item>
    <item>
      <title>拦截过滤器模式</title>
      <link>https://ujava.cn/design/other/interceptingfilter.html</link>
      <guid>https://ujava.cn/design/other/interceptingfilter.html</guid>
      <source url="https://ujava.cn/rss.xml">拦截过滤器模式</source>
      <description>概述 截取过滤器是一种有用的Java设计模式，用于预处理 或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于 请求，然后再将其提供给目标应用程序。这样的使用示例包括认证， 这是在向应用程序发出请求之前必须处理的。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 08:20:09 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>
<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>
<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>
<p>这是在向应用程序发出请求之前必须处理的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>功能切换模式</title>
      <link>https://ujava.cn/design/other/featuretoggle.html</link>
      <guid>https://ujava.cn/design/other/featuretoggle.html</guid>
      <source url="https://ujava.cn/rss.xml">功能切换模式</source>
      <description>概述 软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于 AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:41:37 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>
AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>流接口模式</title>
      <link>https://ujava.cn/design/other/fluentinterface.html</link>
      <guid>https://ujava.cn/design/other/fluentinterface.html</guid>
      <source url="https://ujava.cn/rss.xml">流接口模式</source>
      <description>概述 流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:41:37 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>环绕执行模式</title>
      <link>https://ujava.cn/design/other/executearound.html</link>
      <guid>https://ujava.cn/design/other/executearound.html</guid>
      <source url="https://ujava.cn/rss.xml">环绕执行模式</source>
      <description>概述 环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:36:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>
]]></content:encoded>
    </item>
    <item>
      <title>扩展对象模式</title>
      <link>https://ujava.cn/design/other/extensionobject.html</link>
      <guid>https://ujava.cn/design/other/extensionobject.html</guid>
      <source url="https://ujava.cn/rss.xml">扩展对象模式</source>
      <description>概述 预计将来需要扩展对象的接口。其他接口由扩展对象定义。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:36:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>
]]></content:encoded>
    </item>
    <item>
      <title>扇出扇入(Fan-Out/Fan-In)模式</title>
      <link>https://ujava.cn/design/other/fanoutfanin.html</link>
      <guid>https://ujava.cn/design/other/fanoutfanin.html</guid>
      <source url="https://ujava.cn/rss.xml">扇出扇入(Fan-Out/Fan-In)模式</source>
      <description>概述 当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。 该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:36:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。<br><br>
该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</p>
]]></content:encoded>
    </item>
    <item>
      <title>事件异步模式</title>
      <link>https://ujava.cn/design/other/eventasynchronous.html</link>
      <guid>https://ujava.cn/design/other/eventasynchronous.html</guid>
      <source url="https://ujava.cn/rss.xml">事件异步模式</source>
      <description>概述 基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以： 在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。 同时执行多个操作，每个操作完成后接收通知。 等待资源可用，而不停止（“挂起”）您的应用程序。 使用熟悉的事件和委托模型与挂起的异步操作进行通信。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:14:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以：</p>
<ol>
<li>在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。</li>
<li>同时执行多个操作，每个操作完成后接收通知。</li>
<li>等待资源可用，而不停止（“挂起”）您的应用程序。</li>
<li>使用熟悉的事件和委托模型与挂起的异步操作进行通信。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>事件驱动架构模式</title>
      <link>https://ujava.cn/design/other/eventdrivenarchitecture.html</link>
      <guid>https://ujava.cn/design/other/eventdrivenarchitecture.html</guid>
      <source url="https://ujava.cn/rss.xml">事件驱动架构模式</source>
      <description>概述 使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:14:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</p>
]]></content:encoded>
    </item>
    <item>
      <title>事件队列模式</title>
      <link>https://ujava.cn/design/other/eventqueue.html</link>
      <guid>https://ujava.cn/design/other/eventqueue.html</guid>
      <source url="https://ujava.cn/rss.xml">事件队列模式</source>
      <description>概述 事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:14:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</p>
]]></content:encoded>
    </item>
    <item>
      <title>事件溯源模式</title>
      <link>https://ujava.cn/design/other/eventsourcing.html</link>
      <guid>https://ujava.cn/design/other/eventsourcing.html</guid>
      <source url="https://ujava.cn/rss.xml">事件溯源模式</source>
      <description>概述 不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:14:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</p>
]]></content:encoded>
    </item>
    <item>
      <title>事件聚合器模式</title>
      <link>https://ujava.cn/design/other/eventaggregator.html</link>
      <guid>https://ujava.cn/design/other/eventaggregator.html</guid>
      <source url="https://ujava.cn/rss.xml">事件聚合器模式</source>
      <description>概述 当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</description>
      <category>设计模式</category>
      <pubDate>Sun, 03 Mar 2024 03:00:03 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</p>
]]></content:encoded>
    </item>
    <item>
      <title>委托模式</title>
      <link>https://ujava.cn/design/other/delegate.html</link>
      <guid>https://ujava.cn/design/other/delegate.html</guid>
      <source url="https://ujava.cn/rss.xml">委托模式</source>
      <description>概述 委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</p>
]]></content:encoded>
    </item>
    <item>
      <title>依赖注入模式</title>
      <link>https://ujava.cn/design/other/dependencyinjection.html</link>
      <guid>https://ujava.cn/design/other/dependencyinjection.html</guid>
      <source url="https://ujava.cn/rss.xml">依赖注入模式</source>
      <description>概述 依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</p>
]]></content:encoded>
    </item>
    <item>
      <title>脏标志行为模式</title>
      <link>https://ujava.cn/design/other/dirtyflag.html</link>
      <guid>https://ujava.cn/design/other/dirtyflag.html</guid>
      <source url="https://ujava.cn/rss.xml">脏标志行为模式</source>
      <description>概述 脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。 在深入研究使用此模式之前，需要考虑一些要点： 您需要考虑一些事项： （1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。 （2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。 （3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。<br>
在深入研究使用此模式之前，需要考虑一些要点：</p>
<p>您需要考虑一些事项：</p>
<ul>
<li>（1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。</li>
<li>（2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。</li>
<li>（3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>领域模型模式</title>
      <link>https://ujava.cn/design/other/domainmodel.html</link>
      <guid>https://ujava.cn/design/other/domainmodel.html</guid>
      <source url="https://ujava.cn/rss.xml">领域模型模式</source>
      <description>概述 领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。</p>
]]></content:encoded>
    </item>
    <item>
      <title>双缓冲模式</title>
      <link>https://ujava.cn/design/other/doublebuffering.html</link>
      <guid>https://ujava.cn/design/other/doublebuffering.html</guid>
      <source url="https://ujava.cn/rss.xml">双缓冲模式</source>
      <description>概述 双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。</p>
]]></content:encoded>
    </item>
    <item>
      <title>双重检查锁模式</title>
      <link>https://ujava.cn/design/other/doublechecklock.html</link>
      <guid>https://ujava.cn/design/other/doublechecklock.html</guid>
      <source url="https://ujava.cn/rss.xml">双重检查锁模式</source>
      <description>概述 双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>双分派模式</title>
      <link>https://ujava.cn/design/other/doubledispatch.html</link>
      <guid>https://ujava.cn/design/other/doubledispatch.html</guid>
      <source url="https://ujava.cn/rss.xml">双分派模式</source>
      <description>概述 当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。 实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。 而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。<br>
实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。<br>
而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。</p>
]]></content:encoded>
    </item>
    <item>
      <title>内在价值模式</title>
      <link>https://ujava.cn/design/other/embeddedvalue.html</link>
      <guid>https://ujava.cn/design/other/embeddedvalue.html</guid>
      <source url="https://ujava.cn/rss.xml">内在价值模式</source>
      <description>概述 许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。 嵌入值将对象的值映射到对象所有者记录中的字段。</description>
      <category>设计模式</category>
      <pubDate>Fri, 01 Mar 2024 02:50:49 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。<br>
嵌入值将对象的值映射到对象所有者记录中的字段。</p>
]]></content:encoded>
    </item>
    <item>
      <title>转换器模式</title>
      <link>https://ujava.cn/design/other/converter.html</link>
      <guid>https://ujava.cn/design/other/converter.html</guid>
      <source url="https://ujava.cn/rss.xml">转换器模式</source>
      <description>概述 转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>命令查询职责分离(CQRS)模式</title>
      <link>https://ujava.cn/design/other/cqrs.html</link>
      <guid>https://ujava.cn/design/other/cqrs.html</guid>
      <source url="https://ujava.cn/rss.xml">命令查询职责分离(CQRS)模式</source>
      <description>概述 CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</p>
]]></content:encoded>
    </item>
    <item>
      <title>奇异递归模板(CRTP)模式</title>
      <link>https://ujava.cn/design/other/crtp.html</link>
      <guid>https://ujava.cn/design/other/crtp.html</guid>
      <source url="https://ujava.cn/rss.xml">奇异递归模板(CRTP)模式</source>
      <description>概述 CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式</p>
]]></content:encoded>
    </item>
    <item>
      <title>柯里化(Currying)模式</title>
      <link>https://ujava.cn/design/other/currying.html</link>
      <guid>https://ujava.cn/design/other/currying.html</guid>
      <source url="https://ujava.cn/rss.xml">柯里化(Currying)模式</source>
      <description>概述 Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据访问对象(DAO)模式</title>
      <link>https://ujava.cn/design/other/dao.html</link>
      <guid>https://ujava.cn/design/other/dao.html</guid>
      <source url="https://ujava.cn/rss.xml">数据访问对象(DAO)模式</source>
      <description>概述 数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。 使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。</p>
<p>使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据总线模式</title>
      <link>https://ujava.cn/design/other/databus.html</link>
      <guid>https://ujava.cn/design/other/databus.html</guid>
      <source url="https://ujava.cn/rss.xml">数据总线模式</source>
      <description>概述 http://wiki.c2.com/?DataBusPattern 数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p><a href="http://wiki.c2.com/?DataBusPattern" target="_blank" rel="noopener noreferrer">http://wiki.c2.com/?DataBusPattern</a></p>
<p>数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据本地化模式</title>
      <link>https://ujava.cn/design/other/datalocality.html</link>
      <guid>https://ujava.cn/design/other/datalocality.html</guid>
      <source url="https://ujava.cn/rss.xml">数据本地化模式</source>
      <description>概述 当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能 按照处理顺序将数据保存在连续内存中。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能</p>
<p>按照处理顺序将数据保存在连续内存中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据映射器模式</title>
      <link>https://ujava.cn/design/other/datamapper.html</link>
      <guid>https://ujava.cn/design/other/datamapper.html</guid>
      <source url="https://ujava.cn/rss.xml">数据映射器模式</source>
      <description>概述 数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数据传输对象模式</title>
      <link>https://ujava.cn/design/other/datatransferobject.html</link>
      <guid>https://ujava.cn/design/other/datatransferobject.html</guid>
      <source url="https://ujava.cn/rss.xml">数据传输对象模式</source>
      <description>概述 数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 06:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>安排执行断言模式</title>
      <link>https://ujava.cn/design/other/aaa.html</link>
      <guid>https://ujava.cn/design/other/aaa.html</guid>
      <source url="https://ujava.cn/rss.xml">安排执行断言模式</source>
      <description>概述 安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式</p>
]]></content:encoded>
    </item>
    <item>
      <title>抽象文档模式</title>
      <link>https://ujava.cn/design/other/abstractdocument.html</link>
      <guid>https://ujava.cn/design/other/abstractdocument.html</guid>
      <source url="https://ujava.cn/rss.xml">抽象文档模式</source>
      <description>概述 抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>活动对象模式</title>
      <link>https://ujava.cn/design/other/activeobject.html</link>
      <guid>https://ujava.cn/design/other/activeobject.html</guid>
      <source url="https://ujava.cn/rss.xml">活动对象模式</source>
      <description>概述 活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。</p>
]]></content:encoded>
    </item>
    <item>
      <title>非循环访问者模式</title>
      <link>https://ujava.cn/design/other/acyclicvisitor.html</link>
      <guid>https://ujava.cn/design/other/acyclicvisitor.html</guid>
      <source url="https://ujava.cn/rss.xml">非循环访问者模式</source>
      <description>概述 非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang of Four) Visitor(访问者) 模式固有的依赖关系循环</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang<br>
of Four) Visitor(访问者) 模式固有的依赖关系循环</p>
]]></content:encoded>
    </item>
    <item>
      <title>大使模式</title>
      <link>https://ujava.cn/design/other/ambassadorpattern.html</link>
      <guid>https://ujava.cn/design/other/ambassadorpattern.html</guid>
      <source url="https://ujava.cn/rss.xml">大使模式</source>
      <description>概述 大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。 大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。<br>
大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。</p>
]]></content:encoded>
    </item>
    <item>
      <title>异步方法调用模式</title>
      <link>https://ujava.cn/design/other/asynmethodinvocation.html</link>
      <guid>https://ujava.cn/design/other/asynmethodinvocation.html</guid>
      <source url="https://ujava.cn/rss.xml">异步方法调用模式</source>
      <description>概述 异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。</p>
]]></content:encoded>
    </item>
    <item>
      <title>放弃设计模式</title>
      <link>https://ujava.cn/design/other/balkingdesign.html</link>
      <guid>https://ujava.cn/design/other/balkingdesign.html</guid>
      <source url="https://ujava.cn/rss.xml">放弃设计模式</source>
      <description>概述 在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知</p>
]]></content:encoded>
    </item>
    <item>
      <title>业务委托模式</title>
      <link>https://ujava.cn/design/other/businessdelegate.html</link>
      <guid>https://ujava.cn/design/other/businessdelegate.html</guid>
      <source url="https://ujava.cn/rss.xml">业务委托模式</source>
      <description>概述 业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。 业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。<br>
业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。</p>
]]></content:encoded>
    </item>
    <item>
      <title>字节码模式</title>
      <link>https://ujava.cn/design/other/bytecode.html</link>
      <guid>https://ujava.cn/design/other/bytecode.html</guid>
      <source url="https://ujava.cn/rss.xml">字节码模式</source>
      <description>概述 字节码模式(bytecode pattern) 的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。 当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>字节码模式(bytecode pattern)<br>
的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。<br>
当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。</p>
]]></content:encoded>
    </item>
    <item>
      <title>缓存模式</title>
      <link>https://ujava.cn/design/other/caching.html</link>
      <guid>https://ujava.cn/design/other/caching.html</guid>
      <source url="https://ujava.cn/rss.xml">缓存模式</source>
      <description>概述 缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。 这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。<br>
这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>回调模式</title>
      <link>https://ujava.cn/design/other/callback.html</link>
      <guid>https://ujava.cn/design/other/callback.html</guid>
      <source url="https://ujava.cn/rss.xml">回调模式</source>
      <description>概述 回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。</p>
]]></content:encoded>
    </item>
    <item>
      <title>回路生成器模式</title>
      <link>https://ujava.cn/design/other/circuitbuilder.html</link>
      <guid>https://ujava.cn/design/other/circuitbuilder.html</guid>
      <source url="https://ujava.cn/rss.xml">回路生成器模式</source>
      <description>概述 回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它</p>
]]></content:encoded>
    </item>
    <item>
      <title>客户端会话模式</title>
      <link>https://ujava.cn/design/other/clientsession.html</link>
      <guid>https://ujava.cn/design/other/clientsession.html</guid>
      <source url="https://ujava.cn/rss.xml">客户端会话模式</source>
      <description>概述 客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。</p>
]]></content:encoded>
    </item>
    <item>
      <title>收集参数设计模式</title>
      <link>https://ujava.cn/design/other/collectingparameter.html</link>
      <guid>https://ujava.cn/design/other/collectingparameter.html</guid>
      <source url="https://ujava.cn/rss.xml">收集参数设计模式</source>
      <description>概述 收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。</p>
]]></content:encoded>
    </item>
    <item>
      <title>集合管道模式</title>
      <link>https://ujava.cn/design/other/collectionpipeline.html</link>
      <guid>https://ujava.cn/design/other/collectionpipeline.html</guid>
      <source url="https://ujava.cn/rss.xml">集合管道模式</source>
      <description>概述 集合管道模式(Collection Pipeline) 在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>集合管道模式(Collection Pipeline)</p>
<p>在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。</p>
]]></content:encoded>
    </item>
    <item>
      <title>上下文对象模式</title>
      <link>https://ujava.cn/design/other/contextobject.html</link>
      <guid>https://ujava.cn/design/other/contextobject.html</guid>
      <source url="https://ujava.cn/rss.xml">上下文对象模式</source>
      <description>概述 在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。</description>
      <category>设计模式</category>
      <pubDate>Thu, 29 Feb 2024 02:52:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。</p>
]]></content:encoded>
    </item>
    <item>
      <title>K8S简介</title>
      <link>https://ujava.cn/highfreq/k8s.html</link>
      <guid>https://ujava.cn/highfreq/k8s.html</guid>
      <source url="https://ujava.cn/rss.xml">K8S简介</source>
      <description>一、K8S简介 Kubernetes中文官网：Kubernetes GitHub：github.com/kubernetes/kubernetes Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</description>
      <category>设计高频</category>
      <pubDate>Tue, 27 Feb 2024 08:08:33 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一、K8S简介</h2>
<p>Kubernetes中文官网：<a href="https://kubernetes.io/zh/" target="_blank" rel="noopener noreferrer">Kubernetes</a></p>
<p>GitHub：<a href="http://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreferrer">github.com/kubernetes/kubernetes</a></p>
<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>
<p>Kubernetes集群组件逻辑图<br>
</p>
<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>
<p>Master节点组件及功能<br>
</p>
<p>Slave节点组件及功能<br>
</p>
<p>安装部署</p>
<p>生产环境部署k8s主要有两种方式：</p>
<p>二进制包</p>
<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>
<p>kubeadm工具</p>
<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>
<ul>
<li>kubeadm init：初始化一个Master节点</li>
<li>kubeadm join：将Worker节点加入集群</li>
<li>kubeadm upgrade：升级K8s版本</li>
<li>kubeadm token：管理 kubeadm join 使用的令牌</li>
<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>
<li>kubeadm version：打印 kubeadm 版本</li>
<li>kubeadm alpha：预览可用的新功能</li>
</ul>
<h2> 二、准备工作</h2>
<p>软硬件要求</p>
<ul>
<li>Linux操作系统，Ubuntu 或 CentOS</li>
<li>每台节点至少2G</li>
<li>Master节点至少2C</li>
<li>集群节点网络互通</li>
</ul>
<p>集群规划</p>
<figure><figcaption>img_104.png</figcaption></figure>
<p>环境配置</p>
<p>修改hosts配置</p>
<p>配置所有节点的IP和域名映射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置SSH免密登录</p>
<p>先生成公钥对，再把公钥远程复制到所有节点。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关闭Swap分区</p>
<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>禁用SELinux</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭防火墙</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改内核参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置集群时钟同步</p>
<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置k8s的Yum源</p>
<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、安装Docker</h2>
<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>
<h2> 四、安装K8S集群</h2>
<p>安装三大组件-kubeadm、kubelet、kubectl</p>
<ul>
<li>kubeadm：用来初始化k8s集群的指令。</li>
<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>
<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化k8s集群</p>
<ul>
<li>apiserver-advertise-address：apiserver监听地址</li>
<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>
<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>
<li>service-cidr：为Service分配的IP地址段</li>
<li>pod-network-cidr：为pod分配的IP地址段</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>成功界面：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>
<p>加入节点</p>
<p>所有Node节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改角色：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装网络插件</p>
<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>
</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、测试K8S集群</h2>
<p>创建nginx pod</p>
<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对外暴露访问</p>
<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问nginx</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>
<h2> 六、安装Dashboard</h2>
<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>
<p>Github：<a href="http://github.com/kubernetes/dashboard" target="_blank" rel="noopener noreferrer">github.com/kubernetes/dashboard</a></p>
<p>通过kubectl命令安装</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看service</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器输入访问地址：<a href="https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82" target="_blank" rel="noopener noreferrer">https://192.168.5.10:31128/，需要token才能访问。</a></p>
<figure><figcaption>img_107.png</figcaption></figure>
<p>创建访问账号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>登录界面</p>
<p>输入上面的token，进入dashboard首页</p>
<figure><figcaption>img_108.png</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>Jenkins详解</title>
      <link>https://ujava.cn/highfreq/jenkins.html</link>
      <guid>https://ujava.cn/highfreq/jenkins.html</guid>
      <source url="https://ujava.cn/rss.xml">Jenkins详解</source>
      <description>1.背景 在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试； 或者前后端分离后，经常会修改接口，然后重新部署； 这些情况都会涉及到频繁的打包部署； 手动打包常规步骤： 1.提交代码 2.问一下同组小伙伴有没有要提交的代码 3.拉取代码并打包（war包，或者jar包） 4.上传到Linux服务器 5.查看当前程序是否在运行 6.关闭当前程序 7.启动新的jar包 8.观察日志看是否启动成功 9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</description>
      <category>设计高频</category>
      <pubDate>Tue, 27 Feb 2024 06:40:40 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1.背景</h2>
<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>这些情况都会涉及到频繁的打包部署；</p>
<p>手动打包常规步骤：</p>
<ul>
<li>1.提交代码</li>
<li>2.问一下同组小伙伴有没有要提交的代码</li>
<li>3.拉取代码并打包（war包，或者jar包）</li>
<li>4.上传到Linux服务器</li>
<li>5.查看当前程序是否在运行</li>
<li>6.关闭当前程序</li>
<li>7.启动新的jar包</li>
<li>8.观察日志看是否启动成功</li>
<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>
</ul>
<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>
<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>
<p>只是Jenkins相对来说，使用得更广泛。</p>
<h2> 2.Jenkins服务器搭建及基本配置</h2>
<h3> 2.1.简介</h3>
<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h3> 2.2.Jenkins自动化部署实现原理</h3>
<figure><figcaption>img_70.png</figcaption></figure>
<h3> 2.3.Jenkins部署环境</h3>
<p>基本环境：</p>
<ul>
<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>
<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>
<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>
</ul>
<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>
<h3> 2.4.Jenkins安装</h3>
<ul>
<li>1.下载安装包jenkins.war；</li>
<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>
<li>3.打开浏览器进入链接 <a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a>.</li>
<li>4.填写初始密码，激活系统</li>
</ul>
<figure><figcaption>img_71.png</figcaption></figure>
<ul>
<li>5.进入插件安装选择</li>
</ul>
<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>
<figure><figcaption>img_72.png</figcaption></figure>
<p>选择后，进入插件安装页面<br>
</p>
<ul>
<li>
<p>6.设置初始用户和密码<br>
</p>
</li>
<li>
<p>7.进入系统，安装完成<br>
</p>
</li>
</ul>
<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>
<h3> 2.5.Jenkins基本配置</h3>
<h4> 2.5.1.系统初始化配置</h4>
<figure><figcaption>img_76.png</figcaption></figure>
<p><strong>1.Configure System (系统设置)</strong></p>
<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>
<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>
<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>
</p>
<p><strong>2.Configure Global Security (全局安全配置)</strong></p>
<p>a.配置用户相关的权限</p>
<figure><figcaption>img_78.png</figcaption></figure>
<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>
<p>默认是勾选上了的，这里去掉勾选</p>
<figure><figcaption>img_79.png</figcaption></figure>
<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>
<p>a.配置maven的全局settings路径<br>
</p>
<p>b.配置jdk<br>
</p>
<p>c.配置git</p>
<figure><figcaption>img_82.png</figcaption></figure>
<p>d.配置maven的安装路径</p>
<figure><figcaption>img_83.png</figcaption></figure>
<p><strong>4.配置必要插件</strong></p>
<p>主要是检查如下这两个插件是否已安装</p>
<ul>
<li>插件1：Publish over SSH</li>
<li>插件2：Deploy to container Plugin</li>
</ul>
<figure><figcaption>img_84.png</figcaption></figure>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>
<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>
<h3> 3.1.Jenkins服务器上创建项目和配置</h3>
<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>
<p><strong>1.创建一个工程</strong></p>
<figure><figcaption>img_85.png</figcaption></figure>
<p><strong>2.General(基础配置)</strong></p>
<p>仅需填写标准部分，其他可不填写</p>
<figure><figcaption>img_86.png</figcaption></figure>
<p><strong>3.源码管理</strong><br>
</p>
<p>上图中点击“添加”按钮添加一组账号和密码<br>
</p>
<p><strong>4.构建触发器</strong></p>
<figure><figcaption>img_89.png</figcaption></figure>
<p>如上图：当前项目的回调地址为：</p>
<p><a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>
<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>
<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>
<p><strong>5.构建环境（无需配置）</strong></p>
<p><strong>6.构建</strong></p>
<figure><figcaption>img_90.png</figcaption></figure>
<p><strong>7.构建后操作</strong></p>
<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>
<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>
<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>
</p>
<p>案例中给出的stop.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例中给出的start.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>
<h3> 3.2.Linux服务器配置</h3>
<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>
<figure><figcaption>img_92.png</figcaption></figure>
<h3> 3.3.GitHub服务器配置</h3>
<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>
<p>特别注意：为了保证回调地址网可以使用，</p>
<p>我已经将地址：<a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>
<p>通过花生壳进行外网映射为：<a href="http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>所以，下面配置的是外网映射地址。</p>
<figure><figcaption>img_93.png</figcaption></figure>
<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>
<h2> 4.测试</h2>
<p><strong>1.测试代码</strong><br>
</p>
<p><strong>2.提交代码到git,触发构建</strong></p>
<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>
</p>
<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>
<p>从下图中可以看出，正在构建</p>
<figure><figcaption>img_96.png</figcaption></figure>
<p><strong>5.查看当次构建的控制台日志</strong></p>
<figure><figcaption>img_97.png</figcaption></figure>
<p>说明已经启动成功</p>
<p><strong>6.查看Linux服务器，是否上传代码</strong></p>
<figure><figcaption>img_98.png</figcaption></figure>
<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>
<figure><figcaption>img_99.png</figcaption></figure>
<p><strong>8.浏览器上访问，看是否能用</strong></p>
<figure><figcaption>img_100.png</figcaption></figure>
<p>说明，已经正常启动可以使用。</p>
<p><strong>9.再次确认是否能自动化部署</strong></p>
<p>修改代码，重新提交代码，循环1到8步查看。</p>
<p>如果测试结果是你预期的，那么自动化部署成功。</p>
<h2> 5.总结&amp;资料下载</h2>
<h3> 5.1.总结</h3>
<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>
<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>
<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>
<p>但是，本着学习是为了解决生产的原则，</p>
<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>
<p>没必要把Jenkins的所有功能都学完在使用，</p>
<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>
<h3> 5.2.相关资料</h3>
<ul>
<li>1.案例中的源码地址：<a href="https://github.com/processfactory/demo01.git" target="_blank" rel="noopener noreferrer">https://github.com/processfactory/demo01.git</a></li>
<li>2.官方文档：Jenkins 用户手册</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>DevOps基本概念</title>
      <link>https://ujava.cn/highfreq/devops.html</link>
      <guid>https://ujava.cn/highfreq/devops.html</guid>
      <source url="https://ujava.cn/rss.xml">DevOps基本概念</source>
      <description>1. DevOps 维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。 为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？ 项目管理模式的演变是受项目的规模大小影响的。 最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。 后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</description>
      <category>设计高频</category>
      <pubDate>Tue, 27 Feb 2024 05:50:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. DevOps</h2>
<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>
<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>
<p>项目管理模式的演变是受项目的规模大小影响的。</p>
<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>
<br>
后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>
<p><br>
再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>
<br>
再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>
<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>
<p><br>
DevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>
<ul>
<li>DevOps = 人 + 流程 + 平台</li>
<li>人 + 流程 = 文化</li>
<li>流程 + 平台 = 工具</li>
<li>平台 + 人 = 赋能</li>
</ul>
<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>
<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>
<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>
<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>
<h2> 2. CI/CD</h2>
<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>
<p><br>
CI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>
<p><strong>持续集成</strong>：</p>
<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>
</p>
<p><strong>持续交付</strong>：</p>
<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>
</p>
<p><strong>持续部署</strong>：</p>
<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>
</p>
<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>
<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>
<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>
<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>
<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>SpringCloud详解</title>
      <link>https://ujava.cn/highfreq/springcloud.html</link>
      <guid>https://ujava.cn/highfreq/springcloud.html</guid>
      <source url="https://ujava.cn/rss.xml">SpringCloud详解</source>
      <description>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。 一、SpringCloud概述 SpringCloud：SpringCloud官网</description>
      <category>设计高频</category>
      <pubDate>Mon, 26 Feb 2024 05:26:17 GMT</pubDate>
      <content:encoded><![CDATA[<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>
<h2> 一、SpringCloud概述</h2>
<p>SpringCloud：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud官网</a></p>
<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>
<h2> 二、Spring Cloud 和 Dubbo 对比</h2>
<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>
Spring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>
Dubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>
下面是Spring Cloud和Dubbo的一些比较：<br>
</p>
<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>
<p>需要根据具体的业务需求来选择合适的微服务框架。</p>
<h2> 三、Spring Cloud 优缺点</h2>
<p>其主要优点有：</p>
<ul>
<li>
<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>
</li>
<li>
<p>约定优于配置，基于注解，没有配置文件。</p>
</li>
<li>
<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>
</li>
<li>
<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>
</li>
<li>
<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>
接下来，我们看下它的缺点：</p>
</li>
<li>
<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>
</li>
<li>
<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>
Spring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>
</li>
</ul>
<h2> 四、SpringCloud组件</h2>
<h3> 1、Eureka</h3>
<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、Feign</h3>
<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、Ribbon</h3>
<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、Hystrix</h3>
<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、Config</h3>
<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、SpringCloud应用场景</h2>
<h3> 1、微服务架构</h3>
<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>
<h3> 2、分布式配置中心</h3>
<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>
<h3> 3、服务调用和负载均衡</h3>
<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>
<h3> 4、高可用和容错机制</h3>
<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>
<h2> 六、结语</h2>
<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>
]]></content:encoded>
    </item>
    <item>
      <title>什么是serverless</title>
      <link>https://ujava.cn/highfreq/serverless.html</link>
      <guid>https://ujava.cn/highfreq/serverless.html</guid>
      <source url="https://ujava.cn/rss.xml">什么是serverless</source>
      <description>1 什么是severless ? Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。 img_58.png 纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。 那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。 简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。 进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。 就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</description>
      <category>设计高频</category>
      <pubDate>Mon, 26 Feb 2024 03:22:45 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1 什么是severless ?</h2>
<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>
<figure><figcaption>img_58.png</figcaption></figure>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>
<ul>
<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>
就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>
</ul>
<h2> 2 有服务到无服务构架有哪些变化？</h2>
<ul>
<li>弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>
<li>代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>
<li>按使用量计费。Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。<br>
云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</li>
</ul>
<h2> 3 serverless发展历史</h2>
<p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>
<ul>
<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。</li>
<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>
<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a href="http://iron.io" target="_blank" rel="noopener noreferrer">iron.io</a>。</li>
<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>
</ul>
<h2> 4 severless 分类</h2>
<p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。</p>
<ul>
<li>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</li>
<li>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</li>
</ul>
<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>
<h2> 5 severles优缺点</h2>
<h3> 优点</h3>
<ul>
<li>降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</li>
<li>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</li>
<li>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</li>
<li>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</li>
<li>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</li>
<li>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是多快好省。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</li>
<li>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</li>
<li>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</li>
<li>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</li>
<li>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</li>
<li>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</li>
</ul>
<h3> 缺点</h3>
<ul>
<li>状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>
<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>
<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>
</ul>
<h2> 6 serverless使用场景</h2>
<p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。</p>
<ul>
<li>
<p>异步的并发，组件可独立部署和扩展</p>
</li>
<li>
<p>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</p>
</li>
<li>
<p>短暂、无状态的应用，对冷启动时间不敏感</p>
</li>
<li>
<p>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）<br>
Serverless 的使用场景示例如：</p>
</li>
<li>
<p>ETL</p>
</li>
<li>
<p>机器学习及 AI 模型处理</p>
</li>
<li>
<p>图片处理</p>
</li>
<li>
<p>IoT 传感器数据分析</p>
</li>
<li>
<p>流处理</p>
</li>
<li>
<p>聊天机器人<br>
示例：</p>
</li>
</ul>
<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>
<p>一款移动端游戏至少包含如下几个特性：</p>
<ul>
<li>移动端友好的用户体验</li>
<li>用户管理和权限认证</li>
<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息<br>
传统的应用程序架构可能是这样的：</li>
</ul>
<figure><figcaption>img_59.png</figcaption></figure>
<ul>
<li>一个 app 前端，iOS 或者安卓</li>
<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>
<li>使用关系型数据库存储用户数据，如 MySQL<br>
这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</li>
</ul>
<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>
<figure><figcaption>img_60.png</figcaption></figure>
<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>
<h2> 7 serverless核心技术</h2>
<p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>
<ul>
<li>函数的规范定义</li>
<li>函数部署流水线</li>
<li>Workflow 设置</li>
<li>0-m-n 扩缩容</li>
<li>快速冷启动</li>
</ul>
<h2> 总结</h2>
<p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>企业级架构带来的模式改变</title>
      <link>https://ujava.cn/highfreq/modelchange.html</link>
      <guid>https://ujava.cn/highfreq/modelchange.html</guid>
      <source url="https://ujava.cn/rss.xml">企业级架构带来的模式改变</source>
      <description>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。 一、价值评估有章可循 近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</description>
      <category>设计高频</category>
      <pubDate>Fri, 23 Feb 2024 07:12:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>
<h2> 一、价值评估有章可循</h2>
<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>
<p>企业级架构建设循着企业价值创造的链条，可面向业务领域逐步开展需求识别和定义。对于业务领域而言，其主要职责是创造业务价值，承接战略分析成果，进行产品研发。实践中，业务领域需要清晰定义本领域应具备的能力，提出能力建设方案，并在领域范畴内，按照计划—执行—监督的完整价值流，识别出业务活动。业务活动是指创造端对端业务价值的具体工作，其价值交付主要以产品为载体，包括产品服务的客户、产品提供的渠道、产品所需的合作伙伴等，在流程模型中需要进行全面辨识。基于企业级架构方法论形成的业务需求和业务模型，有助于业务价值的体现和评估：</p>
<p>一是基于企业级架构的全局视角，可以减少个别部门的短期促销行为，同时避免不规范需求引发的产品定价、业务流程不一致等问题。二是企业级架构承接业务战略，始终围绕着价值创造建设，而需求在经过“战略解析—能力主题—产品设计—流程设计—能力实现”的工作模型检验后，将能够更好地满足战略需要，有利于提高核心竞争力。三是需求的业务价值更容易量化，基于企业级架构，可建立产品、客户、渠道、合作方贡献度评价体系，对需求带来的效益进行数字化评估。四是业务需求价值评估能力提高，可以使科技产能更好地倾向于重点需求开发，快速形成竞争力。</p>
<h2> 二、数据治理追本溯源</h2>
<p>如果说价值交付是建设企业级架构的核心，那么业务信息则是构成企业级架构的基础，内容涉及业务架构的业务对象以及业务模型的实体模型等。对此，IT架构的数据架构进一步从数据定义、数据管理、数据服务等方向，规定了数据生命周期中各种形态的管理原则。数据架构组成示意如图1所示。例如，针对实体建模，该架构详细描述定义了业务实体和实体属性；针对数据定义，要求开发数据结构准确继承实体模型；针对元数据管理，要求建立企业级数据字典，保证数据能被正确描述和使用。此外，在数据质量管控方面，则是要求在组织、办法和流程等维度进行全面统筹。</p>
<figure><figcaption>数据架构组成示意</figcaption></figure>
<p>实践证明，如果不能全面梳理数据脉络，数据治理的结果往往是事倍功半。对此，企业级架构有助于为全面实施数据治理打开局面：一是在需求的业务建模阶段，业务流程的数据需求和实体模型需要进行相互验证，并通过企业级数据字典进行定义，在源头保证数据准确性。二是从架构设计到实施工艺，从实体建模到数据结构设计，借助企业级架构可形成全面的数据管理办法，保证数据在产生、传输、存储、服务各个环节的一致性。三是基于企业级架构，可将内部能力按业务组件归集，并依照业务组件开发应用组件，同时加强数据副本管理，进而避免因同类业务被不同应用系统承接导致的管理复杂化问题。综上，数据治理是数字化转型的一项基础性工作，而企业级架构恰好提供了一枚“金钥匙”。</p>
<h2> 三、业务与技术更好衔接</h2>
<p>在瀑布式开发模式下，标准化需求确认需要经历多个不同阶段的准入门禁，需求响应缓慢。与之相比，敏捷开发模式强调客户参与，更有助于加速需求交付进程，例如将开发过程前移到需求提出阶段，或是请业务人员加入开发团队等。除此之外，企业级架构也为业务与技术融合提供了一种新的途径：</p>
<ul>
<li>一是在提交业务需求前，通过对活动进行流程建模，以及对业务对象进行实体建模，并采用结构化、标准化语言(如流程建模的BPMN图和实体建模的ER图等)消弭理解歧义，可基于业务模型团队构建衔接业务和技术的桥梁。</li>
<li>二是企业级架构结合内部视角，可从业务流程、职责划分等维度映射业务组件与应用组件的对应关系，进而实现业务和技术的完美对应。</li>
<li>三是企业级架构的流程建模需要勾连相关实体，而建模产出物结合面向对象的设计方法，将能方便地识别出符合客观世界的对象，对象拥有实体属性，并具备流程模型描述的处理能力。</li>
<li>四是企业级架构在进行实体建模时，可对实体进行归类，定义出主实体，并与周边的多个实体组成业务对象(子主题域)。在开发阶段，通过将业务建模的业务对象(子主题域)设计成相应的数据聚合，可有效保证技术和业务理解一致，使用“共同语言”。</li>
</ul>
<p>总体而言，业务模型通过以业务视角来描述战术层和运营层的业务架构，可为IT架构提供高效输入，而善于使用业务架构和业务模型，也将使业务与技术衔接得更好，加快需求响应速度。业务架构基础模型如图2所示。</p>
<figure><figcaption>业务架构基础模型</figcaption></figure>
<h2> 四、方法实践潜移默化</h2>
<p>从实践角度发出，企业级架构不仅是对业务架构和IT架构进行全局设计，还提供了精确描述企业的统一方法论，如可灵活应用在日常工作中，将产生潜移默化的积极影响：</p>
<ul>
<li>一是价值链分析。企业级架构进行企业层面的流程模型设计，遵循价值创造的链条识别业务领域，并在业务领域通过各类活动实现业务价值，接着就是将活动下的任务按能力类别聚合成业务组件。在IT实施阶段，可沿用同样的分析方法，按价值维度将业务组件进一步细分为子域，最后将能力进行聚合，开发出高内聚的微服务。</li>
<li>二是架构视图绘制。企业级架构的IT架构通常包含了四个维度，即安全架构、技术架构、数据架构和应用架构。其中，应用架构可进一步划分为三个阶段，即分层架构、逻辑架构、物理架构，并从功能视图、接口视图、剖面视图等多个维度进行描述。实践中，上述建模方法不仅可用于搭建企业级总体架构，在描述应用系统的内部架构时也同样适用。</li>
<li>三是名词术语。基于企业级架构建设，有助于统一名词术语，改善概念混淆的状况，进而减少沟通成本。例如，在旧文档中信息系统有时被称作“系统”，也有称作“产品”或“应用”的情况。而结合企业级架构建设，可将业务领域下各类活动的系统统一称为“应用”，负责承接业务组件的系统称为“应用组件”，名称更加准确、明白。</li>
<li>四是建模方法。业界常用的建模方法一般指业务建模采用的BPMN图和实体建模采用的ER图，两者作为通用的建模语言，在开发阶段也常被使用。而企业级架构借助建模过程可将上述方法进一步推广到整个组织，进而可大幅提高描述能力和沟通效率。</li>
<li>五是职责定义。企业级架构对工作职责的定义往往是从目标(WHY)、定义(WHAT)、范围(WHERE)等三个维度进行描述，不仅言简意赅，且广泛适用于各种场景。</li>
</ul>
<p>综上，数字化转型是银行机构践行高质量发展的必由之路。自2018年提出数字化转型总体框架以来，中国银行于2019年全面启动数据治理，并在2020年启动了企业级架构建设，通过自上而下对业务架构、技术架构、工艺方法等进行全面整合，数据治理各环节工作变得更加顺畅，需求开发变得更加敏捷，数字化转型目标也愈发清晰可见!</p>
]]></content:encoded>
    </item>
    <item>
      <title>WebFlux详解</title>
      <link>https://ujava.cn/highfreq/webflux.html</link>
      <guid>https://ujava.cn/highfreq/webflux.html</guid>
      <source url="https://ujava.cn/rss.xml">WebFlux详解</source>
      <description>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。 然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。 所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。 我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</description>
      <category>设计高频</category>
      <pubDate>Thu, 22 Feb 2024 07:31:35 GMT</pubDate>
      <content:encoded><![CDATA[<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>
<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>
<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>
<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>
<p>话说这么多，开始今天的学习吧。</p>
<h2> 什么是 WebFlux</h2>
<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>
<figure><figcaption>img_51.png</figcaption></figure>
<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>
<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>
<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>
<h2> 反应式库</h2>
<h3> 1. Reactive Stream</h3>
<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>
<p>我们先看下这个概念：</p>
<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>
<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>
<p>它由以下几个组件组成：</p>
<ul>
<li>发布者：发布元素到订阅者</li>
<li>订阅者：消费元素</li>
<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>
<li>处理器：发布者与订阅者之间处理数据</li>
</ul>
<h3> 2. Reactor</h3>
<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>
<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>
Reactor 就是 Spring WebFlux 的首选 反应式库。</p>
<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>
<ul>
<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>
<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>
两个都是发布者 Publisher。</li>
</ul>
<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>
<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>
<ul>
<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>
<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>
<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>
</ul>
<p>代码初体验</p>
<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>
<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>
</p>
<ol>
<li>Mono</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>
<ul>
<li>接口耗时：0</li>
<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>
</ul>
<ol start="2">
<li>Flux</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>
<h2> 操作数据库</h2>
<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>
<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>
<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>
<h3> 1. 创建项目</h3>
<p>选择这几个依赖，创建新的 project:</p>
<figure><figcaption>img_53.png</figcaption></figure>
<p>pom.xml 文件里是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是 application.properties:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建数据库表</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个简单的 test_user 表。</p>
<h3> 3. 创建相关类</h3>
<p>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserRepository，就相当于 DAO</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserController 控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>
<h3> 4. 启动测试</h3>
<p>项目启动之后，我们使用 Postman 测试一下。</p>
<h3> 请求地址路由</h3>
<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>
<p>创建 Userhandler.java</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建 RouterConfiguration</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>
<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>
<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>
<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>
<li>通过 addRoute 方法可以配置多个路由策略。<br>
测试</li>
</ul>
<p>修改：</p>
<p>查询和前面一样：</p>
<h3> 适用性</h3>
<p>官网上是这样建议的：</p>
<ul>
<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>
<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>
<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>
<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>
</ul>
<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Reactor模型详解</title>
      <link>https://ujava.cn/highfreq/reactor.html</link>
      <guid>https://ujava.cn/highfreq/reactor.html</guid>
      <source url="https://ujava.cn/rss.xml">Reactor模型详解</source>
      <description>前言 说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。 一、经典的同步阻塞模型 img_46.png 这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</description>
      <category>设计高频</category>
      <pubDate>Thu, 22 Feb 2024 06:49:50 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>
<h2> 一、经典的同步阻塞模型</h2>
<figure><figcaption>img_46.png</figcaption></figure>
<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>
<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>
<ul>
<li>read：从socket读取数据。</li>
<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>
<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>
<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>
1.下面看传统的BIO代码：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>
<p>我们的目标是：</p>
<ul>
<li>随着负载的增加可以优雅降级；</li>
<li>能够随着资源的改进，性能可以持续提升；</li>
<li>同时还要满足可用性和性能指标：</li>
<li>低延迟</li>
<li>满足高峰需求</li>
<li>可调节的服务质量</li>
</ul>
<p>阻塞 （针对的是被调用方）</p>
<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>
让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>
<p>同步 （针对的是调用方）</p>
<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>
如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>
<p>NIO就很好的解决了传统Socket问题：</p>
<ul>
<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>
<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>
</ul>
<p>2.client端代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>
<h2> 二、单reactor单线程设计</h2>
<figure><figcaption>img_47.png</figcaption></figure>
<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>
<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>
<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>
<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>
<p>代码示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了一个Reactor类。</p>
<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>
<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>
监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>
<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>
<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>
<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>
<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>
<p>下面我们可以进行测试了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>
那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>
<h2> 三、单reactor多线程设计</h2>
<figure><figcaption>img_48.png</figcaption></figure>
<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>
<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>
<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看测试结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>
<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>
<h2> 四、多reactor多线程设计</h2>
<figure><figcaption>img_49.png</figcaption></figure>
<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>
只负责处理客户端的写事件。</p>
<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>
<h2> 五、Reactor模型结构图</h2>
<figure><figcaption>img_50.png</figcaption></figure>
<ul>
<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>
<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>
<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>
<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>
<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>企业级架构建模之浅谈三大模型关系</title>
      <link>https://ujava.cn/highfreq/modelrelation.html</link>
      <guid>https://ujava.cn/highfreq/modelrelation.html</guid>
      <source url="https://ujava.cn/rss.xml">企业级架构建模之浅谈三大模型关系</source>
      <description>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。 企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。 产品模型是企业定制化产品的集合，阐述企业提供的服务是什么 流程模型展现可复用的业务环节，表达企业提供的服务怎么做 数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。 从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</description>
      <category>设计高频</category>
      <pubDate>Thu, 22 Feb 2024 02:04:39 GMT</pubDate>
      <content:encoded><![CDATA[<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>
<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>
产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>
<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>
<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>
从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>
<h2> 01、三大模型概述</h2>
<p><br>
1.企架三大模型之——产品模型</p>
<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。顶层的产品线可以理解为银行业务条线，可包含多个产品组，每一个产品组是对其唯一归属的产品线下具有相似业务性质基础产品的聚合。基础产品包含了聚类可售产品所有可能的特征，为对基础产品进一步划分，可创建不同的产品组件。产品组件的存在不仅能对基础产品做出细分，同时也是最底层产品特征相同或相似的产品条件的归类。产品条件表达产品对金额、利率、期限、数量等业务特征的限制规则，可用于对属性和逻辑的控制参数。</p>
<p>2.企架三大模型之——流程模型</p>
<p>流程模型用标准化的方式表达业务流程结构，可分为五层，逐层把企业业务能力分解为业务领域、价值流、活动、任务和步骤，并通过与产品模型和数据模型协同关系，精准刻画业务需求。顶层的业务领域是紧密相关业务的集合。价值流是一组互不相同、界限分明，但相互关联的生产经营活动，是构成价值创造的动态过程，如存款和贷款的界限分明但共同存在为银行创造价值。这里的活动由不同的事件触发，比如外部事件、时间或条件触发的内部事件，活动的存在是为了达成具体的业务目的，企业执行端到端的行为序列集合；活动也是从用户角度看到的执行业务流程。具体来讲，我们可用任务来表达从银行内部执行的操作。活动和任务具备明确目的性，要求产生可观测、有价值的结果。流程模型中最底层的步骤则涵盖所有最细化的业务规则和业务信息。</p>
<p>3.企架三大模型之——数据模型</p>
<p>数据模型是企业范围内统一的数据视图，通过一系列规范和相关图表反映数据需求和设计。根据规则从企业的视角对业务概念进行逻辑化、一致性的表述，用数据语言表达业务需求并展现业务规则，是联接业务和技术的桥梁，也是业务模型的主要组成部分。具体来看，顶层的业务对象是一组关联实体的集合，要求高内聚松耦合；关联的实体不允许重复或缺失。业务实体可视为以业务视角抽象表示一种客观存在于现实世界并且可以跟其他物体区分开，用一系列业务属性来描述的事物。</p>
<p>因此业务实体所具有的某一业务特性，我们称之为实体属性。若干个属性可共同刻画同一实体。向下延申，属性域值对属性取值范围进行规范，每个属性都有需要遵循的值的范围，通过域明确属性的取值规则。属性域实例只与代码类的域关联，用于进一步明确每一个取值下的规范。一个实例组会有多个取值，每个取值称为实例组的一个实例。业务组件是独立的业务模块，指具有相似资源、人和专业技能的任务组合，通过将标准化的任务按照业务对象聚类形成业务组件。</p>
<h2> 02、模型间协同关系</h2>
<p>第一部分概述中已经对每个模型划分层级，比如产品模型自上而下分别是产品线、产品组、基础产品、产品组件和产品条件。三大模型间的协同关系主要也是讨论模型层级与层级间的联动，下面将分类剖析：</p>
<p>1.产品模型对接流程模型</p>
<p><br>
基础产品与活动（多对多） 基础产品仅关联与产品有关的活动。活动可以看作是某个基础产品在提供服务有哪些环节划分，比如任何与贷款相关的基础产品需要有申请贷款额度、审核客户背景等环节共同搭建贷款服务体系。这些环节我们就可以说是这个基础产品对应的活动。在填写流程模型活动表单时，会体现活动编号、名称、详情等信息，也会专门有一列“产品信息”来体现活动对应到哪些具体的基础产品。基础产品与任务（多对多） 刚才提到活动是环节划分，而任务则是某环节衍生出来要做的事，因此任务与其上层活动所关联的基础产品范围上是一致的。延续”申请贷款额度“这个活动案例，银行方面需要完成的任务就是“受理额度申请”等一系列为了完成客户申请贷款额度而做的工作。我们也可以理解为活动是客户角度看到的环节，而任务是从我们服务提供方内部角度对活动拆解出来需要完成的事项。当活动关联了基础产品，才会建立该活动下层任务与基础产品的关系。产品条件与步骤（多对多） 步骤则是呈现任务中的事项具体如何去操作，是环节最细致的拆分。因此当活动和任务关联了基础产品，步骤作为最底层的拆分理应映射产品模型最下层的参数-产品条件。通常一个步骤需要关联至少一个产品条件，同时每个产品条件需要被至少一个步骤使用。对“受理额度申请”这个任务来说，其中一个“检查账户信息”的具体步骤，在流程模型步骤表单“与产品模型映射”列就可以映射“开户银行类型”这一产品条件，表示对某账户开户银行具体类型的选择。</p>
<p>2.数据模型对接流程模型</p>
<p><br>
任务与业务实体（多对多） 数据模型中的实体由流程模型的任务创建而来。流程模型任务表单有专门一列“业务实体”来呈现关系。比如终止某产品协议就可以关联到“产品协议”这个实体。终止某产品协议是要做的事，要把这件事说清楚便需要创建一个产品协议实体去承接，且实体名称需与数据模型的实体精确匹配。步骤与业务实体（多对多） 步骤是任务的细化，和任务一样可以去操作实体。在实际工作中，会遇到步骤牵扯到多个实体的情况，比如“调查客户背景”这个任务，其中有一个步骤是“核实客户基本信息”，涉及操作“账户”实体和“客户信息”实体，这时可根据业务含义判断是否可拆分步骤，拆至最小颗粒度便于业务和技术人员清晰理解流程。步骤与实体属性（多对多） 实体属性用于描述业务实体。流程模型中的“业务规则”列需要体现涉及业务实体下的属性。主要体现对业务规则有影响的关键属性及对应的取值描述和使用规则。还是举“核实客户基本信息”这个步骤，在创建“客户信息”实体的同时会在业务规则中体现是对公客户还是对私客户，因此属性“客户公私类型”便会建立在数据模型与其做映射，属性的取值也直接影响到该步骤最终的结果。</p>
<p>3.业务组件对接业务对象和任务</p>
<figure><figcaption>img_43.png</figcaption></figure>
<p>业务组件与任务（一对多）</p>
<p>业务组件可视为业务分类器，作为独立的业务模块归集具有相似业务目的的任务。这里的相似主要是领域和数据使用的相似。比如“调查客户背景”和“识别客户风险”两项任务都是为了更好了解和识别客户信息和行为，涉及的数据都可以有账户实体下的所有属性字段。因此我们可以将它们归集在“客户管理”业务组件。一个任务只归属一个业务组件，一个业务组件下可包含多个紧密相关的任务。</p>
<p>业务组件与业务对象（一对一/多）</p>
<figure><figcaption>img_44.png</figcaption></figure>
<p>业务组件归集具有相似业务目的的任务，业务对象归集互相关联的实体，而实体由任务来创建。因此业务组件与业务对象的关联具体体现在业务组件下任务对业务对象下实体的操作。以最基本的存款业务举例，“存款”是业务组件，具体任务有“记录存款信息”和“更换存单”，这两项任务便可操作“存款账户”这个业务对象下的“存款合约”和“存单”两个实体。</p>
<p>3.业务事件承接业务领域和活动</p>
<p><br>
业务领域对业务划分主题类型，其具体发生的行为操作称之为业务事件。围绕业务事件所产生的两条关系可总结为业务领域包含业务事件，而事件会触发一系列活动。比如贷款这个业务领域，我们能想到发生的业务事件包括申请住房贷款、购车贷款、助学贷款等贷款额度，这些事件便可触发申请个人贷款额度的活动，这个活动下面的任务和步骤则是对其需要做的事更细致的划分。一个领域涵盖多个事件，每个活动必由一个或多个业务事件触发。在实际建模工作中，三大模型分别建立再做关联映射大大提升建模难度，为了映射而映射，导致模型质量降低。因此，从建模初期保持三大建模的“实时”匹配尤其重要。无论是顶层领域划分规则还是底层参数设定，三个建模组通过完善的沟通机制共同协商而定，是企业级建模结果能够有效应用于全领域业务的基石。</p>
]]></content:encoded>
    </item>
    <item>
      <title>一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构</title>
      <link>https://ujava.cn/highfreq/business.html</link>
      <guid>https://ujava.cn/highfreq/business.html</guid>
      <source url="https://ujava.cn/rss.xml">一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构</source>
      <description>简介 在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。 架构的视角 在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</description>
      <category>设计高频</category>
      <pubDate>Wed, 21 Feb 2024 03:01:36 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
<h2> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>
<p>很多时候架构的视角/分类没有明显的边界，通常是交叉的；<br>
有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</p>
<h2> 业务架构</h2>
<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>
<p><br>
看看京东业务架构（网上分享图）：<br>
</p>
<h2> 应用/技术架构</h2>
<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>
<p>不限于如下视角，主要表示应用开发中的软件架构视角...</p>
<h3> 视角：功能视角</h3>
<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>
<h3> 视角：技术视角-总体</h3>
<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。<br>
</p>
<h3> 视角：技术视角-数据架构</h3>
<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>
<h3> 视角：技术视角-基础架构</h3>
<p>PAAS，IAAS...</p>
<figure><figcaption>img_35.png</figcaption></figure>
<h3> 视角：技术视角-运维架构</h3>
<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>
<figure><figcaption>img_36.png</figcaption></figure>
<h2> 物理架构</h2>
<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>
<p>以一个银行系统为例</p>
<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。<br>
</p>
<p>物理部署架构设计说明：</p>
<ul>
<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>
<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>
<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>
<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>
<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>
<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。<br>
下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。<br>
</li>
</ul>
<p>物理部署架构设计说明：</p>
<ul>
<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>
<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>
<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>
</ul>
<h2> DDD到各种架构</h2>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<p>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</p>
<p>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</p>
<p>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</p>
<figure><figcaption>img_39.png</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>企业架构TOGAF内容框架</title>
      <link>https://ujava.cn/highfreq/togaf.html</link>
      <guid>https://ujava.cn/highfreq/togaf.html</guid>
      <source url="https://ujava.cn/rss.xml">企业架构TOGAF内容框架</source>
      <description>img_24.png 一、内容框架概述 TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。 企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</description>
      <category>设计高频</category>
      <pubDate>Wed, 21 Feb 2024 03:01:36 GMT</pubDate>
      <content:encoded><![CDATA[<figure><figcaption>img_24.png</figcaption></figure>
<h2> 一、内容框架概述</h2>
<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>
<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>
<p>内容框架对企业架构开发方法中各阶段的输入和输出信息进行了分类总结，并通过内容元模型（Content MetaModel）对构成企业架构内容的各个元素（即企业架构中的各个构建块的类型）以及他们之间的关系进行了定义。内容框架中针对其内容的描述采用了一种与架构开发方法的各阶段相映射的方式进行组织，即对架构开发方法的各个阶段所产出的企业架构内容具体是什么进行描述。</p>
<p>虽然针对企业架构内容的定义非常重要，但是同样重要的还有如何对企业架构的内容进行利用。企业架构的核心目标是为具有不同视角的干系人根据其关注点提供准确的视图，从而使得不同的干系人虽然采用了不同的观察角度和描述方式，但的确是在为共同的目标而进行着无障碍沟通和协作。为了达到这一目标，内容框架对于各种视角（ViewPoint）从表现形式和内容方面都进行了归纳总结，并对一些视图的开发也提供了建议和指南。TOGAF是一个通用性的标准，它的内容不可能涵盖企业中所有的视角，因而在具体实践中，各个企业完全可以根据自身需要对这些视角进行引用、修改和组合，从而总结出适合的视角，并借此开发出相应的视图，从而满足企业中具体干系人的需要。</p>
<p>下图展示了内容框架中各方面内容与企业中客观存在的各种资源之间关系，以及企业架构的内容是如何在内容框架的组织下为各个干系人提供帮助的：</p>
<figure><figcaption>img_25.png</figcaption></figure>
<h2> 二、企业架构工作产品分类</h2>
<p>在内容框架中，企业架构开发方法过程中所涉及到的各种工作产品被归纳为如下几种：</p>
<p>1、架构交付物（Architecture Deliverables）：架构交付物是由合同指定并被相关干系人轮流进行正式的审查和签字认可的工作产品。这些交付物代表着架构项目的输出，以及那些在一个项目完结时以文档形式进行交付的，或者作为参考模型、标准或在某一时点的架构情景快照（snapshot of the Architecture Landscape）被过渡到架构资源库中的工作产品。</p>
<p>2、架构制品（Architectural Artifacts）：与架构交付物相比，架构制品是一个从某个特定视角进行架构描述并具备更细粒度的工作产品。例如，网络图、服务器说明、用例说明、架构需求列表以及业务交互矩阵等。就表现形式来讲，架构制品的内容可以通过目录、矩阵和图形这三种方式来表述。通常情况下，一个架构交付物可以包含多个架构制品，而架构制品也可能会出现在多个架构交付物之中，并且架构制品也将会形成架构资源库的内容。</p>
<p>3、构建块（Building Blocks）：构建块代表着业务、IT或者架构能力的一个组件，并且可以与其他构建块组合在一起来对各种架构和解决方案进行交付。根据所处的架构开发阶段的不同，构建块能够在多个详细度层次上进行定义。例如，在架构开发的早期阶段，一个构建块可能仅仅包含一个名字或一个概要描述，而随着架构开发过程的演进，此构建块可能会被进一步分解为若干具有详尽描述的支持性构建块。从内容和所面对的问题上看，构建块可以被进一步分为如下两种：</p>
<p>架构构建块（ABBs：Architecture Building Blocks）：此种类型的构建块一般用于描述各种需要的能力，并对其后的解决方案构建块的轮廓进行了勾勒。例如，企业中的一个客户服务定义了实现这项能力的各种需求，而对于它的真正落实就需要若干解决方案构建块在各方面（流程、数据以及应用软件等）将这些需求映射到具体的实现技术之上。<br>
解决方案构建块（SBBs：Solution Building Blocks）：此种类型的构建块代表了用于实现各种需求（由架构构建块定义）的具体组件。<br>
<br>
以上三种工作产物虽然在内容和产生背景上有着很大的不同，但是他们之间却有着非常紧密的联系。构建块可以说是企业架构资源库的核心内容，并且也是企业架构过程的终极目标产物，因而把其称为企业的模型也并不为过，而架构制品则可以看成此模型在某个角度的各种视图，属于架构描述的范畴。架构交付物比较特殊，它与架构开发方法各阶段紧密相连，并作为各个阶段的输入与输出载体而存在。</p>
<h2> 三、架构交付物（Architecture Deliverables）</h2>
<p>架构交付物是在整个架构开发方法循环过程中所产生或被使用的契约性、正规化的企业架构内容。它与企业架构开发方法有着紧密的联系。本节将针对这些架构交付物以及它们与架构开发方法各阶段之间的关系进行阐述。需要注意的是，本节的内容只提供了一个关于架构交付物的内容概括。由于企业中可能存在着符合其自身需要的项目和过程管理方法，所以企业也可以根据自己的实际情况对这些交付物进行改造和定制。</p>
<p>架构交付物与企业架构开发方法各阶段之间的对应关系（注意，下表采用了简称来标示各企业架构开发方法阶段）：<br>
</p>
<figure><figcaption>img_28.png</figcaption></figure>
<h3> 1、架构构建块</h3>
<p>构建块是企业架构过程的最终目标之一，它是企业对于各个层面上（业务、应用、数据以及技术等）的可重用部件的抽象。架构构建块的内容侧重于对构建块的需求进行描述，就像软件开发中的接口一样，架构构建块并不涉及具体的实现方式，而只是描述了构建块所需要达成的功能。用于描述架构构建块的文档和模型存储在企业架构资源库之中，企业架构开发过程正是对企业中各种客观存在的或计划中的可重用模块进行抽象建模，并最终将这些内容存储到企业架构资源库之中（或对其内容进行更新）。</p>
<h3> 2、架构合同</h3>
<p>目标</p>
<p>架构合同是企业架构开发团队与赞助团队之间关于架构的交付、质量和适用性的联合协定。为了成功实现这一协定则需要企业进行有效的架构治理。通过实现一个用于合同管理的治理方法，企业将会确保：</p>
<ul>
<li>对组织中所有架构相关活动的完整性检查、变更、决策和审计进行持续监督。</li>
<li>现存或正在开发的架构得以贯彻组织的原则、标准和需求。</li>
<li>明确架构在开发和实现的各个方面中的风险，这些方面涵盖了关于可接受的标准、策略、技术和产品的内部开发，以及架构的运营层面，从而使得组织可以在一个具有弹性的环境中继续其业务。</li>
<li>一系列流程和实践，用于确定关于所有架构制品的开发和使用的责任和规则。</li>
<li>对于为合同负责的治理组织，他们的权限级别及其治理之下的架构范围有一个正式的理解。</li>
</ul>
<p>内容</p>
<p>架构设计和开发合同的内容一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>架构范围</li>
<li>架构以及战略原则和需求</li>
<li>一致性需求</li>
<li>架构开发和管理流程，以及相关角色</li>
<li>目标架构评测标准</li>
<li>定义的交付阶段</li>
<li>按照优先级排序的联合工作计划</li>
<li>时间窗口（Time windows）</li>
<li>架构交付和业务指标</li>
</ul>
<p>业务用户的架构合同一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>范围</li>
<li>战略需求</li>
<li>一致性需求</li>
<li>架构采用者</li>
<li>时间窗口</li>
<li>架构业务指标</li>
<li>服务架构（包括服务水平协议（SLA：Service Level Agreement））</li>
</ul>
<h3> 3、架构定义文档</h3>
<p>目标</p>
<p>架构定义文档是一个包含在整个项目中所产生的各种制品的可交付容器。它跨越所有的架构领域（业务、数据、应用和技术），并可用于检阅架构的所有相关状态（当前态、中间态和目标态）。架构定义文档对架构需求文档在如下方面进行互补：</p>
<ul>
<li>架构定义文档提供了一个解决方案的定性视图，用于沟通架构师的意图。</li>
<li>架构需求说明提供了一个解决方案的定量视图，用于声明在架构实现过程中必须遵守的可测量的标准。<br>
内容</li>
</ul>
<p>架构定义文档内容一般包括：</p>
<ul>
<li>范围</li>
<li>目标、阶段目标和约束</li>
<li>架构原则</li>
<li>基线架构</li>
<li>架构模型（针对每个被建模的状态）：业务架构模型、数据架构模型、应用架构模型、技术架构模型</li>
<li>架构方法的基本原理和理由</li>
<li>架构资源库内容映射：架构情景映射、参考模型映射、标准映射、重用评估</li>
<li>差距分析结果</li>
<li>影响评估</li>
</ul>
<h3> 4、架构原则</h3>
<p>目标</p>
<p>通用的规则和指南，一般是不会进行更改的。这些原则知会并支持一个组织用以实现其任务的方法。它是用于定义和指导组织从价值到行为和结果的一系列结构化思路中的一员。</p>
<p>内容</p>
<p>架构原则一般包括如下几个层面的内容（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>业务原则</li>
<li>数据原则</li>
<li>应用原则</li>
<li>技术原则</li>
</ul>
<h3> 5、架构资源库</h3>
<p>目标</p>
<p>架构资源库在企业中充当了对于所有架构相关项目进行存储的区域。它允许各个项目管理它们的交付物，定位可重用资产，并对干系人以及其他有兴趣者进行信息发布。</p>
<p>内容</p>
<p>架构资源库的内容包括如下几个方面（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>架构框架</li>
<li>标准信息库</li>
<li>架构情景</li>
<li>参考架构</li>
<li>治理日志</li>
</ul>
<h3> 6、架构需求说明</h3>
<p>目标</p>
<p>架构需求说明提供了一组量化的描述，用于概括一个项目的实现与架构相符合所必须做的事情。架构需求说明一般会形成一个实施契约，或是更详细的架构定义契约中的主要组件。</p>
<p>内容</p>
<p>架构需求说明的内容通常包括：</p>
<ul>
<li>成功评测标准</li>
<li>架构需求描述</li>
<li>业务服务契约</li>
<li>应用服务契约</li>
<li>实施导则</li>
<li>实施说明</li>
<li>实施标准</li>
<li>互操作需求</li>
<li>约束</li>
<li>假设</li>
</ul>
<h3> 7、架构路线图</h3>
<p>目标</p>
<p>架构路线图列举出各个变化增量，并把他们放到时间轴之上，从而展示了从当前架构到目标架构的演进过程。架构路线图是迁移架构的重要组件，并在架构开发方法的B、C、D、E、F阶段中以增量的方式开发出来。</p>
<p>内容</p>
<p>架构路线图的内容包括：</p>
<ul>
<li>项目列表：每个涉及到的项目的名称、描述和目标，用于实现所建议的架构的项目列表，并按照优先级进行了排序。</li>
<li>基于时间的迁移规划：迁移的效益、针对各种迁移选择的成本估算。</li>
<li>实施建议：用于衡量项目有效性的评估准则、风险和问题、解决方案构建块的描述和模型。</li>
</ul>
<h3> 8、架构愿景</h3>
<p>目标</p>
<p>架构愿景是在项目生命周期早期创建的，它提供了一个高阶的对于最终架构产品的期望视图。目的是为了在一开始就对架构应该达到的期望结果形成一致意见，从而使得在之后的过程中架构师能够关注于切实可行的关键领域。通过提供一份关于整体架构定义的内容摘要，架构愿景对于干系人之间按沟通也提供了一定的支持。</p>
<p>内容</p>
<p>架构愿景的内容通常包括：</p>
<ul>
<li>问题描述：干系人以及他们的关注点，需要解决的问题/场景列表。</li>
<li>详细目标描述</li>
<li>环境和流程模型：流程描述、涉及到环境的流程步骤、涉及到人员的流程步骤、信息流</li>
<li>执行者以及他们担当的角色和责任：人员方面的执行者和角色、计算机方面的执行者和角色、需求</li>
<li>所产生的架构模型：约束、IT原则、支持流程的架构、映射到架构之上的需求。</li>
</ul>
<h3> 9、业务原则、目标和驱动力</h3>
<p>目标</p>
<p>业务原则、目标和驱动力通过描述企业的需要和工作方式为架构工作提供了背景。此外，许多处于架构原则考虑之外的因素对架构的开发也有着重要的影响。</p>
<p>内容</p>
<p>于不同的组织有着不同的特性，因而关于架构业务背景的内容将会各不相同，企业应该根据各自的情况定义这部分内容。</p>
<h3> 10、能力评估</h3>
<p>目标</p>
<p>在做一份详细的架构定义之前，对企业的当前和目标的能力水平有一个清晰的认识是非常有价值的。对于能力评估，我们可以在如下几个层面进行考虑：</p>
<ul>
<li>企业整体的能力水平是什么？企业希望在何处增强或优化其能力？用于支持企业期望发展的架构关注领域是什么？</li>
<li>企业中的IT功能的能力或成熟度水平是什么？就设计管理、操作管理、技术和组织架构而言，进行架构项目最可能的影响都有哪些？为了与企业文化和IT部门的能力相适应，架构项目所需的正规化和详细度的最适宜水平是什么？</li>
<li>企业架构功能的能力和成熟度是什么？当前存在的架构资产有哪些？这些资产是否被一直维护，并且是否还准确？什么样的标准和参考模型需要被考虑进去？是否在这些在架构项目中有可能创建可重用资产？</li>
<li>能力欠缺存在于何处？为了达成目标能力而需要进行转型的业务范围是什么？在对基本能力欠缺考虑之上的转换风险、文化壁垒以及其他方面考虑都有哪些？<br>
内容</li>
</ul>
<p>能力评估的内容通常包括：</p>
<ul>
<li>业务能力评估：业务能力、针对每项能力性能水平的基线状态评估、针对每项能力性能水平的未来状态期望、针对每项能力如何实现的基线状态评估、针对每项能力将会被如何实现的期望</li>
<li>IT能力评估：变更流程的基线和目标成熟度水平、运营流程的基线和目标成熟度水平、基线能力以及容量评估、针对由于架构项目的执行而对IT组织所可能产生的影响的评估</li>
<li>架构成熟度评估：架构治理流程/组织/角色和责任、架构技能评估、架构资源库中的情景定义的深度/广度/质量、架构资源库中的标准定义的深度/广度/质量、架构资源库中的参考模型的深度/广度/质量、针对可重用潜力的评估。</li>
<li>业务转型准备度评估：准备度因素、对于每个准备度因素的愿景、针对当前和目标准备度的评级、与准备度相关的风险。</li>
</ul>
<h3> 11、变更请求</h3>
<p>目标</p>
<p>在架构的实现过程中，在一切清晰之前，原来的架构定义和需求很可能不适合或不足以达成解决方案的实现。在这种情况下，对实施项目进行调整使之与建议的架构方法发生偏离，或请求架构范围扩展是必需的行为。另外，很多外部因素（例如，市场因素、业务策略变化以及新技术机会）也会为扩展及优化架构提供新的机会。在以上这些环境下，一个变更请求可以被提出，用以开始一个新的架构工作周期。</p>
<p>内容</p>
<p>变更请求的内容通常包括：</p>
<ul>
<li>对于所建议的变更的描述</li>
<li>对于所建议的变更的理由</li>
<li>对于所建议的变更的影响评估：针对相关特定需求的引用、迄今需求所涉及的干系人的优先级、重新审视这些需求的各阶段描述、对需求优先级进行排序的阶段、调查和修正需求的优先级阶段的结果、对于需求管理的建议。</li>
<li>资源库引用编号</li>
</ul>
<h3> 12、 沟通计划</h3>
<p>目标</p>
<p>企业架构包含大量的复杂且相互关联的信息。有效地与适当的人在适当的时间针对目标信息进行交流是成功建设企业架构的重要因素。开发沟通计划可以使这些交流通过一种可计划、可管理的方式进行。</p>
<p>内容</p>
<p>沟通计划的内容通常包括：</p>
<ul>
<li>针对干系人的识别，并根据沟通需求进行分组</li>
<li>明确沟通需求、与架构愿景相关的关键消息、沟通风险和关键成功因素（CSFs：Critical Success Factors）</li>
<li>明确用来与干系人进行沟通的机制，并允许其对架构信息的访问</li>
<li>制定沟通时间表。该时间表展示了沟通将在何时何地进行，以及在何种干系人组之间进行</li>
</ul>
<h3> 13、 合规评估</h3>
<p>目标</p>
<p>一旦一个架构被定义了出来，就必须在整个实施过程中对其进行治理，从而保证原先的架构愿景可以被适当的实现，并且实现中的经验教训也可以反馈到架构过程中。针对实施项目进行周期性的合规检查为重新审核项目过程，并保证设计和实施符合企业策略和架构目标，提供了一种有益的机制。</p>
<p>内容</p>
<p>合规评估的内容通常包括：</p>
<ul>
<li>项目进程和状态的概览</li>
<li>项目架构/设计概览</li>
<li>完整的架构清单：硬件和操作系统清单、软件服务和中间件清单、应用清单、信息管理清单、安全清单、系统管理清单、系统工程清单、方法和工具清单。</li>
</ul>
<h3> 14、实施和迁移计划</h3>
<p>目标</p>
<p>通过过渡框架的描述为解决方案的实施提供一个日程表，包括实施的时间、成本、资源、收益和里程碑。</p>
<p>内容</p>
<p>实施和迁移计划的内容通常包括：</p>
<ul>
<li>实施和迁移战略：战略实施方向、实施排序方法</li>
<li>与其他管理框架的交互：架构与业务规划相协调的方法、整合架构的方法、架构与项目管理相协调的方法、架构与运营管理相协调的方法。</li>
<li>项目章程：项目所能交付的能力、所包含的工作包、业务价值、风险、问题、假设和依赖关系</li>
<li>实施规划：由实施分解出来的各个阶段和工作流、为各阶段和工作流进行工作包分配、里程碑和时间要求、工作分解结构、资源需求和成本</li>
</ul>
<h3> 15、实施治理模型</h3>
<p>目标</p>
<p>一旦一个架构被定义，在整个实施过程中就需要对用于实现架构的过渡框架进行治理。在已经建立了架构功能的组织中可能已经存在了一个治理框架，但是对于特定的过程、组织、角色、责任和度量来说，需要根据项目进行具体的定义。</p>
<p>内容</p>
<p>实施治理模型的内容通常包括：</p>
<ul>
<li>治理流程</li>
<li>治理组织结构</li>
<li>治理角色和相应职责</li>
<li>治理检查点和成功与失败标准</li>
</ul>
<h3> 16、 企业组织架构模型</h3>
<p>目标</p>
<p>为了一个架构框架能够被成功地使用，它必须在企业中获得正确的组织、角色和责任的支持。特别重要的是，对不同企业架构参与者之间边界的定义，以及针对跨边界关系的治理。</p>
<p>内容</p>
<p>企业组织架构模型的内容通常包括：</p>
<ul>
<li>受影响的组织的范围</li>
<li>成熟度评估、差距和决议方法</li>
<li>架构团队的角色和责任</li>
<li>针对架构工作的约束</li>
<li>资金预算需求</li>
<li>治理和支持策略</li>
</ul>
<h3> 17、架构工作要求书</h3>
<p>目标</p>
<p>由赞助组织交付给架构组织的用于启动架构开发工作的文档。架构工作要求书可以产生于预备阶段，可以是经过批准的架构变化请求的结果，或者是源于迁移计划对架构工作的参考。</p>
<p>内容</p>
<p>架构工作要求书的内容通常包括：</p>
<ul>
<li>组织赞助者</li>
<li>组织的任务说明</li>
<li>业务目标（以及变更）</li>
<li>业务的战略规划</li>
<li>时间限制</li>
<li>业务环境的变化</li>
<li>组织方面的约束</li>
<li>预算信息以及财务约束</li>
<li>外部约束以及业务约束</li>
<li>当前业务系统描述</li>
<li>当前架构/IT系统描述</li>
<li>开发组织的描述</li>
<li>开发组织可用资源的描述</li>
</ul>
<h3> 18、需求影响评估</h3>
<p>目标</p>
<p>在整个架构开发方法过程中，总会有新的与架构相关的信息被收集起来。当这些信息被收集后，对架构在当前某方面有影响的新因素也经常会显现出来。需求影响评估就是用来对当前架构需求进行评估，阐明需要进行的变更以及这些变更所带来的影响。</p>
<p>内容</p>
<p>需求影响评估的内容通常包括：</p>
<ul>
<li>对于具体需求的引用</li>
<li>迄今需求的相关干系人优先级</li>
<li>进行重审的各个阶段</li>
<li>进行需求优先级排序的阶段</li>
<li>调查和修正需求的优先级阶段的结果</li>
<li>关于需求管理的建议</li>
<li>资源库引用编号</li>
</ul>
<h3> 19、解决方案构建块</h3>
<p>与架构构建块相类似，解决方案构建块也是存储于架构资源库中的构建块的一种，不过它的内容更倾向于在实现层面对企业中的可重用构建块进行描述。可以说，架构构建块定义了构建块的需求，而解决方案构建块则是此需求在具体实现技术层面的映射。关于解决方案构建块的具体内容请参阅后面的内容。</p>
<h3> 20、架构工作说明书</h3>
<p>目标</p>
<p>架构工作说明书定义了用于完成一个架构项目的方法和范围，它也是用于评测架构项目是否被成功执行的典型文档，并且它也形成了架构服务提供者和使用者之间的合同协议的基础。</p>
<p>内容</p>
<p>架构工作说明书的内容通常包括：</p>
<ul>
<li>架构工作标题说明</li>
<li>项目申请和背景</li>
<li>项目描述和范围</li>
<li>架构愿景的概括</li>
<li>管理办法</li>
<li>范围变更程序</li>
<li>角色、责任和交付物</li>
<li>验收标准和程序</li>
<li>项目计划和日程安排</li>
<li>针对架构连续体的支持</li>
<li>签字批准</li>
</ul>
<h3> 21、定制的架构框架</h3>
<p>目标</p>
<p>TOGAF提供了一个行业的标准架构框架，但是要在一个架构项目中对其进行有效地使用，则必须在两个层面上进行定制。首先，需要对TOGAF模型进行定制，使得它可以融入到企业之中。此种定制包括将TOGAF模型整合入企业的项目和过程管理框架、术语定制、展示方式开发、架构工具的选择、配置和部署等方面之中。任何被采用的框架的形式和详细程度应该与企业的其他背景元素相适应，例如文化、干系人、企业架构的商业模型以及当前架构能力的水平。一旦针对框架完成了上面的定制，企业就需要为具体的架构项目做进一步的框架定制，而在这一层面的定制中，企业需要选择适当的架构交付物和架构制品来满足项目和干系人的需要。</p>
<p>内容</p>
<p>定制的架构框架的内容通常包括：</p>
<ul>
<li>定制架构的方法</li>
<li>定制架构的内容（架构交付物和架构制品）</li>
<li>配置和部署工具</li>
<li>治理模型和其他框架的接口：企业架构管理框架、能力管理框架、项目组合管理框架、项目管理框架、运营管理框架。</li>
</ul>
<h3> 22、过渡架构</h3>
<p>目标</p>
<p>过渡架构展示了企业的增量状态，并反映从当前架构到目标架构的过渡过程。过渡架构被用来将单独的工作包和项目组合为可管理的项目组合和程序，用于描述每个阶段的业务价值。</p>
<p>内容</p>
<p>过渡架构的内容通常包括：</p>
<ul>
<li>机会组合描述：综合的差距、解决方案和依赖关系评估、机会描述、收益评估、能力和能力增量、互操作性和共存的需求</li>
<li>工作包组合描述：工作包描述（名称、描述、目标和交付物）、功能性需求、依赖关系、与机会之间的关系、与架构定义文档和架构需求说明之间的关系。</li>
<li>里程碑和里程碑过渡架构：过渡状态描述、每个过渡状态的业务架构、每个过渡状态的数据架构、每个过渡状态的应用架构、每个过渡状态的技术架构。</li>
<li>实施因素评估和推导矩阵（ImplementationFactor Assessment and Deduction Matrix：用于记录将会影响架构实施和迁移计划的各个因素。此矩阵包括在制定迁移计划时需要考虑的各个因素、它们的描述，以及由此而推断出的在制定计划时需要考虑的行动或约束）：风险、问题、假设、依赖、行动。</li>
<li>综合差距、解决方案和依赖矩阵（Consolidated Gaps，Solutions，and Dependencies matrix：此矩阵使架构师可以对在各领域架构差距分析结果中明确的差距进行分组，并评估潜在的解决方案，以及这些方案与差距之间的依赖关系）：架构领域、差距、潜在解决方案、依赖关系。</li>
</ul>
<h2> 四、架构制品（Architectural Artifacts）</h2>
<p>架构制品是针对某个系统或解决方案的模型描述，与架构交付物和构建块相比，架构制品既不是架构开发方法过程各阶段的合约性产物，亦不是企业中客观存在的各种可重用解决方案，而是针对包括这些构建块在内的企业客观现实的描述，并以解答不同干系人的关注点为其最终目标。可以说，架构交付物面向于企业架构的产生，架构构建块倾向于企业架构的结果，而架构制品则注重于针对企业架构的应用（虽然架构交付物可以包含若干架构制品，但是架构制品在本质上还是被用来为不同的干系人按照其视角提供相应的企业客观视图，况且架构交付物对架构制品的包含本身也是架构制品的应用之一，其目的也是为了在架构开发过程中所涉及的不同干系人之间达成共识）。</p>
<p>企业架构并不是一个静态的过程，不能将建设一个包含企业架构内容的信息资源库当作唯一目标。对于任何企业来说，企业架构的意义都应该在于将其自身的战略决策、业务和信息技术资源联系为一个有机整体，并且不同的干系人从企业架构中获得其所需的关于企业的自上而下（自业务至用于支持各项业务实现的解决方案）的视图，而这方面的内容属于针对企业架构内容的使用范畴。在这一范畴之中，所有的企业架构框架理论，哪怕是几乎不涉及企业架构内容的框架，都会关注于两个概念：视角与视图。其中视角是针对不同干系人企业架构内容的需求描述，而视图是基于某一视角的具体架构内容描述，因而也可以说视角是视图的元类型定义。在这两个概念中，视图比较好理解，亦即根据视角的定义而对企业客观现状的某一侧面描述，相比之下，用于对视图进行定义的视角概念则更为关键。视角是不同干系人对于企业架构内容需求的体现，亦即其采用何种角度对企业客观存在或计划存在的自顶层战略、业务至底层解决方案而进行观察。这些角度的定义基本上应该包括如下几个方面：</p>
<p>1、目标需求：不同的干系人担当着不同的角色及责任，其看问题的角度与担当的任务也因此有着非常紧密的联系。一般来讲，目标需求大体可以分为：</p>
<ul>
<li>设计层面：包括了用于指导和支持与设计决策相关的各种制品。例如架构师、开发人员以及业务流程建模人员等干系人经常会用到的UML图、流程建模图（例如BPMN图）、以及用于描述数据的关系-实体图等制品都属于这一范畴。</li>
<li>决策层面：包括了用于支持高层决策的制品（例如，交叉引用表、情景图、以及各种报告等制品），适用于企业中处于管理高层的各种决策人，例如CEO、CIO等。</li>
<li>告知层面：包括了用于为相关干系人进行解释、说服以及获得其承诺方面的制品（流程概述、图表、宣讲动画等）。这些干系人可能会是一般职工、客户，或者其他在企业中从业务到解决方案这条线上虽不占关键位置却需要对企业架构进行了解的干系人。<br>
2、抽象级别需求：上面描述了不同干系人由于其担负任务的不同，因而对于企业的观察也具有着不同的角度，从而对不同的制品产生兴趣。然而，即使不同的干系人针对企业的相同侧面有着共同的兴趣，但是他们对于描述的抽象级别或详细程度也可能有着不同的要求。例如，对于相同的业务流程来说，可能对于高层管理人员来说需要关注的仅是此流程的输入、输出，而对于其实现细节并不一定关心，而对于流程建模人员来说此业务流程恐怕就需要被细化为粒度更加细小的业务功能组合，而对于软件开发人员来讲，可能还要为某个具体业务行为而考虑其相关的数据结构和实现方案。</li>
</ul>
<p>3、展示需求：上述两点可以说是依据干系人所持的角度在内容方面所进行的分类，而除此之外，由于不同的干系人由于各自的偏好不同，他们可能会对视图的展示也有着非常不同的要求。虽然在TOGAF中，架构制品的描述方式被定义为目录、矩阵和图形三种方式，但就其具体展示方式来说，不同的干系人还可能具有不同的要求和偏好。例如，对于组织结构的展示，有的干系人可能偏好于采用简单的树形结构的展示，而其他干系人则可能更加倾向于图形化的结构图。这种展示需求在图形展示方面尤其突出，某些干系人（特别是来自于内部的干系人，例如领域专家等）可能习惯于采用某种标准的标注体系来对架构内容进行展示，而对于其他干系人来讲（例如客户或非专业的干系人）采用如此方式可能并不能取得很好的效果，而采用更加贴近现实的图标来代替标准图标（通常是若干简单的形状、连线和颜色的组合）则更加友好。虽然展示需求也是视角定义所需靠虑的元素之一，但是在大多数情况下这一层面的定义往往可以采用松耦合的方式来进行描述，即将视角的定义分为内容和展示两个层面，并在两者之间建立关联（通常一个内容定义可以包含若干展示定义）。</p>
<p>上述关于视角分类的定义很容易让人产生非此即彼的感觉，即视角是为干系人服务的，因而应该仅从属于某种干系人。这样的思想除了源于思想的惯性，最主要的还是由于忽视了企业架构的核心精神—在组织中创建无障碍的沟通信息流。作为企业架构的核心概念，如果只把视角看作为企业架构描述用的约束和定义，而忽视了沟通这一本质则是违反企业架构最终目标的。每种干系人对于视角的采用都要着自己的要求，但反过来讲，视角却不一定从属于某种干系人，不同的干系人之间可以共享同样的视角，也只有这样才能保证不同干系人之间的顺畅沟通。正像TOGAF中所举的例子一样，飞机的飞行员和航空管制员对于飞行的视角各具特点，并采用不同的语言和元素来对“飞行”进行描述，但是他们同时也采用一种通用的语言（高度、速度等）来进行沟通。在这个例子中，飞行员和航空管制员在自己的领域内分别采用了自己的视角来对“飞行”进行理解和描述，不过作为沟通用的通用语言却形成了第三个，并且是他们所共享的视角。</p>
<p>企业架构开发过程的结果可以说是在架构资源库中按照架构元模型定义而填充的各种实体元素，这也方便了在对企业架构的使用中按照各个干系人的视角为其提供相应的视图。针对架构的使用需要自动化工具的支持，该工具需要支持视角的定义和管理，并能够从企业架构资源库中根据选定的视角生成相应的视图。</p>
<figure><figcaption>img_29.png</figcaption></figure>
<p>不同的企业架构开发框架对于架构制品、视角和视图的定义，有着不同的描述。例如在Zachman框架中，每一个单元格所代表的是某一种干系人视角针对系统某个方面的描述，而在TOGAF中，The Open Group则采用了一种独特的方式对视角进行了组织和定义。与其他框架理论不同，TOGAF定义了一系列原子架构制品，并倡议在企业架构过程中根据不同干系人的需要对这些原子架构制品进行组合，从而生成对于视角的定义。这些原子架构制品业可被看为原子级的视角定义，实际上在TOGAF中也正是用视角（ViewPoint）这个词来称呼各个架构开发阶段相关的原子架构制品。TOGAF并不强制其用户遵循这些原子架构制品，用户可以根据自己的需要增加新的原子架构制品，或对已经定义的原子架构制品进行修订。根据架构制品的描述形式，TOGAF将这些原子架构制品分为以下三类：</p>
<ul>
<li>目录（Catalogs）：此类型的原子架构制品（视角）以列表的形式对各种构建块进行列举。</li>
<li>矩阵（Matrices）：此类型的原子架构制品（视角）用于展示特定构建块之间的关系。</li>
<li>图形（Diagrams）：此类型的原子架构制品（视角）采用了一种具有丰富表现力的方式对构建块以及他们之间的关系进行了展示。此种方式特别适合用于在干系人之间进行沟通的场合。</li>
</ul>
<h3> 1、架构开发过程与架构制品</h3>
<p>表面上架构制品并不像架构交付物那样与架构开发方法的各个阶段有着很强的契约性关联，但是做为架构交付物的重要组成部分，架构制品与架构开发方法之间也有着非常紧密的联系。在TOGAF中，针对架构制品的组织和描述也是以架构开发方法各阶段为基础的，它详尽展示了在每个架构开发方法阶段中所产生的各个原子架构制品，以及这些架构制品与架构内容元模型各扩展之间的关系。</p>
<figure><figcaption>img_30.png</figcaption></figure>
<h3> 2、架构制品定义</h3>
<p>原则目录（Principles catalog）</p>
<p>原则目录对各项业务原则及架构原则进行列举，用以表明一个好的解决方案或架构看起来应该是什么样子。原则用于对各架构决策点的输出进行评估和认可。原则也可在针对变更举措的架构治理中充当辅助工具。</p>
<p>干系人映射矩阵（Stakeholder Map Matrix）</p>
<p>干系人映射矩阵用于明确参与架构活动的各个干系人、他们的影响、他们的主要问题，以及架构框架所必须解答的关注点。通过对于干系人的识别，并对他们的需求进行理解，架构师可以将注意力集中在能够满足干系人需求的各个领域之中。</p>
<p>价值链图（Value Chain Diagram）</p>
<p>价值链表提供了一张面向高层的企业视图，用于表示企业如何与外界环境交互。与在业务架构阶段中开发出来的更加正式的功能解构图相比较，价值链表更着重于表象上的影响。价值链表的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使得所有参与者能够对架构所涉及到的高层次功能性和组织性环境进行理解。</p>
<p>解决方案概念图（Solution Concept Diagram）</p>
<p>解决方案概念图提供了一个解决方案的高层次方向，用于达成架构所涉及的各个目标。与后续架构开发方法阶段开发出来的、更正式且更详细的架构图相比较，解决方案概念图更像是在一开始阶段关于期望解决方案的一张草图。这张图体现了关键的目标、需求和约束，并对将采用正式架构模型来进行更详细描述的各个工作区域进行了标明。解决方案概念图的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使所有的参与者能够理解架构所需要的究竟是什么，以及一个特定的解决方案被期望以何种方式来满足企业的需求。</p>
<p>组织/执行者目录（Organization/Actor Catalog）</p>
<p>该目录的目标是得到一份明确的包括用户和IT系统所有者在内的所有与IT有互动的参与者列表。该列表可以在开发需求时作为完备性检测的参考。例如，针对于一个对客户进行服务支持的应用的需求，我们可以通过如下几个方面对其进行完备性检测：</p>
<ul>
<li>
<p>需要对何种类型的客户进行支持。</p>
</li>
<li>
<p>是否某种类型的用户存在特定需求或约束。</p>
</li>
<li>
<p>此目录所涉及到的内容元模型实体包括：</p>
</li>
<li>
<p>组织单位</p>
</li>
<li>
<p>执行者</p>
</li>
<li>
<p>位置（如果一个单独的位置目录并不存在，则关于位置的信息就需要在这个目录中加以维护）</p>
</li>
</ul>
<p>驱动力/目标/阶段目标目录（Driver/Goal/Objective Catalog）</p>
<p>该目录的目标是描述组织如何通过目标、工作目标和评测（可选内容）来满足其驱动力的需要，并为此提供一份跨越组织的参考。通过针对驱动力、目标和阶段目标的层层分解，各个变更举措可以采用一种跨越组织边界的方式进行协同，并在随后的活动中使得各个干系人得以被明确，此外，相关的变更举措也能够被整合或协调起来。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单元</li>
<li>驱动力</li>
<li>目标</li>
<li>阶段目标</li>
<li>评测（可选内容）</li>
</ul>
<p>角色目录（Role Catalog）</p>
<p>角色目录的目标是为企业中所有的授权级别或区域提供一份列表。一般情况下，应用的安全或行为应该按照其对授权概念的理解而分别进行定义，但在与用户的计算机相绑定时却造成了复杂且不被期望的后果。如果角色在整个组织和所有应用中都得到了定义、理解和共识，那么更加安全并能够提供更加无缝的用户体验的应用将会出现，因为管理员无需通过迂回的解决方法来使用户执行他们的工作。除了对企业的安全定义进行支持，角色目录还可以是明确组织变更管理影响、定义工作职能，以及执行最终用户培训这些方面的关键输入。</p>
<p>由于每个角色都暗含着关于一系列业务功能的访问，如果这些功能被影响到，那么变更管理将必不可少，组织的职责也需要被重新定义，同时新的培训可能也是需要的。</p>
<p>业务服务/功能目录（Business Service/Function Catalog）</p>
<p>业务服务功能目录的目标是提供一份功能性的解构，使得各种功能可以被过滤、汇报和查询，并能够作为功能结构图的一个有力补充。服务功能目录可以被用来对组织中的各项能力进行明确，并对组织中施加到各种功能上的治理水平加以理解。通过功能解构，用于支持业务变化所需要的各种新能力能够被识别出来，或者对变更措施、应用以及技术组件的范围进行确定。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单位</li>
<li>业务功能</li>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
</ul>
<p>位置目录（Location Catalog）</p>
<p>位置目录为企业的业务运营或房屋建筑相关的资产（例如数据中心或终端用户计算设备）所处位置提供了一份列表。针对此位置列表的维护，各个变更举措的位置范围得以被快速地定义出来，并且针对当前情况和建议的目标解决方案进行评估时，完备性测试也得以被执行。例如，一个用于更新台式计算机操作系统的项目需要识别出这些系统所部署的位置。与此相似，当实施一个新的系统时，一张关于位置的图形描述对于开发适当的部署策略是非常关键的，该部署策略被用于对用户和应用的位置进行了解，并且各个与位置相关的问题（例如，国际化、本地化、针对可用性的时区影响、延时距离影响、网络带宽影响和访问）也得以被明确。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>位置</li>
</ul>
<p>流程/事件/控制/产品目录（Process/Event/Control/Product Catalog）</p>
<p>流程/事件/控制/产品目录为流程、触发流程的事件、流程的输出和施加到流程执行之上的控制提供了一份层次结构，并可被用来作为流程图（Process Flow diagram）的一个有力的补充，这些流程图使得企业可以进行跨越组织和流程的过滤、汇报和查询操作，从而对其范围、通用性或影响进行明确。例如，流程/事件/控制/产品目录使得企业可以查看流程与各子流程之间的关系，从而明确源自于一个高层流程的变更所能带来的影响链。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>流程</li>
<li>事件</li>
<li>控制</li>
<li>产品</li>
</ul>
<p>合同/评测目录（Contract/Measure Catalog）</p>
<p>此目录提供了一份关于所有经过批准的服务合同以及与此相关的评测的列表，从而形成了在整个企业内获得批准的服务水平的主列表。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
<li>合同</li>
<li>评测</li>
</ul>
<p>业务交互矩阵（Business Interaction Matrix）</p>
<p>此矩阵用于描述企业中各组织与业务功能之间的交互关系。理解企业中的业务交互是很重要的，因为它有助于突出整个组织中的价值链以及相互依赖关系。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织</li>
<li>业务功能</li>
<li>业务服务</li>
<li>业务服务之间的通信关系</li>
<li>业务服务之间的依赖关系</li>
</ul>
<p>执行者/角色矩阵（Actor/Role Matrix）</p>
<p>此矩阵用于展示哪些执行者扮演何种角色，并支持对安全性和技能需求的定义。理解执行者与角色之间的关系对定义培训需求、用户安全设置和组织变更管理具有关键性作用。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>执行者</li>
<li>角色</li>
<li>执行者与角色之间的担当关系</li>
</ul>
<p>务足迹图（Business Footprint Diagram）</p>
<p>业务足迹图描述了业务目标、组织单元、业务功能和服务之间的关联，并将这些功能映射到各个提供了所需能力的技术组件之上。它在从技术组件到业务目标的映射中提供了清晰的可追溯性，同时还对已经明确的服务的所有权进行了阐述。业务功能图仅对联系组织单元功能与交付服务的关键因素进行描述，并且还可被用来作为与高层次干系人（CIO、CEO等）进行沟通的平台。</p>
<p>业务服务/信息图（Business Service/Information Diagram）</p>
<p>业务服务/信息图展示了用于对一个或多个业务服务进行支持的信息，包括了由业务服务使用或者产生的数据及其信息源。服务/信息图对信息在架构中的最初表现形式进行了展现，因此为数据架构阶段的进一步描述打下了基础。</p>
<p>功能分解图（Functional Decomposition Diagram）</p>
<p>功能分解图的目标是将组织中与架构相关的各项能力展现在一张图纸之上。通过从功能的视角检视组织的各项能力，企业可以快速针对组织所做的事情进行建模，而不用陷入针对组织如何做所进行的额外讨论之中。</p>
<p>产品生命周期图（Product Lifecycle Diagram）</p>
<p>产品生命周期图的目标是对企业中关键实体的理解进行辅助。就关于产品从生产到撤销过程中所必须遵守的环境的关注、立法和规章来说，理解产品生命周期变得越来越重要。与此相同，在为了保证在控制、流程和程序的设计严谨而进行的业务架构开发过程中，创建涉及个人或敏感信息产品的组织必须对产品生命周期具有一个详尽的理解，例如信用卡、借记卡、智能卡以及用户身份认证等信息。</p>
<p>目标/阶段目标/服务图（Goal/Objective/Ser viceDiagram）</p>
<p>此图的目标是为服务对业务愿景或策略的达成而定义方法。通过将服务与驱动力、目标、阶段目标和相关的评测进行关联，企业可以了解到哪些服务贡献于相似的业务效能方面。此外，该图还为针对某一特定服务所形成的高效能的认定提供了定性的输入。</p>
<p>业务用例图（Business Use-Case Diagram）</p>
<p>业务用例图展示了业务服务的提供者和使用者之间的关系。业务服务被各个执行者或其他的业务服务所使用，而业务用例图则通过针对业务能力在何时以及如何被使用的描述，为业务能力的描述方面提供了额外的价值。此图形的目标是对各执行者和他们在各流程和功能中所担当的角色之间的交互关系进行描述和验证。随着架构过程的演进，这些用例图也将从业务级别发展至包括数据、应用和技术在内的更加详尽的级别。除此之外，业务用例图也可在系统设计工作中得到复用。</p>
<p>组织分解图（Organization Decomposition Diagram）</p>
<p>组织分解图描述了执行者、角色以及他们在组织树中所处位置之间的关系。一份组织分解图应提供了一条组织中决策者和业务拥有者的命令链。虽然组织分解图并不打算将组织与其目标联系在一起，但是在这张图中为最终目标与干系人之间建立直观的联系也是可以的。</p>
<p>流程图（Process Flow Diagram）</p>
<p>流程图的目标是对流程元模型实体相关的所有模型和映射进行描述，它展示了位于各个活动之间的顺序化控制流，并可借助于泳道技术来表达各个流程步骤的归属和实现。例如，用于支持一个流程步骤的应用就可以作为一条泳道来展示。除此之外，流程图也可以被用来细化赋予在流程之上的控制、触发某流程或产生于流程结束时的事件，以及由于流程执行所产生的各种输出产物。流程图在为主题专家描述架构时非常有用，它可以为这些专家描述一个特定功能的工作是如何被完成的。通过这样一个过程，每个流程步骤可以被细化为更小粒度的功能块，而且这些功能块在以后亦可以被当作一个流程来进行进一步的阐述。</p>
<p>事件图（Event Diagram）</p>
<p>事件图的目标是描述事件与流程之间的关系。诸如某些特定信息的到来，或者是某个特定的时间点这样的特定事件会致使业务中特定的工作和行为得以进行，同时也经常会有被称为业务事件（或简称事件）的信息被当作某个流程的触发者。</p>
<p>数据实体/数据组件目录（Data Entity/Data Component Catalog）</p>
<p>数据实体/数据组件目录的目标是明确和维护企业中使用的所有数据的列表，包括数据实体，以及用于存储数据实体的数据组件。一个经过批准的数据实体/数据组件目录支持对信息管理和数据治理策略的定义和应用，并且鼓励对数据进行有效地共享和重用。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>逻辑数据组件</li>
<li>物理数据组件</li>
</ul>
<p>数据实体/业务功能矩阵（Data Entity/Business Function Matrix）</p>
<p>此矩阵用来描述企业中数据实体和业务功能之间的关系。业务功能被具有明显边界的业务服务所支持，并通过业务流程加以实现。通过数据实体与业务功能之间的映射，企业可以得到：</p>
<ul>
<li>将数据实体的所有权分配给各个组织。</li>
<li>理解业务服务的数据和信息交换需求。</li>
<li>支持差距分析，并决定是否有需要被创建的数据实体被遗漏。</li>
<li>为数据实体定义源系统、记录系统和引用系统。</li>
<li>启动企业的数据治理程序的开发（建立数据管家、开发与业务功能相关的数据标准等）。</li>
</ul>
<p>此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>业务功能</li>
<li>数据实体与其所属组织单位的“从属”关系</li>
</ul>
<p>系统/数据矩阵（System/Data Matrix）</p>
<p>此矩阵用于描述系统与系统所访问和更新的数据实体之间的关系（一张两维表，其中一个纬度对应逻辑应用组件，而另外一个则对应数据实体）。系统用于创建、读取、更新和删除与他们相关联的特定数据实体。例如，一个客户关系系统将创建、读取、更新和删除客户实体信息。处在一个被封包好的服务环境中的数据实体可以被分为主数据、引用数据、事务数据、内容数据和历史数据，而用于操作这些数据实体的应用则包括事务应用、信息管理应用和业务仓库应用。针对应用组件和数据实体之间映射是一个非常重要的步骤，因为它可以使得：</p>
<ul>
<li>针对数据的访问能力被分配给组织中的具体应用。</li>
<li>了解在不同应用中数据重复的程度，以及数据生命周期的规模。</li>
<li>了解在何处相同的数据会被不同的应用所更新。</li>
<li>支持差距分析，并确定是否本应存在的应用被遗漏了。</li>
</ul>
<p>类图（Class Diagram）</p>
<p>类图的主要目标是描述企业中重要数据实体（或类）之间的关系。此图用于清晰地展示数据之间的关系，并帮助干系人理解企业下层数据模型。</p>
<p>数据传播图（Data Dissemination Diagram）</p>
<p>数据传播图的目标是展示数据实体、业务服务和应用组件之间关系。此图展示了各个逻辑实体如何被应用组件所实现。它使得针对数据大小的调整得以被有效地执行，同时IT足迹也会得以改善。而且，通过为数据设置业务价值，应用组件的业务重要性的指标也能够在同时被获得。另外，此图还可以展示针对数据复制和主引用的所有权，即它可以展示数据的两个备份以及数据之间的主-备份关系。此图还能够包含服务，比如，封装数据并且驻留在应用之内的服务，或者驻留在应用之上并能够访问封装在应用中的数据的服务。</p>
<p>上面所说的IT footprint中，footprint，即足迹，的本意是由动物遗留下的包含了遗留者本身标识和信息的事物。在信息技术领域，根据哈佛商学院Andrew McAfee所述，技术足迹表示了其在地理、逻辑分区和/或功能方面所能延展到范围，是针对一个信息技术所期望的覆盖范围的描述（A technology's footprint is its geographic, divisional, and/or functional reach. It's a description of how much territory a piece of IT is intended to cover）。在TOGAF中并没有说明数据大小的调整与IT足迹改善之间的关系，也没有说明所谓的IT足迹改善的具体含义。不过通过互联网上的一个关于IT足迹改善的实例，即将原本有着十几台计算机的教室用一台中心计算机和若干终端来代替，笔者有感而发，粗浅的认为这里IT足迹改善意思是说由于数据尺寸得到了很好的调整，那么不必需的冗余信息被削减，因而数据和应用的“足迹”，即其涉及到的范围，将比冗余剔除前更加清晰有效</p>
<p>数据安全图（Data Security Diagram）</p>
<p>数据可以看作是企业的一项资产，简单的讲，数据安全可被认为是确保企业数据不被损害，并且针对数据的访问也要在适当的控制之下。数据安全图的目标是描述何执行者可以访问企业中的哪些数据。此外，此图也可以被用来阐述与数据隐私法规以及其他应用性法规的符合度。此图还需要考虑发生在企业合作伙伴或其他团体对企业系统进行访问之处的信任含义，例如在外包的情形下，信息可能会被企业之外的其他人员（甚至身处国门之外）所管理。</p>
<p>类层次结构图（Class HierarchyDiagram）</p>
<p>类层次结构图的目标是为技术方面的干系人展示一个有关类层次的视图。此图的优点是干系人可以得到一份关于数据实体在技术层面上如何被使用的图形描述，它使得干系人可以了解何人正在针对数据进行使用，以及他是在何时、如何以及为何进行这项活动。</p>
<p>数据迁移图（Data Migration Diagram）</p>
<p>在实现一个以封包服务为基础的解决方案时，数据迁移是非常重要的，特别是将现存的遗留系统替换为一个服务封包时，或者当企业将要迁移到一个更大的封包服务时。每个服务包都倾向于具有属于他们自己的数据模型，并且在数据迁移过程中，遗留的应用数据可能需要在载入到服务封包之前需要进行某种转化。数据迁移活动通常包含如下的步骤：</p>
<ul>
<li>从原有应用中抽取出数据。</li>
<li>配置源数据</li>
<li>执行数据转换，其中包括数据质量相关的各个过程：
<ul>
<li>对数据进行标准化、归一化，并消除数据的重复性（数据清洗）。</li>
<li>针对不同来源的数据进行比对、合并和整合。</li>
<li>进行自源头至目标的映射</li>
</ul>
</li>
<li>将数据加载到目标应用之中。</li>
</ul>
<p>数据迁移图的目标是展示数据如何从源头应用流入到目标应用之中。此图为数据从源头到目标过程的进行提供了一个可视化表达，并可在数据审计和追溯中作为辅助工具。此外，此图所展示的细节程度可以按照需要进行调整。例如，数据迁移图可以仅仅包含一个关于迁移情况的整体布置，也可以为单独的应用提供元数据元素级别的详细信息。</p>
<p>数据生命周期图（Data Lifecycle Diagram）</p>
<p>数据生命周期图是在业务流程的约束之下对业务数据在其整个生命周期（从概念阶段到最终退出）中对其进行管理的核心部分。数据从本质上讲是一个实体，并独立于业务流程和活动。数据状态的每个变化都被表现在这张图中，这也可以包括引起此状态变化事件或规则。数据与流程的分离使得通用数据需求可以被识别出来，从而使得资源共享得以有效达成。</p>
<p>应用组合目录（Application Por tfolio Catalog）</p>
<p>此目录的目标是明确和维护企业中所有应用的列表。一个经过批准的应用组合目录使得一系列应用得以被定义和治理。此目录为后面的矩阵和图形提供了基础，是应用架构开发阶段的起点。现有的应用注册表和资源库（比如SAP的解决方案管理和系统情况目录产品）也从基线和目标两个角度为这个目录的制定提供了输入。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>信息系统服务</li>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
</ul>
<p>接口目录（Interface Catalog）</p>
<p>接口目录用来界定应用之间接口的范围，并对这些接口进行文档化记录，从而使得应用间的所有依赖关系得以被尽可地界定。系统可以用来创建、读取、更新和删除其他系统内的数据。无论是通过循环载入的批处理文件、对其他系统数据库的直接连接，还是通过某种形式的应用程序接口或Web服务，这些行为都是通过接口来实现。针对应用组件之间关系的映射是一个非常重要的步骤，它使得如下情形得以实现：</p>
<ul>
<li>了解应用间交互程度的，从而可以站在应用与其他系统之间依赖性的角度识别出各个关键的交互。</li>
<li>了解应用之间接口的数量和类型。</li>
<li>了解应用之间接口的重复程度。</li>
<li>在考虑目标应用组合时明确各接口的简化潜力。</li>
<li>支持差距分析，并确定是存在本应建立的应用被遗漏了。</li>
</ul>
<p>此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
<li>应用之间的通信关系</li>
</ul>
<p>系统/组织矩阵（System/Organization Matrix）</p>
<p>此矩阵用于描述企业中系统与组织单元之间的关系。业务功能由组织单元来执行，而一些由组织单元执行的功能和服务也将会被IT系统所支持。应用组件与组织单元之间的映射非常重要，它会使得：</p>
<ul>
<li>为执行业务功能的组织单元分配针对应用的使用。</li>
<li>理解由组织单元所执行的业务服务和流程对应用支持需求。</li>
<li>支持差距分析，并确定是否有需要被建立的应用被遗漏。</li>
<li>定义特定组织单元所使用的应用集合</li>
</ul>
<p>。<br>
此矩阵是一张两维表，其中逻辑/物理应用组件在一条坐标轴上，而组织单元在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
<ul>
<li>组织单位与服务之间的从属关系。</li>
<li>执行者与组织单位之间的从属关系，以及其与服务之间的使用关系。</li>
<li>服务与逻辑/物理应用组件之间的实现关系。</li>
</ul>
<p>角色/系统矩阵（Role/System Matrix）</p>
<p>此矩阵用来描述企业中系统与业务角色之间的关系。一个组织中的人们会与各种系统发生交互。在交互过程中，这些用户被假定成为执行一项任务的特定角色，例如，产品购买者。应用组件与角色之间的关系映射非常重要，它使得：</p>
<ul>
<li>
<p>在组织内为特定的角色分配针对应用的使用。</p>
</li>
<li>
<p>理解支持功能的业务服务和流程的应用安全需求，并检查是否与现有策略相符合。</p>
</li>
<li>
<p>支持差距分析，并确定是否有应该被创建的应用被遗漏。</p>
</li>
<li>
<p>定义被特定业务角色所使用的应用集合。<br>
此矩阵是一个两维表，其中逻辑应用组件在一条坐标轴上，而角色在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>角色与功能之间的访问关系。</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>系统/功能矩阵（System/Function Matrix）</p>
<p>此矩阵用于阐述企业中系统与业务功能之间的关系。业务功能由组织单元所执行。一些业务功能和服务将会被IT系统所支持。应用组件与功能之间的关系映射是非常重要的，它使得如下方面成为可能：</p>
<ul>
<li>
<p>为业务功能分配针对应用的使用</p>
</li>
<li>
<p>理解业务服务和流程的应用支持需求</p>
</li>
<li>
<p>支持差距分析，并确定是否有需要被创建的应用被遗漏</p>
</li>
<li>
<p>定义被特定业务功能所使用的应用集合<br>
此矩阵是一张两维表，其中逻辑应用组件位于一条坐标轴上，而功能处在另一条坐标轴之上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>应用交互矩阵（Application Interaction Matrix）</p>
<p>应用交互矩阵的目标是阐述系统之间的沟通关系。在矩阵中展示的应用交互映射与接口目录或者应用通信图示相类似的，只不过以矩阵的形式来展示。此矩阵是一张两维表，其中的每一个维度都包含了应用服务、逻辑应用组件和物理应用组件这些概念。在此矩阵中所描述的关系包括：</p>
<ul>
<li>应用服务之间的使用关系。</li>
<li>逻辑应用组件之间的通信关系。</li>
<li>物理应用组件的通信关系。</li>
</ul>
<p>应用通信图（Application Communication Diagram）</p>
<p>此图的目标是描述所有与应用之间的沟通相关的模型和映射。应用通信图展示了应用的应用组件和接口，并且接口可以关联数据实体，而应用则可以关联业务服务。此图所表述的“通信”应该是符合逻辑的，并且仅用来展示与架构相关的中介技术。</p>
<p>应用和用户位置图（Application and User Location Diagram）</p>
<p>应用和用户位置图展示了应用的地理分布情况。它可以被用来展示：</p>
<ul>
<li>被最终用户所使用的各个应用的地点分布</li>
<li>被执行和/或交付（在客户端情形下）的各个主机应用程序的地点分布情况</li>
<li>被开发、测试和发布的应用所处位置的分布情况</li>
</ul>
<p>此图的目标在于清晰地描述与应用发生交互的业务用户所处的业务位置，而且还包括了应用基础设施的位置。通过此图，我们可以：</p>
<ul>
<li>
<p>识别出足以支持分散在各地的用户群的产品包的数量</p>
</li>
<li>
<p>估算产品或软件的用户许可的类型和数量</p>
</li>
<li>
<p>估算用户的支持等级和支持中心的位置</p>
</li>
<li>
<p>选择系统管理工具、结构，以及用于支持本地或远程的企业用户/客户/合作伙伴的管理系统</p>
</li>
<li>
<p>适当规划业务的技术组件，即服务规模、网络带宽等</p>
</li>
<li>
<p>在实施应用和技术架构解决方案时进行性能方面的考虑<br>
用户通常会采用多种方式与应用进行交互，例如：</p>
</li>
<li>
<p>支持日常业务的运营。</p>
</li>
<li>
<p>参与业务流程的执行过程。</p>
</li>
<li>
<p>访问信息（查询、读取等）。</p>
</li>
<li>
<p>开发应用。</p>
</li>
<li>
<p>管理、维护应用。</p>
</li>
</ul>
<p>系统用例图（System Use-Case Diagram）</p>
<p>系统用例图展示了客户与应用服务提供者之间的关系。应用服务被角色或其他应用服务所使用，并且通过描述功能是在何时被如何使用，应用用例图对应用功能的描述提供了更多意义。此图的目标是帮助描述和验证各个参与者与他们对应用所担当的角色之间的交互。随着架构的进展，这些用例能够从功能性信息演进到包含技术实现细节。架构系统用例还可以在更细节的系统设计工作中被复用。</p>
<p>企业管理能力图（Enterprise Manageability Diagram）</p>
<p>企业管理能力图展示了一个或多个应用是如何与用以支持一个解决方案的运营管理的应用和技术组件进行交互的。此图实际上是针对应用通信图的一个过滤，特别是针对企业管理类软件方面。基于此图的分析可以揭示组织的IT服务管理操作方面重复、差距和机遇。</p>
<p>流程/系统实现图（Process/System Realization Diagram）</p>
<p>流程/系统实现图的目标是清晰地阐述在业务流程执行过程中涉及到多个应用时所产生的事件的顺序。此图可以识别出能够被简化的复杂顺序，以及架构中各种可能的合理化点，从而为业务用户提供更加及时的信息。此外，此图还可被用来明确流程中能够通过减少应用之间的交互流量而进行效率改善的地方。</p>
<p>软件工程图（Software Engineering Diagram）</p>
<p>系统工程图从开发的角度将应用分解为包、模块、服务和操作，它使得在各规划迁移阶段和分析机会与解决方案时进行更加详细的影响分析成为可能。在管理复杂开发环境时，系统工程图对应用开发团队和应用管理团队是非常有用的。</p>
<p>应用迁移图（Application Migration Diagram）</p>
<p>应用迁移图表明了应用从基线到目标应用组件的迁移过程，它通过精确地展示哪些应用和接口在迁移各阶段中需要被映射，使得针对迁移成本的估算更加准确。应用迁移图确定了临时的应用、集结区域以及用于支持迁移的各项基础设施。</p>
<p>软件分布图（Software Distribution Diagram）</p>
<p>软件分布图展示了应用软件在整个组织内的结构和布局，它在系统升级或应用整合项目中是非常有用的。此外，软件分布图还展示了物理应用在整个物理技术领域中是如何分布的，以及这些物理技术的位置。软件分布图对软件是如何被托管的这一问题提供了一份清晰的视图，而且还使得管理操作人员能够了解应用软件在安装成功后是如何被维护的。</p>
<p>技术标准目录（Technology Standards Catalog）</p>
<p>技术标准目标记录了企业中被批准的各项技术标准，涵盖了技术、版本、技术生命周期，以及技术的更新周期。根据组织需要，也可能包括地点或者业务的特定领域的标准信息。此目录提供了一个当前或能够被部署的企业标准技术的快照，并有助于在整个企业内搜寻差异。如果当前已经存在了各种技术标准，那么把它们放入到技术组合目录中将会得到一张关于各技术标准符合性的基线视图。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>技术组合目录（Technology Por tfolio Catalog）</p>
<p>此目录的目标是识别和维护整个企业中在用技术的列表，包括硬件、技术设施软件，以及应用软件。一个经过批准的技术组合支持技术产品和版本的生命周期管理，而且还形成了技术标准定义的基础。技术组合目录为后续的矩阵和图形描述提供了基础，是技术架构开发阶段的起点。技术注册表和资源库从基线和目标的视角为此目录提供了输入。在此目录中的技术应该按照TOGAF技术参考模型（可以按照需要来对模型进行扩展，从而符合针对正在使用的技术产品的分类）进行分类。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>系统/技术矩阵（System/Technology Matrix）</p>
<p>系统/技术矩阵记录了业务系统与技术平台之间的映射关系。此矩阵应该是一张或多张平台分解图的补充，并应与这些图保持一致。此矩阵展示了：</p>
<ul>
<li>逻辑/物理应用组件。</li>
<li>服务、逻辑技术组件以及物理技术组件。</li>
<li>物理技术组件与物理应用组件之间的实现关系。</li>
</ul>
<p>环境和位置图（Environments and Locations Diagram）</p>
<p>环境和位置图描述了哪些应用处于哪些位置，并标识出什么技术和/或应用被用在了哪些地方，以及表示出业务用户一般在何处与应用进行交互。此图还展示了不同部署环境的存在和位置，包括非生产环境，例如开发和预生产。</p>
<p>平台分解图（Platform Decomposition Diagram）</p>
<p>平台分解图描述了用于支持信息系统架构运行的技术平台。此图涵盖了技术设施平台的所有方面，并提供了一个关于企业技术平台的概览。此图可以通过扩展来将技术平台映射到适当的处于特定功能或流程区域内的应用组件。此图还可以被用来展示规范说明的细节，例如产品版本、CPU数量等，或者只是用来提供技术环境概览的非正式的“过眼图”。</p>
<p>此图应该清楚的展示企业应用和针对每个应用区域的技术平台，它可以被进一步分解为：</p>
<ul>
<li>硬件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
<li>软件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>处理图（Processing Diagram）</p>
<p>处理图关注于代码/配置的部署单元（针对业务功能、服务或应用组件的分组），以及这些单元是如何被部署到技术平台之上的。处理图表明了：</p>
<ul>
<li>
<p>哪些应用组件需要被组织起来，并形成部署单元。</p>
</li>
<li>
<p>部署单元之间是如何连接和交互的。</p>
</li>
<li>
<p>应用配置和使用模式是如何针对不同的技术组件而产生负载或容量方面需求。<br>
针对部署单元的组织和分组依赖于对组件的展示、业务逻辑以及数据存储层和服务水平需求这些方面关注点的分离。例如，展示层部署单元是基于如下方面进行分组的：</p>
</li>
<li>
<p>用于提供用户界面或用户访问功能的应用组件。</p>
</li>
<li>
<p>根据位置和用户角色来进行区分的应用组件。<br>
每个部署单元是由若干子单元所组成的，例如：</p>
</li>
<li>
<p>安装单元：包含可执行的代码或封包配置的部分。</p>
</li>
<li>
<p>执行单元：应用组件以及与其相关的运行时状态。</p>
</li>
<li>
<p>持久化单元：代表应用组件的持久化状态的数据。<br>
部署单元可以被部署到专用或共享的技术组件之上（工作站、Web服务器、应用服务器或数据库服务器等）。需要注意的是，技术处理对于服务的定义和粒度具有着较大的影响。</p>
</li>
</ul>
<p>网络计算/硬件图（Networked Computing/Hardware Diagram）</p>
<p>从大型机到客户端-服务器系统的改造开始，以及随后的电子商务和J2EE的出现，大型企业逐步进入到了一个高度网络化的分布式网络计算环境之中。当前，大多数应用都具有一个Web前端，并且就这些应用的部署架构来说，具备三个独立层次的情况还是非常常见的，亦即Web表现层、业务逻辑或应用层，以及一个后台数据存储层。将应用部署到一个共享的通用技术设施环境之中也是一种常见的做法。</p>
<p>由此可见，将逻辑应用与在开发和生产过程中对应用进行支持的技术组件之间的映射关系记录起来是非常重要的。网络计算/硬件图的目标是展示逻辑应用组件在一个分布式网络计算环境中部署的逻辑视图。此图之所以有用，是因为通过此图我们可以：</p>
<ul>
<li>了解应用部署在分布式网络计算环境中的什么地方。</li>
<li>建立针对这些技术组件的授权、安全和访问。</li>
<li>了解在问题解决和故障排除中用以支持应用的技术架构。</li>
<li>对应用所遇到的性能问题进行隔离，确定应用是代码相关的，还是技术平台相关的，并对具体的物理技术组件进行必要的升级。</li>
<li>当新的技术出现并能够因此带来成本缩减时，确定可通过此技术进行优化的区域。</li>
<li>使得应用/技术审计成为可能，并证明企业技术标准的符合性程度。</li>
<li>作为将变更引入到技术架构的用力工具，从而支持有效地变更管理。</li>
<li>当应用从一个共享环境迁移到一个专门的环境时，建立可追溯性和正在进行变化的应用的终端地址，反之亦然。</li>
</ul>
<p>通过适当的定义，网络计算/硬件图的范围可以涵盖某一个特定的应用、业务功能或者是整个企业，而如果选择在企业级别进行开发，那么组织就可以通过一种与应用无关的方式来对网络计算情况进行描述。</p>
<p>通信工程图（Communications Engineering Diagram）</p>
<p>通信工程图描述了处在技术架构中的各资产之间的通信方法（收发信息的方法）。此图展示了客户端和服务器组件之间的逻辑连接，并明确了用于对这些逻辑连接进行实现的网络边界和网络基础设施。需要注意的是，此图并不描述参与通信的信息格式或内容，但它可以对通信协议以及容量方面的问题进行阐述。</p>
<p>项目背景图（Project Context Diagram）</p>
<p>项目背景图展示了作为过渡路线图一部分而实现的工作包的范围。此图会将工作包与在项目中被增加、删除或影响的组织、功能、服务、流程、应用、数据以及技术连接在一起。此图对于项目组合管理和项目动员来说也是一个有价值的工具。</p>
<p>效益图（Benefits Diagram）</p>
<p>效益图展示了在架构定义中识别出来的各种机会，并通过他们的相对规模、效益和复杂度进行分类。此图可被干系人用来对这些识别出来的机会进行选择、对其优先级进行定义，并对他们的顺序进行确定。</p>
<p>需求目录（Requirements Catalog）</p>
<p>需求目录包含企业需要用来满足目标要求的种种事物。在架构行为中所产生的需求一般会通过变更措施来实现，并在机会和解决方案阶段中界定其范围。需求还可以被用来作为质量保证的工具，从而保证针对特定架构的使用始终处在其使用范围之内。</p>
<h3> 3、针对视图的开发</h3>
<p>如前所述，TOGAF中定义了一系列基本的架构制品来担当原子性视角，不同的组织可以根据自身的需要创建、改造或利用这些原子视角，并根据不同干系人的关注点将这些架构制品组合为适合于他们的视角定义，因而针对视图的开发需要明确其目标干系人、他们的关注点，以及所采用的各种基本架构制品和建模方法。TOGAF中针对多种视图的开发方法进行了建议，包括：</p>
<ul>
<li>业务架构视图：此视图是为用户而进行开发的，它从系统用户的角度对系统的功能性方面进行关注。</li>
<li>企业安全视图：此视图是为系统安全工程师而进行开发的，它从安全的角度对系统如何实现，以及安全如何影响系统特性这些方面进行关注，这其中最重要的是，相关干系人能够了解如何确保系统仅能被具有权限的人员或系统来进行访问，以及如何保护系统不受到非授权地侵扰。</li>
<li>软件工程视图：创建一个软件密集型系统是非常耗费资源和时间的，因而建立一个能够帮助最小化劳力付出和风险的导则是非常必要的，而这正是软件工程视图的目标。此视图应该是为开发系统的软件工程师而进行开发的。</li>
<li>系统工程视图：此视图应该是为系统的系统工程人员而进行开发的，并从硬件/软件和网络连接的角度对系统如何被实现进行关注。</li>
<li>通信工程视图：此视图应该是为系统的通信工程人员而进行开发的，并在通信工程师的角度关注于系统是如何被实现的。</li>
<li>数据流视图：此视图应该是为系统的数据库工程师而进行开发的。此视图的主要关注点在于了解如何为正确的人员和应用通过适当的接口并在合适的时间提供正确的数据。</li>
<li>企业管理能力视图：此视图应该是为系统的运营、行政和管理人员而进行开发的。此视图的主要关注点在于了解系统是如何做为一个整体而被管理的，以及系统的所有组件是如何被管理的，这其中关键之处在于管理系统变更，并对预防性维护措施进行预测。</li>
<li>采购视图：此视图应该是为在架构组件的采购过程中所牵涉的人员而进行开发的。此视图的主要关注点在于了解哪些架构的构建块是需要被采购的，以及与采购行为相关的各种约束。</li>
</ul>
<h3> 5、构建块（Building Blocks）</h3>
<p>架构构建块可以说是企业架构内容的核心，也是企业架构开发方法的最终产物。与此相比，架构交付物所面向的是企业架构开发过程，架构制品则可以看作是企业架构内容的表现形式和使用方式，而唯有构建块则是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些企业各个领域中的可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<p>构建块特性</p>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>构建块是为了达成整个组织的需要而定义的功能包。</li>
<li>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</li>
<li>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</li>
<li>构建块通常会与其他相互依存的构建块进行互操作。</li>
</ul>
<p>除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
<ul>
<li>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</li>
<li>一个好的构建块可以由其他构建块组合而成。</li>
<li>一个好的构建块可以是其他构建块的一个组件。</li>
<li>在理想的情况下，一个构建块应是可重用和可替换的，并具备详尽的描述。</li>
</ul>
<p>构建块分类</p>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的，也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者则在实现的层面对能够实现构建块的解决方案进行描述。需要注意的是，由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合，因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>①架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>②解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>解决方案与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<p>构建块的使用原则</p>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同，并且组织也应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用，因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>
<p>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</p>
</li>
<li>
<p>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</p>
</li>
<li>
<p>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并在之后将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</p>
</li>
<li>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
</li>
<li>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
</li>
</ul>
<p>构建块与架构开发方法</p>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，而包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<h2> 五、机构构建块（Building Blocks）</h2>
<p>架构构建块是企业架构内容的核心，也是企业架构开发方法的最终产物。架构交付物面向的是企业架构开发过程，架构制品则是企业架构内容的表现形式和使用方式，而唯有构建块是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<h3> 1、构建块特性</h3>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>
<p>构建块是为了达成整个组织的需要而定义的功能包。</p>
</li>
<li>
<p>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</p>
</li>
<li>
<p>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</p>
</li>
<li>
<p>构建块通常会与其他相互依存的构建块进行互操作。<br>
除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
</li>
<li>
<p>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</p>
</li>
<li>
<p>一个好的构建块可以由其他构建块组合而成。</p>
</li>
<li>
<p>一个好的构建块可以是其他构建块的一个组件。</p>
</li>
<li>
<p>一个构建块应是可重用和可替换的，并具备详尽的描述。</p>
</li>
</ul>
<h3> 2、构建块分类</h3>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的。也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者在实现层面对能够实现构建块的解决方案进行描述。由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合。因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<h3> 3、构建块的使用原则</h3>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同。组织应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用。因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</li>
<li>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</li>
<li>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</li>
</ul>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
<h3> 4、构建块与架构开发方法</h3>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<figure><figcaption>img_31.png</figcaption></figure>
]]></content:encoded>
    </item>
    <item>
      <title>Java的四个核心思想</title>
      <link>https://ujava.cn/java/basecore.html</link>
      <guid>https://ujava.cn/java/basecore.html</guid>
      <source url="https://ujava.cn/rss.xml">Java的四个核心思想</source>
      <description>Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。 Java虚拟机 Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。</description>
      <category>Java</category>
      <pubDate>Wed, 31 Jan 2024 00:48:57 GMT</pubDate>
      <content:encoded><![CDATA[<p>Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。</p>
<h2> Java虚拟机</h2>
<p>Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。</p>
<p>不同的Java虚拟机中，执行引擎可能实现得非常不同。在由软件实现的虚拟机中：</p>
<ul>
<li>（1）最简单的执行引擎就是一次性解释字节码。</li>
<li>（2）另一种执行引擎更快，但是也更消耗内存，叫做"即时编译器(just-in-time compiler)"。在这种情况下，第一次被执行的字节码会被编译成本地机器代码。编译出的本地机器代码会被缓存，当以后方法被调用的时候可以重用。</li>
<li>（3）第三种执行引擎是自适应优化器。在这种方法里，虚拟机开始的时候解释字节码，但是会监视运行中程序的活动，并且记录下使用最频繁的代码段。程序运行的时候，虚拟机只把那些活动最频繁的代码编译成本地代码，其他的代码由于使用得不是很频繁，继续保留为字节码-由虚拟机继续解释它们。一个自适应的优化器可以使得Java虚拟机在80%<sub>90%的时间里执行被优化过的本地代码，而只需要编译10%</sub>20%的对性能有影响的代码。</li>
</ul>
<p>当Java虚拟机是由主机操作系统上的软件实现的时候，Java程序通过调用本地方法(native method)和主机交互。Java中有两种方法: Java方法和本地方法。Java方法是由Java语言编写，编译成字节码文件，存储在class文件中的。本地方法是由其他语言(比如c,c++或汇编语言)编写的，编译成何处理器相关的机器代码。本地方法保存在动态链接库中,格式是各个平台专有的。运行中Java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库，并调用这个方法。本地方法是联系Java程序和底层主机操作系统的连接方法。</p>
<p>通过本地方法，Java程序可以直接访问底层操作系统的资源。一个本地方法接口(Java Native Interface, JNI)-使得本地方法可以在特定主机系统的任何一个Java平台实现上运行。</p>
<p>如果希望使用特定主机上的资源，它们又无法从Java API访问，那么可以写一个平台相关的Java程序来调用本地方法。如果希望保证程序的平台无关性，那么只能通过Java API来访问底层系统资源。</p>
<h2> 类装载器的体系结构</h2>
<p>一个Java应用程序可以使用两种类装载器："启动(bootstrap)"类装载器和用户定义的类装载器。启动类装载器(这是系统中唯一的)是Java虚拟机实现的一部分。启动类装载器通常使用某种默认方式从本地磁盘中装载类，包括Java API类(启动类装载器也被称为原始类装载器、系统类装载器或者默认类装载器)。</p>
<p>Java应用程序能够在运行时安装用户定义的类装载器，这种类装载器能够使用自定义的方式来装载类。例如，从网络下载class文件。尽管启动类装载器是虚拟机实现的本质部分，而用户定义的类装载器不是，但用户定义的类装载器能够用Java来编写,能够被编译成class文件，能够被虚拟机装载，还能够像其它对象一样实例化。</p>
<p>由于有用户定义类装载器，所以不必在编译的时候就知道运行中的Java应用程序中最终会加入的所有的类。用户定义的类装载器使得在运行扩展Java应用程序成为可能。当它运行时，应用程序能够解决它需要哪些额外的类，能够决定是使用一个或是更多的用户定义的类装载器来装载。由于类装载器是用Java编写的，所以用任何在Java代码中可以表述的风格来进行类装载。这些类可以通过网络下载，可以从某些数据库中获取，甚至可以动态生成。</p>
<p>每一个类被装载的时候，Java虚拟机都监视这个类，看到它到底是被启动类装载器还是被用户定义类装载器装载。当被装载的类引用了另外一个类时，虚拟机就会使用装载第一个类的类装载器装载引用的类。例如，如果虚拟机使用一个特定的类装载器装载Volcano这个类，它就会使用这个类装载器装载Volcano类使用的所有类。</p>
<p>由于Java虚拟机采取这种方式进行类的装载，所以被装载的类默认情况下只能看到被同一个类装载器装载的别的类。通过这种方法，Java的体系结构允许在一个Java应用程序中建立多个命名空间。运行时的Java程序中的每一个类装载器都有自己的命名空间。</p>
<p>Java应用程序可以创建多个(或多种)被不同的类装载器装载的类并把这些类存放在不同的命名空间中，它们不能相互访问，除非应用程序显示地允许这么做。当编写一个Java应用程序的时候，从不同源文件装载的类可以分隔在不同的命名空间中。通过这种方法，就能够使用Java类装载器的体系结构来控制任何不同源文件中装载的代码之间的相互影响，特别是能够阻止恶意代码获取访问或破坏善意代码的权限。</p>
<p>Web浏览器是一个动态扩展的例子，Web浏览器使用用户定义的类装载器从网络下载用于Java applet的class文件。Web浏览器使用一个用来安装用户定义类装载器的Java应用程序。这个用户定义的类装载器通常被称为Java Applet类装载器，它知道如何向HTTP服务器请求class文件。Java Applet可以作为动态扩展的例子，因为Java应用程序并不知道它什么时候会开始从网络下载浏览器请求的class文件。只有当浏览器遇到有Java applet的页面时，才决定是否需要下载class文件。</p>
<p>Web浏览器启动的Java应用程序通常为每个提供class文件的网络地址分别创建不同的用户定义类装载器，因此，不同的用户定义类装载器装载不同来源的class文件。这就可以把它们分别放置在Java主机应用程序的不同命名空间之下。由于不同来源的Java applet文件放置在不同的命名空间中，恶意的Java applet代码就不会直接访问从别的地方下载的class文件。这就能够限制或阻止不同来源的代码之间的相互访问。</p>
<h2> Java class文件</h2>
<p>Java class文件主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。这种途径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件时可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。</p>
<p>当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的"机器语言"。</p>
<p>class文件设计得紧凑，因此它们可以快速地在网络上传送。其次，由于Java程序是动态连接和动态扩展的，class文件可以在需要的时候才下载。这个特点使得Java应用程序能够安排从网络上下载class文件的时间，从而可以最大限度地减少终端用户的等待时间。</p>
<h2> Java API</h2>
<p>Java API通过支持平台无关性和安全性，使得Java适应于网络应用。Java API是运行库的集合，它提供了一套访问主机系统资源的标准方法。运行Java程序时，虚拟机装载程序的class文件是所使用的Java API class文件。所有被装载的class文件(包括从应用程序中和从Java API中提取的)和所有已经装载的动态库(包含本地方法)共同组成了再Java虚拟机上运行的整个程序。</p>
<p>在一个平台能够支持Java程序以前，必须在这个特定平台上明确地实现API的功能。为访问主机上的本地资源，Java API调用了本地方法。由于Java API class文件调用了本地方法，Java程序就不需要再调用它们了。通过这种方法，Java API class文件为底层主机提供了具有平台无关性、标准接口的Java程序。对Java程序而言，无论平台内部如何，Java API都会有同样的表现和可预测的行为。正是由于在每个特定的主机平台上明确地实现了Java虚拟机和Java API,因此，Java程序自身就能够成为具有平台无关性的程序。</p>
<p>Java API在Java安全性模型方面也有贡献。当Java API的方法进行任何有潜在危险的操作(比如进行本地磁盘写操作)之前，都会通过查询访问控制器来检验是否得到了授权。访问控制器是一个类，该类用来执行栈检验，已决定是否允许某种操作。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>