{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "UJava",
  "home_page_url": "https://ujava.cn/",
  "feed_url": "https://ujava.cn/feed.json",
  "description": " 【Java学习 + Java面试】首选UJava！  ",
  "items": [
    {
      "title": "反应器(Reactor)模式",
      "url": "https://ujava.cn/design/other/reactor.html",
      "id": "https://ujava.cn/design/other/reactor.html",
      "summary": "概述 Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。",
      "content_html": "<h2> 概述</h2>\n<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "读写锁模式",
      "url": "https://ujava.cn/design/other/readerwriterlock.html",
      "id": "https://ujava.cn/design/other/readerwriterlock.html",
      "summary": "概述 当访问数据结构模式时，常规锁不会区分“读锁”和“写锁” 由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。 众所周知，读写器锁的存在解决了这个问题 “多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成 并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者 正在修改或写入数据，并被取消阻止，直到写入程序完成写入。",
      "content_html": "<h2> 概述</h2>\n<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>\n由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>\n众所周知，读写器锁的存在解决了这个问题<br>\n“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>\n并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>\n正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "注册(Registry)模式",
      "url": "https://ujava.cn/design/other/registry.html",
      "id": "https://ujava.cn/design/other/registry.html",
      "summary": "概述 存储单个类的对象，并提供对它们的全局访问点。 与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。",
      "content_html": "<h2> 概述</h2>\n<p>存储单个类的对象，并提供对它们的全局访问点。<br>\n与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "存储库(Repository)模式",
      "url": "https://ujava.cn/design/other/repository.html",
      "id": "https://ujava.cn/design/other/repository.html",
      "summary": "概述 存储库层添加在域和数据映射层之间，以将域对象与 数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个 存储库模式在域类数量很大或很重的系统中特别有用 利用查询。",
      "content_html": "<h2> 概述</h2>\n<p>存储库层添加在域和数据映射层之间，以将域对象与<br>\n数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>\n存储库模式在域类数量很大或很重的系统中特别有用<br>\n利用查询。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "资源获取即初始化模式",
      "url": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "id": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "summary": "概述 资源获取即初始化模式可用于实现异常安全的资源管理。",
      "content_html": "<h2> 概述</h2>\n<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "重试(Retry)模式",
      "url": "https://ujava.cn/design/other/retry.html",
      "id": "https://ujava.cn/design/other/retry.html",
      "summary": "概述 透明地重试涉及与外部资源通信的某些操作， 特别是在网络上，将调用代码与重试实现细节隔离开来。",
      "content_html": "<h2> 概述</h2>\n<p>透明地重试涉及与外部资源通信的某些操作，<br>\n特别是在网络上，将调用代码与重试实现细节隔离开来。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "角色对象(Role Object)模式",
      "url": "https://ujava.cn/design/other/roleobject.html",
      "id": "https://ujava.cn/design/other/roleobject.html",
      "summary": "概述 通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色 对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为 单独的对象、不同的上下文是分开的，并且简化了系统配置。",
      "content_html": "<h2> 概述</h2>\n<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>\n对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>\n单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务(Saga)模式",
      "url": "https://ujava.cn/design/other/saga.html",
      "id": "https://ujava.cn/design/other/saga.html",
      "summary": "概述 这种模式用于分布式服务，以原子方式执行一组操作。 这是数据库中事务的模拟，但就微服务架构而言，这是执行的 在分布式环境中",
      "content_html": "<h2> 概述</h2>\n<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>\n这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>\n在分布式环境中</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分离接口模式",
      "url": "https://ujava.cn/design/other/separatedinterface.html",
      "id": "https://ujava.cn/design/other/separatedinterface.html",
      "summary": "概述 在不同的包中分离接口定义和实现。这允许客户端 完全不知道实现。",
      "content_html": "<h2> 概述</h2>\n<p>在不同的包中分离接口定义和实现。这允许客户端<br>\n完全不知道实现。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "序列化实体模式",
      "url": "https://ujava.cn/design/other/serializedentity.html",
      "id": "https://ujava.cn/design/other/serializedentity.html",
      "summary": "概述 序列化实体模式。 序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。",
      "content_html": "<h2> 概述</h2>\n<p>序列化实体模式。<br>\n序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "雇工(Servant)模式",
      "url": "https://ujava.cn/design/other/servant.html",
      "id": "https://ujava.cn/design/other/servant.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务层模式",
      "url": "https://ujava.cn/design/other/servicelayer.html",
      "id": "https://ujava.cn/design/other/servicelayer.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务定位模式",
      "url": "https://ujava.cn/design/other/servicelocator.html",
      "id": "https://ujava.cn/design/other/servicelocator.html",
      "summary": "概述 使用封装获取服务所涉及的过程 强抽象层。",
      "content_html": "<h2> 概述</h2>\n<p>使用封装获取服务所涉及的过程<br>\n强抽象层。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务工作者模式",
      "url": "https://ujava.cn/design/other/serviceworker.html",
      "id": "https://ujava.cn/design/other/serviceworker.html",
      "summary": "概述 将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。",
      "content_html": "<h2> 概述</h2>\n<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分区(Sharding)模式",
      "url": "https://ujava.cn/design/other/sharding.html",
      "id": "https://ujava.cn/design/other/sharding.html",
      "summary": "概述 Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。 shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。",
      "content_html": "<h2> 概述</h2>\n<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>\nshard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "空间分区模式",
      "url": "https://ujava.cn/design/other/spatialpartition.html",
      "id": "https://ujava.cn/design/other/spatialpartition.html",
      "summary": "概述 正如《游戏编程模式》一书中所解释的那样 Bob Nystrom认为，空间分区模式通过将对象存储在 按位置组织的数据结构。",
      "content_html": "<h2> 概述</h2>\n<p>正如<a href=\"http://gameprogrammingpatterns.com/spatial-partition.html\" target=\"_blank\" rel=\"noopener noreferrer\">《游戏编程模式》</a>一书中所解释的那样<br>\nBob Nystrom认为，空间分区模式通过将对象存储在<br>\n按位置组织的数据结构。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "特殊例子模式",
      "url": "https://ujava.cn/design/other/specialcase.html",
      "id": "https://ujava.cn/design/other/specialcase.html",
      "summary": "概述 定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。",
      "content_html": "<h2> 概述</h2>\n<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "规范(Specification)模式",
      "url": "https://ujava.cn/design/other/specification.html",
      "id": "https://ujava.cn/design/other/specification.html",
      "summary": "概述 规范模式将如何匹配候选对象的语句与候选对象分开 与之匹配的。它不仅在选择中有用，而且对 验证和按订单建造。",
      "content_html": "<h2> 概述</h2>\n<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>\n与之匹配的。它不仅在选择中有用，而且对<br>\n验证和按订单建造。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "步骤建立者模式",
      "url": "https://ujava.cn/design/other/stepbuilder.html",
      "id": "https://ujava.cn/design/other/stepbuilder.html",
      "summary": "概述 Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。 用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。",
      "content_html": "<h2> 概述</h2>\n<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>\n用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扼杀者(Strangler)模式",
      "url": "https://ujava.cn/design/other/strangler.html",
      "id": "https://ujava.cn/design/other/strangler.html",
      "summary": "概述 通过逐步替换特定的功能，逐步迁移遗留系统 新的应用程序和服务。随着旧系统的功能被替换 系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后 扼杀旧系统，让你退役。",
      "content_html": "<h2> 概述</h2>\n<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>\n新的应用程序和服务。随着旧系统的功能被替换<br>\n系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>\n扼杀旧系统，让你退役。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "子类沙盒模式",
      "url": "https://ujava.cn/design/other/subclasssandbox.html",
      "id": "https://ujava.cn/design/other/subclasssandbox.html",
      "summary": "概述 子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。",
      "content_html": "<h2> 概述</h2>\n<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "表模块(Table Module)模式",
      "url": "https://ujava.cn/design/other/tablemodule.html",
      "id": "https://ujava.cn/design/other/tablemodule.html",
      "summary": "概述 表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。",
      "content_html": "<h2> 概述</h2>\n<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模版方法(Template method)模式",
      "url": "https://ujava.cn/design/other/templatemethod.html",
      "id": "https://ujava.cn/design/other/templatemethod.html",
      "summary": "概述 在操作中定义算法的骨架，将一些步骤推迟到子类中。样板 方法允许子类在不更改算法的情况下重新定义算法的某些步骤 结构",
      "content_html": "<h2> 概述</h2>\n<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>\n方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>\n结构</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "本地线程存储模式",
      "url": "https://ujava.cn/design/other/threadlocalstorage.html",
      "id": "https://ujava.cn/design/other/threadlocalstorage.html",
      "summary": "概述 提供为每个线程提供一个变量副本的功能，使其线程安全。",
      "content_html": "<h2> 概述</h2>\n<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "线程池模式",
      "url": "https://ujava.cn/design/other/threadpool.html",
      "id": "https://ujava.cn/design/other/threadpool.html",
      "summary": "概述 通常情况下，要执行的任务是短暂的，并且任务数量很大。 为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁 线程而不是执行实际任务。线程池通过重用现有的 线程，并消除创建新线程的延迟。",
      "content_html": "<h2> 概述</h2>\n<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>\n为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>\n线程而不是执行实际任务。线程池通过重用现有的<br>\n线程，并消除创建新线程的延迟。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "节流(Throttling)模式",
      "url": "https://ujava.cn/design/other/throttling.html",
      "id": "https://ujava.cn/design/other/throttling.html",
      "summary": "概述 确保给定的客户端访问服务资源的次数不能超过指定的限制。",
      "content_html": "<h2> 概述</h2>\n<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "读者容错(Tolerant Reader)模式",
      "url": "https://ujava.cn/design/other/tolerantreader.html",
      "id": "https://ujava.cn/design/other/tolerantreader.html",
      "summary": "概述 Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法 是在从另一个服务读取数据时尽可能宽容。这样，当 交流模式发生变化，读者一定不能断。",
      "content_html": "<h2> 概述</h2>\n<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>\n是在从另一个服务读取数据时尽可能宽容。这样，当<br>\n交流模式发生变化，读者一定不能断。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "蹦床(Trampoline)模式",
      "url": "https://ujava.cn/design/other/trampoline.html",
      "id": "https://ujava.cn/design/other/trampoline.html",
      "summary": "概述 Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法 并且交织功能的执行而不将它们硬编码在一起。",
      "content_html": "<h2> 概述</h2>\n<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>\n并且交织功能的执行而不将它们硬编码在一起。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务脚本模式",
      "url": "https://ujava.cn/design/other/transactionscript.html",
      "id": "https://ujava.cn/design/other/transactionscript.html",
      "summary": "概述 事务脚本按过程组织业务逻辑，其中每个过程处理一个 来自演示文稿的请求。",
      "content_html": "<h2> 概述</h2>\n<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>\n来自演示文稿的请求。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双(Twin)模式",
      "url": "https://ujava.cn/design/other/twin.html",
      "id": "https://ujava.cn/design/other/twin.html",
      "summary": "概述 双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个 java中的继承",
      "content_html": "<h2> 概述</h2>\n<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>\njava中的继承</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务脚本模式",
      "url": "https://ujava.cn/design/other/typeobject.html",
      "id": "https://ujava.cn/design/other/typeobject.html",
      "summary": "概述 当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。",
      "content_html": "<h2> 概述</h2>\n<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "工作单元模式",
      "url": "https://ujava.cn/design/other/unitofwork.html",
      "id": "https://ujava.cn/design/other/unitofwork.html",
      "summary": "概述 当业务事务完成时，所有更新都作为一个大的工作单元发送 一次性持久化，以最大限度地减少数据库往返。",
      "content_html": "<h2> 概述</h2>\n<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>\n一次性持久化，以最大限度地减少数据库往返。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "更新方法模式",
      "url": "https://ujava.cn/design/other/updatemethod.html",
      "id": "https://ujava.cn/design/other/updatemethod.html",
      "summary": "概述 更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。",
      "content_html": "<h2> 概述</h2>\n<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "值对象模式",
      "url": "https://ujava.cn/design/other/valueobject.html",
      "id": "https://ujava.cn/design/other/valueobject.html",
      "summary": "概述 提供遵循值语义而不是引用语义的对象。 这意味着值对象的相等性不是基于身份的。两个值对象是 当它们具有相同的值时相等，而不一定是同一对象。",
      "content_html": "<h2> 概述</h2>\n<p>提供遵循值语义而不是引用语义的对象。<br>\n这意味着值对象的相等性不是基于身份的。两个值对象是<br>\n当它们具有相同的值时相等，而不一定是同一对象。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "版本号模式",
      "url": "https://ujava.cn/design/other/versionnumber.html",
      "id": "https://ujava.cn/design/other/versionnumber.html",
      "summary": "概述 版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。",
      "content_html": "<h2> 概述</h2>\n<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "页面对象模式",
      "url": "https://ujava.cn/design/other/pageobject.html",
      "id": "https://ujava.cn/design/other/pageobject.html",
      "summary": "概述 Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI 组件。这样一来，它允许测试类本身专注于测试逻辑。",
      "content_html": "<h2> 概述</h2>\n<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>\n组件。这样一来，它允许测试类本身专注于测试逻辑。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "参数对象模式",
      "url": "https://ujava.cn/design/other/parameterobject.html",
      "id": "https://ujava.cn/design/other/parameterobject.html",
      "summary": "概述 Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。",
      "content_html": "<h2> 概述</h2>\n<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "部分响应模式",
      "url": "https://ujava.cn/design/other/partialresponse.html",
      "id": "https://ujava.cn/design/other/partialresponse.html",
      "summary": "概述 根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。",
      "content_html": "<h2> 概述</h2>\n<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "管道(Pipeline)模式",
      "url": "https://ujava.cn/design/other/pipeline.html",
      "id": "https://ujava.cn/design/other/pipeline.html",
      "summary": "概述 通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。",
      "content_html": "<h2> 概述</h2>\n<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "毒丸(Poison Pill)模式",
      "url": "https://ujava.cn/design/other/poisonpill.html",
      "id": "https://ujava.cn/design/other/poisonpill.html",
      "summary": "概述 毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。",
      "content_html": "<h2> 概述</h2>\n<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "演示模型模式",
      "url": "https://ujava.cn/design/other/presentationmodel.html",
      "id": "https://ujava.cn/design/other/presentationmodel.html",
      "summary": "概述 演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。",
      "content_html": "<h2> 概述</h2>\n<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "优先级队列模式",
      "url": "https://ujava.cn/design/other/priorityqueue.html",
      "id": "https://ujava.cn/design/other/priorityqueue.html",
      "summary": "概述 对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。",
      "content_html": "<h2> 概述</h2>\n<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "私有类数据模式",
      "url": "https://ujava.cn/design/other/privateclassdata.html",
      "id": "https://ujava.cn/design/other/privateclassdata.html",
      "summary": "概述 私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。",
      "content_html": "<h2> 概述</h2>\n<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "生产者消费者模式",
      "url": "https://ujava.cn/design/other/producerconsumer.html",
      "id": "https://ujava.cn/design/other/producerconsumer.html",
      "summary": "概述 生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。",
      "content_html": "<h2> 概述</h2>\n<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "承诺(Promise)模式",
      "url": "https://ujava.cn/design/other/promise.html",
      "id": "https://ujava.cn/design/other/promise.html",
      "summary": "概述 Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。",
      "content_html": "<h2> 概述</h2>\n<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "属性(Property)模式",
      "url": "https://ujava.cn/design/other/property.html",
      "id": "https://ujava.cn/design/other/property.html",
      "summary": "概述 使用现有对象作为父对象创建对象和新对象的层次结构。",
      "content_html": "<h2> 概述</h2>\n<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "基于队列的负载均衡模式",
      "url": "https://ujava.cn/design/other/queuebasedloadlevel.html",
      "id": "https://ujava.cn/design/other/queuebasedloadlevel.html",
      "summary": "概述 使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。",
      "content_html": "<h2> 概述</h2>\n<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "页面控制模式",
      "url": "https://ujava.cn/design/other/pagecontroller.html",
      "id": "https://ujava.cn/design/other/pagecontroller.html",
      "summary": "概述 这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。",
      "content_html": "<h2> 概述</h2>\n<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>\n",
      "date_published": "2024-03-04T02:16:14.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "层模式",
      "url": "https://ujava.cn/design/other/layers.html",
      "id": "https://ujava.cn/design/other/layers.html",
      "summary": "概述 层是一种体系结构模式，其中软件职责在不同的 应用程序的层。",
      "content_html": "<h2> 概述</h2>\n<p>层是一种体系结构模式，其中软件职责在不同的</p>\n<p>应用程序的层。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "懒加载模式",
      "url": "https://ujava.cn/design/other/lazyloading.html",
      "id": "https://ujava.cn/design/other/lazyloading.html",
      "summary": "概述 延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。",
      "content_html": "<h2> 概述</h2>\n<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者选举模式",
      "url": "https://ujava.cn/design/other/leaderelection.html",
      "id": "https://ujava.cn/design/other/leaderelection.html",
      "summary": "概述 领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。",
      "content_html": "<h2> 概述</h2>\n<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者跟随者模式",
      "url": "https://ujava.cn/design/other/leaderfollowers.html",
      "id": "https://ujava.cn/design/other/leaderfollowers.html",
      "summary": "概述 领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。",
      "content_html": "<h2> 概述</h2>\n<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "锁定对象模式",
      "url": "https://ujava.cn/design/other/lockableobject.html",
      "id": "https://ujava.cn/design/other/lockableobject.html",
      "summary": "概述 可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。",
      "content_html": "<h2> 概述</h2>\n<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "日志整合模式",
      "url": "https://ujava.cn/design/other/logaggregation.html",
      "id": "https://ujava.cn/design/other/logaggregation.html",
      "summary": "概述 集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。",
      "content_html": "<h2> 概述</h2>\n<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "标记接口模式",
      "url": "https://ujava.cn/design/other/markerinterface.html",
      "id": "https://ujava.cn/design/other/markerinterface.html",
      "summary": "概述 使用空界面作为标记来区分经过特殊处理的对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用空界面作为标记来区分经过特殊处理的对象。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "主从模式",
      "url": "https://ujava.cn/design/other/masterworker.html",
      "id": "https://ujava.cn/design/other/masterworker.html",
      "summary": "概述 当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。",
      "content_html": "<h2> 概述</h2>\n<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "元数据对象关系映射模式",
      "url": "https://ujava.cn/design/other/metadatamapping.html",
      "id": "https://ujava.cn/design/other/metadatamapping.html",
      "summary": "概述 保存元数据中对象关系映射的详细信息。",
      "content_html": "<h2> 概述</h2>\n<p>保存元数据中对象关系映射的详细信息。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模块模式",
      "url": "https://ujava.cn/design/other/module.html",
      "id": "https://ujava.cn/design/other/module.html",
      "summary": "概述 模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。",
      "content_html": "<h2> 概述</h2>\n<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "单体(monad)模式",
      "url": "https://ujava.cn/design/other/monad.html",
      "id": "https://ujava.cn/design/other/monad.html",
      "summary": "概述 基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。 从形式上讲，monad 由一个类型构造函数 M 和两个操作组成： bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。",
      "content_html": "<h2> 概述</h2>\n<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>\n<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>\n<ul>\n<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>\n<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "单态(MonoState)模式",
      "url": "https://ujava.cn/design/other/monostate.html",
      "id": "https://ujava.cn/design/other/monostate.html",
      "summary": "概述 强制执行一种行为，例如在所有实例之间共享相同的状态。",
      "content_html": "<h2> 概述</h2>\n<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "多态(Multiton)模式",
      "url": "https://ujava.cn/design/other/multiton.html",
      "id": "https://ujava.cn/design/other/multiton.html",
      "summary": "概述 确保类只有有限数量的实例，并提供对它们的全局访问点。",
      "content_html": "<h2> 概述</h2>\n<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "静音(Mute Idiom)模式",
      "url": "https://ujava.cn/design/other/muteidiom.html",
      "id": "https://ujava.cn/design/other/muteidiom.html",
      "summary": "概述 提供一个模板来抑制任何已声明但不能发生或只应记录的异常； 同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。",
      "content_html": "<h2> 概述</h2>\n<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>\n同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图控制器(MVC)模式",
      "url": "https://ujava.cn/design/other/mvc.html",
      "id": "https://ujava.cn/design/other/mvc.html",
      "summary": "概述 将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。",
      "content_html": "<h2> 概述</h2>\n<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图反应(MVI)模式",
      "url": "https://ujava.cn/design/other/mvi.html",
      "id": "https://ujava.cn/design/other/mvi.html",
      "summary": "概述 MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。",
      "content_html": "<h2> 概述</h2>\n<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图分离(MVP)模式",
      "url": "https://ujava.cn/design/other/mvp.html",
      "id": "https://ujava.cn/design/other/mvp.html",
      "summary": "概述 应用“关注点分离”原则，使开发人员能够构建和测试用户界面。",
      "content_html": "<h2> 概述</h2>\n<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图视图模型(MVVM)模式",
      "url": "https://ujava.cn/design/other/mvvm.html",
      "id": "https://ujava.cn/design/other/mvvm.html",
      "summary": "概述 应用“关注点分离”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。",
      "content_html": "<h2> 概述</h2>\n<p>应用“<a href=\"https://java-design-patterns.comprinciplesseparate-of-concerns\" target=\"_blank\" rel=\"noopener noreferrer\">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "裸对象(Naked Objects)模式",
      "url": "https://ujava.cn/design/other/nakedobjects.html",
      "id": "https://ujava.cn/design/other/nakedobjects.html",
      "summary": "概述 裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。 裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。 裸对象模式具有许多优点，包括： 1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。 2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。 3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。",
      "content_html": "<h2> 概述</h2>\n<ul>\n<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>\n<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>\n<li>裸对象模式具有许多优点，包括：\n<ul>\n<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>\n<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>\n<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象母亲模式",
      "url": "https://ujava.cn/design/other/objectmother.html",
      "id": "https://ujava.cn/design/other/objectmother.html",
      "summary": "概述 它用于定义具有独立构建器和工厂接口的不可变内容的工厂。",
      "content_html": "<h2> 概述</h2>\n<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象池模式",
      "url": "https://ujava.cn/design/other/objectpool.html",
      "id": "https://ujava.cn/design/other/objectpool.html",
      "summary": "概述 当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。",
      "content_html": "<h2> 概述</h2>\n<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "乐观线下锁模式",
      "url": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "id": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "summary": "概述 提供避免在关系数据库中同时更改一条记录的能力。",
      "content_html": "<h2> 概述</h2>\n<p>提供避免在关系数据库中同时更改一条记录的能力。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "Flux模式",
      "url": "https://ujava.cn/design/other/flux.html",
      "id": "https://ujava.cn/design/other/flux.html",
      "summary": "概述 Flux避开MVC，转而支持单向数据流。当 用户与视图交互，视图通过中心传播动作 调度器，到保存应用程序数据和业务的各种存储 逻辑，更新所有受影响的视图。",
      "content_html": "<h2> 概述</h2>\n<p>Flux避开MVC，转而支持单向数据流。当<br>\n用户与视图交互，视图通过中心传播动作<br>\n调度器，到保存应用程序数据和业务的各种存储<br>\n逻辑，更新所有受影响的视图。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "Flyweight模式",
      "url": "https://ujava.cn/design/other/flyweight.html",
      "id": "https://ujava.cn/design/other/flyweight.html",
      "summary": "概述 使用共享可以有效地支持大量细粒度对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用共享可以有效地支持大量细粒度对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "前端控制器模式",
      "url": "https://ujava.cn/design/other/frontcontroller.html",
      "id": "https://ujava.cn/design/other/frontcontroller.html",
      "summary": "概述 为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。",
      "content_html": "<h2> 概述</h2>\n<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "游戏循环模式",
      "url": "https://ujava.cn/design/other/gameloop.html",
      "id": "https://ujava.cn/design/other/gameloop.html",
      "summary": "概述 游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入 无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝 控制游戏的速率。 这种模式将游戏时间的进展与用户输入和处理器速度解耦。",
      "content_html": "<h2> 概述</h2>\n<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>\n<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>\n<p>控制游戏的速率。</p>\n<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "保护性暂停模式",
      "url": "https://ujava.cn/design/other/guardedsuspension.html",
      "id": "https://ujava.cn/design/other/guardedsuspension.html",
      "summary": "概述 当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。",
      "content_html": "<h2> 概述</h2>\n<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "半同步半异步模式",
      "url": "https://ujava.cn/design/other/halfsyncasync.html",
      "id": "https://ujava.cn/design/other/halfsyncasync.html",
      "summary": "概述 半同步/半异步模式将同步I/O与 系统中的异步I/O，以简化并发编程工作，而不需要 从而降低执行效率。",
      "content_html": "<h2> 概述</h2>\n<p>半同步/半异步模式将同步I/O与</p>\n<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>\n<p>从而降低执行效率。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "健康检查模式",
      "url": "https://ujava.cn/design/other/healthcheck.html",
      "id": "https://ujava.cn/design/other/healthcheck.html",
      "summary": "概述 通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。",
      "content_html": "<h2> 概述</h2>\n<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "六边形体系结构模式",
      "url": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "id": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "summary": "概述 允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。",
      "content_html": "<h2> 概述</h2>\n<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "同一性映射模式",
      "url": "https://ujava.cn/design/other/identitymap.html",
      "id": "https://ujava.cn/design/other/identitymap.html",
      "summary": "概述 通过将每个加载的对象保持在地图中，确保每个对象只加载一次。 引用对象时使用地图查找对象。",
      "content_html": "<h2> 概述</h2>\n<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>\n<p>引用对象时使用地图查找对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "拦截过滤器模式",
      "url": "https://ujava.cn/design/other/interceptingfilter.html",
      "id": "https://ujava.cn/design/other/interceptingfilter.html",
      "summary": "概述 截取过滤器是一种有用的Java设计模式，用于预处理 或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于 请求，然后再将其提供给目标应用程序。这样的使用示例包括认证， 这是在向应用程序发出请求之前必须处理的。",
      "content_html": "<h2> 概述</h2>\n<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>\n<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>\n<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>\n<p>这是在向应用程序发出请求之前必须处理的。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "功能切换模式",
      "url": "https://ujava.cn/design/other/featuretoggle.html",
      "id": "https://ujava.cn/design/other/featuretoggle.html",
      "summary": "概述 软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于 AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。",
      "content_html": "<h2> 概述</h2>\n<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>\nAB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "流接口模式",
      "url": "https://ujava.cn/design/other/fluentinterface.html",
      "id": "https://ujava.cn/design/other/fluentinterface.html",
      "summary": "概述 流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。",
      "content_html": "<h2> 概述</h2>\n<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "环绕执行模式",
      "url": "https://ujava.cn/design/other/executearound.html",
      "id": "https://ujava.cn/design/other/executearound.html",
      "summary": "概述 环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。",
      "content_html": "<h2> 概述</h2>\n<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扩展对象模式",
      "url": "https://ujava.cn/design/other/extensionobject.html",
      "id": "https://ujava.cn/design/other/extensionobject.html",
      "summary": "概述 预计将来需要扩展对象的接口。其他接口由扩展对象定义。",
      "content_html": "<h2> 概述</h2>\n<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扇出扇入模式",
      "url": "https://ujava.cn/design/other/fanoutfanin.html",
      "id": "https://ujava.cn/design/other/fanoutfanin.html",
      "summary": "概述 (Fan-Out/Fan-In) 当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。 该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。",
      "content_html": "<h2> 概述</h2>\n<p>(Fan-Out/Fan-In)</p>\n<p>当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。<br><br>\n该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件异步模式",
      "url": "https://ujava.cn/design/other/eventasynchronous.html",
      "id": "https://ujava.cn/design/other/eventasynchronous.html",
      "summary": "概述 基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以： 在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。 同时执行多个操作，每个操作完成后接收通知。 等待资源可用，而不停止（“挂起”）您的应用程序。 使用熟悉的事件和委托模型与挂起的异步操作进行通信。",
      "content_html": "<h2> 概述</h2>\n<p>基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以：</p>\n<ol>\n<li>在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。</li>\n<li>同时执行多个操作，每个操作完成后接收通知。</li>\n<li>等待资源可用，而不停止（“挂起”）您的应用程序。</li>\n<li>使用熟悉的事件和委托模型与挂起的异步操作进行通信。</li>\n</ol>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件驱动架构模式",
      "url": "https://ujava.cn/design/other/eventdrivenarchitecture.html",
      "id": "https://ujava.cn/design/other/eventdrivenarchitecture.html",
      "summary": "概述 使用事件驱动架构向其他应用程序发送和通知对象的状态更改。",
      "content_html": "<h2> 概述</h2>\n<p>使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件队列模式",
      "url": "https://ujava.cn/design/other/eventqueue.html",
      "id": "https://ujava.cn/design/other/eventqueue.html",
      "summary": "概述 事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。",
      "content_html": "<h2> 概述</h2>\n<p>事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件溯源模式",
      "url": "https://ujava.cn/design/other/eventsourcing.html",
      "id": "https://ujava.cn/design/other/eventsourcing.html",
      "summary": "概述 不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。",
      "content_html": "<h2> 概述</h2>\n<p>不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件聚合器模式",
      "url": "https://ujava.cn/design/other/eventaggregator.html",
      "id": "https://ujava.cn/design/other/eventaggregator.html",
      "summary": "概述 当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。",
      "content_html": "<h2> 概述</h2>\n<p>当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</p>\n",
      "date_published": "2024-03-03T03:00:03.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "委托模式",
      "url": "https://ujava.cn/design/other/delegate.html",
      "id": "https://ujava.cn/design/other/delegate.html",
      "summary": "概述 委托模式提供了一种机制，用于抽象出所需操作的实现和控制。",
      "content_html": "<h2> 概述</h2>\n<p>委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "依赖注入模式",
      "url": "https://ujava.cn/design/other/dependencyinjection.html",
      "id": "https://ujava.cn/design/other/dependencyinjection.html",
      "summary": "概述 依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。",
      "content_html": "<h2> 概述</h2>\n<p>依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "脏标志行为模式",
      "url": "https://ujava.cn/design/other/dirtyflag.html",
      "id": "https://ujava.cn/design/other/dirtyflag.html",
      "summary": "概述 脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。 在深入研究使用此模式之前，需要考虑一些要点： 您需要考虑一些事项： （1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。 （2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。 （3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。",
      "content_html": "<h2> 概述</h2>\n<p>脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。<br>\n在深入研究使用此模式之前，需要考虑一些要点：</p>\n<p>您需要考虑一些事项：</p>\n<ul>\n<li>（1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。</li>\n<li>（2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。</li>\n<li>（3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。</li>\n</ul>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领域模型模式",
      "url": "https://ujava.cn/design/other/domainmodel.html",
      "id": "https://ujava.cn/design/other/domainmodel.html",
      "summary": "概述 领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。",
      "content_html": "<h2> 概述</h2>\n<p>领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双缓冲模式",
      "url": "https://ujava.cn/design/other/doublebuffering.html",
      "id": "https://ujava.cn/design/other/doublebuffering.html",
      "summary": "概述 双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。",
      "content_html": "<h2> 概述</h2>\n<p>双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双重检查锁模式",
      "url": "https://ujava.cn/design/other/doublechecklock.html",
      "id": "https://ujava.cn/design/other/doublechecklock.html",
      "summary": "概述 双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。",
      "content_html": "<h2> 概述</h2>\n<p>双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双分派模式",
      "url": "https://ujava.cn/design/other/doubledispatch.html",
      "id": "https://ujava.cn/design/other/doubledispatch.html",
      "summary": "概述 当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。 实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。 而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。",
      "content_html": "<h2> 概述</h2>\n<p>当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。<br>\n实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。<br>\n而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "内在价值模式",
      "url": "https://ujava.cn/design/other/embeddedvalue.html",
      "id": "https://ujava.cn/design/other/embeddedvalue.html",
      "summary": "概述 许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。 嵌入值将对象的值映射到对象所有者记录中的字段。",
      "content_html": "<h2> 概述</h2>\n<p>许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。<br>\n嵌入值将对象的值映射到对象所有者记录中的字段。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "转换器模式",
      "url": "https://ujava.cn/design/other/converter.html",
      "id": "https://ujava.cn/design/other/converter.html",
      "summary": "概述 转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。",
      "content_html": "<h2> 概述</h2>\n<p>转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "命令查询职责分离(CQRS)模式",
      "url": "https://ujava.cn/design/other/cqrs.html",
      "id": "https://ujava.cn/design/other/cqrs.html",
      "summary": "概述 CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。",
      "content_html": "<h2> 概述</h2>\n<p>CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    }
  ]
}