{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "UJava",
  "home_page_url": "https://ujava.cn/",
  "feed_url": "https://ujava.cn/feed.json",
  "description": " 【Java学习 + Java面试】首选UJava！  ",
  "items": [
    {
      "title": "层模式",
      "url": "https://ujava.cn/design/other/layers.html",
      "id": "https://ujava.cn/design/other/layers.html",
      "summary": "概述 层是一种体系结构模式，其中软件职责在不同的 应用程序的层。",
      "content_html": "<h2> 概述</h2>\n<p>层是一种体系结构模式，其中软件职责在不同的</p>\n<p>应用程序的层。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "懒加载模式",
      "url": "https://ujava.cn/design/other/lazyloading.html",
      "id": "https://ujava.cn/design/other/lazyloading.html",
      "summary": "概述 延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。",
      "content_html": "<h2> 概述</h2>\n<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者选举模式",
      "url": "https://ujava.cn/design/other/leaderelection.html",
      "id": "https://ujava.cn/design/other/leaderelection.html",
      "summary": "概述 领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。",
      "content_html": "<h2> 概述</h2>\n<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者跟随者模式",
      "url": "https://ujava.cn/design/other/leaderfollowers.html",
      "id": "https://ujava.cn/design/other/leaderfollowers.html",
      "summary": "概述 领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。",
      "content_html": "<h2> 概述</h2>\n<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "锁定对象模式",
      "url": "https://ujava.cn/design/other/lockableobject.html",
      "id": "https://ujava.cn/design/other/lockableobject.html",
      "summary": "概述 可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。",
      "content_html": "<h2> 概述</h2>\n<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "日志整合模式",
      "url": "https://ujava.cn/design/other/logaggregation.html",
      "id": "https://ujava.cn/design/other/logaggregation.html",
      "summary": "概述 集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。",
      "content_html": "<h2> 概述</h2>\n<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "标记接口模式",
      "url": "https://ujava.cn/design/other/markerinterface.html",
      "id": "https://ujava.cn/design/other/markerinterface.html",
      "summary": "概述 使用空界面作为标记来区分经过特殊处理的对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用空界面作为标记来区分经过特殊处理的对象。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "主从模式",
      "url": "https://ujava.cn/design/other/masterworker.html",
      "id": "https://ujava.cn/design/other/masterworker.html",
      "summary": "概述 当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。",
      "content_html": "<h2> 概述</h2>\n<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "元数据对象关系映射模式",
      "url": "https://ujava.cn/design/other/metadatamapping.html",
      "id": "https://ujava.cn/design/other/metadatamapping.html",
      "summary": "概述 保存元数据中对象关系映射的详细信息。",
      "content_html": "<h2> 概述</h2>\n<p>保存元数据中对象关系映射的详细信息。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "",
      "url": "https://ujava.cn/design/other/module.html",
      "id": "https://ujava.cn/design/other/module.html",
      "summary": "title: 模块模式 icon: laptop-code category: 设计模式 tag: 设计模式 概述 模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。",
      "content_html": "<hr>\n<p>title: 模块模式<br>\nicon: laptop-code<br>\ncategory:</p>\n<ul>\n<li>设计模式<br>\ntag:</li>\n<li>设计模式</li>\n</ul>\n<hr>\n<h2> 概述</h2>\n<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "单体(monad)模式",
      "url": "https://ujava.cn/design/other/monad.html",
      "id": "https://ujava.cn/design/other/monad.html",
      "summary": "概述 基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。 从形式上讲，monad 由一个类型构造函数 M 和两个操作组成： bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。",
      "content_html": "<h2> 概述</h2>\n<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>\n<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>\n<ul>\n<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>\n<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "单态(MonoState)模式",
      "url": "https://ujava.cn/design/other/monostate.html",
      "id": "https://ujava.cn/design/other/monostate.html",
      "summary": "概述 强制执行一种行为，例如在所有实例之间共享相同的状态。",
      "content_html": "<h2> 概述</h2>\n<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "多态(Multiton)模式",
      "url": "https://ujava.cn/design/other/multiton.html",
      "id": "https://ujava.cn/design/other/multiton.html",
      "summary": "概述 确保类只有有限数量的实例，并提供对它们的全局访问点。",
      "content_html": "<h2> 概述</h2>\n<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "静音(Mute Idiom)模式",
      "url": "https://ujava.cn/design/other/muteidiom.html",
      "id": "https://ujava.cn/design/other/muteidiom.html",
      "summary": "概述 提供一个模板来抑制任何已声明但不能发生或只应记录的异常； 同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。",
      "content_html": "<h2> 概述</h2>\n<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>\n同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图控制器(MVC)模式",
      "url": "https://ujava.cn/design/other/mvc.html",
      "id": "https://ujava.cn/design/other/mvc.html",
      "summary": "概述 将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。",
      "content_html": "<h2> 概述</h2>\n<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图反应(MVI)模式",
      "url": "https://ujava.cn/design/other/mvi.html",
      "id": "https://ujava.cn/design/other/mvi.html",
      "summary": "概述 MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。",
      "content_html": "<h2> 概述</h2>\n<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图分离(MVP)模式",
      "url": "https://ujava.cn/design/other/mvp.html",
      "id": "https://ujava.cn/design/other/mvp.html",
      "summary": "概述 应用“关注点分离”原则，使开发人员能够构建和测试用户界面。",
      "content_html": "<h2> 概述</h2>\n<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图视图模型(MVVM)模式",
      "url": "https://ujava.cn/design/other/mvvm.html",
      "id": "https://ujava.cn/design/other/mvvm.html",
      "summary": "概述 应用“关注点分离”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。",
      "content_html": "<h2> 概述</h2>\n<p>应用“<a href=\"https://java-design-patterns.comprinciplesseparate-of-concerns\" target=\"_blank\" rel=\"noopener noreferrer\">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "裸对象(Naked Objects)模式",
      "url": "https://ujava.cn/design/other/nakedobjects.html",
      "id": "https://ujava.cn/design/other/nakedobjects.html",
      "summary": "概述 裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。 裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。 裸对象模式具有许多优点，包括： 1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。 2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。 3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。",
      "content_html": "<h2> 概述</h2>\n<ul>\n<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>\n<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>\n<li>裸对象模式具有许多优点，包括：\n<ul>\n<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>\n<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>\n<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象母亲(Object Mother)模式",
      "url": "https://ujava.cn/design/other/objectmother.html",
      "id": "https://ujava.cn/design/other/objectmother.html",
      "summary": "概述 它用于定义具有独立构建器和工厂接口的不可变内容的工厂。",
      "content_html": "<h2> 概述</h2>\n<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象池(Object Pool)模式",
      "url": "https://ujava.cn/design/other/objectpool.html",
      "id": "https://ujava.cn/design/other/objectpool.html",
      "summary": "概述 当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。",
      "content_html": "<h2> 概述</h2>\n<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "乐观线下锁(Optimistic Offline Lock)模式",
      "url": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "id": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "summary": "概述 提供避免在关系数据库中同时更改一条记录的能力。",
      "content_html": "<h2> 概述</h2>\n<p>提供避免在关系数据库中同时更改一条记录的能力。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "flux模式",
      "url": "https://ujava.cn/design/other/flux.html",
      "id": "https://ujava.cn/design/other/flux.html",
      "summary": "概述 Flux避开MVC，转而支持单向数据流。当 用户与视图交互，视图通过中心传播动作 调度器，到保存应用程序数据和业务的各种存储 逻辑，更新所有受影响的视图。",
      "content_html": "<h2> 概述</h2>\n<p>Flux避开MVC，转而支持单向数据流。当<br>\n用户与视图交互，视图通过中心传播动作<br>\n调度器，到保存应用程序数据和业务的各种存储<br>\n逻辑，更新所有受影响的视图。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "flyweight模式",
      "url": "https://ujava.cn/design/other/flyweight.html",
      "id": "https://ujava.cn/design/other/flyweight.html",
      "summary": "概述 使用共享可以有效地支持大量细粒度对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用共享可以有效地支持大量细粒度对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "前端控制器模式",
      "url": "https://ujava.cn/design/other/frontcontroller.html",
      "id": "https://ujava.cn/design/other/frontcontroller.html",
      "summary": "概述 为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。",
      "content_html": "<h2> 概述</h2>\n<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "游戏循环模式",
      "url": "https://ujava.cn/design/other/gameloop.html",
      "id": "https://ujava.cn/design/other/gameloop.html",
      "summary": "概述 游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入 无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝 控制游戏的速率。 这种模式将游戏时间的进展与用户输入和处理器速度解耦。",
      "content_html": "<h2> 概述</h2>\n<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>\n<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>\n<p>控制游戏的速率。</p>\n<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "保护性暂停模式",
      "url": "https://ujava.cn/design/other/guardedsuspension.html",
      "id": "https://ujava.cn/design/other/guardedsuspension.html",
      "summary": "概述 当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。",
      "content_html": "<h2> 概述</h2>\n<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "半同步半异步模式",
      "url": "https://ujava.cn/design/other/halfsyncasync.html",
      "id": "https://ujava.cn/design/other/halfsyncasync.html",
      "summary": "概述 半同步/半异步模式将同步I/O与 系统中的异步I/O，以简化并发编程工作，而不需要 从而降低执行效率。",
      "content_html": "<h2> 概述</h2>\n<p>半同步/半异步模式将同步I/O与</p>\n<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>\n<p>从而降低执行效率。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "健康检查模式",
      "url": "https://ujava.cn/design/other/healthcheck.html",
      "id": "https://ujava.cn/design/other/healthcheck.html",
      "summary": "概述 通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。",
      "content_html": "<h2> 概述</h2>\n<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "六边形体系结构模式",
      "url": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "id": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "summary": "概述 允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。",
      "content_html": "<h2> 概述</h2>\n<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "同一性映射模式",
      "url": "https://ujava.cn/design/other/identitymap.html",
      "id": "https://ujava.cn/design/other/identitymap.html",
      "summary": "概述 通过将每个加载的对象保持在地图中，确保每个对象只加载一次。 引用对象时使用地图查找对象。",
      "content_html": "<h2> 概述</h2>\n<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>\n<p>引用对象时使用地图查找对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "拦截过滤器模式",
      "url": "https://ujava.cn/design/other/interceptingfilter.html",
      "id": "https://ujava.cn/design/other/interceptingfilter.html",
      "summary": "概述 截取过滤器是一种有用的Java设计模式，用于预处理 或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于 请求，然后再将其提供给目标应用程序。这样的使用示例包括认证， 这是在向应用程序发出请求之前必须处理的。",
      "content_html": "<h2> 概述</h2>\n<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>\n<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>\n<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>\n<p>这是在向应用程序发出请求之前必须处理的。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "功能切换模式",
      "url": "https://ujava.cn/design/other/featuretoggle.html",
      "id": "https://ujava.cn/design/other/featuretoggle.html",
      "summary": "概述 软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于 AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。",
      "content_html": "<h2> 概述</h2>\n<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>\nAB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "流接口模式",
      "url": "https://ujava.cn/design/other/fluentinterface.html",
      "id": "https://ujava.cn/design/other/fluentinterface.html",
      "summary": "概述 流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。",
      "content_html": "<h2> 概述</h2>\n<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "环绕执行模式",
      "url": "https://ujava.cn/design/other/executearound.html",
      "id": "https://ujava.cn/design/other/executearound.html",
      "summary": "概述 环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。",
      "content_html": "<h2> 概述</h2>\n<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扩展对象模式",
      "url": "https://ujava.cn/design/other/extensionobject.html",
      "id": "https://ujava.cn/design/other/extensionobject.html",
      "summary": "概述 预计将来需要扩展对象的接口。其他接口由扩展对象定义。",
      "content_html": "<h2> 概述</h2>\n<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扇出扇入(Fan-Out/Fan-In)模式",
      "url": "https://ujava.cn/design/other/fanoutfanin.html",
      "id": "https://ujava.cn/design/other/fanoutfanin.html",
      "summary": "概述 当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。 该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。",
      "content_html": "<h2> 概述</h2>\n<p>当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。<br><br>\n该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件异步模式",
      "url": "https://ujava.cn/design/other/eventasynchronous.html",
      "id": "https://ujava.cn/design/other/eventasynchronous.html",
      "summary": "概述 基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以： 在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。 同时执行多个操作，每个操作完成后接收通知。 等待资源可用，而不停止（“挂起”）您的应用程序。 使用熟悉的事件和委托模型与挂起的异步操作进行通信。",
      "content_html": "<h2> 概述</h2>\n<p>基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以：</p>\n<ol>\n<li>在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。</li>\n<li>同时执行多个操作，每个操作完成后接收通知。</li>\n<li>等待资源可用，而不停止（“挂起”）您的应用程序。</li>\n<li>使用熟悉的事件和委托模型与挂起的异步操作进行通信。</li>\n</ol>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件驱动架构模式",
      "url": "https://ujava.cn/design/other/eventdrivenarchitecture.html",
      "id": "https://ujava.cn/design/other/eventdrivenarchitecture.html",
      "summary": "概述 使用事件驱动架构向其他应用程序发送和通知对象的状态更改。",
      "content_html": "<h2> 概述</h2>\n<p>使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件队列模式",
      "url": "https://ujava.cn/design/other/eventqueue.html",
      "id": "https://ujava.cn/design/other/eventqueue.html",
      "summary": "概述 事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。",
      "content_html": "<h2> 概述</h2>\n<p>事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件溯源模式",
      "url": "https://ujava.cn/design/other/eventsourcing.html",
      "id": "https://ujava.cn/design/other/eventsourcing.html",
      "summary": "概述 不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。",
      "content_html": "<h2> 概述</h2>\n<p>不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</p>\n",
      "date_published": "2024-03-03T03:14:23.000Z",
      "date_modified": "2024-03-03T03:14:23.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事件聚合器模式",
      "url": "https://ujava.cn/design/other/eventaggregator.html",
      "id": "https://ujava.cn/design/other/eventaggregator.html",
      "summary": "概述 当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。",
      "content_html": "<h2> 概述</h2>\n<p>当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</p>\n",
      "date_published": "2024-03-03T03:00:03.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "委托模式",
      "url": "https://ujava.cn/design/other/delegate.html",
      "id": "https://ujava.cn/design/other/delegate.html",
      "summary": "概述 委托模式提供了一种机制，用于抽象出所需操作的实现和控制。",
      "content_html": "<h2> 概述</h2>\n<p>委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "依赖注入模式",
      "url": "https://ujava.cn/design/other/dependencyinjection.html",
      "id": "https://ujava.cn/design/other/dependencyinjection.html",
      "summary": "概述 依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。",
      "content_html": "<h2> 概述</h2>\n<p>依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "脏标志行为模式",
      "url": "https://ujava.cn/design/other/dirtyflag.html",
      "id": "https://ujava.cn/design/other/dirtyflag.html",
      "summary": "概述 脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。 在深入研究使用此模式之前，需要考虑一些要点： 您需要考虑一些事项： （1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。 （2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。 （3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。",
      "content_html": "<h2> 概述</h2>\n<p>脏标志行为模式允许您避免无论如何都需要再次执行的昂贵操作。这是一个简单的模式，实际上只是解释了如何向类添加一个布尔值，您可以在属性更改时设置该值。这将使您的班级知道，它之前可能计算过的任何结果都需要在请求时再次计算。重新计算结果后，可以清除布尔值。<br>\n在深入研究使用此模式之前，需要考虑一些要点：</p>\n<p>您需要考虑一些事项：</p>\n<ul>\n<li>（1） 您需要它吗？当要计算的结果难以计算或需要大量资源计算时，此设计模式非常有效。你想保存它们。您也不想连续多次计算它们，而只有最后一个才算数。</li>\n<li>（2） 什么时候设置脏标志？确保每当重要属性发生更改时，在类本身中设置 dirty 标志。此属性应影响计算结果的结果，并且通过更改属性，使最后一个结果无效。</li>\n<li>（3） 你什么时候清除脏标志？每当使用最新信息计算结果时，都应该清除脏标志，这似乎是显而易见的，但有时您可能希望清除该标志。</li>\n</ul>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领域模型模式",
      "url": "https://ujava.cn/design/other/domainmodel.html",
      "id": "https://ujava.cn/design/other/domainmodel.html",
      "summary": "概述 领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。",
      "content_html": "<h2> 概述</h2>\n<p>领域模型模式是比事务脚本和表模块更复杂的组织域逻辑的解决方案。它提供了一种面向对象的方式来处理复杂的逻辑。而不是使用一个过程来处理用户操作的所有业务逻辑（如事务脚本），而是有多个对象，每个对象都处理与其相关的域逻辑的一部分。域模型模式和表模块模式之间的显著区别在于，在表模块中，单个类封装了表中存储的所有记录的所有域逻辑，而在域模型中，每个类仅表示基础表中的一条记录。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双缓冲模式",
      "url": "https://ujava.cn/design/other/doublebuffering.html",
      "id": "https://ujava.cn/design/other/doublebuffering.html",
      "summary": "概述 双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。",
      "content_html": "<h2> 概述</h2>\n<p>双缓冲是一个术语，用于描述具有两个缓冲区的设备。使用多个缓冲区可提高设备的整体吞吐量，并有助于防止出现瓶颈。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双重检查锁模式",
      "url": "https://ujava.cn/design/other/doublechecklock.html",
      "id": "https://ujava.cn/design/other/doublechecklock.html",
      "summary": "概述 双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。",
      "content_html": "<h2> 概述</h2>\n<p>双重检查锁定是一种并发设计模式，用于通过首先测试锁定条件（“锁定提示”）而不实际获取锁来减少获取锁的开销。只有当锁定条件检查指示需要锁定时，实际的锁定逻辑才会继续进行。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双分派模式",
      "url": "https://ujava.cn/design/other/doubledispatch.html",
      "id": "https://ujava.cn/design/other/doubledispatch.html",
      "summary": "概述 当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。 实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。 而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。",
      "content_html": "<h2> 概述</h2>\n<p>当带有参数的消息发送到对象时，结果行为由接收方中该方法的实现定义。有时，行为也必须由参数的类型决定。<br>\n实现此目的的一种方法是为 methods 参数创建多个 instanceof-checks。但是，这会产生维护问题。添加新类型时，我们还需要更改方法的实现并添加新的 instanceof-check。这违反了单一责任原则——一个类应该只有一个理由来改变。<br>\n而不是 instanceof-checks，更好的方法是对参数对象进行另一个虚拟调用。这样，可以轻松添加新功能，而无需修改现有实现（开闭原则）。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "内在价值模式",
      "url": "https://ujava.cn/design/other/embeddedvalue.html",
      "id": "https://ujava.cn/design/other/embeddedvalue.html",
      "summary": "概述 许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。 嵌入值将对象的值映射到对象所有者记录中的字段。",
      "content_html": "<h2> 概述</h2>\n<p>许多小对象在 OO 系统中有意义，但在数据库中没有意义。示例包括货币感知货币对象（金额、货币）和日期范围。尽管默认的想法是将对象保存为表格，但任何理智的人都不会想要货币值表。<br>\n嵌入值将对象的值映射到对象所有者记录中的字段。</p>\n",
      "date_published": "2024-03-01T02:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "转换器模式",
      "url": "https://ujava.cn/design/other/converter.html",
      "id": "https://ujava.cn/design/other/converter.html",
      "summary": "概述 转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。",
      "content_html": "<h2> 概述</h2>\n<p>转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "命令查询职责分离(CQRS)模式",
      "url": "https://ujava.cn/design/other/cqrs.html",
      "id": "https://ujava.cn/design/other/cqrs.html",
      "summary": "概述 CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。",
      "content_html": "<h2> 概述</h2>\n<p>CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "奇异递归模板(CRTP)模式",
      "url": "https://ujava.cn/design/other/crtp.html",
      "id": "https://ujava.cn/design/other/crtp.html",
      "summary": "概述 CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式",
      "content_html": "<h2> 概述</h2>\n<p>CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "柯里化(Currying)模式",
      "url": "https://ujava.cn/design/other/currying.html",
      "id": "https://ujava.cn/design/other/currying.html",
      "summary": "概述 Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。",
      "content_html": "<h2> 概述</h2>\n<p>Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "数据访问对象(DAO)模式",
      "url": "https://ujava.cn/design/other/dao.html",
      "id": "https://ujava.cn/design/other/dao.html",
      "summary": "概述 数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。 使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。",
      "content_html": "<h2> 概述</h2>\n<p>数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。</p>\n<p>使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "数据总线模式",
      "url": "https://ujava.cn/design/other/databus.html",
      "id": "https://ujava.cn/design/other/databus.html",
      "summary": "概述 http://wiki.c2.com/?DataBusPattern 数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。",
      "content_html": "<h2> 概述</h2>\n<p><a href=\"http://wiki.c2.com/?DataBusPattern\" target=\"_blank\" rel=\"noopener noreferrer\">http://wiki.c2.com/?DataBusPattern</a></p>\n<p>数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "数据本地化模式",
      "url": "https://ujava.cn/design/other/datalocality.html",
      "id": "https://ujava.cn/design/other/datalocality.html",
      "summary": "概述 当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能 按照处理顺序将数据保存在连续内存中。",
      "content_html": "<h2> 概述</h2>\n<p>当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能</p>\n<p>按照处理顺序将数据保存在连续内存中。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "数据映射器模式",
      "url": "https://ujava.cn/design/other/datamapper.html",
      "id": "https://ujava.cn/design/other/datamapper.html",
      "summary": "概述 数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。",
      "content_html": "<h2> 概述</h2>\n<p>数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "数据传输对象模式",
      "url": "https://ujava.cn/design/other/datatransferobject.html",
      "id": "https://ujava.cn/design/other/datatransferobject.html",
      "summary": "概述 数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。",
      "content_html": "<h2> 概述</h2>\n<p>数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。</p>\n",
      "date_published": "2024-02-29T06:34:22.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "安排执行断言模式",
      "url": "https://ujava.cn/design/other/aaa.html",
      "id": "https://ujava.cn/design/other/aaa.html",
      "summary": "概述 安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式",
      "content_html": "<h2> 概述</h2>\n<p>安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:06:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "抽象文档模式",
      "url": "https://ujava.cn/design/other/abstractdocument.html",
      "id": "https://ujava.cn/design/other/abstractdocument.html",
      "summary": "概述 抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。",
      "content_html": "<h2> 概述</h2>\n<p>抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "活动对象模式",
      "url": "https://ujava.cn/design/other/activeobject.html",
      "id": "https://ujava.cn/design/other/activeobject.html",
      "summary": "概述 活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。",
      "content_html": "<h2> 概述</h2>\n<p>活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "非循环访问者模式",
      "url": "https://ujava.cn/design/other/acyclicvisitor.html",
      "id": "https://ujava.cn/design/other/acyclicvisitor.html",
      "summary": "概述 非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang of Four) Visitor(访问者) 模式固有的依赖关系循环",
      "content_html": "<h2> 概述</h2>\n<p>非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang<br>\nof Four) Visitor(访问者) 模式固有的依赖关系循环</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "大使模式",
      "url": "https://ujava.cn/design/other/ambassadorpattern.html",
      "id": "https://ujava.cn/design/other/ambassadorpattern.html",
      "summary": "概述 大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。 大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。",
      "content_html": "<h2> 概述</h2>\n<p>大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。<br>\n大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "异步方法调用模式",
      "url": "https://ujava.cn/design/other/asynmethodinvocation.html",
      "id": "https://ujava.cn/design/other/asynmethodinvocation.html",
      "summary": "概述 异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。",
      "content_html": "<h2> 概述</h2>\n<p>异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "放弃设计模式",
      "url": "https://ujava.cn/design/other/balkingdesign.html",
      "id": "https://ujava.cn/design/other/balkingdesign.html",
      "summary": "概述 在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知",
      "content_html": "<h2> 概述</h2>\n<p>在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:06:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "业务委托模式",
      "url": "https://ujava.cn/design/other/businessdelegate.html",
      "id": "https://ujava.cn/design/other/businessdelegate.html",
      "summary": "概述 业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。 业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。",
      "content_html": "<h2> 概述</h2>\n<p>业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。<br>\n业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "字节码模式",
      "url": "https://ujava.cn/design/other/bytecode.html",
      "id": "https://ujava.cn/design/other/bytecode.html",
      "summary": "概述 字节码模式(bytecode pattern) 的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。 当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。",
      "content_html": "<h2> 概述</h2>\n<p>字节码模式(bytecode pattern)<br>\n的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。<br>\n当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "缓存模式",
      "url": "https://ujava.cn/design/other/caching.html",
      "id": "https://ujava.cn/design/other/caching.html",
      "summary": "概述 缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。 这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。",
      "content_html": "<h2> 概述</h2>\n<p>缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。<br>\n这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "回调模式",
      "url": "https://ujava.cn/design/other/callback.html",
      "id": "https://ujava.cn/design/other/callback.html",
      "summary": "概述 回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。",
      "content_html": "<h2> 概述</h2>\n<p>回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "回路生成器模式",
      "url": "https://ujava.cn/design/other/circuitbuilder.html",
      "id": "https://ujava.cn/design/other/circuitbuilder.html",
      "summary": "概述 回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它",
      "content_html": "<h2> 概述</h2>\n<p>回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "客户端会话模式",
      "url": "https://ujava.cn/design/other/clientsession.html",
      "id": "https://ujava.cn/design/other/clientsession.html",
      "summary": "概述 客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。",
      "content_html": "<h2> 概述</h2>\n<p>客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "收集参数设计模式",
      "url": "https://ujava.cn/design/other/collectingparameter.html",
      "id": "https://ujava.cn/design/other/collectingparameter.html",
      "summary": "概述 收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。",
      "content_html": "<h2> 概述</h2>\n<p>收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "集合管道模式",
      "url": "https://ujava.cn/design/other/collectionpipeline.html",
      "id": "https://ujava.cn/design/other/collectionpipeline.html",
      "summary": "概述 集合管道模式(Collection Pipeline) 在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。",
      "content_html": "<h2> 概述</h2>\n<p>集合管道模式(Collection Pipeline)</p>\n<p>在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "上下文对象模式",
      "url": "https://ujava.cn/design/other/contextobject.html",
      "id": "https://ujava.cn/design/other/contextobject.html",
      "summary": "概述 在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。",
      "content_html": "<h2> 概述</h2>\n<p>在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。</p>\n",
      "date_published": "2024-02-29T02:52:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "K8S简介",
      "url": "https://ujava.cn/highfreq/k8s.html",
      "id": "https://ujava.cn/highfreq/k8s.html",
      "summary": "一、K8S简介 Kubernetes中文官网：Kubernetes GitHub：github.com/kubernetes/kubernetes Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。",
      "content_html": "<h2> 一、K8S简介</h2>\n<p>Kubernetes中文官网：<a href=\"https://kubernetes.io/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a></p>\n<p>GitHub：<a href=\"http://github.com/kubernetes/kubernetes\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/kubernetes</a></p>\n<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>\n<p>Kubernetes集群组件逻辑图<br>\n</p>\n<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>\n<p>Master节点组件及功能<br>\n</p>\n<p>Slave节点组件及功能<br>\n</p>\n<p>安装部署</p>\n<p>生产环境部署k8s主要有两种方式：</p>\n<p>二进制包</p>\n<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>\n<p>kubeadm工具</p>\n<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>\n<ul>\n<li>kubeadm init：初始化一个Master节点</li>\n<li>kubeadm join：将Worker节点加入集群</li>\n<li>kubeadm upgrade：升级K8s版本</li>\n<li>kubeadm token：管理 kubeadm join 使用的令牌</li>\n<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>\n<li>kubeadm version：打印 kubeadm 版本</li>\n<li>kubeadm alpha：预览可用的新功能</li>\n</ul>\n<h2> 二、准备工作</h2>\n<p>软硬件要求</p>\n<ul>\n<li>Linux操作系统，Ubuntu 或 CentOS</li>\n<li>每台节点至少2G</li>\n<li>Master节点至少2C</li>\n<li>集群节点网络互通</li>\n</ul>\n<p>集群规划</p>\n<figure><figcaption>img_104.png</figcaption></figure>\n<p>环境配置</p>\n<p>修改hosts配置</p>\n<p>配置所有节点的IP和域名映射</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置SSH免密登录</p>\n<p>先生成公钥对，再把公钥远程复制到所有节点。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关闭Swap分区</p>\n<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>禁用SELinux</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关闭防火墙</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改内核参数</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置集群时钟同步</p>\n<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置k8s的Yum源</p>\n<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、安装Docker</h2>\n<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>\n<h2> 四、安装K8S集群</h2>\n<p>安装三大组件-kubeadm、kubelet、kubectl</p>\n<ul>\n<li>kubeadm：用来初始化k8s集群的指令。</li>\n<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>\n<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化k8s集群</p>\n<ul>\n<li>apiserver-advertise-address：apiserver监听地址</li>\n<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>\n<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>\n<li>service-cidr：为Service分配的IP地址段</li>\n<li>pod-network-cidr：为pod分配的IP地址段</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>成功界面：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>\n<p>加入节点</p>\n<p>所有Node节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>修改角色：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>安装网络插件</p>\n<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>\n</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、测试K8S集群</h2>\n<p>创建nginx pod</p>\n<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对外暴露访问</p>\n<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>访问nginx</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>\n<h2> 六、安装Dashboard</h2>\n<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>\n<p>Github：<a href=\"http://github.com/kubernetes/dashboard\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/dashboard</a></p>\n<p>通过kubectl命令安装</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看service</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浏览器输入访问地址：<a href=\"https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://192.168.5.10:31128/，需要token才能访问。</a></p>\n<figure><figcaption>img_107.png</figcaption></figure>\n<p>创建访问账号</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取token</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>登录界面</p>\n<p>输入上面的token，进入dashboard首页</p>\n<figure><figcaption>img_108.png</figcaption></figure>\n",
      "date_published": "2024-02-27T08:08:33.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "Jenkins详解",
      "url": "https://ujava.cn/highfreq/jenkins.html",
      "id": "https://ujava.cn/highfreq/jenkins.html",
      "summary": "1.背景 在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试； 或者前后端分离后，经常会修改接口，然后重新部署； 这些情况都会涉及到频繁的打包部署； 手动打包常规步骤： 1.提交代码 2.问一下同组小伙伴有没有要提交的代码 3.拉取代码并打包（war包，或者jar包） 4.上传到Linux服务器 5.查看当前程序是否在运行 6.关闭当前程序 7.启动新的jar包 8.观察日志看是否启动成功 9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）",
      "content_html": "<h2> 1.背景</h2>\n<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>\n<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>\n<p>这些情况都会涉及到频繁的打包部署；</p>\n<p>手动打包常规步骤：</p>\n<ul>\n<li>1.提交代码</li>\n<li>2.问一下同组小伙伴有没有要提交的代码</li>\n<li>3.拉取代码并打包（war包，或者jar包）</li>\n<li>4.上传到Linux服务器</li>\n<li>5.查看当前程序是否在运行</li>\n<li>6.关闭当前程序</li>\n<li>7.启动新的jar包</li>\n<li>8.观察日志看是否启动成功</li>\n<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>\n</ul>\n<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>\n<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>\n<p>只是Jenkins相对来说，使用得更广泛。</p>\n<h2> 2.Jenkins服务器搭建及基本配置</h2>\n<h3> 2.1.简介</h3>\n<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<h3> 2.2.Jenkins自动化部署实现原理</h3>\n<figure><figcaption>img_70.png</figcaption></figure>\n<h3> 2.3.Jenkins部署环境</h3>\n<p>基本环境：</p>\n<ul>\n<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>\n<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>\n<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>\n</ul>\n<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>\n<h3> 2.4.Jenkins安装</h3>\n<ul>\n<li>1.下载安装包jenkins.war；</li>\n<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>\n<li>3.打开浏览器进入链接 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080</a>.</li>\n<li>4.填写初始密码，激活系统</li>\n</ul>\n<figure><figcaption>img_71.png</figcaption></figure>\n<ul>\n<li>5.进入插件安装选择</li>\n</ul>\n<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>\n<figure><figcaption>img_72.png</figcaption></figure>\n<p>选择后，进入插件安装页面<br>\n</p>\n<ul>\n<li>\n<p>6.设置初始用户和密码<br>\n</p>\n</li>\n<li>\n<p>7.进入系统，安装完成<br>\n</p>\n</li>\n</ul>\n<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>\n<h3> 2.5.Jenkins基本配置</h3>\n<h4> 2.5.1.系统初始化配置</h4>\n<figure><figcaption>img_76.png</figcaption></figure>\n<p><strong>1.Configure System (系统设置)</strong></p>\n<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>\n<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>\n<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>\n</p>\n<p><strong>2.Configure Global Security (全局安全配置)</strong></p>\n<p>a.配置用户相关的权限</p>\n<figure><figcaption>img_78.png</figcaption></figure>\n<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>\n<p>默认是勾选上了的，这里去掉勾选</p>\n<figure><figcaption>img_79.png</figcaption></figure>\n<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>\n<p>a.配置maven的全局settings路径<br>\n</p>\n<p>b.配置jdk<br>\n</p>\n<p>c.配置git</p>\n<figure><figcaption>img_82.png</figcaption></figure>\n<p>d.配置maven的安装路径</p>\n<figure><figcaption>img_83.png</figcaption></figure>\n<p><strong>4.配置必要插件</strong></p>\n<p>主要是检查如下这两个插件是否已安装</p>\n<ul>\n<li>插件1：Publish over SSH</li>\n<li>插件2：Deploy to container Plugin</li>\n</ul>\n<figure><figcaption>img_84.png</figcaption></figure>\n<p>添加图片注释，不超过 140 字（可选）</p>\n<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>\n<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>\n<h3> 3.1.Jenkins服务器上创建项目和配置</h3>\n<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>\n<p><strong>1.创建一个工程</strong></p>\n<figure><figcaption>img_85.png</figcaption></figure>\n<p><strong>2.General(基础配置)</strong></p>\n<p>仅需填写标准部分，其他可不填写</p>\n<figure><figcaption>img_86.png</figcaption></figure>\n<p><strong>3.源码管理</strong><br>\n</p>\n<p>上图中点击“添加”按钮添加一组账号和密码<br>\n</p>\n<p><strong>4.构建触发器</strong></p>\n<figure><figcaption>img_89.png</figcaption></figure>\n<p>如上图：当前项目的回调地址为：</p>\n<p><a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>\n<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>\n<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>\n<p><strong>5.构建环境（无需配置）</strong></p>\n<p><strong>6.构建</strong></p>\n<figure><figcaption>img_90.png</figcaption></figure>\n<p><strong>7.构建后操作</strong></p>\n<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>\n<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>\n<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>\n</p>\n<p>案例中给出的stop.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>案例中给出的start.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>\n<h3> 3.2.Linux服务器配置</h3>\n<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>\n<figure><figcaption>img_92.png</figcaption></figure>\n<h3> 3.3.GitHub服务器配置</h3>\n<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>\n<p>特别注意：为了保证回调地址网可以使用，</p>\n<p>我已经将地址：<a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>\n<p>通过花生壳进行外网映射为：<a href=\"http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>所以，下面配置的是外网映射地址。</p>\n<figure><figcaption>img_93.png</figcaption></figure>\n<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>\n<h2> 4.测试</h2>\n<p><strong>1.测试代码</strong><br>\n</p>\n<p><strong>2.提交代码到git,触发构建</strong></p>\n<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>\n</p>\n<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>\n<p>从下图中可以看出，正在构建</p>\n<figure><figcaption>img_96.png</figcaption></figure>\n<p><strong>5.查看当次构建的控制台日志</strong></p>\n<figure><figcaption>img_97.png</figcaption></figure>\n<p>说明已经启动成功</p>\n<p><strong>6.查看Linux服务器，是否上传代码</strong></p>\n<figure><figcaption>img_98.png</figcaption></figure>\n<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>\n<figure><figcaption>img_99.png</figcaption></figure>\n<p><strong>8.浏览器上访问，看是否能用</strong></p>\n<figure><figcaption>img_100.png</figcaption></figure>\n<p>说明，已经正常启动可以使用。</p>\n<p><strong>9.再次确认是否能自动化部署</strong></p>\n<p>修改代码，重新提交代码，循环1到8步查看。</p>\n<p>如果测试结果是你预期的，那么自动化部署成功。</p>\n<h2> 5.总结&amp;资料下载</h2>\n<h3> 5.1.总结</h3>\n<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>\n<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>\n<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>\n<p>但是，本着学习是为了解决生产的原则，</p>\n<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>\n<p>没必要把Jenkins的所有功能都学完在使用，</p>\n<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>\n<h3> 5.2.相关资料</h3>\n<ul>\n<li>1.案例中的源码地址：<a href=\"https://github.com/processfactory/demo01.git\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/processfactory/demo01.git</a></li>\n<li>2.官方文档：Jenkins 用户手册</li>\n</ul>\n",
      "date_published": "2024-02-27T06:40:40.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "DevOps基本概念",
      "url": "https://ujava.cn/highfreq/devops.html",
      "id": "https://ujava.cn/highfreq/devops.html",
      "summary": "1. DevOps 维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。 为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？ 项目管理模式的演变是受项目的规模大小影响的。 最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。 后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。",
      "content_html": "<h2> 1. DevOps</h2>\n<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>\n<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>\n<p>项目管理模式的演变是受项目的规模大小影响的。</p>\n<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>\n<br>\n后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>\n<p><br>\n再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>\n<br>\n再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>\n<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>\n<p><br>\nDevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>\n<ul>\n<li>DevOps = 人 + 流程 + 平台</li>\n<li>人 + 流程 = 文化</li>\n<li>流程 + 平台 = 工具</li>\n<li>平台 + 人 = 赋能</li>\n</ul>\n<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>\n<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>\n<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>\n<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>\n<h2> 2. CI/CD</h2>\n<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>\n<p><br>\nCI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>\n<p><strong>持续集成</strong>：</p>\n<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>\n</p>\n<p><strong>持续交付</strong>：</p>\n<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>\n</p>\n<p><strong>持续部署</strong>：</p>\n<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>\n</p>\n<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>\n<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>\n<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>\n<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>\n<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>\n",
      "date_published": "2024-02-27T05:50:08.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "SpringCloud详解",
      "url": "https://ujava.cn/highfreq/springcloud.html",
      "id": "https://ujava.cn/highfreq/springcloud.html",
      "summary": "SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。 一、SpringCloud概述 SpringCloud：SpringCloud官网",
      "content_html": "<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>\n<h2> 一、SpringCloud概述</h2>\n<p>SpringCloud：<a href=\"https://spring.io/projects/spring-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud官网</a></p>\n<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>\n<h2> 二、Spring Cloud 和 Dubbo 对比</h2>\n<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>\nSpring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>\nDubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>\n下面是Spring Cloud和Dubbo的一些比较：<br>\n</p>\n<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>\n<p>需要根据具体的业务需求来选择合适的微服务框架。</p>\n<h2> 三、Spring Cloud 优缺点</h2>\n<p>其主要优点有：</p>\n<ul>\n<li>\n<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>\n</li>\n<li>\n<p>约定优于配置，基于注解，没有配置文件。</p>\n</li>\n<li>\n<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>\n</li>\n<li>\n<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>\n</li>\n<li>\n<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>\n接下来，我们看下它的缺点：</p>\n</li>\n<li>\n<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>\n</li>\n<li>\n<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>\nSpring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>\n</li>\n</ul>\n<h2> 四、SpringCloud组件</h2>\n<h3> 1、Eureka</h3>\n<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2、Feign</h3>\n<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3、Ribbon</h3>\n<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4、Hystrix</h3>\n<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5、Config</h3>\n<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、SpringCloud应用场景</h2>\n<h3> 1、微服务架构</h3>\n<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>\n<h3> 2、分布式配置中心</h3>\n<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>\n<h3> 3、服务调用和负载均衡</h3>\n<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>\n<h3> 4、高可用和容错机制</h3>\n<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>\n<h2> 六、结语</h2>\n<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>\n",
      "date_published": "2024-02-26T05:26:17.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "什么是serverless",
      "url": "https://ujava.cn/highfreq/serverless.html",
      "id": "https://ujava.cn/highfreq/serverless.html",
      "summary": "1 什么是severless ? Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。 img_58.png 纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。 那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。 简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。 进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。 就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。",
      "content_html": "<h2> 1 什么是severless ?</h2>\n<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>\n<figure><figcaption>img_58.png</figcaption></figure>\n<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>\n<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>\n<ul>\n<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>\n<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>\n就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>\n</ul>\n<h2> 2 有服务到无服务构架有哪些变化？</h2>\n<ul>\n<li>弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>\n<li>代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>\n<li>按使用量计费。Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。<br>\n云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</li>\n</ul>\n<h2> 3 serverless发展历史</h2>\n<p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>\n<ul>\n<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。</li>\n<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>\n<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a href=\"http://iron.io\" target=\"_blank\" rel=\"noopener noreferrer\">iron.io</a>。</li>\n<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>\n</ul>\n<h2> 4 severless 分类</h2>\n<p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。</p>\n<ul>\n<li>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</li>\n<li>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</li>\n</ul>\n<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>\n<h2> 5 severles优缺点</h2>\n<h3> 优点</h3>\n<ul>\n<li>降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</li>\n<li>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</li>\n<li>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</li>\n<li>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</li>\n<li>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</li>\n<li>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是多快好省。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</li>\n<li>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</li>\n<li>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</li>\n<li>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</li>\n<li>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</li>\n<li>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</li>\n</ul>\n<h3> 缺点</h3>\n<ul>\n<li>状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>\n<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>\n<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>\n</ul>\n<h2> 6 serverless使用场景</h2>\n<p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。</p>\n<ul>\n<li>\n<p>异步的并发，组件可独立部署和扩展</p>\n</li>\n<li>\n<p>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</p>\n</li>\n<li>\n<p>短暂、无状态的应用，对冷启动时间不敏感</p>\n</li>\n<li>\n<p>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）<br>\nServerless 的使用场景示例如：</p>\n</li>\n<li>\n<p>ETL</p>\n</li>\n<li>\n<p>机器学习及 AI 模型处理</p>\n</li>\n<li>\n<p>图片处理</p>\n</li>\n<li>\n<p>IoT 传感器数据分析</p>\n</li>\n<li>\n<p>流处理</p>\n</li>\n<li>\n<p>聊天机器人<br>\n示例：</p>\n</li>\n</ul>\n<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>\n<p>一款移动端游戏至少包含如下几个特性：</p>\n<ul>\n<li>移动端友好的用户体验</li>\n<li>用户管理和权限认证</li>\n<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息<br>\n传统的应用程序架构可能是这样的：</li>\n</ul>\n<figure><figcaption>img_59.png</figcaption></figure>\n<ul>\n<li>一个 app 前端，iOS 或者安卓</li>\n<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>\n<li>使用关系型数据库存储用户数据，如 MySQL<br>\n这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</li>\n</ul>\n<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>\n<figure><figcaption>img_60.png</figcaption></figure>\n<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>\n<h2> 7 serverless核心技术</h2>\n<p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>\n<ul>\n<li>函数的规范定义</li>\n<li>函数部署流水线</li>\n<li>Workflow 设置</li>\n<li>0-m-n 扩缩容</li>\n<li>快速冷启动</li>\n</ul>\n<h2> 总结</h2>\n<p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>\n",
      "date_published": "2024-02-26T03:22:45.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业级架构带来的模式改变",
      "url": "https://ujava.cn/highfreq/modelchange.html",
      "id": "https://ujava.cn/highfreq/modelchange.html",
      "summary": "数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。 一、价值评估有章可循 近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。",
      "content_html": "<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>\n<h2> 一、价值评估有章可循</h2>\n<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>\n<p>企业级架构建设循着企业价值创造的链条，可面向业务领域逐步开展需求识别和定义。对于业务领域而言，其主要职责是创造业务价值，承接战略分析成果，进行产品研发。实践中，业务领域需要清晰定义本领域应具备的能力，提出能力建设方案，并在领域范畴内，按照计划—执行—监督的完整价值流，识别出业务活动。业务活动是指创造端对端业务价值的具体工作，其价值交付主要以产品为载体，包括产品服务的客户、产品提供的渠道、产品所需的合作伙伴等，在流程模型中需要进行全面辨识。基于企业级架构方法论形成的业务需求和业务模型，有助于业务价值的体现和评估：</p>\n<p>一是基于企业级架构的全局视角，可以减少个别部门的短期促销行为，同时避免不规范需求引发的产品定价、业务流程不一致等问题。二是企业级架构承接业务战略，始终围绕着价值创造建设，而需求在经过“战略解析—能力主题—产品设计—流程设计—能力实现”的工作模型检验后，将能够更好地满足战略需要，有利于提高核心竞争力。三是需求的业务价值更容易量化，基于企业级架构，可建立产品、客户、渠道、合作方贡献度评价体系，对需求带来的效益进行数字化评估。四是业务需求价值评估能力提高，可以使科技产能更好地倾向于重点需求开发，快速形成竞争力。</p>\n<h2> 二、数据治理追本溯源</h2>\n<p>如果说价值交付是建设企业级架构的核心，那么业务信息则是构成企业级架构的基础，内容涉及业务架构的业务对象以及业务模型的实体模型等。对此，IT架构的数据架构进一步从数据定义、数据管理、数据服务等方向，规定了数据生命周期中各种形态的管理原则。数据架构组成示意如图1所示。例如，针对实体建模，该架构详细描述定义了业务实体和实体属性；针对数据定义，要求开发数据结构准确继承实体模型；针对元数据管理，要求建立企业级数据字典，保证数据能被正确描述和使用。此外，在数据质量管控方面，则是要求在组织、办法和流程等维度进行全面统筹。</p>\n<figure><figcaption>数据架构组成示意</figcaption></figure>\n<p>实践证明，如果不能全面梳理数据脉络，数据治理的结果往往是事倍功半。对此，企业级架构有助于为全面实施数据治理打开局面：一是在需求的业务建模阶段，业务流程的数据需求和实体模型需要进行相互验证，并通过企业级数据字典进行定义，在源头保证数据准确性。二是从架构设计到实施工艺，从实体建模到数据结构设计，借助企业级架构可形成全面的数据管理办法，保证数据在产生、传输、存储、服务各个环节的一致性。三是基于企业级架构，可将内部能力按业务组件归集，并依照业务组件开发应用组件，同时加强数据副本管理，进而避免因同类业务被不同应用系统承接导致的管理复杂化问题。综上，数据治理是数字化转型的一项基础性工作，而企业级架构恰好提供了一枚“金钥匙”。</p>\n<h2> 三、业务与技术更好衔接</h2>\n<p>在瀑布式开发模式下，标准化需求确认需要经历多个不同阶段的准入门禁，需求响应缓慢。与之相比，敏捷开发模式强调客户参与，更有助于加速需求交付进程，例如将开发过程前移到需求提出阶段，或是请业务人员加入开发团队等。除此之外，企业级架构也为业务与技术融合提供了一种新的途径：</p>\n<ul>\n<li>一是在提交业务需求前，通过对活动进行流程建模，以及对业务对象进行实体建模，并采用结构化、标准化语言(如流程建模的BPMN图和实体建模的ER图等)消弭理解歧义，可基于业务模型团队构建衔接业务和技术的桥梁。</li>\n<li>二是企业级架构结合内部视角，可从业务流程、职责划分等维度映射业务组件与应用组件的对应关系，进而实现业务和技术的完美对应。</li>\n<li>三是企业级架构的流程建模需要勾连相关实体，而建模产出物结合面向对象的设计方法，将能方便地识别出符合客观世界的对象，对象拥有实体属性，并具备流程模型描述的处理能力。</li>\n<li>四是企业级架构在进行实体建模时，可对实体进行归类，定义出主实体，并与周边的多个实体组成业务对象(子主题域)。在开发阶段，通过将业务建模的业务对象(子主题域)设计成相应的数据聚合，可有效保证技术和业务理解一致，使用“共同语言”。</li>\n</ul>\n<p>总体而言，业务模型通过以业务视角来描述战术层和运营层的业务架构，可为IT架构提供高效输入，而善于使用业务架构和业务模型，也将使业务与技术衔接得更好，加快需求响应速度。业务架构基础模型如图2所示。</p>\n<figure><figcaption>业务架构基础模型</figcaption></figure>\n<h2> 四、方法实践潜移默化</h2>\n<p>从实践角度发出，企业级架构不仅是对业务架构和IT架构进行全局设计，还提供了精确描述企业的统一方法论，如可灵活应用在日常工作中，将产生潜移默化的积极影响：</p>\n<ul>\n<li>一是价值链分析。企业级架构进行企业层面的流程模型设计，遵循价值创造的链条识别业务领域，并在业务领域通过各类活动实现业务价值，接着就是将活动下的任务按能力类别聚合成业务组件。在IT实施阶段，可沿用同样的分析方法，按价值维度将业务组件进一步细分为子域，最后将能力进行聚合，开发出高内聚的微服务。</li>\n<li>二是架构视图绘制。企业级架构的IT架构通常包含了四个维度，即安全架构、技术架构、数据架构和应用架构。其中，应用架构可进一步划分为三个阶段，即分层架构、逻辑架构、物理架构，并从功能视图、接口视图、剖面视图等多个维度进行描述。实践中，上述建模方法不仅可用于搭建企业级总体架构，在描述应用系统的内部架构时也同样适用。</li>\n<li>三是名词术语。基于企业级架构建设，有助于统一名词术语，改善概念混淆的状况，进而减少沟通成本。例如，在旧文档中信息系统有时被称作“系统”，也有称作“产品”或“应用”的情况。而结合企业级架构建设，可将业务领域下各类活动的系统统一称为“应用”，负责承接业务组件的系统称为“应用组件”，名称更加准确、明白。</li>\n<li>四是建模方法。业界常用的建模方法一般指业务建模采用的BPMN图和实体建模采用的ER图，两者作为通用的建模语言，在开发阶段也常被使用。而企业级架构借助建模过程可将上述方法进一步推广到整个组织，进而可大幅提高描述能力和沟通效率。</li>\n<li>五是职责定义。企业级架构对工作职责的定义往往是从目标(WHY)、定义(WHAT)、范围(WHERE)等三个维度进行描述，不仅言简意赅，且广泛适用于各种场景。</li>\n</ul>\n<p>综上，数字化转型是银行机构践行高质量发展的必由之路。自2018年提出数字化转型总体框架以来，中国银行于2019年全面启动数据治理，并在2020年启动了企业级架构建设，通过自上而下对业务架构、技术架构、工艺方法等进行全面整合，数据治理各环节工作变得更加顺畅，需求开发变得更加敏捷，数字化转型目标也愈发清晰可见!</p>\n",
      "date_published": "2024-02-23T07:12:07.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "WebFlux详解",
      "url": "https://ujava.cn/highfreq/webflux.html",
      "id": "https://ujava.cn/highfreq/webflux.html",
      "summary": "因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。 然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。 所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。 我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。",
      "content_html": "<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>\n<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>\n<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>\n<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>\n<p>话说这么多，开始今天的学习吧。</p>\n<h2> 什么是 WebFlux</h2>\n<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>\n<figure><figcaption>img_51.png</figcaption></figure>\n<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>\n<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>\n<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>\n<h2> 反应式库</h2>\n<h3> 1. Reactive Stream</h3>\n<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>\n<p>我们先看下这个概念：</p>\n<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>\n<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>\n<p>它由以下几个组件组成：</p>\n<ul>\n<li>发布者：发布元素到订阅者</li>\n<li>订阅者：消费元素</li>\n<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>\n<li>处理器：发布者与订阅者之间处理数据</li>\n</ul>\n<h3> 2. Reactor</h3>\n<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>\n<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>\nReactor 就是 Spring WebFlux 的首选 反应式库。</p>\n<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>\n<ul>\n<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>\n<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>\n两个都是发布者 Publisher。</li>\n</ul>\n<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>\n<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>\n<ul>\n<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>\n<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>\n<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>\n</ul>\n<p>代码初体验</p>\n<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>\n<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>\n</p>\n<ol>\n<li>Mono</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>\n<ul>\n<li>接口耗时：0</li>\n<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>\n</ul>\n<ol start=\"2\">\n<li>Flux</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>\n<h2> 操作数据库</h2>\n<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>\n<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>\n<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>\n<h3> 1. 创建项目</h3>\n<p>选择这几个依赖，创建新的 project:</p>\n<figure><figcaption>img_53.png</figcaption></figure>\n<p>pom.xml 文件里是这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后是 application.properties:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2. 创建数据库表</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个简单的 test_user 表。</p>\n<h3> 3. 创建相关类</h3>\n<p>实体类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserRepository，就相当于 DAO</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserController 控制器</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>\n<h3> 4. 启动测试</h3>\n<p>项目启动之后，我们使用 Postman 测试一下。</p>\n<h3> 请求地址路由</h3>\n<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>\n<p>创建 Userhandler.java</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建 RouterConfiguration</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>\n<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>\n<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>\n<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>\n<li>通过 addRoute 方法可以配置多个路由策略。<br>\n测试</li>\n</ul>\n<p>修改：</p>\n<p>查询和前面一样：</p>\n<h3> 适用性</h3>\n<p>官网上是这样建议的：</p>\n<ul>\n<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>\n<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>\n<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>\n<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>\n</ul>\n<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>\n",
      "date_published": "2024-02-22T07:31:35.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "Reactor模型详解",
      "url": "https://ujava.cn/highfreq/reactor.html",
      "id": "https://ujava.cn/highfreq/reactor.html",
      "summary": "前言 说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。 一、经典的同步阻塞模型 img_46.png 这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。",
      "content_html": "<h2> 前言</h2>\n<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>\n<h2> 一、经典的同步阻塞模型</h2>\n<figure><figcaption>img_46.png</figcaption></figure>\n<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>\n<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>\n<ul>\n<li>read：从socket读取数据。</li>\n<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>\n<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>\n<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>\n1.下面看传统的BIO代码：</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>\n<p>我们的目标是：</p>\n<ul>\n<li>随着负载的增加可以优雅降级；</li>\n<li>能够随着资源的改进，性能可以持续提升；</li>\n<li>同时还要满足可用性和性能指标：</li>\n<li>低延迟</li>\n<li>满足高峰需求</li>\n<li>可调节的服务质量</li>\n</ul>\n<p>阻塞 （针对的是被调用方）</p>\n<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>\n让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>\n<p>同步 （针对的是调用方）</p>\n<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>\n如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>\n<p>NIO就很好的解决了传统Socket问题：</p>\n<ul>\n<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>\n<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>\n</ul>\n<p>2.client端代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>\n<h2> 二、单reactor单线程设计</h2>\n<figure><figcaption>img_47.png</figcaption></figure>\n<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>\n<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>\n<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>\n<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>\n<p>代码示例</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义了一个Reactor类。</p>\n<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>\n<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>\n监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>\n<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>\n<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>\n<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>\n<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>\n<p>下面我们可以进行测试了：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>\n那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>\n<h2> 三、单reactor多线程设计</h2>\n<figure><figcaption>img_48.png</figcaption></figure>\n<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>\n<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>\n<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看测试结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>\n<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>\n<h2> 四、多reactor多线程设计</h2>\n<figure><figcaption>img_49.png</figcaption></figure>\n<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>\n只负责处理客户端的写事件。</p>\n<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>\n<h2> 五、Reactor模型结构图</h2>\n<figure><figcaption>img_50.png</figcaption></figure>\n<ul>\n<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>\n<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>\n<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>\n<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>\n<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>\n</ul>\n",
      "date_published": "2024-02-22T06:49:50.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业级架构建模之浅谈三大模型关系",
      "url": "https://ujava.cn/highfreq/modelrelation.html",
      "id": "https://ujava.cn/highfreq/modelrelation.html",
      "summary": "通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。 企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。 产品模型是企业定制化产品的集合，阐述企业提供的服务是什么 流程模型展现可复用的业务环节，表达企业提供的服务怎么做 数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。 从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。",
      "content_html": "<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>\n<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>\n产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>\n<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>\n<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>\n从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>\n<h2> 01、三大模型概述</h2>\n<p><br>\n1.企架三大模型之——产品模型</p>\n<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。顶层的产品线可以理解为银行业务条线，可包含多个产品组，每一个产品组是对其唯一归属的产品线下具有相似业务性质基础产品的聚合。基础产品包含了聚类可售产品所有可能的特征，为对基础产品进一步划分，可创建不同的产品组件。产品组件的存在不仅能对基础产品做出细分，同时也是最底层产品特征相同或相似的产品条件的归类。产品条件表达产品对金额、利率、期限、数量等业务特征的限制规则，可用于对属性和逻辑的控制参数。</p>\n<p>2.企架三大模型之——流程模型</p>\n<p>流程模型用标准化的方式表达业务流程结构，可分为五层，逐层把企业业务能力分解为业务领域、价值流、活动、任务和步骤，并通过与产品模型和数据模型协同关系，精准刻画业务需求。顶层的业务领域是紧密相关业务的集合。价值流是一组互不相同、界限分明，但相互关联的生产经营活动，是构成价值创造的动态过程，如存款和贷款的界限分明但共同存在为银行创造价值。这里的活动由不同的事件触发，比如外部事件、时间或条件触发的内部事件，活动的存在是为了达成具体的业务目的，企业执行端到端的行为序列集合；活动也是从用户角度看到的执行业务流程。具体来讲，我们可用任务来表达从银行内部执行的操作。活动和任务具备明确目的性，要求产生可观测、有价值的结果。流程模型中最底层的步骤则涵盖所有最细化的业务规则和业务信息。</p>\n<p>3.企架三大模型之——数据模型</p>\n<p>数据模型是企业范围内统一的数据视图，通过一系列规范和相关图表反映数据需求和设计。根据规则从企业的视角对业务概念进行逻辑化、一致性的表述，用数据语言表达业务需求并展现业务规则，是联接业务和技术的桥梁，也是业务模型的主要组成部分。具体来看，顶层的业务对象是一组关联实体的集合，要求高内聚松耦合；关联的实体不允许重复或缺失。业务实体可视为以业务视角抽象表示一种客观存在于现实世界并且可以跟其他物体区分开，用一系列业务属性来描述的事物。</p>\n<p>因此业务实体所具有的某一业务特性，我们称之为实体属性。若干个属性可共同刻画同一实体。向下延申，属性域值对属性取值范围进行规范，每个属性都有需要遵循的值的范围，通过域明确属性的取值规则。属性域实例只与代码类的域关联，用于进一步明确每一个取值下的规范。一个实例组会有多个取值，每个取值称为实例组的一个实例。业务组件是独立的业务模块，指具有相似资源、人和专业技能的任务组合，通过将标准化的任务按照业务对象聚类形成业务组件。</p>\n<h2> 02、模型间协同关系</h2>\n<p>第一部分概述中已经对每个模型划分层级，比如产品模型自上而下分别是产品线、产品组、基础产品、产品组件和产品条件。三大模型间的协同关系主要也是讨论模型层级与层级间的联动，下面将分类剖析：</p>\n<p>1.产品模型对接流程模型</p>\n<p><br>\n基础产品与活动（多对多） 基础产品仅关联与产品有关的活动。活动可以看作是某个基础产品在提供服务有哪些环节划分，比如任何与贷款相关的基础产品需要有申请贷款额度、审核客户背景等环节共同搭建贷款服务体系。这些环节我们就可以说是这个基础产品对应的活动。在填写流程模型活动表单时，会体现活动编号、名称、详情等信息，也会专门有一列“产品信息”来体现活动对应到哪些具体的基础产品。基础产品与任务（多对多） 刚才提到活动是环节划分，而任务则是某环节衍生出来要做的事，因此任务与其上层活动所关联的基础产品范围上是一致的。延续”申请贷款额度“这个活动案例，银行方面需要完成的任务就是“受理额度申请”等一系列为了完成客户申请贷款额度而做的工作。我们也可以理解为活动是客户角度看到的环节，而任务是从我们服务提供方内部角度对活动拆解出来需要完成的事项。当活动关联了基础产品，才会建立该活动下层任务与基础产品的关系。产品条件与步骤（多对多） 步骤则是呈现任务中的事项具体如何去操作，是环节最细致的拆分。因此当活动和任务关联了基础产品，步骤作为最底层的拆分理应映射产品模型最下层的参数-产品条件。通常一个步骤需要关联至少一个产品条件，同时每个产品条件需要被至少一个步骤使用。对“受理额度申请”这个任务来说，其中一个“检查账户信息”的具体步骤，在流程模型步骤表单“与产品模型映射”列就可以映射“开户银行类型”这一产品条件，表示对某账户开户银行具体类型的选择。</p>\n<p>2.数据模型对接流程模型</p>\n<p><br>\n任务与业务实体（多对多） 数据模型中的实体由流程模型的任务创建而来。流程模型任务表单有专门一列“业务实体”来呈现关系。比如终止某产品协议就可以关联到“产品协议”这个实体。终止某产品协议是要做的事，要把这件事说清楚便需要创建一个产品协议实体去承接，且实体名称需与数据模型的实体精确匹配。步骤与业务实体（多对多） 步骤是任务的细化，和任务一样可以去操作实体。在实际工作中，会遇到步骤牵扯到多个实体的情况，比如“调查客户背景”这个任务，其中有一个步骤是“核实客户基本信息”，涉及操作“账户”实体和“客户信息”实体，这时可根据业务含义判断是否可拆分步骤，拆至最小颗粒度便于业务和技术人员清晰理解流程。步骤与实体属性（多对多） 实体属性用于描述业务实体。流程模型中的“业务规则”列需要体现涉及业务实体下的属性。主要体现对业务规则有影响的关键属性及对应的取值描述和使用规则。还是举“核实客户基本信息”这个步骤，在创建“客户信息”实体的同时会在业务规则中体现是对公客户还是对私客户，因此属性“客户公私类型”便会建立在数据模型与其做映射，属性的取值也直接影响到该步骤最终的结果。</p>\n<p>3.业务组件对接业务对象和任务</p>\n<figure><figcaption>img_43.png</figcaption></figure>\n<p>业务组件与任务（一对多）</p>\n<p>业务组件可视为业务分类器，作为独立的业务模块归集具有相似业务目的的任务。这里的相似主要是领域和数据使用的相似。比如“调查客户背景”和“识别客户风险”两项任务都是为了更好了解和识别客户信息和行为，涉及的数据都可以有账户实体下的所有属性字段。因此我们可以将它们归集在“客户管理”业务组件。一个任务只归属一个业务组件，一个业务组件下可包含多个紧密相关的任务。</p>\n<p>业务组件与业务对象（一对一/多）</p>\n<figure><figcaption>img_44.png</figcaption></figure>\n<p>业务组件归集具有相似业务目的的任务，业务对象归集互相关联的实体，而实体由任务来创建。因此业务组件与业务对象的关联具体体现在业务组件下任务对业务对象下实体的操作。以最基本的存款业务举例，“存款”是业务组件，具体任务有“记录存款信息”和“更换存单”，这两项任务便可操作“存款账户”这个业务对象下的“存款合约”和“存单”两个实体。</p>\n<p>3.业务事件承接业务领域和活动</p>\n<p><br>\n业务领域对业务划分主题类型，其具体发生的行为操作称之为业务事件。围绕业务事件所产生的两条关系可总结为业务领域包含业务事件，而事件会触发一系列活动。比如贷款这个业务领域，我们能想到发生的业务事件包括申请住房贷款、购车贷款、助学贷款等贷款额度，这些事件便可触发申请个人贷款额度的活动，这个活动下面的任务和步骤则是对其需要做的事更细致的划分。一个领域涵盖多个事件，每个活动必由一个或多个业务事件触发。在实际建模工作中，三大模型分别建立再做关联映射大大提升建模难度，为了映射而映射，导致模型质量降低。因此，从建模初期保持三大建模的“实时”匹配尤其重要。无论是顶层领域划分规则还是底层参数设定，三个建模组通过完善的沟通机制共同协商而定，是企业级建模结果能够有效应用于全领域业务的基石。</p>\n",
      "date_published": "2024-02-22T02:04:39.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构",
      "url": "https://ujava.cn/highfreq/business.html",
      "id": "https://ujava.cn/highfreq/business.html",
      "summary": "简介 在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。 架构的视角 在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。",
      "content_html": "<h2> 简介</h2>\n<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>\n<h2> 架构的视角</h2>\n<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>\n<p>很多时候架构的视角/分类没有明显的边界，通常是交叉的；<br>\n有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</p>\n<h2> 业务架构</h2>\n<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>\n<p><br>\n看看京东业务架构（网上分享图）：<br>\n</p>\n<h2> 应用/技术架构</h2>\n<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>\n<p>不限于如下视角，主要表示应用开发中的软件架构视角...</p>\n<h3> 视角：功能视角</h3>\n<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>\n<h3> 视角：技术视角-总体</h3>\n<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>\n<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。<br>\n</p>\n<h3> 视角：技术视角-数据架构</h3>\n<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>\n<h3> 视角：技术视角-基础架构</h3>\n<p>PAAS，IAAS...</p>\n<figure><figcaption>img_35.png</figcaption></figure>\n<h3> 视角：技术视角-运维架构</h3>\n<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>\n<figure><figcaption>img_36.png</figcaption></figure>\n<h2> 物理架构</h2>\n<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>\n<p>以一个银行系统为例</p>\n<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。<br>\n</p>\n<p>物理部署架构设计说明：</p>\n<ul>\n<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>\n<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>\n<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>\n<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>\n<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>\n<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。<br>\n下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。<br>\n</li>\n</ul>\n<p>物理部署架构设计说明：</p>\n<ul>\n<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>\n<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>\n<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>\n</ul>\n<h2> DDD到各种架构</h2>\n<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>\n<p>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</p>\n<p>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</p>\n<p>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</p>\n<figure><figcaption>img_39.png</figcaption></figure>\n",
      "date_published": "2024-02-21T03:01:36.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业架构TOGAF内容框架",
      "url": "https://ujava.cn/highfreq/togaf.html",
      "id": "https://ujava.cn/highfreq/togaf.html",
      "summary": "img_24.png 一、内容框架概述 TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。 企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。",
      "content_html": "<figure><figcaption>img_24.png</figcaption></figure>\n<h2> 一、内容框架概述</h2>\n<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>\n<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>\n<p>内容框架对企业架构开发方法中各阶段的输入和输出信息进行了分类总结，并通过内容元模型（Content MetaModel）对构成企业架构内容的各个元素（即企业架构中的各个构建块的类型）以及他们之间的关系进行了定义。内容框架中针对其内容的描述采用了一种与架构开发方法的各阶段相映射的方式进行组织，即对架构开发方法的各个阶段所产出的企业架构内容具体是什么进行描述。</p>\n<p>虽然针对企业架构内容的定义非常重要，但是同样重要的还有如何对企业架构的内容进行利用。企业架构的核心目标是为具有不同视角的干系人根据其关注点提供准确的视图，从而使得不同的干系人虽然采用了不同的观察角度和描述方式，但的确是在为共同的目标而进行着无障碍沟通和协作。为了达到这一目标，内容框架对于各种视角（ViewPoint）从表现形式和内容方面都进行了归纳总结，并对一些视图的开发也提供了建议和指南。TOGAF是一个通用性的标准，它的内容不可能涵盖企业中所有的视角，因而在具体实践中，各个企业完全可以根据自身需要对这些视角进行引用、修改和组合，从而总结出适合的视角，并借此开发出相应的视图，从而满足企业中具体干系人的需要。</p>\n<p>下图展示了内容框架中各方面内容与企业中客观存在的各种资源之间关系，以及企业架构的内容是如何在内容框架的组织下为各个干系人提供帮助的：</p>\n<figure><figcaption>img_25.png</figcaption></figure>\n<h2> 二、企业架构工作产品分类</h2>\n<p>在内容框架中，企业架构开发方法过程中所涉及到的各种工作产品被归纳为如下几种：</p>\n<p>1、架构交付物（Architecture Deliverables）：架构交付物是由合同指定并被相关干系人轮流进行正式的审查和签字认可的工作产品。这些交付物代表着架构项目的输出，以及那些在一个项目完结时以文档形式进行交付的，或者作为参考模型、标准或在某一时点的架构情景快照（snapshot of the Architecture Landscape）被过渡到架构资源库中的工作产品。</p>\n<p>2、架构制品（Architectural Artifacts）：与架构交付物相比，架构制品是一个从某个特定视角进行架构描述并具备更细粒度的工作产品。例如，网络图、服务器说明、用例说明、架构需求列表以及业务交互矩阵等。就表现形式来讲，架构制品的内容可以通过目录、矩阵和图形这三种方式来表述。通常情况下，一个架构交付物可以包含多个架构制品，而架构制品也可能会出现在多个架构交付物之中，并且架构制品也将会形成架构资源库的内容。</p>\n<p>3、构建块（Building Blocks）：构建块代表着业务、IT或者架构能力的一个组件，并且可以与其他构建块组合在一起来对各种架构和解决方案进行交付。根据所处的架构开发阶段的不同，构建块能够在多个详细度层次上进行定义。例如，在架构开发的早期阶段，一个构建块可能仅仅包含一个名字或一个概要描述，而随着架构开发过程的演进，此构建块可能会被进一步分解为若干具有详尽描述的支持性构建块。从内容和所面对的问题上看，构建块可以被进一步分为如下两种：</p>\n<p>架构构建块（ABBs：Architecture Building Blocks）：此种类型的构建块一般用于描述各种需要的能力，并对其后的解决方案构建块的轮廓进行了勾勒。例如，企业中的一个客户服务定义了实现这项能力的各种需求，而对于它的真正落实就需要若干解决方案构建块在各方面（流程、数据以及应用软件等）将这些需求映射到具体的实现技术之上。<br>\n解决方案构建块（SBBs：Solution Building Blocks）：此种类型的构建块代表了用于实现各种需求（由架构构建块定义）的具体组件。<br>\n<br>\n以上三种工作产物虽然在内容和产生背景上有着很大的不同，但是他们之间却有着非常紧密的联系。构建块可以说是企业架构资源库的核心内容，并且也是企业架构过程的终极目标产物，因而把其称为企业的模型也并不为过，而架构制品则可以看成此模型在某个角度的各种视图，属于架构描述的范畴。架构交付物比较特殊，它与架构开发方法各阶段紧密相连，并作为各个阶段的输入与输出载体而存在。</p>\n<h2> 三、架构交付物（Architecture Deliverables）</h2>\n<p>架构交付物是在整个架构开发方法循环过程中所产生或被使用的契约性、正规化的企业架构内容。它与企业架构开发方法有着紧密的联系。本节将针对这些架构交付物以及它们与架构开发方法各阶段之间的关系进行阐述。需要注意的是，本节的内容只提供了一个关于架构交付物的内容概括。由于企业中可能存在着符合其自身需要的项目和过程管理方法，所以企业也可以根据自己的实际情况对这些交付物进行改造和定制。</p>\n<p>架构交付物与企业架构开发方法各阶段之间的对应关系（注意，下表采用了简称来标示各企业架构开发方法阶段）：<br>\n</p>\n<figure><figcaption>img_28.png</figcaption></figure>\n<h3> 1、架构构建块</h3>\n<p>构建块是企业架构过程的最终目标之一，它是企业对于各个层面上（业务、应用、数据以及技术等）的可重用部件的抽象。架构构建块的内容侧重于对构建块的需求进行描述，就像软件开发中的接口一样，架构构建块并不涉及具体的实现方式，而只是描述了构建块所需要达成的功能。用于描述架构构建块的文档和模型存储在企业架构资源库之中，企业架构开发过程正是对企业中各种客观存在的或计划中的可重用模块进行抽象建模，并最终将这些内容存储到企业架构资源库之中（或对其内容进行更新）。</p>\n<h3> 2、架构合同</h3>\n<p>目标</p>\n<p>架构合同是企业架构开发团队与赞助团队之间关于架构的交付、质量和适用性的联合协定。为了成功实现这一协定则需要企业进行有效的架构治理。通过实现一个用于合同管理的治理方法，企业将会确保：</p>\n<ul>\n<li>对组织中所有架构相关活动的完整性检查、变更、决策和审计进行持续监督。</li>\n<li>现存或正在开发的架构得以贯彻组织的原则、标准和需求。</li>\n<li>明确架构在开发和实现的各个方面中的风险，这些方面涵盖了关于可接受的标准、策略、技术和产品的内部开发，以及架构的运营层面，从而使得组织可以在一个具有弹性的环境中继续其业务。</li>\n<li>一系列流程和实践，用于确定关于所有架构制品的开发和使用的责任和规则。</li>\n<li>对于为合同负责的治理组织，他们的权限级别及其治理之下的架构范围有一个正式的理解。</li>\n</ul>\n<p>内容</p>\n<p>架构设计和开发合同的内容一般包括：</p>\n<ul>\n<li>介绍和背景</li>\n<li>协议性质</li>\n<li>架构范围</li>\n<li>架构以及战略原则和需求</li>\n<li>一致性需求</li>\n<li>架构开发和管理流程，以及相关角色</li>\n<li>目标架构评测标准</li>\n<li>定义的交付阶段</li>\n<li>按照优先级排序的联合工作计划</li>\n<li>时间窗口（Time windows）</li>\n<li>架构交付和业务指标</li>\n</ul>\n<p>业务用户的架构合同一般包括：</p>\n<ul>\n<li>介绍和背景</li>\n<li>协议性质</li>\n<li>范围</li>\n<li>战略需求</li>\n<li>一致性需求</li>\n<li>架构采用者</li>\n<li>时间窗口</li>\n<li>架构业务指标</li>\n<li>服务架构（包括服务水平协议（SLA：Service Level Agreement））</li>\n</ul>\n<h3> 3、架构定义文档</h3>\n<p>目标</p>\n<p>架构定义文档是一个包含在整个项目中所产生的各种制品的可交付容器。它跨越所有的架构领域（业务、数据、应用和技术），并可用于检阅架构的所有相关状态（当前态、中间态和目标态）。架构定义文档对架构需求文档在如下方面进行互补：</p>\n<ul>\n<li>架构定义文档提供了一个解决方案的定性视图，用于沟通架构师的意图。</li>\n<li>架构需求说明提供了一个解决方案的定量视图，用于声明在架构实现过程中必须遵守的可测量的标准。<br>\n内容</li>\n</ul>\n<p>架构定义文档内容一般包括：</p>\n<ul>\n<li>范围</li>\n<li>目标、阶段目标和约束</li>\n<li>架构原则</li>\n<li>基线架构</li>\n<li>架构模型（针对每个被建模的状态）：业务架构模型、数据架构模型、应用架构模型、技术架构模型</li>\n<li>架构方法的基本原理和理由</li>\n<li>架构资源库内容映射：架构情景映射、参考模型映射、标准映射、重用评估</li>\n<li>差距分析结果</li>\n<li>影响评估</li>\n</ul>\n<h3> 4、架构原则</h3>\n<p>目标</p>\n<p>通用的规则和指南，一般是不会进行更改的。这些原则知会并支持一个组织用以实现其任务的方法。它是用于定义和指导组织从价值到行为和结果的一系列结构化思路中的一员。</p>\n<p>内容</p>\n<p>架构原则一般包括如下几个层面的内容（其具体内容请参看TOGAF标准相关内容）：</p>\n<ul>\n<li>业务原则</li>\n<li>数据原则</li>\n<li>应用原则</li>\n<li>技术原则</li>\n</ul>\n<h3> 5、架构资源库</h3>\n<p>目标</p>\n<p>架构资源库在企业中充当了对于所有架构相关项目进行存储的区域。它允许各个项目管理它们的交付物，定位可重用资产，并对干系人以及其他有兴趣者进行信息发布。</p>\n<p>内容</p>\n<p>架构资源库的内容包括如下几个方面（其具体内容请参看TOGAF标准相关内容）：</p>\n<ul>\n<li>架构框架</li>\n<li>标准信息库</li>\n<li>架构情景</li>\n<li>参考架构</li>\n<li>治理日志</li>\n</ul>\n<h3> 6、架构需求说明</h3>\n<p>目标</p>\n<p>架构需求说明提供了一组量化的描述，用于概括一个项目的实现与架构相符合所必须做的事情。架构需求说明一般会形成一个实施契约，或是更详细的架构定义契约中的主要组件。</p>\n<p>内容</p>\n<p>架构需求说明的内容通常包括：</p>\n<ul>\n<li>成功评测标准</li>\n<li>架构需求描述</li>\n<li>业务服务契约</li>\n<li>应用服务契约</li>\n<li>实施导则</li>\n<li>实施说明</li>\n<li>实施标准</li>\n<li>互操作需求</li>\n<li>约束</li>\n<li>假设</li>\n</ul>\n<h3> 7、架构路线图</h3>\n<p>目标</p>\n<p>架构路线图列举出各个变化增量，并把他们放到时间轴之上，从而展示了从当前架构到目标架构的演进过程。架构路线图是迁移架构的重要组件，并在架构开发方法的B、C、D、E、F阶段中以增量的方式开发出来。</p>\n<p>内容</p>\n<p>架构路线图的内容包括：</p>\n<ul>\n<li>项目列表：每个涉及到的项目的名称、描述和目标，用于实现所建议的架构的项目列表，并按照优先级进行了排序。</li>\n<li>基于时间的迁移规划：迁移的效益、针对各种迁移选择的成本估算。</li>\n<li>实施建议：用于衡量项目有效性的评估准则、风险和问题、解决方案构建块的描述和模型。</li>\n</ul>\n<h3> 8、架构愿景</h3>\n<p>目标</p>\n<p>架构愿景是在项目生命周期早期创建的，它提供了一个高阶的对于最终架构产品的期望视图。目的是为了在一开始就对架构应该达到的期望结果形成一致意见，从而使得在之后的过程中架构师能够关注于切实可行的关键领域。通过提供一份关于整体架构定义的内容摘要，架构愿景对于干系人之间按沟通也提供了一定的支持。</p>\n<p>内容</p>\n<p>架构愿景的内容通常包括：</p>\n<ul>\n<li>问题描述：干系人以及他们的关注点，需要解决的问题/场景列表。</li>\n<li>详细目标描述</li>\n<li>环境和流程模型：流程描述、涉及到环境的流程步骤、涉及到人员的流程步骤、信息流</li>\n<li>执行者以及他们担当的角色和责任：人员方面的执行者和角色、计算机方面的执行者和角色、需求</li>\n<li>所产生的架构模型：约束、IT原则、支持流程的架构、映射到架构之上的需求。</li>\n</ul>\n<h3> 9、业务原则、目标和驱动力</h3>\n<p>目标</p>\n<p>业务原则、目标和驱动力通过描述企业的需要和工作方式为架构工作提供了背景。此外，许多处于架构原则考虑之外的因素对架构的开发也有着重要的影响。</p>\n<p>内容</p>\n<p>于不同的组织有着不同的特性，因而关于架构业务背景的内容将会各不相同，企业应该根据各自的情况定义这部分内容。</p>\n<h3> 10、能力评估</h3>\n<p>目标</p>\n<p>在做一份详细的架构定义之前，对企业的当前和目标的能力水平有一个清晰的认识是非常有价值的。对于能力评估，我们可以在如下几个层面进行考虑：</p>\n<ul>\n<li>企业整体的能力水平是什么？企业希望在何处增强或优化其能力？用于支持企业期望发展的架构关注领域是什么？</li>\n<li>企业中的IT功能的能力或成熟度水平是什么？就设计管理、操作管理、技术和组织架构而言，进行架构项目最可能的影响都有哪些？为了与企业文化和IT部门的能力相适应，架构项目所需的正规化和详细度的最适宜水平是什么？</li>\n<li>企业架构功能的能力和成熟度是什么？当前存在的架构资产有哪些？这些资产是否被一直维护，并且是否还准确？什么样的标准和参考模型需要被考虑进去？是否在这些在架构项目中有可能创建可重用资产？</li>\n<li>能力欠缺存在于何处？为了达成目标能力而需要进行转型的业务范围是什么？在对基本能力欠缺考虑之上的转换风险、文化壁垒以及其他方面考虑都有哪些？<br>\n内容</li>\n</ul>\n<p>能力评估的内容通常包括：</p>\n<ul>\n<li>业务能力评估：业务能力、针对每项能力性能水平的基线状态评估、针对每项能力性能水平的未来状态期望、针对每项能力如何实现的基线状态评估、针对每项能力将会被如何实现的期望</li>\n<li>IT能力评估：变更流程的基线和目标成熟度水平、运营流程的基线和目标成熟度水平、基线能力以及容量评估、针对由于架构项目的执行而对IT组织所可能产生的影响的评估</li>\n<li>架构成熟度评估：架构治理流程/组织/角色和责任、架构技能评估、架构资源库中的情景定义的深度/广度/质量、架构资源库中的标准定义的深度/广度/质量、架构资源库中的参考模型的深度/广度/质量、针对可重用潜力的评估。</li>\n<li>业务转型准备度评估：准备度因素、对于每个准备度因素的愿景、针对当前和目标准备度的评级、与准备度相关的风险。</li>\n</ul>\n<h3> 11、变更请求</h3>\n<p>目标</p>\n<p>在架构的实现过程中，在一切清晰之前，原来的架构定义和需求很可能不适合或不足以达成解决方案的实现。在这种情况下，对实施项目进行调整使之与建议的架构方法发生偏离，或请求架构范围扩展是必需的行为。另外，很多外部因素（例如，市场因素、业务策略变化以及新技术机会）也会为扩展及优化架构提供新的机会。在以上这些环境下，一个变更请求可以被提出，用以开始一个新的架构工作周期。</p>\n<p>内容</p>\n<p>变更请求的内容通常包括：</p>\n<ul>\n<li>对于所建议的变更的描述</li>\n<li>对于所建议的变更的理由</li>\n<li>对于所建议的变更的影响评估：针对相关特定需求的引用、迄今需求所涉及的干系人的优先级、重新审视这些需求的各阶段描述、对需求优先级进行排序的阶段、调查和修正需求的优先级阶段的结果、对于需求管理的建议。</li>\n<li>资源库引用编号</li>\n</ul>\n<h3> 12、 沟通计划</h3>\n<p>目标</p>\n<p>企业架构包含大量的复杂且相互关联的信息。有效地与适当的人在适当的时间针对目标信息进行交流是成功建设企业架构的重要因素。开发沟通计划可以使这些交流通过一种可计划、可管理的方式进行。</p>\n<p>内容</p>\n<p>沟通计划的内容通常包括：</p>\n<ul>\n<li>针对干系人的识别，并根据沟通需求进行分组</li>\n<li>明确沟通需求、与架构愿景相关的关键消息、沟通风险和关键成功因素（CSFs：Critical Success Factors）</li>\n<li>明确用来与干系人进行沟通的机制，并允许其对架构信息的访问</li>\n<li>制定沟通时间表。该时间表展示了沟通将在何时何地进行，以及在何种干系人组之间进行</li>\n</ul>\n<h3> 13、 合规评估</h3>\n<p>目标</p>\n<p>一旦一个架构被定义了出来，就必须在整个实施过程中对其进行治理，从而保证原先的架构愿景可以被适当的实现，并且实现中的经验教训也可以反馈到架构过程中。针对实施项目进行周期性的合规检查为重新审核项目过程，并保证设计和实施符合企业策略和架构目标，提供了一种有益的机制。</p>\n<p>内容</p>\n<p>合规评估的内容通常包括：</p>\n<ul>\n<li>项目进程和状态的概览</li>\n<li>项目架构/设计概览</li>\n<li>完整的架构清单：硬件和操作系统清单、软件服务和中间件清单、应用清单、信息管理清单、安全清单、系统管理清单、系统工程清单、方法和工具清单。</li>\n</ul>\n<h3> 14、实施和迁移计划</h3>\n<p>目标</p>\n<p>通过过渡框架的描述为解决方案的实施提供一个日程表，包括实施的时间、成本、资源、收益和里程碑。</p>\n<p>内容</p>\n<p>实施和迁移计划的内容通常包括：</p>\n<ul>\n<li>实施和迁移战略：战略实施方向、实施排序方法</li>\n<li>与其他管理框架的交互：架构与业务规划相协调的方法、整合架构的方法、架构与项目管理相协调的方法、架构与运营管理相协调的方法。</li>\n<li>项目章程：项目所能交付的能力、所包含的工作包、业务价值、风险、问题、假设和依赖关系</li>\n<li>实施规划：由实施分解出来的各个阶段和工作流、为各阶段和工作流进行工作包分配、里程碑和时间要求、工作分解结构、资源需求和成本</li>\n</ul>\n<h3> 15、实施治理模型</h3>\n<p>目标</p>\n<p>一旦一个架构被定义，在整个实施过程中就需要对用于实现架构的过渡框架进行治理。在已经建立了架构功能的组织中可能已经存在了一个治理框架，但是对于特定的过程、组织、角色、责任和度量来说，需要根据项目进行具体的定义。</p>\n<p>内容</p>\n<p>实施治理模型的内容通常包括：</p>\n<ul>\n<li>治理流程</li>\n<li>治理组织结构</li>\n<li>治理角色和相应职责</li>\n<li>治理检查点和成功与失败标准</li>\n</ul>\n<h3> 16、 企业组织架构模型</h3>\n<p>目标</p>\n<p>为了一个架构框架能够被成功地使用，它必须在企业中获得正确的组织、角色和责任的支持。特别重要的是，对不同企业架构参与者之间边界的定义，以及针对跨边界关系的治理。</p>\n<p>内容</p>\n<p>企业组织架构模型的内容通常包括：</p>\n<ul>\n<li>受影响的组织的范围</li>\n<li>成熟度评估、差距和决议方法</li>\n<li>架构团队的角色和责任</li>\n<li>针对架构工作的约束</li>\n<li>资金预算需求</li>\n<li>治理和支持策略</li>\n</ul>\n<h3> 17、架构工作要求书</h3>\n<p>目标</p>\n<p>由赞助组织交付给架构组织的用于启动架构开发工作的文档。架构工作要求书可以产生于预备阶段，可以是经过批准的架构变化请求的结果，或者是源于迁移计划对架构工作的参考。</p>\n<p>内容</p>\n<p>架构工作要求书的内容通常包括：</p>\n<ul>\n<li>组织赞助者</li>\n<li>组织的任务说明</li>\n<li>业务目标（以及变更）</li>\n<li>业务的战略规划</li>\n<li>时间限制</li>\n<li>业务环境的变化</li>\n<li>组织方面的约束</li>\n<li>预算信息以及财务约束</li>\n<li>外部约束以及业务约束</li>\n<li>当前业务系统描述</li>\n<li>当前架构/IT系统描述</li>\n<li>开发组织的描述</li>\n<li>开发组织可用资源的描述</li>\n</ul>\n<h3> 18、需求影响评估</h3>\n<p>目标</p>\n<p>在整个架构开发方法过程中，总会有新的与架构相关的信息被收集起来。当这些信息被收集后，对架构在当前某方面有影响的新因素也经常会显现出来。需求影响评估就是用来对当前架构需求进行评估，阐明需要进行的变更以及这些变更所带来的影响。</p>\n<p>内容</p>\n<p>需求影响评估的内容通常包括：</p>\n<ul>\n<li>对于具体需求的引用</li>\n<li>迄今需求的相关干系人优先级</li>\n<li>进行重审的各个阶段</li>\n<li>进行需求优先级排序的阶段</li>\n<li>调查和修正需求的优先级阶段的结果</li>\n<li>关于需求管理的建议</li>\n<li>资源库引用编号</li>\n</ul>\n<h3> 19、解决方案构建块</h3>\n<p>与架构构建块相类似，解决方案构建块也是存储于架构资源库中的构建块的一种，不过它的内容更倾向于在实现层面对企业中的可重用构建块进行描述。可以说，架构构建块定义了构建块的需求，而解决方案构建块则是此需求在具体实现技术层面的映射。关于解决方案构建块的具体内容请参阅后面的内容。</p>\n<h3> 20、架构工作说明书</h3>\n<p>目标</p>\n<p>架构工作说明书定义了用于完成一个架构项目的方法和范围，它也是用于评测架构项目是否被成功执行的典型文档，并且它也形成了架构服务提供者和使用者之间的合同协议的基础。</p>\n<p>内容</p>\n<p>架构工作说明书的内容通常包括：</p>\n<ul>\n<li>架构工作标题说明</li>\n<li>项目申请和背景</li>\n<li>项目描述和范围</li>\n<li>架构愿景的概括</li>\n<li>管理办法</li>\n<li>范围变更程序</li>\n<li>角色、责任和交付物</li>\n<li>验收标准和程序</li>\n<li>项目计划和日程安排</li>\n<li>针对架构连续体的支持</li>\n<li>签字批准</li>\n</ul>\n<h3> 21、定制的架构框架</h3>\n<p>目标</p>\n<p>TOGAF提供了一个行业的标准架构框架，但是要在一个架构项目中对其进行有效地使用，则必须在两个层面上进行定制。首先，需要对TOGAF模型进行定制，使得它可以融入到企业之中。此种定制包括将TOGAF模型整合入企业的项目和过程管理框架、术语定制、展示方式开发、架构工具的选择、配置和部署等方面之中。任何被采用的框架的形式和详细程度应该与企业的其他背景元素相适应，例如文化、干系人、企业架构的商业模型以及当前架构能力的水平。一旦针对框架完成了上面的定制，企业就需要为具体的架构项目做进一步的框架定制，而在这一层面的定制中，企业需要选择适当的架构交付物和架构制品来满足项目和干系人的需要。</p>\n<p>内容</p>\n<p>定制的架构框架的内容通常包括：</p>\n<ul>\n<li>定制架构的方法</li>\n<li>定制架构的内容（架构交付物和架构制品）</li>\n<li>配置和部署工具</li>\n<li>治理模型和其他框架的接口：企业架构管理框架、能力管理框架、项目组合管理框架、项目管理框架、运营管理框架。</li>\n</ul>\n<h3> 22、过渡架构</h3>\n<p>目标</p>\n<p>过渡架构展示了企业的增量状态，并反映从当前架构到目标架构的过渡过程。过渡架构被用来将单独的工作包和项目组合为可管理的项目组合和程序，用于描述每个阶段的业务价值。</p>\n<p>内容</p>\n<p>过渡架构的内容通常包括：</p>\n<ul>\n<li>机会组合描述：综合的差距、解决方案和依赖关系评估、机会描述、收益评估、能力和能力增量、互操作性和共存的需求</li>\n<li>工作包组合描述：工作包描述（名称、描述、目标和交付物）、功能性需求、依赖关系、与机会之间的关系、与架构定义文档和架构需求说明之间的关系。</li>\n<li>里程碑和里程碑过渡架构：过渡状态描述、每个过渡状态的业务架构、每个过渡状态的数据架构、每个过渡状态的应用架构、每个过渡状态的技术架构。</li>\n<li>实施因素评估和推导矩阵（ImplementationFactor Assessment and Deduction Matrix：用于记录将会影响架构实施和迁移计划的各个因素。此矩阵包括在制定迁移计划时需要考虑的各个因素、它们的描述，以及由此而推断出的在制定计划时需要考虑的行动或约束）：风险、问题、假设、依赖、行动。</li>\n<li>综合差距、解决方案和依赖矩阵（Consolidated Gaps，Solutions，and Dependencies matrix：此矩阵使架构师可以对在各领域架构差距分析结果中明确的差距进行分组，并评估潜在的解决方案，以及这些方案与差距之间的依赖关系）：架构领域、差距、潜在解决方案、依赖关系。</li>\n</ul>\n<h2> 四、架构制品（Architectural Artifacts）</h2>\n<p>架构制品是针对某个系统或解决方案的模型描述，与架构交付物和构建块相比，架构制品既不是架构开发方法过程各阶段的合约性产物，亦不是企业中客观存在的各种可重用解决方案，而是针对包括这些构建块在内的企业客观现实的描述，并以解答不同干系人的关注点为其最终目标。可以说，架构交付物面向于企业架构的产生，架构构建块倾向于企业架构的结果，而架构制品则注重于针对企业架构的应用（虽然架构交付物可以包含若干架构制品，但是架构制品在本质上还是被用来为不同的干系人按照其视角提供相应的企业客观视图，况且架构交付物对架构制品的包含本身也是架构制品的应用之一，其目的也是为了在架构开发过程中所涉及的不同干系人之间达成共识）。</p>\n<p>企业架构并不是一个静态的过程，不能将建设一个包含企业架构内容的信息资源库当作唯一目标。对于任何企业来说，企业架构的意义都应该在于将其自身的战略决策、业务和信息技术资源联系为一个有机整体，并且不同的干系人从企业架构中获得其所需的关于企业的自上而下（自业务至用于支持各项业务实现的解决方案）的视图，而这方面的内容属于针对企业架构内容的使用范畴。在这一范畴之中，所有的企业架构框架理论，哪怕是几乎不涉及企业架构内容的框架，都会关注于两个概念：视角与视图。其中视角是针对不同干系人企业架构内容的需求描述，而视图是基于某一视角的具体架构内容描述，因而也可以说视角是视图的元类型定义。在这两个概念中，视图比较好理解，亦即根据视角的定义而对企业客观现状的某一侧面描述，相比之下，用于对视图进行定义的视角概念则更为关键。视角是不同干系人对于企业架构内容需求的体现，亦即其采用何种角度对企业客观存在或计划存在的自顶层战略、业务至底层解决方案而进行观察。这些角度的定义基本上应该包括如下几个方面：</p>\n<p>1、目标需求：不同的干系人担当着不同的角色及责任，其看问题的角度与担当的任务也因此有着非常紧密的联系。一般来讲，目标需求大体可以分为：</p>\n<ul>\n<li>设计层面：包括了用于指导和支持与设计决策相关的各种制品。例如架构师、开发人员以及业务流程建模人员等干系人经常会用到的UML图、流程建模图（例如BPMN图）、以及用于描述数据的关系-实体图等制品都属于这一范畴。</li>\n<li>决策层面：包括了用于支持高层决策的制品（例如，交叉引用表、情景图、以及各种报告等制品），适用于企业中处于管理高层的各种决策人，例如CEO、CIO等。</li>\n<li>告知层面：包括了用于为相关干系人进行解释、说服以及获得其承诺方面的制品（流程概述、图表、宣讲动画等）。这些干系人可能会是一般职工、客户，或者其他在企业中从业务到解决方案这条线上虽不占关键位置却需要对企业架构进行了解的干系人。<br>\n2、抽象级别需求：上面描述了不同干系人由于其担负任务的不同，因而对于企业的观察也具有着不同的角度，从而对不同的制品产生兴趣。然而，即使不同的干系人针对企业的相同侧面有着共同的兴趣，但是他们对于描述的抽象级别或详细程度也可能有着不同的要求。例如，对于相同的业务流程来说，可能对于高层管理人员来说需要关注的仅是此流程的输入、输出，而对于其实现细节并不一定关心，而对于流程建模人员来说此业务流程恐怕就需要被细化为粒度更加细小的业务功能组合，而对于软件开发人员来讲，可能还要为某个具体业务行为而考虑其相关的数据结构和实现方案。</li>\n</ul>\n<p>3、展示需求：上述两点可以说是依据干系人所持的角度在内容方面所进行的分类，而除此之外，由于不同的干系人由于各自的偏好不同，他们可能会对视图的展示也有着非常不同的要求。虽然在TOGAF中，架构制品的描述方式被定义为目录、矩阵和图形三种方式，但就其具体展示方式来说，不同的干系人还可能具有不同的要求和偏好。例如，对于组织结构的展示，有的干系人可能偏好于采用简单的树形结构的展示，而其他干系人则可能更加倾向于图形化的结构图。这种展示需求在图形展示方面尤其突出，某些干系人（特别是来自于内部的干系人，例如领域专家等）可能习惯于采用某种标准的标注体系来对架构内容进行展示，而对于其他干系人来讲（例如客户或非专业的干系人）采用如此方式可能并不能取得很好的效果，而采用更加贴近现实的图标来代替标准图标（通常是若干简单的形状、连线和颜色的组合）则更加友好。虽然展示需求也是视角定义所需靠虑的元素之一，但是在大多数情况下这一层面的定义往往可以采用松耦合的方式来进行描述，即将视角的定义分为内容和展示两个层面，并在两者之间建立关联（通常一个内容定义可以包含若干展示定义）。</p>\n<p>上述关于视角分类的定义很容易让人产生非此即彼的感觉，即视角是为干系人服务的，因而应该仅从属于某种干系人。这样的思想除了源于思想的惯性，最主要的还是由于忽视了企业架构的核心精神—在组织中创建无障碍的沟通信息流。作为企业架构的核心概念，如果只把视角看作为企业架构描述用的约束和定义，而忽视了沟通这一本质则是违反企业架构最终目标的。每种干系人对于视角的采用都要着自己的要求，但反过来讲，视角却不一定从属于某种干系人，不同的干系人之间可以共享同样的视角，也只有这样才能保证不同干系人之间的顺畅沟通。正像TOGAF中所举的例子一样，飞机的飞行员和航空管制员对于飞行的视角各具特点，并采用不同的语言和元素来对“飞行”进行描述，但是他们同时也采用一种通用的语言（高度、速度等）来进行沟通。在这个例子中，飞行员和航空管制员在自己的领域内分别采用了自己的视角来对“飞行”进行理解和描述，不过作为沟通用的通用语言却形成了第三个，并且是他们所共享的视角。</p>\n<p>企业架构开发过程的结果可以说是在架构资源库中按照架构元模型定义而填充的各种实体元素，这也方便了在对企业架构的使用中按照各个干系人的视角为其提供相应的视图。针对架构的使用需要自动化工具的支持，该工具需要支持视角的定义和管理，并能够从企业架构资源库中根据选定的视角生成相应的视图。</p>\n<figure><figcaption>img_29.png</figcaption></figure>\n<p>不同的企业架构开发框架对于架构制品、视角和视图的定义，有着不同的描述。例如在Zachman框架中，每一个单元格所代表的是某一种干系人视角针对系统某个方面的描述，而在TOGAF中，The Open Group则采用了一种独特的方式对视角进行了组织和定义。与其他框架理论不同，TOGAF定义了一系列原子架构制品，并倡议在企业架构过程中根据不同干系人的需要对这些原子架构制品进行组合，从而生成对于视角的定义。这些原子架构制品业可被看为原子级的视角定义，实际上在TOGAF中也正是用视角（ViewPoint）这个词来称呼各个架构开发阶段相关的原子架构制品。TOGAF并不强制其用户遵循这些原子架构制品，用户可以根据自己的需要增加新的原子架构制品，或对已经定义的原子架构制品进行修订。根据架构制品的描述形式，TOGAF将这些原子架构制品分为以下三类：</p>\n<ul>\n<li>目录（Catalogs）：此类型的原子架构制品（视角）以列表的形式对各种构建块进行列举。</li>\n<li>矩阵（Matrices）：此类型的原子架构制品（视角）用于展示特定构建块之间的关系。</li>\n<li>图形（Diagrams）：此类型的原子架构制品（视角）采用了一种具有丰富表现力的方式对构建块以及他们之间的关系进行了展示。此种方式特别适合用于在干系人之间进行沟通的场合。</li>\n</ul>\n<h3> 1、架构开发过程与架构制品</h3>\n<p>表面上架构制品并不像架构交付物那样与架构开发方法的各个阶段有着很强的契约性关联，但是做为架构交付物的重要组成部分，架构制品与架构开发方法之间也有着非常紧密的联系。在TOGAF中，针对架构制品的组织和描述也是以架构开发方法各阶段为基础的，它详尽展示了在每个架构开发方法阶段中所产生的各个原子架构制品，以及这些架构制品与架构内容元模型各扩展之间的关系。</p>\n<figure><figcaption>img_30.png</figcaption></figure>\n<h3> 2、架构制品定义</h3>\n<p>原则目录（Principles catalog）</p>\n<p>原则目录对各项业务原则及架构原则进行列举，用以表明一个好的解决方案或架构看起来应该是什么样子。原则用于对各架构决策点的输出进行评估和认可。原则也可在针对变更举措的架构治理中充当辅助工具。</p>\n<p>干系人映射矩阵（Stakeholder Map Matrix）</p>\n<p>干系人映射矩阵用于明确参与架构活动的各个干系人、他们的影响、他们的主要问题，以及架构框架所必须解答的关注点。通过对于干系人的识别，并对他们的需求进行理解，架构师可以将注意力集中在能够满足干系人需求的各个领域之中。</p>\n<p>价值链图（Value Chain Diagram）</p>\n<p>价值链表提供了一张面向高层的企业视图，用于表示企业如何与外界环境交互。与在业务架构阶段中开发出来的更加正式的功能解构图相比较，价值链表更着重于表象上的影响。价值链表的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使得所有参与者能够对架构所涉及到的高层次功能性和组织性环境进行理解。</p>\n<p>解决方案概念图（Solution Concept Diagram）</p>\n<p>解决方案概念图提供了一个解决方案的高层次方向，用于达成架构所涉及的各个目标。与后续架构开发方法阶段开发出来的、更正式且更详细的架构图相比较，解决方案概念图更像是在一开始阶段关于期望解决方案的一张草图。这张图体现了关键的目标、需求和约束，并对将采用正式架构模型来进行更详细描述的各个工作区域进行了标明。解决方案概念图的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使所有的参与者能够理解架构所需要的究竟是什么，以及一个特定的解决方案被期望以何种方式来满足企业的需求。</p>\n<p>组织/执行者目录（Organization/Actor Catalog）</p>\n<p>该目录的目标是得到一份明确的包括用户和IT系统所有者在内的所有与IT有互动的参与者列表。该列表可以在开发需求时作为完备性检测的参考。例如，针对于一个对客户进行服务支持的应用的需求，我们可以通过如下几个方面对其进行完备性检测：</p>\n<ul>\n<li>\n<p>需要对何种类型的客户进行支持。</p>\n</li>\n<li>\n<p>是否某种类型的用户存在特定需求或约束。</p>\n</li>\n<li>\n<p>此目录所涉及到的内容元模型实体包括：</p>\n</li>\n<li>\n<p>组织单位</p>\n</li>\n<li>\n<p>执行者</p>\n</li>\n<li>\n<p>位置（如果一个单独的位置目录并不存在，则关于位置的信息就需要在这个目录中加以维护）</p>\n</li>\n</ul>\n<p>驱动力/目标/阶段目标目录（Driver/Goal/Objective Catalog）</p>\n<p>该目录的目标是描述组织如何通过目标、工作目标和评测（可选内容）来满足其驱动力的需要，并为此提供一份跨越组织的参考。通过针对驱动力、目标和阶段目标的层层分解，各个变更举措可以采用一种跨越组织边界的方式进行协同，并在随后的活动中使得各个干系人得以被明确，此外，相关的变更举措也能够被整合或协调起来。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织单元</li>\n<li>驱动力</li>\n<li>目标</li>\n<li>阶段目标</li>\n<li>评测（可选内容）</li>\n</ul>\n<p>角色目录（Role Catalog）</p>\n<p>角色目录的目标是为企业中所有的授权级别或区域提供一份列表。一般情况下，应用的安全或行为应该按照其对授权概念的理解而分别进行定义，但在与用户的计算机相绑定时却造成了复杂且不被期望的后果。如果角色在整个组织和所有应用中都得到了定义、理解和共识，那么更加安全并能够提供更加无缝的用户体验的应用将会出现，因为管理员无需通过迂回的解决方法来使用户执行他们的工作。除了对企业的安全定义进行支持，角色目录还可以是明确组织变更管理影响、定义工作职能，以及执行最终用户培训这些方面的关键输入。</p>\n<p>由于每个角色都暗含着关于一系列业务功能的访问，如果这些功能被影响到，那么变更管理将必不可少，组织的职责也需要被重新定义，同时新的培训可能也是需要的。</p>\n<p>业务服务/功能目录（Business Service/Function Catalog）</p>\n<p>业务服务功能目录的目标是提供一份功能性的解构，使得各种功能可以被过滤、汇报和查询，并能够作为功能结构图的一个有力补充。服务功能目录可以被用来对组织中的各项能力进行明确，并对组织中施加到各种功能上的治理水平加以理解。通过功能解构，用于支持业务变化所需要的各种新能力能够被识别出来，或者对变更措施、应用以及技术组件的范围进行确定。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织单位</li>\n<li>业务功能</li>\n<li>业务服务</li>\n<li>信息系统服务（可选内容）</li>\n</ul>\n<p>位置目录（Location Catalog）</p>\n<p>位置目录为企业的业务运营或房屋建筑相关的资产（例如数据中心或终端用户计算设备）所处位置提供了一份列表。针对此位置列表的维护，各个变更举措的位置范围得以被快速地定义出来，并且针对当前情况和建议的目标解决方案进行评估时，完备性测试也得以被执行。例如，一个用于更新台式计算机操作系统的项目需要识别出这些系统所部署的位置。与此相似，当实施一个新的系统时，一张关于位置的图形描述对于开发适当的部署策略是非常关键的，该部署策略被用于对用户和应用的位置进行了解，并且各个与位置相关的问题（例如，国际化、本地化、针对可用性的时区影响、延时距离影响、网络带宽影响和访问）也得以被明确。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>位置</li>\n</ul>\n<p>流程/事件/控制/产品目录（Process/Event/Control/Product Catalog）</p>\n<p>流程/事件/控制/产品目录为流程、触发流程的事件、流程的输出和施加到流程执行之上的控制提供了一份层次结构，并可被用来作为流程图（Process Flow diagram）的一个有力的补充，这些流程图使得企业可以进行跨越组织和流程的过滤、汇报和查询操作，从而对其范围、通用性或影响进行明确。例如，流程/事件/控制/产品目录使得企业可以查看流程与各子流程之间的关系，从而明确源自于一个高层流程的变更所能带来的影响链。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>流程</li>\n<li>事件</li>\n<li>控制</li>\n<li>产品</li>\n</ul>\n<p>合同/评测目录（Contract/Measure Catalog）</p>\n<p>此目录提供了一份关于所有经过批准的服务合同以及与此相关的评测的列表，从而形成了在整个企业内获得批准的服务水平的主列表。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>业务服务</li>\n<li>信息系统服务（可选内容）</li>\n<li>合同</li>\n<li>评测</li>\n</ul>\n<p>业务交互矩阵（Business Interaction Matrix）</p>\n<p>此矩阵用于描述企业中各组织与业务功能之间的交互关系。理解企业中的业务交互是很重要的，因为它有助于突出整个组织中的价值链以及相互依赖关系。此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织</li>\n<li>业务功能</li>\n<li>业务服务</li>\n<li>业务服务之间的通信关系</li>\n<li>业务服务之间的依赖关系</li>\n</ul>\n<p>执行者/角色矩阵（Actor/Role Matrix）</p>\n<p>此矩阵用于展示哪些执行者扮演何种角色，并支持对安全性和技能需求的定义。理解执行者与角色之间的关系对定义培训需求、用户安全设置和组织变更管理具有关键性作用。此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>执行者</li>\n<li>角色</li>\n<li>执行者与角色之间的担当关系</li>\n</ul>\n<p>务足迹图（Business Footprint Diagram）</p>\n<p>业务足迹图描述了业务目标、组织单元、业务功能和服务之间的关联，并将这些功能映射到各个提供了所需能力的技术组件之上。它在从技术组件到业务目标的映射中提供了清晰的可追溯性，同时还对已经明确的服务的所有权进行了阐述。业务功能图仅对联系组织单元功能与交付服务的关键因素进行描述，并且还可被用来作为与高层次干系人（CIO、CEO等）进行沟通的平台。</p>\n<p>业务服务/信息图（Business Service/Information Diagram）</p>\n<p>业务服务/信息图展示了用于对一个或多个业务服务进行支持的信息，包括了由业务服务使用或者产生的数据及其信息源。服务/信息图对信息在架构中的最初表现形式进行了展现，因此为数据架构阶段的进一步描述打下了基础。</p>\n<p>功能分解图（Functional Decomposition Diagram）</p>\n<p>功能分解图的目标是将组织中与架构相关的各项能力展现在一张图纸之上。通过从功能的视角检视组织的各项能力，企业可以快速针对组织所做的事情进行建模，而不用陷入针对组织如何做所进行的额外讨论之中。</p>\n<p>产品生命周期图（Product Lifecycle Diagram）</p>\n<p>产品生命周期图的目标是对企业中关键实体的理解进行辅助。就关于产品从生产到撤销过程中所必须遵守的环境的关注、立法和规章来说，理解产品生命周期变得越来越重要。与此相同，在为了保证在控制、流程和程序的设计严谨而进行的业务架构开发过程中，创建涉及个人或敏感信息产品的组织必须对产品生命周期具有一个详尽的理解，例如信用卡、借记卡、智能卡以及用户身份认证等信息。</p>\n<p>目标/阶段目标/服务图（Goal/Objective/Ser viceDiagram）</p>\n<p>此图的目标是为服务对业务愿景或策略的达成而定义方法。通过将服务与驱动力、目标、阶段目标和相关的评测进行关联，企业可以了解到哪些服务贡献于相似的业务效能方面。此外，该图还为针对某一特定服务所形成的高效能的认定提供了定性的输入。</p>\n<p>业务用例图（Business Use-Case Diagram）</p>\n<p>业务用例图展示了业务服务的提供者和使用者之间的关系。业务服务被各个执行者或其他的业务服务所使用，而业务用例图则通过针对业务能力在何时以及如何被使用的描述，为业务能力的描述方面提供了额外的价值。此图形的目标是对各执行者和他们在各流程和功能中所担当的角色之间的交互关系进行描述和验证。随着架构过程的演进，这些用例图也将从业务级别发展至包括数据、应用和技术在内的更加详尽的级别。除此之外，业务用例图也可在系统设计工作中得到复用。</p>\n<p>组织分解图（Organization Decomposition Diagram）</p>\n<p>组织分解图描述了执行者、角色以及他们在组织树中所处位置之间的关系。一份组织分解图应提供了一条组织中决策者和业务拥有者的命令链。虽然组织分解图并不打算将组织与其目标联系在一起，但是在这张图中为最终目标与干系人之间建立直观的联系也是可以的。</p>\n<p>流程图（Process Flow Diagram）</p>\n<p>流程图的目标是对流程元模型实体相关的所有模型和映射进行描述，它展示了位于各个活动之间的顺序化控制流，并可借助于泳道技术来表达各个流程步骤的归属和实现。例如，用于支持一个流程步骤的应用就可以作为一条泳道来展示。除此之外，流程图也可以被用来细化赋予在流程之上的控制、触发某流程或产生于流程结束时的事件，以及由于流程执行所产生的各种输出产物。流程图在为主题专家描述架构时非常有用，它可以为这些专家描述一个特定功能的工作是如何被完成的。通过这样一个过程，每个流程步骤可以被细化为更小粒度的功能块，而且这些功能块在以后亦可以被当作一个流程来进行进一步的阐述。</p>\n<p>事件图（Event Diagram）</p>\n<p>事件图的目标是描述事件与流程之间的关系。诸如某些特定信息的到来，或者是某个特定的时间点这样的特定事件会致使业务中特定的工作和行为得以进行，同时也经常会有被称为业务事件（或简称事件）的信息被当作某个流程的触发者。</p>\n<p>数据实体/数据组件目录（Data Entity/Data Component Catalog）</p>\n<p>数据实体/数据组件目录的目标是明确和维护企业中使用的所有数据的列表，包括数据实体，以及用于存储数据实体的数据组件。一个经过批准的数据实体/数据组件目录支持对信息管理和数据治理策略的定义和应用，并且鼓励对数据进行有效地共享和重用。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>数据实体</li>\n<li>逻辑数据组件</li>\n<li>物理数据组件</li>\n</ul>\n<p>数据实体/业务功能矩阵（Data Entity/Business Function Matrix）</p>\n<p>此矩阵用来描述企业中数据实体和业务功能之间的关系。业务功能被具有明显边界的业务服务所支持，并通过业务流程加以实现。通过数据实体与业务功能之间的映射，企业可以得到：</p>\n<ul>\n<li>将数据实体的所有权分配给各个组织。</li>\n<li>理解业务服务的数据和信息交换需求。</li>\n<li>支持差距分析，并决定是否有需要被创建的数据实体被遗漏。</li>\n<li>为数据实体定义源系统、记录系统和引用系统。</li>\n<li>启动企业的数据治理程序的开发（建立数据管家、开发与业务功能相关的数据标准等）。</li>\n</ul>\n<p>此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>数据实体</li>\n<li>业务功能</li>\n<li>数据实体与其所属组织单位的“从属”关系</li>\n</ul>\n<p>系统/数据矩阵（System/Data Matrix）</p>\n<p>此矩阵用于描述系统与系统所访问和更新的数据实体之间的关系（一张两维表，其中一个纬度对应逻辑应用组件，而另外一个则对应数据实体）。系统用于创建、读取、更新和删除与他们相关联的特定数据实体。例如，一个客户关系系统将创建、读取、更新和删除客户实体信息。处在一个被封包好的服务环境中的数据实体可以被分为主数据、引用数据、事务数据、内容数据和历史数据，而用于操作这些数据实体的应用则包括事务应用、信息管理应用和业务仓库应用。针对应用组件和数据实体之间映射是一个非常重要的步骤，因为它可以使得：</p>\n<ul>\n<li>针对数据的访问能力被分配给组织中的具体应用。</li>\n<li>了解在不同应用中数据重复的程度，以及数据生命周期的规模。</li>\n<li>了解在何处相同的数据会被不同的应用所更新。</li>\n<li>支持差距分析，并确定是否本应存在的应用被遗漏了。</li>\n</ul>\n<p>类图（Class Diagram）</p>\n<p>类图的主要目标是描述企业中重要数据实体（或类）之间的关系。此图用于清晰地展示数据之间的关系，并帮助干系人理解企业下层数据模型。</p>\n<p>数据传播图（Data Dissemination Diagram）</p>\n<p>数据传播图的目标是展示数据实体、业务服务和应用组件之间关系。此图展示了各个逻辑实体如何被应用组件所实现。它使得针对数据大小的调整得以被有效地执行，同时IT足迹也会得以改善。而且，通过为数据设置业务价值，应用组件的业务重要性的指标也能够在同时被获得。另外，此图还可以展示针对数据复制和主引用的所有权，即它可以展示数据的两个备份以及数据之间的主-备份关系。此图还能够包含服务，比如，封装数据并且驻留在应用之内的服务，或者驻留在应用之上并能够访问封装在应用中的数据的服务。</p>\n<p>上面所说的IT footprint中，footprint，即足迹，的本意是由动物遗留下的包含了遗留者本身标识和信息的事物。在信息技术领域，根据哈佛商学院Andrew McAfee所述，技术足迹表示了其在地理、逻辑分区和/或功能方面所能延展到范围，是针对一个信息技术所期望的覆盖范围的描述（A technology's footprint is its geographic, divisional, and/or functional reach. It's a description of how much territory a piece of IT is intended to cover）。在TOGAF中并没有说明数据大小的调整与IT足迹改善之间的关系，也没有说明所谓的IT足迹改善的具体含义。不过通过互联网上的一个关于IT足迹改善的实例，即将原本有着十几台计算机的教室用一台中心计算机和若干终端来代替，笔者有感而发，粗浅的认为这里IT足迹改善意思是说由于数据尺寸得到了很好的调整，那么不必需的冗余信息被削减，因而数据和应用的“足迹”，即其涉及到的范围，将比冗余剔除前更加清晰有效</p>\n<p>数据安全图（Data Security Diagram）</p>\n<p>数据可以看作是企业的一项资产，简单的讲，数据安全可被认为是确保企业数据不被损害，并且针对数据的访问也要在适当的控制之下。数据安全图的目标是描述何执行者可以访问企业中的哪些数据。此外，此图也可以被用来阐述与数据隐私法规以及其他应用性法规的符合度。此图还需要考虑发生在企业合作伙伴或其他团体对企业系统进行访问之处的信任含义，例如在外包的情形下，信息可能会被企业之外的其他人员（甚至身处国门之外）所管理。</p>\n<p>类层次结构图（Class HierarchyDiagram）</p>\n<p>类层次结构图的目标是为技术方面的干系人展示一个有关类层次的视图。此图的优点是干系人可以得到一份关于数据实体在技术层面上如何被使用的图形描述，它使得干系人可以了解何人正在针对数据进行使用，以及他是在何时、如何以及为何进行这项活动。</p>\n<p>数据迁移图（Data Migration Diagram）</p>\n<p>在实现一个以封包服务为基础的解决方案时，数据迁移是非常重要的，特别是将现存的遗留系统替换为一个服务封包时，或者当企业将要迁移到一个更大的封包服务时。每个服务包都倾向于具有属于他们自己的数据模型，并且在数据迁移过程中，遗留的应用数据可能需要在载入到服务封包之前需要进行某种转化。数据迁移活动通常包含如下的步骤：</p>\n<ul>\n<li>从原有应用中抽取出数据。</li>\n<li>配置源数据</li>\n<li>执行数据转换，其中包括数据质量相关的各个过程：\n<ul>\n<li>对数据进行标准化、归一化，并消除数据的重复性（数据清洗）。</li>\n<li>针对不同来源的数据进行比对、合并和整合。</li>\n<li>进行自源头至目标的映射</li>\n</ul>\n</li>\n<li>将数据加载到目标应用之中。</li>\n</ul>\n<p>数据迁移图的目标是展示数据如何从源头应用流入到目标应用之中。此图为数据从源头到目标过程的进行提供了一个可视化表达，并可在数据审计和追溯中作为辅助工具。此外，此图所展示的细节程度可以按照需要进行调整。例如，数据迁移图可以仅仅包含一个关于迁移情况的整体布置，也可以为单独的应用提供元数据元素级别的详细信息。</p>\n<p>数据生命周期图（Data Lifecycle Diagram）</p>\n<p>数据生命周期图是在业务流程的约束之下对业务数据在其整个生命周期（从概念阶段到最终退出）中对其进行管理的核心部分。数据从本质上讲是一个实体，并独立于业务流程和活动。数据状态的每个变化都被表现在这张图中，这也可以包括引起此状态变化事件或规则。数据与流程的分离使得通用数据需求可以被识别出来，从而使得资源共享得以有效达成。</p>\n<p>应用组合目录（Application Por tfolio Catalog）</p>\n<p>此目录的目标是明确和维护企业中所有应用的列表。一个经过批准的应用组合目录使得一系列应用得以被定义和治理。此目录为后面的矩阵和图形提供了基础，是应用架构开发阶段的起点。现有的应用注册表和资源库（比如SAP的解决方案管理和系统情况目录产品）也从基线和目标两个角度为这个目录的制定提供了输入。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>信息系统服务</li>\n<li>逻辑应用组件</li>\n<li>物理应用组件</li>\n</ul>\n<p>接口目录（Interface Catalog）</p>\n<p>接口目录用来界定应用之间接口的范围，并对这些接口进行文档化记录，从而使得应用间的所有依赖关系得以被尽可地界定。系统可以用来创建、读取、更新和删除其他系统内的数据。无论是通过循环载入的批处理文件、对其他系统数据库的直接连接，还是通过某种形式的应用程序接口或Web服务，这些行为都是通过接口来实现。针对应用组件之间关系的映射是一个非常重要的步骤，它使得如下情形得以实现：</p>\n<ul>\n<li>了解应用间交互程度的，从而可以站在应用与其他系统之间依赖性的角度识别出各个关键的交互。</li>\n<li>了解应用之间接口的数量和类型。</li>\n<li>了解应用之间接口的重复程度。</li>\n<li>在考虑目标应用组合时明确各接口的简化潜力。</li>\n<li>支持差距分析，并确定是存在本应建立的应用被遗漏了。</li>\n</ul>\n<p>此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>逻辑应用组件</li>\n<li>物理应用组件</li>\n<li>应用之间的通信关系</li>\n</ul>\n<p>系统/组织矩阵（System/Organization Matrix）</p>\n<p>此矩阵用于描述企业中系统与组织单元之间的关系。业务功能由组织单元来执行，而一些由组织单元执行的功能和服务也将会被IT系统所支持。应用组件与组织单元之间的映射非常重要，它会使得：</p>\n<ul>\n<li>为执行业务功能的组织单元分配针对应用的使用。</li>\n<li>理解由组织单元所执行的业务服务和流程对应用支持需求。</li>\n<li>支持差距分析，并确定是否有需要被建立的应用被遗漏。</li>\n<li>定义特定组织单元所使用的应用集合</li>\n</ul>\n<p>。<br>\n此矩阵是一张两维表，其中逻辑/物理应用组件在一条坐标轴上，而组织单元在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n<ul>\n<li>组织单位与服务之间的从属关系。</li>\n<li>执行者与组织单位之间的从属关系，以及其与服务之间的使用关系。</li>\n<li>服务与逻辑/物理应用组件之间的实现关系。</li>\n</ul>\n<p>角色/系统矩阵（Role/System Matrix）</p>\n<p>此矩阵用来描述企业中系统与业务角色之间的关系。一个组织中的人们会与各种系统发生交互。在交互过程中，这些用户被假定成为执行一项任务的特定角色，例如，产品购买者。应用组件与角色之间的关系映射非常重要，它使得：</p>\n<ul>\n<li>\n<p>在组织内为特定的角色分配针对应用的使用。</p>\n</li>\n<li>\n<p>理解支持功能的业务服务和流程的应用安全需求，并检查是否与现有策略相符合。</p>\n</li>\n<li>\n<p>支持差距分析，并确定是否有应该被创建的应用被遗漏。</p>\n</li>\n<li>\n<p>定义被特定业务角色所使用的应用集合。<br>\n此矩阵是一个两维表，其中逻辑应用组件在一条坐标轴上，而角色在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n</li>\n<li>\n<p>角色与功能之间的访问关系。</p>\n</li>\n<li>\n<p>功能与服务之间的绑定关系。</p>\n</li>\n<li>\n<p>服务与逻辑/物理应用组件的实现关系。</p>\n</li>\n</ul>\n<p>系统/功能矩阵（System/Function Matrix）</p>\n<p>此矩阵用于阐述企业中系统与业务功能之间的关系。业务功能由组织单元所执行。一些业务功能和服务将会被IT系统所支持。应用组件与功能之间的关系映射是非常重要的，它使得如下方面成为可能：</p>\n<ul>\n<li>\n<p>为业务功能分配针对应用的使用</p>\n</li>\n<li>\n<p>理解业务服务和流程的应用支持需求</p>\n</li>\n<li>\n<p>支持差距分析，并确定是否有需要被创建的应用被遗漏</p>\n</li>\n<li>\n<p>定义被特定业务功能所使用的应用集合<br>\n此矩阵是一张两维表，其中逻辑应用组件位于一条坐标轴上，而功能处在另一条坐标轴之上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n</li>\n<li>\n<p>功能与服务之间的绑定关系。</p>\n</li>\n<li>\n<p>服务与逻辑/物理应用组件的实现关系。</p>\n</li>\n</ul>\n<p>应用交互矩阵（Application Interaction Matrix）</p>\n<p>应用交互矩阵的目标是阐述系统之间的沟通关系。在矩阵中展示的应用交互映射与接口目录或者应用通信图示相类似的，只不过以矩阵的形式来展示。此矩阵是一张两维表，其中的每一个维度都包含了应用服务、逻辑应用组件和物理应用组件这些概念。在此矩阵中所描述的关系包括：</p>\n<ul>\n<li>应用服务之间的使用关系。</li>\n<li>逻辑应用组件之间的通信关系。</li>\n<li>物理应用组件的通信关系。</li>\n</ul>\n<p>应用通信图（Application Communication Diagram）</p>\n<p>此图的目标是描述所有与应用之间的沟通相关的模型和映射。应用通信图展示了应用的应用组件和接口，并且接口可以关联数据实体，而应用则可以关联业务服务。此图所表述的“通信”应该是符合逻辑的，并且仅用来展示与架构相关的中介技术。</p>\n<p>应用和用户位置图（Application and User Location Diagram）</p>\n<p>应用和用户位置图展示了应用的地理分布情况。它可以被用来展示：</p>\n<ul>\n<li>被最终用户所使用的各个应用的地点分布</li>\n<li>被执行和/或交付（在客户端情形下）的各个主机应用程序的地点分布情况</li>\n<li>被开发、测试和发布的应用所处位置的分布情况</li>\n</ul>\n<p>此图的目标在于清晰地描述与应用发生交互的业务用户所处的业务位置，而且还包括了应用基础设施的位置。通过此图，我们可以：</p>\n<ul>\n<li>\n<p>识别出足以支持分散在各地的用户群的产品包的数量</p>\n</li>\n<li>\n<p>估算产品或软件的用户许可的类型和数量</p>\n</li>\n<li>\n<p>估算用户的支持等级和支持中心的位置</p>\n</li>\n<li>\n<p>选择系统管理工具、结构，以及用于支持本地或远程的企业用户/客户/合作伙伴的管理系统</p>\n</li>\n<li>\n<p>适当规划业务的技术组件，即服务规模、网络带宽等</p>\n</li>\n<li>\n<p>在实施应用和技术架构解决方案时进行性能方面的考虑<br>\n用户通常会采用多种方式与应用进行交互，例如：</p>\n</li>\n<li>\n<p>支持日常业务的运营。</p>\n</li>\n<li>\n<p>参与业务流程的执行过程。</p>\n</li>\n<li>\n<p>访问信息（查询、读取等）。</p>\n</li>\n<li>\n<p>开发应用。</p>\n</li>\n<li>\n<p>管理、维护应用。</p>\n</li>\n</ul>\n<p>系统用例图（System Use-Case Diagram）</p>\n<p>系统用例图展示了客户与应用服务提供者之间的关系。应用服务被角色或其他应用服务所使用，并且通过描述功能是在何时被如何使用，应用用例图对应用功能的描述提供了更多意义。此图的目标是帮助描述和验证各个参与者与他们对应用所担当的角色之间的交互。随着架构的进展，这些用例能够从功能性信息演进到包含技术实现细节。架构系统用例还可以在更细节的系统设计工作中被复用。</p>\n<p>企业管理能力图（Enterprise Manageability Diagram）</p>\n<p>企业管理能力图展示了一个或多个应用是如何与用以支持一个解决方案的运营管理的应用和技术组件进行交互的。此图实际上是针对应用通信图的一个过滤，特别是针对企业管理类软件方面。基于此图的分析可以揭示组织的IT服务管理操作方面重复、差距和机遇。</p>\n<p>流程/系统实现图（Process/System Realization Diagram）</p>\n<p>流程/系统实现图的目标是清晰地阐述在业务流程执行过程中涉及到多个应用时所产生的事件的顺序。此图可以识别出能够被简化的复杂顺序，以及架构中各种可能的合理化点，从而为业务用户提供更加及时的信息。此外，此图还可被用来明确流程中能够通过减少应用之间的交互流量而进行效率改善的地方。</p>\n<p>软件工程图（Software Engineering Diagram）</p>\n<p>系统工程图从开发的角度将应用分解为包、模块、服务和操作，它使得在各规划迁移阶段和分析机会与解决方案时进行更加详细的影响分析成为可能。在管理复杂开发环境时，系统工程图对应用开发团队和应用管理团队是非常有用的。</p>\n<p>应用迁移图（Application Migration Diagram）</p>\n<p>应用迁移图表明了应用从基线到目标应用组件的迁移过程，它通过精确地展示哪些应用和接口在迁移各阶段中需要被映射，使得针对迁移成本的估算更加准确。应用迁移图确定了临时的应用、集结区域以及用于支持迁移的各项基础设施。</p>\n<p>软件分布图（Software Distribution Diagram）</p>\n<p>软件分布图展示了应用软件在整个组织内的结构和布局，它在系统升级或应用整合项目中是非常有用的。此外，软件分布图还展示了物理应用在整个物理技术领域中是如何分布的，以及这些物理技术的位置。软件分布图对软件是如何被托管的这一问题提供了一份清晰的视图，而且还使得管理操作人员能够了解应用软件在安装成功后是如何被维护的。</p>\n<p>技术标准目录（Technology Standards Catalog）</p>\n<p>技术标准目标记录了企业中被批准的各项技术标准，涵盖了技术、版本、技术生命周期，以及技术的更新周期。根据组织需要，也可能包括地点或者业务的特定领域的标准信息。此目录提供了一个当前或能够被部署的企业标准技术的快照，并有助于在整个企业内搜寻差异。如果当前已经存在了各种技术标准，那么把它们放入到技术组合目录中将会得到一张关于各技术标准符合性的基线视图。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>平台服务</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>技术组合目录（Technology Por tfolio Catalog）</p>\n<p>此目录的目标是识别和维护整个企业中在用技术的列表，包括硬件、技术设施软件，以及应用软件。一个经过批准的技术组合支持技术产品和版本的生命周期管理，而且还形成了技术标准定义的基础。技术组合目录为后续的矩阵和图形描述提供了基础，是技术架构开发阶段的起点。技术注册表和资源库从基线和目标的视角为此目录提供了输入。在此目录中的技术应该按照TOGAF技术参考模型（可以按照需要来对模型进行扩展，从而符合针对正在使用的技术产品的分类）进行分类。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>平台服务</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>系统/技术矩阵（System/Technology Matrix）</p>\n<p>系统/技术矩阵记录了业务系统与技术平台之间的映射关系。此矩阵应该是一张或多张平台分解图的补充，并应与这些图保持一致。此矩阵展示了：</p>\n<ul>\n<li>逻辑/物理应用组件。</li>\n<li>服务、逻辑技术组件以及物理技术组件。</li>\n<li>物理技术组件与物理应用组件之间的实现关系。</li>\n</ul>\n<p>环境和位置图（Environments and Locations Diagram）</p>\n<p>环境和位置图描述了哪些应用处于哪些位置，并标识出什么技术和/或应用被用在了哪些地方，以及表示出业务用户一般在何处与应用进行交互。此图还展示了不同部署环境的存在和位置，包括非生产环境，例如开发和预生产。</p>\n<p>平台分解图（Platform Decomposition Diagram）</p>\n<p>平台分解图描述了用于支持信息系统架构运行的技术平台。此图涵盖了技术设施平台的所有方面，并提供了一个关于企业技术平台的概览。此图可以通过扩展来将技术平台映射到适当的处于特定功能或流程区域内的应用组件。此图还可以被用来展示规范说明的细节，例如产品版本、CPU数量等，或者只是用来提供技术环境概览的非正式的“过眼图”。</p>\n<p>此图应该清楚的展示企业应用和针对每个应用区域的技术平台，它可以被进一步分解为：</p>\n<ul>\n<li>硬件：</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n<li>软件：</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>处理图（Processing Diagram）</p>\n<p>处理图关注于代码/配置的部署单元（针对业务功能、服务或应用组件的分组），以及这些单元是如何被部署到技术平台之上的。处理图表明了：</p>\n<ul>\n<li>\n<p>哪些应用组件需要被组织起来，并形成部署单元。</p>\n</li>\n<li>\n<p>部署单元之间是如何连接和交互的。</p>\n</li>\n<li>\n<p>应用配置和使用模式是如何针对不同的技术组件而产生负载或容量方面需求。<br>\n针对部署单元的组织和分组依赖于对组件的展示、业务逻辑以及数据存储层和服务水平需求这些方面关注点的分离。例如，展示层部署单元是基于如下方面进行分组的：</p>\n</li>\n<li>\n<p>用于提供用户界面或用户访问功能的应用组件。</p>\n</li>\n<li>\n<p>根据位置和用户角色来进行区分的应用组件。<br>\n每个部署单元是由若干子单元所组成的，例如：</p>\n</li>\n<li>\n<p>安装单元：包含可执行的代码或封包配置的部分。</p>\n</li>\n<li>\n<p>执行单元：应用组件以及与其相关的运行时状态。</p>\n</li>\n<li>\n<p>持久化单元：代表应用组件的持久化状态的数据。<br>\n部署单元可以被部署到专用或共享的技术组件之上（工作站、Web服务器、应用服务器或数据库服务器等）。需要注意的是，技术处理对于服务的定义和粒度具有着较大的影响。</p>\n</li>\n</ul>\n<p>网络计算/硬件图（Networked Computing/Hardware Diagram）</p>\n<p>从大型机到客户端-服务器系统的改造开始，以及随后的电子商务和J2EE的出现，大型企业逐步进入到了一个高度网络化的分布式网络计算环境之中。当前，大多数应用都具有一个Web前端，并且就这些应用的部署架构来说，具备三个独立层次的情况还是非常常见的，亦即Web表现层、业务逻辑或应用层，以及一个后台数据存储层。将应用部署到一个共享的通用技术设施环境之中也是一种常见的做法。</p>\n<p>由此可见，将逻辑应用与在开发和生产过程中对应用进行支持的技术组件之间的映射关系记录起来是非常重要的。网络计算/硬件图的目标是展示逻辑应用组件在一个分布式网络计算环境中部署的逻辑视图。此图之所以有用，是因为通过此图我们可以：</p>\n<ul>\n<li>了解应用部署在分布式网络计算环境中的什么地方。</li>\n<li>建立针对这些技术组件的授权、安全和访问。</li>\n<li>了解在问题解决和故障排除中用以支持应用的技术架构。</li>\n<li>对应用所遇到的性能问题进行隔离，确定应用是代码相关的，还是技术平台相关的，并对具体的物理技术组件进行必要的升级。</li>\n<li>当新的技术出现并能够因此带来成本缩减时，确定可通过此技术进行优化的区域。</li>\n<li>使得应用/技术审计成为可能，并证明企业技术标准的符合性程度。</li>\n<li>作为将变更引入到技术架构的用力工具，从而支持有效地变更管理。</li>\n<li>当应用从一个共享环境迁移到一个专门的环境时，建立可追溯性和正在进行变化的应用的终端地址，反之亦然。</li>\n</ul>\n<p>通过适当的定义，网络计算/硬件图的范围可以涵盖某一个特定的应用、业务功能或者是整个企业，而如果选择在企业级别进行开发，那么组织就可以通过一种与应用无关的方式来对网络计算情况进行描述。</p>\n<p>通信工程图（Communications Engineering Diagram）</p>\n<p>通信工程图描述了处在技术架构中的各资产之间的通信方法（收发信息的方法）。此图展示了客户端和服务器组件之间的逻辑连接，并明确了用于对这些逻辑连接进行实现的网络边界和网络基础设施。需要注意的是，此图并不描述参与通信的信息格式或内容，但它可以对通信协议以及容量方面的问题进行阐述。</p>\n<p>项目背景图（Project Context Diagram）</p>\n<p>项目背景图展示了作为过渡路线图一部分而实现的工作包的范围。此图会将工作包与在项目中被增加、删除或影响的组织、功能、服务、流程、应用、数据以及技术连接在一起。此图对于项目组合管理和项目动员来说也是一个有价值的工具。</p>\n<p>效益图（Benefits Diagram）</p>\n<p>效益图展示了在架构定义中识别出来的各种机会，并通过他们的相对规模、效益和复杂度进行分类。此图可被干系人用来对这些识别出来的机会进行选择、对其优先级进行定义，并对他们的顺序进行确定。</p>\n<p>需求目录（Requirements Catalog）</p>\n<p>需求目录包含企业需要用来满足目标要求的种种事物。在架构行为中所产生的需求一般会通过变更措施来实现，并在机会和解决方案阶段中界定其范围。需求还可以被用来作为质量保证的工具，从而保证针对特定架构的使用始终处在其使用范围之内。</p>\n<h3> 3、针对视图的开发</h3>\n<p>如前所述，TOGAF中定义了一系列基本的架构制品来担当原子性视角，不同的组织可以根据自身的需要创建、改造或利用这些原子视角，并根据不同干系人的关注点将这些架构制品组合为适合于他们的视角定义，因而针对视图的开发需要明确其目标干系人、他们的关注点，以及所采用的各种基本架构制品和建模方法。TOGAF中针对多种视图的开发方法进行了建议，包括：</p>\n<ul>\n<li>业务架构视图：此视图是为用户而进行开发的，它从系统用户的角度对系统的功能性方面进行关注。</li>\n<li>企业安全视图：此视图是为系统安全工程师而进行开发的，它从安全的角度对系统如何实现，以及安全如何影响系统特性这些方面进行关注，这其中最重要的是，相关干系人能够了解如何确保系统仅能被具有权限的人员或系统来进行访问，以及如何保护系统不受到非授权地侵扰。</li>\n<li>软件工程视图：创建一个软件密集型系统是非常耗费资源和时间的，因而建立一个能够帮助最小化劳力付出和风险的导则是非常必要的，而这正是软件工程视图的目标。此视图应该是为开发系统的软件工程师而进行开发的。</li>\n<li>系统工程视图：此视图应该是为系统的系统工程人员而进行开发的，并从硬件/软件和网络连接的角度对系统如何被实现进行关注。</li>\n<li>通信工程视图：此视图应该是为系统的通信工程人员而进行开发的，并在通信工程师的角度关注于系统是如何被实现的。</li>\n<li>数据流视图：此视图应该是为系统的数据库工程师而进行开发的。此视图的主要关注点在于了解如何为正确的人员和应用通过适当的接口并在合适的时间提供正确的数据。</li>\n<li>企业管理能力视图：此视图应该是为系统的运营、行政和管理人员而进行开发的。此视图的主要关注点在于了解系统是如何做为一个整体而被管理的，以及系统的所有组件是如何被管理的，这其中关键之处在于管理系统变更，并对预防性维护措施进行预测。</li>\n<li>采购视图：此视图应该是为在架构组件的采购过程中所牵涉的人员而进行开发的。此视图的主要关注点在于了解哪些架构的构建块是需要被采购的，以及与采购行为相关的各种约束。</li>\n</ul>\n<h3> 5、构建块（Building Blocks）</h3>\n<p>架构构建块可以说是企业架构内容的核心，也是企业架构开发方法的最终产物。与此相比，架构交付物所面向的是企业架构开发过程，架构制品则可以看作是企业架构内容的表现形式和使用方式，而唯有构建块则是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些企业各个领域中的可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>\n<p>构建块特性</p>\n<p>在TOGAF中，构建块所共有的特性被定义如下：</p>\n<ul>\n<li>构建块是为了达成整个组织的需要而定义的功能包。</li>\n<li>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</li>\n<li>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</li>\n<li>构建块通常会与其他相互依存的构建块进行互操作。</li>\n</ul>\n<p>除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>\n<ul>\n<li>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</li>\n<li>一个好的构建块可以由其他构建块组合而成。</li>\n<li>一个好的构建块可以是其他构建块的一个组件。</li>\n<li>在理想的情况下，一个构建块应是可重用和可替换的，并具备详尽的描述。</li>\n</ul>\n<p>构建块分类</p>\n<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的，也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者则在实现的层面对能够实现构建块的解决方案进行描述。需要注意的是，由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合，因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>\n<p>①架构构建块（ABBs：Architecture Building Blocks）</p>\n<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>\n</li>\n<li>\n<p>用以指导解决方案架构块的开发。<br>\n架构构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>\n</li>\n<li>\n<p>接口：提供的选择集合。</p>\n</li>\n<li>\n<p>与其他构建块之间的互操作和关系。</p>\n</li>\n<li>\n<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>\n</li>\n<li>\n<p>业务和组织实体之间的映射和策略。</p>\n</li>\n</ul>\n<p>②解决方案构建块（SBBs：SolutionBuilding Blocks）</p>\n<p>解决方案与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>对用于进行功能实现的产品和组件进行定义。</p>\n</li>\n<li>\n<p>对实施进行了定义。</p>\n</li>\n<li>\n<p>满足业务需求。</p>\n</li>\n<li>\n<p>产品或厂商是明确的。<br>\n解决方案构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>具体的功能和属性。</p>\n</li>\n<li>\n<p>接口：具体实现集合。</p>\n</li>\n<li>\n<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>\n</li>\n<li>\n<p>解决方案构建块与IT技术和运用策略之间的映射。</p>\n</li>\n<li>\n<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>\n</li>\n<li>\n<p>性能以及可配置能力。</p>\n</li>\n<li>\n<p>设计驱动力和约束，包括物理架构。</p>\n</li>\n<li>\n<p>解决方案构建块与架构构建块之间的关系。</p>\n</li>\n</ul>\n<p>构建块的使用原则</p>\n<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同，并且组织也应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用，因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>\n<ul>\n<li>\n<p>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</p>\n</li>\n<li>\n<p>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</p>\n</li>\n<li>\n<p>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>\n通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并在之后将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</p>\n</li>\n<li>\n<p>从如下角度对企业中的能力或资产进行分类：</p>\n<ul>\n<li>可重用的构建块，例如遗留项。</li>\n<li>需要被开发的构建块，例如新的应用。</li>\n<li>需要被采购的构建块，例如从市场中可购得的应用。</li>\n</ul>\n</li>\n<li>\n<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>\n</li>\n</ul>\n<p>构建块与架构开发方法</p>\n<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>\n<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，而包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>\n<h2> 五、机构构建块（Building Blocks）</h2>\n<p>架构构建块是企业架构内容的核心，也是企业架构开发方法的最终产物。架构交付物面向的是企业架构开发过程，架构制品则是企业架构内容的表现形式和使用方式，而唯有构建块是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>\n<h3> 1、构建块特性</h3>\n<p>在TOGAF中，构建块所共有的特性被定义如下：</p>\n<ul>\n<li>\n<p>构建块是为了达成整个组织的需要而定义的功能包。</p>\n</li>\n<li>\n<p>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</p>\n</li>\n<li>\n<p>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</p>\n</li>\n<li>\n<p>构建块通常会与其他相互依存的构建块进行互操作。<br>\n除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>\n</li>\n<li>\n<p>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</p>\n</li>\n<li>\n<p>一个好的构建块可以由其他构建块组合而成。</p>\n</li>\n<li>\n<p>一个好的构建块可以是其他构建块的一个组件。</p>\n</li>\n<li>\n<p>一个构建块应是可重用和可替换的，并具备详尽的描述。</p>\n</li>\n</ul>\n<h3> 2、构建块分类</h3>\n<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的。也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者在实现层面对能够实现构建块的解决方案进行描述。由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合。因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>\n<p>架构构建块（ABBs：Architecture Building Blocks）</p>\n<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>\n</li>\n<li>\n<p>用以指导解决方案架构块的开发。<br>\n架构构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>\n</li>\n<li>\n<p>接口：提供的选择集合。</p>\n</li>\n<li>\n<p>与其他构建块之间的互操作和关系。</p>\n</li>\n<li>\n<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>\n</li>\n<li>\n<p>业务和组织实体之间的映射和策略。</p>\n</li>\n</ul>\n<p>解决方案构建块（SBBs：SolutionBuilding Blocks）</p>\n<p>与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>对用于进行功能实现的产品和组件进行定义。</p>\n</li>\n<li>\n<p>对实施进行了定义。</p>\n</li>\n<li>\n<p>满足业务需求。</p>\n</li>\n<li>\n<p>产品或厂商是明确的。<br>\n解决方案构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>具体的功能和属性。</p>\n</li>\n<li>\n<p>接口：具体实现集合。</p>\n</li>\n<li>\n<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>\n</li>\n<li>\n<p>解决方案构建块与IT技术和运用策略之间的映射。</p>\n</li>\n<li>\n<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>\n</li>\n<li>\n<p>性能以及可配置能力。</p>\n</li>\n<li>\n<p>设计驱动力和约束，包括物理架构。</p>\n</li>\n<li>\n<p>解决方案构建块与架构构建块之间的关系。</p>\n</li>\n</ul>\n<h3> 3、构建块的使用原则</h3>\n<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同。组织应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用。因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>\n<ul>\n<li>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</li>\n<li>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</li>\n<li>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>\n通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</li>\n</ul>\n<p>从如下角度对企业中的能力或资产进行分类：</p>\n<ul>\n<li>可重用的构建块，例如遗留项。</li>\n<li>需要被开发的构建块，例如新的应用。</li>\n<li>需要被采购的构建块，例如从市场中可购得的应用。</li>\n</ul>\n<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>\n<h3> 4、构建块与架构开发方法</h3>\n<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>\n<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>\n<figure><figcaption>img_31.png</figcaption></figure>\n",
      "date_published": "2024-02-21T03:01:36.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "Java的四个核心思想",
      "url": "https://ujava.cn/java/basecore.html",
      "id": "https://ujava.cn/java/basecore.html",
      "summary": "Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。 Java虚拟机 Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。",
      "content_html": "<p>Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。</p>\n<h2> Java虚拟机</h2>\n<p>Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。</p>\n<p>不同的Java虚拟机中，执行引擎可能实现得非常不同。在由软件实现的虚拟机中：</p>\n<ul>\n<li>（1）最简单的执行引擎就是一次性解释字节码。</li>\n<li>（2）另一种执行引擎更快，但是也更消耗内存，叫做\"即时编译器(just-in-time compiler)\"。在这种情况下，第一次被执行的字节码会被编译成本地机器代码。编译出的本地机器代码会被缓存，当以后方法被调用的时候可以重用。</li>\n<li>（3）第三种执行引擎是自适应优化器。在这种方法里，虚拟机开始的时候解释字节码，但是会监视运行中程序的活动，并且记录下使用最频繁的代码段。程序运行的时候，虚拟机只把那些活动最频繁的代码编译成本地代码，其他的代码由于使用得不是很频繁，继续保留为字节码-由虚拟机继续解释它们。一个自适应的优化器可以使得Java虚拟机在80%<sub>90%的时间里执行被优化过的本地代码，而只需要编译10%</sub>20%的对性能有影响的代码。</li>\n</ul>\n<p>当Java虚拟机是由主机操作系统上的软件实现的时候，Java程序通过调用本地方法(native method)和主机交互。Java中有两种方法: Java方法和本地方法。Java方法是由Java语言编写，编译成字节码文件，存储在class文件中的。本地方法是由其他语言(比如c,c++或汇编语言)编写的，编译成何处理器相关的机器代码。本地方法保存在动态链接库中,格式是各个平台专有的。运行中Java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库，并调用这个方法。本地方法是联系Java程序和底层主机操作系统的连接方法。</p>\n<p>通过本地方法，Java程序可以直接访问底层操作系统的资源。一个本地方法接口(Java Native Interface, JNI)-使得本地方法可以在特定主机系统的任何一个Java平台实现上运行。</p>\n<p>如果希望使用特定主机上的资源，它们又无法从Java API访问，那么可以写一个平台相关的Java程序来调用本地方法。如果希望保证程序的平台无关性，那么只能通过Java API来访问底层系统资源。</p>\n<h2> 类装载器的体系结构</h2>\n<p>一个Java应用程序可以使用两种类装载器：\"启动(bootstrap)\"类装载器和用户定义的类装载器。启动类装载器(这是系统中唯一的)是Java虚拟机实现的一部分。启动类装载器通常使用某种默认方式从本地磁盘中装载类，包括Java API类(启动类装载器也被称为原始类装载器、系统类装载器或者默认类装载器)。</p>\n<p>Java应用程序能够在运行时安装用户定义的类装载器，这种类装载器能够使用自定义的方式来装载类。例如，从网络下载class文件。尽管启动类装载器是虚拟机实现的本质部分，而用户定义的类装载器不是，但用户定义的类装载器能够用Java来编写,能够被编译成class文件，能够被虚拟机装载，还能够像其它对象一样实例化。</p>\n<p>由于有用户定义类装载器，所以不必在编译的时候就知道运行中的Java应用程序中最终会加入的所有的类。用户定义的类装载器使得在运行扩展Java应用程序成为可能。当它运行时，应用程序能够解决它需要哪些额外的类，能够决定是使用一个或是更多的用户定义的类装载器来装载。由于类装载器是用Java编写的，所以用任何在Java代码中可以表述的风格来进行类装载。这些类可以通过网络下载，可以从某些数据库中获取，甚至可以动态生成。</p>\n<p>每一个类被装载的时候，Java虚拟机都监视这个类，看到它到底是被启动类装载器还是被用户定义类装载器装载。当被装载的类引用了另外一个类时，虚拟机就会使用装载第一个类的类装载器装载引用的类。例如，如果虚拟机使用一个特定的类装载器装载Volcano这个类，它就会使用这个类装载器装载Volcano类使用的所有类。</p>\n<p>由于Java虚拟机采取这种方式进行类的装载，所以被装载的类默认情况下只能看到被同一个类装载器装载的别的类。通过这种方法，Java的体系结构允许在一个Java应用程序中建立多个命名空间。运行时的Java程序中的每一个类装载器都有自己的命名空间。</p>\n<p>Java应用程序可以创建多个(或多种)被不同的类装载器装载的类并把这些类存放在不同的命名空间中，它们不能相互访问，除非应用程序显示地允许这么做。当编写一个Java应用程序的时候，从不同源文件装载的类可以分隔在不同的命名空间中。通过这种方法，就能够使用Java类装载器的体系结构来控制任何不同源文件中装载的代码之间的相互影响，特别是能够阻止恶意代码获取访问或破坏善意代码的权限。</p>\n<p>Web浏览器是一个动态扩展的例子，Web浏览器使用用户定义的类装载器从网络下载用于Java applet的class文件。Web浏览器使用一个用来安装用户定义类装载器的Java应用程序。这个用户定义的类装载器通常被称为Java Applet类装载器，它知道如何向HTTP服务器请求class文件。Java Applet可以作为动态扩展的例子，因为Java应用程序并不知道它什么时候会开始从网络下载浏览器请求的class文件。只有当浏览器遇到有Java applet的页面时，才决定是否需要下载class文件。</p>\n<p>Web浏览器启动的Java应用程序通常为每个提供class文件的网络地址分别创建不同的用户定义类装载器，因此，不同的用户定义类装载器装载不同来源的class文件。这就可以把它们分别放置在Java主机应用程序的不同命名空间之下。由于不同来源的Java applet文件放置在不同的命名空间中，恶意的Java applet代码就不会直接访问从别的地方下载的class文件。这就能够限制或阻止不同来源的代码之间的相互访问。</p>\n<h2> Java class文件</h2>\n<p>Java class文件主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。这种途径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件时可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。</p>\n<p>当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的\"机器语言\"。</p>\n<p>class文件设计得紧凑，因此它们可以快速地在网络上传送。其次，由于Java程序是动态连接和动态扩展的，class文件可以在需要的时候才下载。这个特点使得Java应用程序能够安排从网络上下载class文件的时间，从而可以最大限度地减少终端用户的等待时间。</p>\n<h2> Java API</h2>\n<p>Java API通过支持平台无关性和安全性，使得Java适应于网络应用。Java API是运行库的集合，它提供了一套访问主机系统资源的标准方法。运行Java程序时，虚拟机装载程序的class文件是所使用的Java API class文件。所有被装载的class文件(包括从应用程序中和从Java API中提取的)和所有已经装载的动态库(包含本地方法)共同组成了再Java虚拟机上运行的整个程序。</p>\n<p>在一个平台能够支持Java程序以前，必须在这个特定平台上明确地实现API的功能。为访问主机上的本地资源，Java API调用了本地方法。由于Java API class文件调用了本地方法，Java程序就不需要再调用它们了。通过这种方法，Java API class文件为底层主机提供了具有平台无关性、标准接口的Java程序。对Java程序而言，无论平台内部如何，Java API都会有同样的表现和可预测的行为。正是由于在每个特定的主机平台上明确地实现了Java虚拟机和Java API,因此，Java程序自身就能够成为具有平台无关性的程序。</p>\n<p>Java API在Java安全性模型方面也有贡献。当Java API的方法进行任何有潜在危险的操作(比如进行本地磁盘写操作)之前，都会通过查询访问控制器来检验是否得到了授权。访问控制器是一个类，该类用来执行栈检验，已决定是否允许某种操作。</p>\n",
      "date_published": "2024-01-31T00:48:57.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java UML类图",
      "url": "https://ujava.cn/java/uml.html",
      "id": "https://ujava.cn/java/uml.html",
      "summary": "面向对象概念 面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。 它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。 扩展：面向功能概念 结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。",
      "content_html": "<h2> 面向对象概念</h2>\n<p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。</p>\n<p>它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p>\n<h3> 扩展：面向功能概念</h3>\n<p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p>\n<p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p>\n<p>结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p>\n<p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p>\n<ul>\n<li>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。</li>\n<li>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高</li>\n</ul>\n<h2> 面向对象的三大特性</h2>\n<p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态</p>\n<ul>\n<li>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</li>\n<li>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</li>\n<li>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征<br>\n注意：如果说是对象的四大特性，那么还需要把抽象加上</li>\n</ul>\n<p>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p>\n<h2> 封装</h2>\n<p>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</p>\n<p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>\n<ul>\n<li>隐藏类的实现细节；</li>\n<li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li>\n<li>可进行数据检查，从而有利于保证对象信息的完整性；</li>\n<li>便于修改，提高代码的可维护性。</li>\n</ul>\n<h3> 封装的实现</h3>\n<p>为了实现良好的封装，需要从两个方面考虑：</p>\n<ul>\n<li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；</li>\n<li>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。<br>\n封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</li>\n</ul>\n<h2> 继承</h2>\n<p>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</p>\n<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n<p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>\n<h3> 继承的实现</h3>\n<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><h3> C++和Java继承区别</h3>\n<p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>\n<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。</p>\n<p>Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。</p>\n<p>比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>\n<p>准确来说，Java是可以实现\"多继承\"的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆</p>\n<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>\n<h2> 多态</h2>\n<p>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征</p>\n<p>因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p>\n<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass(); ，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>\n<h3> 多态的实现</h3>\n<p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。</p>\n<p>在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。</p>\n<ul>\n<li>对于父类型，可以有三种形式，即普通的类、抽象类、接口</li>\n<li>对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法<br>\n具体案例如下：</li>\n</ul>\n<p>多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。</p>\n<p>例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 driver.drive(obj) 这样的方式来调用，对调用者足够的友好。</p>\n<p>但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。</p>\n<p>当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，类似的代码会堆积的越来越多，显得臃肿。</p>\n<p>采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vehicle子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 类(对象)之间的关系</h2>\n<h3> UML类图</h3>\n<p>类之间的关系，类与接口之间关系可以分一下几种</p>\n<ul>\n<li>泛化关系(Generalization)</li>\n<li>实现关系 (Realization)</li>\n<li>聚合关系 (Aggregation)</li>\n<li>组合关系 (Composition)</li>\n<li>关联关系 (Association)</li>\n<li>依赖关系 (Dependency)</li>\n</ul>\n<figure><figcaption>img_19.png</figcaption></figure>\n<h3> 泛化关系 (Generalization)</h3>\n<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>\n<figure><figcaption>img_18.png</figcaption></figure>\n<h3> 实现关系 (Realization)</h3>\n<p>用来实现一个接口，在 Java 中使用 implement 关键字。</p>\n<figure><figcaption>img_20.png</figcaption></figure>\n<h3> 聚合关系 (Aggregation)</h3>\n<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>\n<figure><figcaption>img_21.png</figcaption></figure>\n<h3> 组合关系 (Composition)</h3>\n<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。<br>\n</p>\n<h3> 关联关系 (Association)</h3>\n<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。</p>\n<p>因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>\n<figure><figcaption>img_23.png</figcaption></figure>\n<h3> 依赖关系 (Dependency)</h3>\n<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。</p>\n<p>A 类和 B 类是依赖关系主要有三种形式：</p>\n<ul>\n<li>A 类是 B 类中的(某中方法的)局部变量；</li>\n<li>A 类是 B 类方法当中的一个参数；</li>\n<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>\n</ul>\n<figure><figcaption>img_24.png</figcaption></figure>\n",
      "date_published": "2024-01-30T01:34:07.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java ReentrantLock锁的设计思想",
      "url": "https://ujava.cn/java/reentrantlock.html",
      "id": "https://ujava.cn/java/reentrantlock.html",
      "summary": "一、开头 在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。 主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题： 线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度 过多线程造成线程之间的上下文切换，导致效率低下 因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。” 简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。",
      "content_html": "<h2> 一、开头</h2>\n<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。<br>\n主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题：</p>\n<ul>\n<li>线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度</li>\n<li>过多线程造成线程之间的上下文切换，导致效率低下</li>\n</ul>\n<p>因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。”<br>\n简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。</p>\n<h2> 二、关健术语</h2>\n<p>本文用到的一些关键词语以及常用术语，主要如下：</p>\n<ul>\n<li>并发(Concurrent): 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</li>\n<li>并行(Parallel): 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。</li>\n<li>信号量(Semaphore):  是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用，也是作系统用来解决并发中的互斥和同步问题的一种方法。</li>\n<li>信号量机制(Semaphores)： 用来解决同步/互斥的问题的，它是1965年,荷兰学者 Dijkstra提出了一种卓有成效的实现进程互斥与同步的方法。</li>\n<li>管程(Monitor) :  一般是指管理共享变量以及对共享变量的操作过程，让它们支持并发的一种机制。</li>\n<li>互斥(Mutual Exclusion)：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。即就是同一时刻只允许一个线程访问共享资源的问题。</li>\n<li>同步(Synchronization)：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。即就是线程之间如何通信、协作的问题。</li>\n<li>对象池(Object Pool): 指的是一次性创建出 N 个对象，之后所有的线程重复利用这 N 个对象，当然对象在被释放前，也是不允许其他线程使用的, 一般指保存实例对象的容器。</li>\n</ul>\n<h2> 三、基本概述</h2>\n<p>在Java领域中，我们可以将锁大致分为基于Java语法层面(关键词)实现的锁和基于JDK层面实现的锁。</p>\n<p>在Java领域中, 尤其是在并发编程领域，对于多线程并发执行一直有两大核心问题：同步和互斥。其中：</p>\n<ul>\n<li>互斥(Mutual Exclusion)：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。即就是同一时刻只允许一个线程访问共享资源的问题。</li>\n<li>同步(Synchronization)：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。即就是线程之间如何通信、协作的问题。<br>\n针对对于这两大核心问题，利用管程是能够解决和实现的，因此可以说，管程是并发编程的万能钥匙。<br>\n虽然，Java在基于语法层面(synchronized 关键字)实现了对管程技术,但是从使用方式和性能上来说，内置锁(synchronized 关键字)的粒度相对过大，不支持超时和中断等问题。<br>\n为了弥补这些问题，从JDK层面对其“重复造轮子”，在JDK内部对其重新设计和定义，甚至实现了新的特性。<br>\n在Java领域中，从JDK源码分析来看，基于JDK层面实现的锁大致主要可以分为以下4种方式：</li>\n</ul>\n<figure><figcaption>img_10.png</figcaption></figure>\n<ul>\n<li>基于Lock接口实现的锁：JDK1.5版本提供的ReentrantLock类</li>\n<li>基于ReadWriteLock接口实现的锁：JDK1.5版本提供的ReentrantReadWriteLock类</li>\n<li>基于AQS基础同步器实现的锁：JDK1.5版本提供的并发相关的同步器Semaphore，CyclicBarrier以及CountDownLatch等�</li>\n<li>基于自定义API操作实现的锁：JDK1.8版本中提供的StampedLock类<br>\n从阅读源码不难发现，在Java SDK 并发包主要通过AbstractQueuedSynchronizer(AQS)实现多线程同步机制的封装与定义，而通过Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。</li>\n</ul>\n<h3> 1.AQS基础同步器基本理论</h3>\n<p>在Java领域中,同步器是专门为多线程并发设计的同步机制，主要是多线程并发执行时线程之间通过某种共享状态来实现同步，只有当状态满足这种条件时线程才往下执行的一种同步机制。</p>\n<figure><figcaption>img_11.png</figcaption></figure>\n<p>一个标准的AQS同步器主要有同步状态机制，等待队列，条件队列，独占模式，共享模式等五大核心要素组成。<br>\n在Java领域中，JDK的JUC(java.util.concurrent.)包中提供了各种并发工具，但是大部分同步工具的实现基于AbstractQueuedSynchronizer类实现，其内部结构主要如下：</p>\n<ul>\n<li>\n<p>同步状态机制(Synchronization Status)：主要用于实现锁(Lock)机制，是指同步状态，其要求对于状态的更新必须原子性的</p>\n</li>\n<li>\n<p>等待队列(Wait Queue)：主要用于存放等待线程获取到的锁资源，并且把线程维护到一个Node(节点)里面和维护一个非阻塞的CHL Node FIFO(先进先出)队列，主要是采用自旋锁+CAS操作来保证节点插入和移除的原子性操作。</p>\n</li>\n<li>\n<p>条件队列(Condition Queue)：用于实现锁的条件机制，一般主要是指替换“等待-通知”工作机制，主要是通过ConditionObject对象实现Condition接口提供的方法实现。</p>\n</li>\n<li>\n<p>独占模式(Exclusive Mode)：主要用于实现独占锁，主要是基于静态内部类Node的常量标志EXCLUSIVE来标识该节点是独占模式</p>\n</li>\n<li>\n<p>共享模式(Shared Mode)：主要用于实现共享锁，主要是基于静态内部类Node的常量标志SHARED来标识该节点是共享模式<br>\n我们可以得到一个比较通用的并发同步工具基础模型，大致包含如下几个内容，其中：<br>\n</p>\n</li>\n<li>\n<p>条件变量(Conditional Variable)： 利用线程间共享的变量进行同步的一种工作机制</p>\n</li>\n<li>\n<p>共享变量((Shared Variable))：一般指对象实体对象的成员变量和属性</p>\n</li>\n<li>\n<p>阻塞队列(Blocking Queue)：共享变量(Shared Variable)及其对共享变量的操作统一封装</p>\n</li>\n<li>\n<p>等待队列(Wait Queue)：每个条件变量都对应有一个等待队列(Wait Queue),内部需要实现入队操作(Enqueue)和出队操作(Dequeue)方法</p>\n</li>\n<li>\n<p>变量状态描述机(Synchronization Status)：描述条件变量和共享变量之间状态变化，又可以称其为同步状态</p>\n</li>\n<li>\n<p>工作模式(Operation Mode)： 线程资源具有排他性，因此定义独占模式和共享模式两种工作模式<br>\n综上所述，条件变量和等待队列的作用是解决线程之间的同步问题；共享变量与阻塞队列的作用是解决线程之间的互斥问题。</p>\n</li>\n</ul>\n<h3> 2. JDK显式锁统一概念模型</h3>\n<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。</p>\n<figure><figcaption>img_13.png</figcaption></figure>\n<p>综合Java领域中的并发锁的各种实现与应用分析来看，一把锁或者一种锁，基本上都会包含以下几个方面：</p>\n<ul>\n<li>锁的同步器工作机制：主要是考虑共享模式还是独享模式，是否支持超时机制，以及是否支持超时机制？</li>\n<li>锁的同步器工作模式：主要是基于AQS基础同步器封装内部同步器，是否考虑公平/非公平模式？</li>\n<li>锁的状态变量机制： 主要锁的状态设置，是否共享状态变量？</li>\n<li>锁的队列封装定义：主要是指等待队列和条件队列，是否需要条件队列或者等待队列定义？</li>\n<li>锁的底层实现操作： 主要是指底层CL锁和CAS操作，是否需要考虑自旋锁或者CAS操作实例对象方法？</li>\n<li>锁的组合实现新锁： 主要是基于独占锁和共享锁，是否考虑对应API自定义操作实现？<br>\n综上所述，大致可以根据上述这些方向，我们便可以清楚知道Java领域中各种锁实现的基本理论时和实现思想。</li>\n</ul>\n<h3> 3.ReentrantLock(可重入锁)的设计与实现</h3>\n<p>在Java领域中，ReentrantLock(可重入锁)是针对于Java多线程并发控制中对一个线程可以多次对某个锁进行加锁操作，主要是基于内置的AQS基础抽象队列同步器实现的一种并发控制工具类。</p>\n<figure><figcaption>img_14.png</figcaption></figure>\n<p>一般来说，对于同一个线程是否可以重复占有同一个锁对象的角度来分，大致主要可以分为可重入锁与不可重入锁。其中：</p>\n<ul>\n<li>可重入锁：一个线程可以多次抢占同一个锁，也就意味着能够支持一个线程对资源的重复加锁，或者说，一个线程可以多次进入同一个锁所同步的临界区代码块。</li>\n<li>不可重入锁：一个线程只能抢占一次同一个锁，也就意味着在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程才能够获取锁。</li>\n</ul>\n<p>ReentrantLock是JDK中显式锁一个主要基于Lock接口API实现的基础实现类，拥有与内置锁(synchronized)相同的并发性和内存语义，同时提供了限时抢占、可中断抢占等一些高级锁特性。<br>\n除此之外，ReentrantLock基于内置的AQS基础抽象队列同步器实现，在线程参与锁资源竞争比较激烈的场景下，能表现出比内置锁较佳的性能。<br>\n而且，ReentrantLock是一种独占锁，在独占模式下只能逐一使用锁，也就是说，任意时刻最多只会有一个线程持有锁的控制权。</p>\n<ol>\n<li>\n<h4> 设计思想</h4>\n</li>\n</ol>\n<figure><figcaption>img_15.png</figcaption></figure>\n<p>ReentrantLock类最早是在JDK1.5版本提供的，从设计思想上来看，主要包括同步器工作模式，获取锁方法，释放锁方法以及定义Condition队列方法等4个核心要素。其中：</p>\n<ul>\n<li>实现Lock接口 ：主要基于Lock接口API实现对应方法，拥有与内置锁(synchronized)相同的并发性和内存语义，用于支持和解决解决互斥问题。</li>\n<li>同步器工作模式：基于AQS基础抽象队列同步器封装内置实现一个静态的内置同步器抽象类，然后基于这个抽象类分别实现了公平同步器和非公平同步器，用来指定和描述同步器工作模式是公平模式还是非公平模式。</li>\n<li>公平/非公平模式：主要描述的是多个线程在同时获取锁时是否按照先到先得的顺序获取锁，如果是则为公平模式，否则为非公平模式。</li>\n<li>获取锁方法：主要定义了一个lock()方法来获取锁，表示假如锁已经被其他线程占有或持有，其当前获取锁的线程则进入等待状态。</li>\n<li>释放锁方法：主要定义了一个unlock()方法来释放锁，表示假如锁已经被其他线程放弃或释放，其当前获取锁的线程则获得该锁。</li>\n<li>定义Condition队列操作方法： 主要是基于Condition接口来定义一个方法实现锁的条件机制，用于支持线程的阻塞和唤醒功能即就是解决同步问题，也就是我们说的线程间的通信方式。</li>\n<li>定义等待队列操作方法： 主要是依据条件队列来时进行对应的操作，间接适配AQS基础同步器中对于等待队列的功能，保证获取锁的顺序的公平性</li>\n</ul>\n<ol start=\"2\">\n<li>\n<h4> 基本实现</h4>\n</li>\n</ol>\n<figure><figcaption>img_16.png</figcaption></figure>\n<p>在ReentrantLock类的JDK1.8版本中，对于ReentrantLock的基本实现如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>内部同步器：基于AQS基础同步器封装和定义了一个静态内部Sync抽象类，其中抽象了一个内置锁lock()方法</li>\n<li>同步器工作模式：提供了 2个构造方法，其中无参数构造方法表示的是默认的工作模式，有参数构造方法主要依据参数来实现指定的工作模式</li>\n<li>获取锁： 主要是提供了lock()方法，调用的静态内部Sync抽象类内置锁lock()方法，而本质上是AQS同步器中的acquire()方法</li>\n<li>释放锁： 主要是提供了unlock()方法，而本质上是调用的AQS同步器中的release()方法</li>\n<li>创建条件队列： 主要是基于Condition接口定义了newCondition() 方法，调用的静态内部Sync抽象类ewCondition()方法，而本质上是调用的AQS同步器中的ConditionObject中的newCondition()方法</li>\n</ul>\n<p><strong>2.1 基于AQS同步器封装静态内部Sync抽象类</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>Sync类：FairSync公平同步器和NonfairSync非公平同步器的抽象父类。</li>\n<li>校验isHeldExclusively()方法： ReentrantLock锁是属于独占模式，需要当前锁持有线程与当前线程是否一致</li>\n<li>nonfairTryAcquire()方法： 一般主要用于非公平模式获取锁，其核心是compareAndSetState方法和setExclusiveOwnerThread方法</li>\n<li>tryRelease()方法： 其公平/非公平模式都是通过ryRelease()来释放锁操作</li>\n<li>newCondition()方法： 基于AQS同步器的ConditionObject对象封装实现，提供给 ReentrantLock类使用</li>\n<li>私有readObject()方法：对于输入的对象进行流化处理</li>\n</ul>\n<p>特别需要注意的是，我们需要重点关注nonfairTryAcquire()方法和tryRelease()方法，其中：</p>\n<ul>\n<li>获取非公平锁 nonfairTryAcquire()方法：主要是用于获取AQS的状态变量status，其默认取值范围是0和1，其中，0表示未被加锁，1表示已经被加锁</li>\n<li>如果状态变量status=0，使用compareAndSetState方法进行CAS原子修改操作，把状态变量修改为1，并且通过setExclusiveOwnerThread设置当前线程为锁的持有线程</li>\n<li>如果状态变量status=1，表示当前线程为锁的持有线程，正在进入锁重入操作，状态变量累加1，超过重入次数时，会抛出throw new Error(“Maximum lock count exceeded”)</li>\n<li>释放锁tryRelease()方法：主要是检查当前线程是否为锁持有线程，随后AQS同步器状态变量减1，如果不是 throw new IllegalMonitorStateException()</li>\n<li>如果状态变量status=0，表示锁已经释放成功，通过setExclusiveOwnerThread设置锁的持有线程为null，也就是置空锁的持有线程</li>\n<li>如果状态变量status !=0,  需要状态变量递减1即可，直到锁已经释放成功</li>\n</ul>\n<p><strong>2.2 基于Sync抽象类封装FairSync公平同步器</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>实现方式： 主要基于AQS封装的内部静态抽象Sync同步类实现，使用的AQS的独占模式。</li>\n<li>主要方法： 主要提供了lock()和tryAcquire()方法，其严格意义上来说，仅仅只是实现了tryAcquire()方法，但是最关键的使用hasQueuedPredecessors来保证了锁的公平性。</li>\n<li>锁获取方式： 主要是采用完全通过队列来实现实现公平机制，即就是检查是否存在等待队列，如果队列之中已经存在其他线程，直接放弃操作。</li>\n</ul>\n<p><strong>2.3 基于Sync抽象类封装NonfairSync非公平同步器</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>实现方式： 主要基于AQS封装的内部静态抽象Sync同步类实现，使用的AQS的独占模式。</li>\n<li>主要方法： 主要提供了lock()和tryAcquire()方法，其严格意义上来说，仅仅只是实现了tryAcquire()方法，直接调用了Sync同步类的nonfairTryAcquire()方法。</li>\n<li>锁获取方式： 主要是采用闯入策略来打破锁的公平，也就是一般准备获取锁的线程会先尝试获取锁，失败之后才进入队列中。</li>\n</ul>\n<h2> 3. 具体实现</h2>\n<p><br>\n在ReentrantLock类的JDK1.8版本中，对于ReentrantLock的具体实现如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>获取锁的方法：主要提供了一般模式lock()方法，支持可中断机制lockInterruptibly()方法，无参数tryLock()方法以及有参数的支持超时机制的tryLock(long timeout, TimeUnit unit)方法</li>\n<li>释放锁的方法：主要是unlock()方法，间接调用是内部同步器中的release()方法</li>\n<li>条件队列操作：主要提供了获取队列中的线程对象getQueuedThreads()，检测队列入队hasWaiters(Condition condition) 方法，以及</li>\n<li>等待队列操作：主要提供了获取队列中的线程对象getWaitingThreads(Condition condition)，检测队列入队hasQueuedThread(Thread thread) 方法，以及获取队列长度getQueueLength()方法和getWaitingThreads(Condition condition)方法</li>\n<li>其他检测判断：主要有判断是否公平模式isFair()方法，是否当前线程独占isHeldByCurrentThread()方法，以及是否加锁 isLocked()等</li>\n</ul>\n<p>需要注意的是，在JDK1.8版本之后，对于ReentrantLock的实现有些细微的变化，感兴趣的可自行参考相关版本的源码进行对比分析。</p>\n<p>综上所述，从一定意义上讲，ReentrantLock是一种可重入的独占(互斥)锁，属于AQS基础抽象队列同步器中独占模式孵化的产物，支持公平模式与非公平模式，默认采用非公平模式。</p>\n<h2> 最后</h2>\n<p>通过对Java领域中，JDK内部提供的各种锁的实现来看，一直围绕的核心主要还是基于AQS基础同步器来实现的，但是AQS基础同步器不是一种非它不可的技术标准规范，更多的只是一套技术参考指南。</p>\n<p>但是，实际上，Java对于锁的实现与运用远远不止这些，还有相位器(Phaser)和交换器(Exchanger),以及在Java JDK1.8版本之前并发容器ConcurrentHashMap中使用的分段锁(Segment)。</p>\n<p>不论是何种实现和应用，在Java并发编程领域来讲，都是围绕线程安全问题的角度去考虑的，只是针对于各种各样的业务场景做的具体的实现。</p>\n<p>一定意义上来讲，对线程加锁只是并发编程的实现方式之一，相对于实际应用来说，Java领域中的锁都只是一种单一应用的锁，只是给我们掌握Java并发编程提供一种思想没，三言两语也不可能详尽。</p>\n<p>到此为止，这算是对于Java领域中并发锁的最终章，文中表述均为个人看法和个人理解，如有不到之处，忘请谅解也请给予批评指正。</p>\n",
      "date_published": "2024-01-29T08:06:37.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "JDK源码中用到的23种设计模式",
      "url": "https://ujava.cn/java/jdkdesign.html",
      "id": "https://ujava.cn/java/jdkdesign.html",
      "summary": "创建模式 Singleton(单例) Abstract factory(抽象工厂) Factory(工厂方法) Builder(建造者) Prototype(原型) 结构模式 Adapter(适配器) Composite(组合) Decorator(装饰器) Facade(门面) Flyweight(享元模式) Proxy(代理) 行为模式 Chain of Responsibility(责任链) Command(命令) Interpreter(解释器) Iterator(迭代器) Mediator(中介) Memento(快照-备忘录模式) Observer(观察者) State(状态) Strategy(策略) Template(模板) Visitor(访问者)",
      "content_html": "<!-- TOC -->\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F\">创建模式</a>\n<ul>\n<li><a href=\"#singleton%E5%8D%95%E4%BE%8B\">Singleton(单例)</a></li>\n<li><a href=\"#abstract-factory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82\">Abstract factory(抽象工厂)</a></li>\n<li><a href=\"#factory%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95\">Factory(工厂方法)</a></li>\n<li><a href=\"#builder%E5%BB%BA%E9%80%A0%E8%80%85\">Builder(建造者)</a></li>\n<li><a href=\"#prototype%E5%8E%9F%E5%9E%8B\">Prototype(原型)</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F\">结构模式</a>\n<ul>\n<li><a href=\"#adapter%E9%80%82%E9%85%8D%E5%99%A8\">Adapter(适配器)</a></li>\n<li><a href=\"#composite%E7%BB%84%E5%90%88\">Composite(组合)</a></li>\n<li><a href=\"#decorator%E8%A3%85%E9%A5%B0%E5%99%A8\">Decorator(装饰器)</a></li>\n<li><a href=\"#facade%E9%97%A8%E9%9D%A2\">Facade(门面)</a></li>\n<li><a href=\"#flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\">Flyweight(享元模式)</a></li>\n<li><a href=\"#proxy%E4%BB%A3%E7%90%86\">Proxy(代理)</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F\">行为模式</a>\n<ul>\n<li><a href=\"#chain-of-responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE\">Chain of Responsibility(责任链)</a></li>\n<li><a href=\"#command%E5%91%BD%E4%BB%A4\">Command(命令)</a></li>\n<li><a href=\"#interpreter%E8%A7%A3%E9%87%8A%E5%99%A8\">Interpreter(解释器)</a></li>\n<li><a href=\"#iterator%E8%BF%AD%E4%BB%A3%E5%99%A8\">Iterator(迭代器)</a></li>\n<li><a href=\"#mediator%E4%B8%AD%E4%BB%8B\">Mediator(中介)</a></li>\n<li><a href=\"#memento%E5%BF%AB%E7%85%A7-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\">Memento(快照-备忘录模式)</a></li>\n<li><a href=\"#observer%E8%A7%82%E5%AF%9F%E8%80%85\">Observer(观察者)</a></li>\n<li><a href=\"#state%E7%8A%B6%E6%80%81\">State(状态)</a></li>\n<li><a href=\"#strategy%E7%AD%96%E7%95%A5\">Strategy(策略)</a></li>\n<li><a href=\"#template%E6%A8%A1%E6%9D%BF\">Template(模板)</a></li>\n<li><a href=\"#visitor%E8%AE%BF%E9%97%AE%E8%80%85\">Visitor(访问者)</a></li>\n</ul>\n</li>\n</ul>\n<!-- TOC -->\n<h1> 创建模式</h1>\n<h2> Singleton(单例)</h2>\n<p>只允许一个实例。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Abstract factory(抽象工厂)</h2>\n<p>创建一组有关联的对象实例。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Factory(工厂方法)</h2>\n<p>按照需求返回一个类型的实例。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Builder(建造者)</h2>\n<p>主要用来简化一个复杂对象的创建。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Prototype(原型)</h2>\n<p>使用自己的实例创建另外一个实例。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 结构模式</h1>\n<h2> Adapter(适配器)</h2>\n<p>可通过创建方法识别采用不同抽象/接口类型的实例，并返回自己/抽象/接口类型的实现，其装饰/覆盖给定实例。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Composite(组合)</h2>\n<p>让使用者将单独对象和组合对象混用。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Decorator(装饰器)</h2>\n<p>为一个对象动态地加上一系列动作，而不需要因为这些动作的不同产生大量的继承类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Facade(门面)</h2>\n<p>一个简单的接口包装一组组件、接口、抽象或者子系统。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Flyweight(享元模式)</h2>\n<p>使用缓存来加速大量小对象的访问时间。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Proxy(代理)</h2>\n<p>用一个简单的对象代替一个复杂的对象。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h1> 行为模式</h1>\n<h2> Chain of Responsibility(责任链)</h2>\n<p>一个对象在一个链接传递直到被处理。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Command(命令)</h2>\n<p>将一系列命令封装成在一个类中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Interpreter(解释器)</h2>\n<p>定义语言的文法，并且建立一个解释器来解释该语言中的句子。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Iterator(迭代器)</h2>\n<p>对象遍历。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Mediator(中介)</h2>\n<p>用一个中介对象来封装一系列关于对象交互行为。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Memento(快照-备忘录模式)</h2>\n<p>保存另外一个对象内部状态拷贝的对象</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Observer(观察者)</h2>\n<p>事件监听器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> State(状态)</h2>\n<p>不同的状态，不同的行为；或者说每个状态有相应的行为。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Strategy(策略)</h2>\n<p>定义一系列算法，把这些算法一个一个封装成单独的类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Template(模板)</h2>\n<p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Visitor(访问者)</h2>\n<p>作用于某个对象群中各个对象的操作，它可以使你在不改变这些对象本身的情况下，定义作用于这些对象的新操作。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-01-25T00:56:50.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java核心包结构设计思想",
      "url": "https://ujava.cn/java/package.html",
      "id": "https://ujava.cn/java/package.html",
      "summary": "在研读 JDK 源码之前，先了解 JDK 几个核心包的设计思想，将有助于我们理解当初的设计者们的意图，让我们更能体会到设计者的良苦用心。 1 java.lang 语言包 提供利用 Java 编程语言进行程序设计的基础类。最重要的类是 Object（类层次结构的根）和 Class（其实例表示正在运行的应用程序中的类）。 把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float 和 Double 就是用于这个目的。例如，一个 Double 类型的对象包含了一个类型为 double 的字段，这表示如果引用某个值，则可以将该值存储在引用类型的变量中。这些类还提供了大量用于转换基值的方法，并支持一些标准方法，比如 equals 和 hashCode。Void 类是一个非实例化的类，它保持一个对表示基本类型 void 的 Class 对象的引用。",
      "content_html": "<p>在研读 JDK 源码之前，先了解 JDK 几个核心包的设计思想，将有助于我们理解当初的设计者们的意图，让我们更能体会到设计者的良苦用心。</p>\n<h2> 1 java.lang 语言包</h2>\n<p>提供利用 Java 编程语言进行程序设计的基础类。最重要的类是 Object（类层次结构的根）和 Class（其实例表示正在运行的应用程序中的类）。</p>\n<p>把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float 和 Double 就是用于这个目的。例如，一个 Double 类型的对象包含了一个类型为 double 的字段，这表示如果引用某个值，则可以将该值存储在引用类型的变量中。这些类还提供了大量用于转换基值的方法，并支持一些标准方法，比如 equals 和 hashCode。Void 类是一个非实例化的类，它保持一个对表示基本类型 void 的 Class 对象的引用。</p>\n<p>类 Math 提供了常用的数学函数，比如正弦、余弦和平方根。类似地，类 String 和 StringBuffer 提供了常用的字符串操作。</p>\n<p>类 ClassLoader、Process、Runtime、SecurityManager 和 System 提供了管理类的动态加载、外部进程创建、主机环境查询（比如时间）和安全策略实施等“系统操作”。</p>\n<p>类 Throwable 包含了可能由 throw 语句抛出的对象。Throwable 的子类表示错误和异常。</p>\n<p><strong>字符编码</strong></p>\n<p>java.nio.charset.Charset 类的规范描述了字符编码的命名约定，以及每个 Java 平台实现必须支持的标准编码集。</p>\n<h2> 2 java.util</h2>\n<p><strong>简介</strong></p>\n<p>包含 collection 框架、遗留的 collection 类、事件模型、日期和时间工具、国际化和各种实用的工具类（字符串标记生成器、随机数生成器和位数组）。</p>\n<p>限于篇幅和重要性，我们这里只讨论最常用的 collection 容器类库的设计规划。</p>\n<p>Java平台包括一个集合框架。集合是代表一组对象的对象（例如经典的Vector类）。集合框架是用于表示和操作集合的统一体系结构，使集合可以独立于实现细节进行操作。</p>\n<p>集合框架的主要优点是：</p>\n<ul>\n<li>通过提供数据结构和算法来减少编程工作，因此不必自己实现它们</li>\n<li>通过提供数据结构和算法的高性能实现来提高性能。因为每个接口的各种实现都是可互换的，所以可以通过切换实现来调整程序</li>\n<li>通过建立公共语言来回传递集合，从而在不相关的API之间提供互操作性</li>\n<li>通过要求您学习多个临时集合API，减少了学习API所需的工作量</li>\n<li>通过不需要生成临时集合API，减少了设计和实现API所需的工作量</li>\n<li>通过为集合和用于操作集合的算法提供标准接口，促进软件重用</li>\n</ul>\n<p>集合框架包括：</p>\n<ul>\n<li>Collection接口。表示不同类型的集合，例如set，list和map。这些接口构成了框架的基础</li>\n<li>通用实现。集合接口的主要实现</li>\n<li>旧版实现。改造了早期版本的Vector和Hashtable的收集类，以实现集合接口</li>\n<li>特殊用途的实现。设计用于特殊情况的实现。这些实现显示非标准的性能特征，使用限制或行为</li>\n<li>并发实现。专为高度并发使用而设计的实现，下一节具体描述</li>\n<li>包装器实现。向其他实现中添加功能，例如同步</li>\n<li>便利的实现。集合接口的高性能“微型实现”</li>\n<li>抽象实现。集合接口的部分实现可简化自定义实现</li>\n<li>算法。对集合执行有用功能的静态方法，例如对列表进行排序</li>\n<li>基础设施。为集合接口提供基本支持的接口</li>\n<li>数组实用程序。原始类型和引用对象数组的实用程序函数。严格来讲，它不是集合框架的一部分，而是与集合框架同时添加到Java平台，并且依赖于某些相同的基础结构。</li>\n</ul>\n<p><strong>集合接口</strong></p>\n<p>分为两组。最基本的接口java.util.Collection具有以下子类或接口：<br>\n</p>\n<p>其他集合接口基于java.util.Map，而不是真实的集合。但是，这些接口包含集合视图操作，使它们可以作为集合进行操作。map具有以下子类：<br>\n</p>\n<p>集合接口中的许多修改方法都标记为可选。允许实现不执行这些操作中的一项或多项，如果尝试执行，则会抛出运行时异常（UnsupportedOperationException）。每个实现的文档必须指定支持哪些可选操作。引入了一些术语以帮助该规范：</p>\n<ul>\n<li>\n<p>不支持修改操作（例如添加，删除和清除）的集合称为unmodifiable。非不可修改的集合是modifiable</p>\n</li>\n<li>\n<p>另外保证不可见Collection对象中的任何更改的集合称为immutable。非不可更改的集合是mutable</p>\n</li>\n<li>\n<p>即使元素可以更改，也要保证其大小保持不变的列表称为 fixed-size。非固定大小的列表称为variable-size。</p>\n</li>\n<li>\n<p>支持快速（通常为固定时间）索引元素访问的列表称为random access列表。不支持快速索引元素访问的列表称为sequential access列表。 RandomAccess标记接口使列表能够公布它们支持随机访问的事实。这使得通用算法在应用于随机或顺序访问列表时，可以更改其行为以提供良好的性能。<br>\n一些实现限制了可以存储哪些元素（或在Maps中，键和值）。可能的限制包括要求元素：</p>\n</li>\n<li>\n<p>属于特定类型</p>\n</li>\n<li>\n<p>不为空</p>\n</li>\n<li>\n<p>服从一些任意谓词<br>\n尝试添加违反实现限制的元素会导致运行时异常，通常是ClassCastException，IllegalArgumentException或NullPointerException。尝试删除或测试是否存在违反实现限制的元素会导致异常。一些受限制的集合允许这种用法。</p>\n</li>\n</ul>\n<p><strong>集合实现</strong></p>\n<p>实现collection接口的类通常以Implementation-style Interface的形式来命名。下表总结了通用实现：<br>\n</p>\n<p>通用实现支持集合接口中的所有可选操作，并且对它们可能包含的元素没有限制。它们是不同步的，但是Collections类包含称为同步包装器的静态工厂，可用于将同步添加到许多未同步的集合中。所有新的实现都有fail-fast迭代器，该迭代器检测无效的并发修改，并且快速而干净地失败（而不是行为异常）。</p>\n<p>AbstractCollection，AbstractSet，AbstractList，AbstractSequentialList和AbstractMap类提供了核心集合接口的基本实现，以最大程度地减少实现它们所需的工作量。这些类的API文档精确地描述了每种方法的实现方式，因此，在特定实现的基本操作得以执行的情况下，实现者知道必须重写哪些方法。</p>\n<p><strong>并发容器</strong></p>\n<p>使用来自多个线程的集合的应用程序必须经过仔细地编程。通常，这称为并发编程。 Java平台包括对并发编程的广泛支持。</p>\n<p>集合是如此频繁地使用，以至于各种并发友好接口和集合的实现都包含在API中。这些类型超出了前面讨论的同步包装程序的范围，可提供并发编程中经常需要的功能。</p>\n<p>这些并发感知接口可用：<br>\n</p>\n<p>可以使用以下并发感知实现类。</p>\n<figure><figcaption>img_4.png</figcaption></figure>\n<p><strong>设计目标</strong></p>\n<p>主要设计目标是生产一种尺寸更小且更重要的是“概念重量”的API。至关重要的是，新功能与当前的Java程序员似乎并没有太大区别。它必须增加现有设施，而不是更换它们。同时，新的API必须足够强大才能提供先前描述的所有优点。</p>\n<p>为了使核心接口的数量保持较小，接口不会尝试捕获诸如可变性，可修改性和可缩放性之类的细微差别。相反，核心接口中的某些调用是可选的，从而使实现可以引发UnsupportedOperationException来指示它们不支持指定的可选操作。集合实现者必须清楚地记录实现支持哪些可选操作。</p>\n<p>为了使每个核心接口中的方法数量保持较小，接口仅在满足以下任一条件时才包含方法：</p>\n<ul>\n<li>这是真正的基本操作：可以合理定义其他基本操作的基本操作</li>\n<li>有一个令人信服的性能原因，为什么重要的实现要覆盖它</li>\n</ul>\n<p>至关重要的是，所有合理的馆藏表现形式必须能够良好地互操作。这包括数组，如果不更改语言就不能直接实现Collection接口。因此，该框架包括以下方法：使集合能够移动到数组中，将数组视为集合，将map视为集合。</p>\n<h2> 3 java.util.concurrent</h2>\n<p>从JDK1.5版本开始提供：在并发编程中很常用的实用工具类。该包涵盖几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。</p>\n<p>下面简要描述主要的组件。</p>\n<h3> 3.1 执行器（Executors）</h3>\n<p><strong>接口</strong></p>\n<p>Executor 是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。</p>\n<p>根据所使用的具体 Executor 类的不同，任务们可能在新创建的线程中、已有的任务执行线程中或者调用 execute() 的线程中执行，并且可能顺序或并发执行。</p>\n<ul>\n<li>ExecutorService 提供了多个完整的异步任务执行框架。</li>\n</ul>\n<figure><figcaption>img_5.png</figcaption></figure>\n<p>ExecutorService 管理任务的排队和安排，并允许受控的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。</p>\n<p>Future 返回函数的结果，允许确定执行是否完成，并提供取消任务执行的方法。</p>\n<p>RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。</p>\n<p><strong>实现</strong></p>\n<p>类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体实现类 FutureTask，它提供了 Future 的常见可扩展实现，以及 ExecutorCompletionService 有助于协调对异步任务组的处理。</p>\n<p>ForkJoinPool类提供了一个Executor，主要用于处理ForkJoinTask及其子类的实例。这些类使用工作窃取调度程序，该任务调度程序可满足符合计算密集型并行处理中经常存在的限制的任务的高吞吐量。</p>\n<h3> 3.2 队列</h3>\n<p>ConcurrentLinkedQueue 类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。ConcurrentLinkedDeque类与此类似，但是还支持Deque接口。</p>\n<p>java.util.concurrent 包中的五个实现都支持扩展的 BlockingQueue 接口。该接口定义了 put 和 take 的阻塞版本：<br>\n</p>\n<p>这些不同的类覆盖了生产者-消费者、消息传递、任务并行执行和相关并发设计的大多数常见模型的上下文。</p>\n<p>扩展接口TransferQueue及其实现LinkedTransferQueue引入了同步的传输方法（以及相关功能），生产者可以选择阻塞等待其消费者。</p>\n<p>BlockingDeque 接口继承了 BlockingQueue，以支持 FIFO 和 LIFO（基于栈）操作。LinkedBlockingDeque 类就提供了这样一个实现。</p>\n<h3> 3.3 超时</h3>\n<p>TimeUnit 类为指定和控制基于超时的操作提供了多层粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，都包含了基于超时机制的操作。</p>\n<p>在使用超时的所有场景中，超时规定了在表明已超时前，该方法应等待的最少时间。超时后，实现类们会“尽力”检测超时。当然了，在检测到超时和超时后再次真正地执行线程之间可能还要经过一段不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。</p>\n<h3> 3.4 同步器</h3>\n<p>五个类可辅助实现常见的专用同步语法。</p>\n<ul>\n<li>Semaphore 是一个经典的并发工具</li>\n<li>CountDownLatch 是一个非常简单但又常用的工具，在持有给定数目的信号、事件或条件前一直阻塞</li>\n<li>CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用</li>\n<li>Phaser 提供了更灵活的屏障形式，可用于控制多个线程之间的分阶段计算。</li>\n<li>Exchanger 允许两个线程在一个会合点交换对象，它在多流水线设计中是有用的</li>\n</ul>\n<h3> 3.5 并发容器</h3>\n<p>除队列外，此包还提供了设计用于多线程上下文中的容器实现：</p>\n<figure><figcaption>img_7.png</figcaption></figure>\n<p>当期望许多线程访问同一个给定容器时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读请求数和遍历请求远大于对list的更新时，CopyOnWriteArrayList 优于同步的 ArrayList。</p>\n<p>此包中与某些类一起使用的 “Concurrent” 前缀是一种速记，暗示着与类似的“同步化”的类有所不同。例如Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步化的，但 ConcurrentHashMap 则是“并发的（Concurrent）”。并发容器是线程安全的，但不受单个独占锁的管理。在 ConcurrentHashMap 这一特定场景下，它可以安全地允许任意次数的并发读，以及数目可调的并发写。适用场景如下：</p>\n<ul>\n<li>需要通过单个锁防止对容器的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性</li>\n<li>在期望多线程访问公共的容器的其他情况中，通常“concurrent”版本要更好</li>\n<li>当容器是未共享的，或者仅持有其他锁时容器才可访问时，非同步的普通容器则要更好。</li>\n</ul>\n<p>大多数并发容器的实现（包括大多数队列）与常规的 java.util 包中的约定也不同，因为它们的迭代器Iterators和Spliterators提供了弱一致的，而不是fast-fail的遍历：</p>\n<ul>\n<li>他们可能会与其他操作并发进行</li>\n<li>他们永远不会抛ConcurrentModificationException</li>\n<li>它们被保证可以遍历在构造时就已经存在的元素恰好一次，并且可以（但不保证）反映出构造后的任何修改。</li>\n</ul>\n<h3> 3.6 内存一致性属性</h3>\n<ul>\n<li>\n<p>Java语言规范的第 17 章定义了内存操作（例如对共享变量的读写）的 happens-before （先行发生，以下简称 HB）关系<br>\n<br>\n只有写操作HB读操作时，才保证一个线程写结果对另一个线程的读是可见的。synchronized 和 volatile 构造以及Thread.start() 和 Thread.join() 方法可以形成HB关系。尤其是：</p>\n</li>\n<li>\n<p>线程中，按照程序的顺序，前面的操作先行发生于后面的操作</p>\n</li>\n<li>\n<p>监视器锁上的解锁（退出 synchronized 块或方法）HB同一监视器锁上后续（时间概念上的）的加锁（进入synchronized 块或方法）。并且因为 happen-before 关系是可传递的，所以解锁之前的线程的所有操作 happen-before 加锁后的所有操作</p>\n</li>\n<li>\n<p>对某volatile字段的写操作HB每个后续（时间上的先后）对相同字段的读。volatile 字段的读写与进入和退出监视器具有相似的内存一致性效果，但并不需要互斥锁</p>\n</li>\n<li>\n<p>在线程对象上调用start()方法HB该启动了的线程中的任意动作</p>\n</li>\n<li>\n<p>线程中的所有操作HB从该线程上的 join 成功返回的任何其他线程</p>\n</li>\n</ul>\n<p>java.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：</p>\n<ul>\n<li>线程中将一个对象放入任何并发容器之前的操作 HB 从另一线程中的容器访问或移除该元素的后续操作</li>\n<li>线程中向 Executor 提交 Runnable 之前的操作 HB 其执行开始。同样适用于向 ExecutorService 提交 Callables</li>\n<li>异步计算（由 Future 接口表示）所采取的操作  HB 通过另一线程中 Future.get() 获取结果的后续的操作</li>\n<li>“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。</li>\n<li>对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 HB 另一线程中对应 exchange() 后续的操作。</li>\n</ul>\n<h2> 4 java.util.concurrent.locks</h2>\n<p>该包的接口和类提供了用于锁和等待条件的框架，这些条件不同于内置的同步和监视器。该框架允许使用锁和条件来实现更大的灵活性，但以更复杂的语法为代价。</p>\n<p>Lock 接口支持那些语义不同（重入、公平等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现为 ReentrantLock。</p>\n<p>ReadWriteLock 接口以类似方式定义了一些读线程可以共享而写线程独占的锁。此包只提供了一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。</p>\n<p>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，一个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p>\n<p>AbstractQueuedSynchronizer 类是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器。 AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。LockSupport 类提供了更低级别的阻塞和解除阻塞支持，这对那些实现自己的定制锁的开发人员很有用。</p>\n<h2> 5 <a href=\"http://java.io\" target=\"_blank\" rel=\"noopener noreferrer\">java.io</a></h2>\n<p>通过数据流、序列化和文件系统提供系统输入和输出，<a href=\"http://Java.io\" target=\"_blank\" rel=\"noopener noreferrer\">Java.io</a> 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入的数据源和输出的目标对象。</p>\n<p>除非另有说明，否则向此包的任何类或接口中的构造方法或方法传递 null 参数时，都将抛出 NullPointerException。</p>\n<p>流可以理解为数据的序列：</p>\n<ul>\n<li>输入流，从一个源读数据</li>\n<li>输出流，向一个目标写数据<br>\n流支持很多种格式，比如：基本类型、对象、数组等。下图展示了该包的内容从数据源、操作目标等角度可大致分类如下：</li>\n</ul>\n<figure><figcaption>img_9.png</figcaption></figure>\n",
      "date_published": "2024-01-24T03:14:02.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java值传递",
      "url": "https://ujava.cn/java/why-there-only-value-passing-in-java.html",
      "id": "https://ujava.cn/java/why-there-only-value-passing-in-java.html",
      "summary": "开始之前，我们先来搞懂下面这两个概念： 形参&amp;实参 值传递&amp;引用传递 形参&amp;实参 方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为： 实参（实际参数，Arguments）：用于传递给函数/方法的参数，必须有确定的值。 形参（形式参数，Parameters）：用于定义函数/方法，接收实参，不需要有确定的值。",
      "content_html": "<p>开始之前，我们先来搞懂下面这两个概念：</p>\n<ul>\n<li>形参&amp;实参</li>\n<li>值传递&amp;引用传递</li>\n</ul>\n<h2> 形参&amp;实参</h2>\n<p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>\n<ul>\n<li><strong>实参（实际参数，Arguments）</strong>：用于传递给函数/方法的参数，必须有确定的值。</li>\n<li><strong>形参（形式参数，Parameters）</strong>：用于定义函数/方法，接收实参，不需要有确定的值。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 值传递&amp;引用传递</h2>\n<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>\n<ul>\n<li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li>\n<li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>\n</ul>\n<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>\n<h2> 为什么 Java 只有值传递？</h2>\n<p><strong>为什么说 Java 只有值传递呢？</strong> 不需要太多废话，我通过 3 个例子来给大家证明。</p>\n<h3> 案例 1：传递基本类型参数</h3>\n<p>代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解析：</p>\n<p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>\n<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。</p>\n<h3> 案例 2：传递引用类型参数 1</h3>\n<p>代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解析：</p>\n<p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p>\n<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p>\n<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>\n<p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p>\n<h3> 案例 3：传递引用类型参数 2</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出:</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>解析：</p>\n<p>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！</p>\n<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>\n<h2> 引用传递是怎么样的？</h2>\n<p>看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。<br>\n但是，引用传递到底长什么样呢？下面以 <code>C++</code> 的代码为例，让你看一下引用传递的庐山真面目。</p>\n<div class=\"language-C++ line-numbers-mode\" data-ext=\"C++\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出结果：</p>\n<div class=\"language-text line-numbers-mode\" data-ext=\"text\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分析：可以看到，在 <code>incr</code> 函数中对形参的修改，可以影响到实参的值。要注意：这里的 <code>incr</code> 形参的数据类型用的是 <code>int&amp;</code> 才为引用传递，如果是用 <code>int</code> 的话还是值传递哦！</p>\n<h2> 为什么 Java 不引入引用传递呢？</h2>\n<p>引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？</p>\n<p><strong>注意：以下为个人观点看法，并非来自于 Java 官方：</strong></p>\n<ol>\n<li>出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。</li>\n<li>Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。</li>\n</ol>\n<h2> 总结</h2>\n<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：</p>\n<ul>\n<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>\n<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>\n</ul>\n",
      "date_published": "2024-01-24T01:45:54.000Z",
      "date_modified": "2024-03-03T03:03:42.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "几种常见web容器",
      "url": "https://ujava.cn/highfreq/container.html",
      "id": "https://ujava.cn/highfreq/container.html",
      "summary": "简介 应用服务器：tomcat 常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。 在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。 glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5 平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations 1.0、StAX 1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。",
      "content_html": "<h2> 简介</h2>\n<p>应用服务器：tomcat</p>\n<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>\n<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>\n<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>\n<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish<br>\nv1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5<br>\n平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations<br>\n1.0、StAX<br>\n1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>\n<h2> webSphere</h2>\n<p>WebSphere是 IBM 的集成软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web<br>\n应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的集成软件。</p>\n<h2> JBoss</h2>\n<p>JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3.0的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。2006年,Jboss公司被Redhat公司收购。</p>\n<h2> Tomcat</h2>\n<p>Tomcat是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun<br>\n的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5 支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat<br>\n技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>\n<p>JBoss与Tomcat的是完全开源的</p>\n<p>WebLogic与WebSphere都是对业内多种标准的全面支持，包括EJB、JSB、JMS、JDBC、XML和WML，使Web应用系统的实施更为简单，并且保护了投资，同时也使基于标准的解决方案的开发更加简便。</p>\n<h4> 扩展性的不同：</h4>\n<p>WebLogic和WebSphere都是以其高扩展的架构体系闻名于业内，包括客户机连接的共享、资源 pooling以及动态网页和EJB组件群集。</p>\n<h4> 应用范围的区别：</h4>\n<p>Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>\n<p>WebLogic和WebSphere是商业软件，功能齐全强大，主要应用于大型企业的大型项目。</p>\n<p>JBOSS 主要应用于EJB服务的中小型公司。</p>\n<h4> JBoss还具有如下六大优点：</h4>\n<p>1、JBoss是免费的，开放源代码J2EE的实现，它通过LGPL许可证进行发布。</p>\n<p>2、JBoss需要的内存和硬盘空间比较小。</p>\n<p>3、安装非常简单。先解压缩JBoss打包文件再配置一些环境变量就可以了。</p>\n<p>4、JBoss能够\"热部署\"，部署BEAN只是简单拷贝BEAN的JAR文件到部署路径下就可以了。如果没有加载就加载它；如果已经加载了就卸载掉，然后LOAD这个新的。</p>\n<p>5、JBoss与Web服务器在同一个Java虚拟机中运行，Servlet调用EJB不经过网络，从而大大提高运行效率，提升安全性能。</p>\n<p>6、用户可以直接实施J2EE-EAR，而不是以前分别实施EJB-JAR和Web-WAR，非常方便。</p>\n<p>JBoss的安装和配置可以直接拷贝使用，但是要改动 %JBoss-HOME%\\bin\\run.bat里JAVA-HOME的设置，改成本机JDK的目录。运行run.bat来启动JBoss</p>\n<h2> Weblogic</h2>\n<p>WebLogic是美国bea公司出品的一个application<br>\nserver确切的说是一个基于j2ee架构的中间件，webserver是用来构建网站的必要软件用来解析发布网页等功能，它是用纯java开发的。weblogic本来不是由bea发明的，是它从别人手中买过来，然后再加工扩展。目前weblogic在世界application<br>\nserver市场上占有最大的份额，其他还有象IBM的websphere，免费的tomcat、resin等中间件。</p>\n<p>BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java<br>\nEnterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>\n<p>BEA WebLogic Server拥有处理关键Web应用系统问题所需的性能 、可扩展性和高可用性。</p>\n<p>与BEA WebLogic Commerce ServerTM配合使用， BEA WebLogic Server可为部署适应性个性化电子商务应用系统提供完善的解决方案。</p>\n<p>BEA WebLogic Server具有开发和部署关键任务电子商务Web应用系统 所需的多种特色和优势</p>\n<p>WebLogic: WebLogic<br>\n是一套基于JAVA功能强大的电子商务套件，提供了许多功能强大的中间件以方便编程人员编写的JSP、SERVLET等电子商务应用，可以为企业提供一个完整的商务应用解决方案。不适合开发阶段，太慢了，适合于运行环境（收费）。</p>\n",
      "date_published": "2023-11-29T11:50:17.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "系统总体结构设计",
      "url": "https://ujava.cn/highfreq/overall.html",
      "id": "https://ujava.cn/highfreq/overall.html",
      "summary": "简介 系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。 一、系统设计的任务 系统设计的概念 系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。",
      "content_html": "<h2> 简介</h2>\n<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>\n<h2> 一、系统设计的任务</h2>\n<ol>\n<li>系统设计的概念</li>\n</ol>\n<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>\n<p>系统设计是开发人员进行的工作，他们将系统设计阶段得到的目标系统的逻辑模型转换为目标系统的物理模型，该阶段得到工作成果――系统设计说明书是下一个阶段系统实施的工作依据。</p>\n<ol start=\"2\">\n<li>系统设计的主要内容</li>\n</ol>\n<p>系统设计的主要任务是进行总体设计和详细设计。下面分别说明它们的具体内容。</p>\n<p>(1) 总体设计</p>\n<p>总体设计包括系统模块结构设计和计算机物理系统的配置方案设计。</p>\n<ol>\n<li>系统模块结构设计</li>\n</ol>\n<p>系统模块结构设计的任务是划分子系统，然后确定子系统的模块结构，并画出模块结构图。在这个过程中必须考虑以下几个问题：</p>\n<p>如何将一个系统划分成多个子系统；</p>\n<p>每个子系统如何划分成多个模块；</p>\n<p>如何确定子系统之间、模块之间传送的数据及其调用关系；</p>\n<p>如何评价并改进模块结构的质量。</p>\n<ol start=\"2\">\n<li>计算机物理系统配置方案设计</li>\n</ol>\n<p>在进行总体设计时，还要进行计算机物理系统具体配置方案的设计，要解决计算机软硬件系统的配置、通信网络系统的配置、机房设备的配置等问题。计算机物理系统具体配置方案要经过用户单位和领导部门的同意才可进行实施。</p>\n<p>开发管理信息系统的大量经验教训说明，选择计算机软硬件设备不能光看广告或资料介绍，必须进行充分的调查研究，最好应向使用过该软硬件设备的单位了解运行情况及优缺点，并征求有关专家的意见，然后进行论证，最后写出计算机物理系统配置方案报告。</p>\n<p>从我国的实际情况看，不少单位是先买计算机然后决定开发。这种不科学的、盲目的做法是不可取的，它会造成极大浪费。因为，计算机更新换代是非常快的，就是在开发初期和在开发的中后期系统实施阶段购买计算机设备，价格差别就会很大。因此，在开发管理信息系统过程中应在系统设计的总体设计阶段才具体设计计算机物理系统的配置方案。</p>\n<p>(2) 详细设计</p>\n<p>在总体设计基础上，第二步进行的是详细设计，主要有处理过程设计以确定每个模块内部的详细执行过程，包括局部数据组织、控制流、每一步的具体加工要求等，一般来说，处理过程模块详细设计的难度已不太大，关键是用一种合适的方式来描述每个模块的执行过程，常用的有流程图、问题分析图、IPO图和过程设计语言等；除了处理过程设计，还有代码设计、界面设计、数据库设计、输入输出设计等。</p>\n<p>(3) 编写系统设计说明书</p>\n<p>系统设计阶段的结果是系统设计说明书，它主要由模块结构图、模块说明书和其它详细设计的内容组成。</p>\n<h2> 系统设计的方法与工具</h2>\n<p>系统设计的工作复杂又细致，总体设计阶段需要进行系统模块结构设计，要将一个大系统分解成不同层次、多个模块组成的系统，在详细设计阶段要在模块结构设计的基础上，给出每个模块实现方法的细节，并对模块的输入、输出和处理过程作详细描述，以便在系统实施阶段进行程序设计时可以把这个描述直接“翻译”成用某种程序设计语言书写的程序。系统设计在技术上有相当的难度，为此需要有一定的设计方法和设计工具来指导。70年代以来，出现了多种设计方法，其中结构化设计方法是较为典型的方法，本章将对该设计方法进行论述并介绍几个常用的设计工具。</p>\n<h2> 一、结构化设计的方法</h2>\n<p>结构化设计（STRUCTURED DESIGN, 简称SD)<br>\n方法是使用最广的一种设计方法，由美国IBM公司的W·STEVENS、G·MYERS和·CONSTANTINE等人提出。该方法适合于软件系统的总体设计和详细设计，特别是将一个复杂的系统转换成模块化结构系统，该方法具有它的优势。在使用过程中可将结构化设计方法与结构化分析（SA)<br>\n方法及编程阶段的结构化程序设计方法(SP)前后衔接起来，SD方法具有以下特点：</p>\n<p>1．相对独立、功能单一的模块结构</p>\n<p>结构化设计的基本思想是将系统设计成由多个相对独立、功能单一的模块组成的结构。由于模块之间相对独立，每一模块就可以单独地被理解、编写、测试、排错和修改,从而有效地防止错误在模块之间扩散蔓延，提高了系统的质量(<br>\n可维护性、可靠性等)。因此，大大简化了系统研制开发的工作。</p>\n<p>2．“块内联系大、块间联系小”的模块性能标准</p>\n<p>“模块内部联系要大，模块之间联系要小”，这是结构化设计中衡量模块“相对独立”性能的标准。事实上，块内联系和块间联系是同一件事的两个方面。系统中各组成成分之间是有联系的，若把联系密切的成分组织在同一模块中，块内联系高了，块间联系自然就少了。反之，若把密切相关的一些组成成分分散在各个模块中，势必造成很高的块间联系，这将影响系统的可维护性。所以，在系统设计过程中一定要以结构化设计的模块性能标准为指导。</p>\n<p>3．采用模块结构图的描述方式</p>\n<p>结构化设计方法使用的描述方式是模块结构图。</p>\n<h2> 系统模块结构设计</h2>\n<p>总体设计的另外一个主要内容是合理地进行系统模块结构的分析和定义，将一个复杂的系统设计转为若干个子系统和一系列基本模块的设计，并通过模块结构图把分解的子系统和一个个模块按层次结构联系起来。下面来介绍如何进行模块的分解、如何从数据流图导出模块结构图以及模块结构图的改进。</p>\n<h4> 一、模块分解的原则和依据</h4>\n<p>系统逻辑模型中数据流图中的模块是逻辑处理模块，模型中没有说明模块的物理构成和实现途径，同时也看不出模块的层次分解关系，为此在系统结构设计中要将数据流图上的各个逻辑处理模块进一步分解，用模块结构图确定系统的层次结构关系，并将系统的逻辑模型转变为物理模型。</p>\n<ol>\n<li>“耦合小，内聚大”的基本原则</li>\n</ol>\n<p>在结构化设计中，采用自顶向下，逐步细化的方法将系统分解成为一些相对独立、功能单一的模块。如何度量模块之间的独立性呢？</p>\n<p>在一个管理信息系统中，系统的各组成部分之间总是存在着各种联系的，将系统或子系统划分成若干模块，则一个模块内部的联系就是块内联系，而穿越模块边界的联系就是块间联系。由于模块之间的互相联系越多，模块的独立性就越少，因此，引入模块耦合和内聚的概念。</p>\n<p>耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。</p>\n<p>内聚表示模块内部各成分之间的联系程度。</p>\n<p>一般说来，在系统中各模块的内聚越大，则模块间的耦合越小。但这种关系并不是绝对的。耦合小使得模块间尽可能相对独立，从而各模块可以单独开发和维护。内聚大使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚。</p>\n<ol start=\"2\">\n<li>对子系统或模块进行划分的依据</li>\n</ol>\n<p>一个合理的子系统或模块划分，应该是内部联系强，子系统或模块间尽可能独立，接口明确、简单，尽量适应用户的组织体系，有适当的共用性。也就是上面所说的“耦合小，内聚大”。按照结构化设计的思想，对模块或子系统进行划分的依据通常有以下几种：</p>\n<p>(1)按逻辑划分，把相类似的处理逻辑功能放在一个子系统或模块里。例如，把“对所有业务输入数据进行编辑”的功能放在一个子系统或模块里。那么不管是库存、还是财务，只要有业务输入数据都由这个子系统或模块来校错、编辑。</p>\n<p>(2)按时间划分，把要在同一时间段执行的各种处理结合成一个子系统或模块。</p>\n<p>(3)按过程划分，即按工作流程划分。从控制流程的角度看，同一子系统或模块的许多功能都应该是相关的。</p>\n<p>(4)按通信划分，把相互需要较多通讯的处理结合成一个子系统或模块。这样可减少子系统间或模块间的通讯，使接口简单。</p>\n<p>(5)按职能划分，即按管理的功能。例如，财务、物资、销售子系统，或输入记帐凭证、计算机优解子系统或模块等等。</p>\n<p>一般来说，按职能划分子系统，按逻辑划分模块的方式是比较合理和方便的</p>\n<h2> 详细设计</h2>\n<p>进行了系统的总体设计后即可在此基础上进行系统的详细设计了，即各种输入、输出、处理和数据存储等的详细设计。下面分别介绍详细设计的内容。</p>\n<h4> 一、代码设计</h4>\n<p>代码是用来表示事物名称、属性和状态等的符号。在管理信息系统中，代码是人和机器的共同语言，是系统进行信息分类、校对、统计和检索的依据。代码设计就是要设计出一套能为系统各部门公用的、优化的代码系统，这是实现计算机管理的一个前提条件。</p>\n<ol>\n<li>代码设计的原则</li>\n</ol>\n<p>代码设计是一项重要的工作，合理的编码结构是使管理信息系统具有生命力的重要因素。设计代码的基本原则是：</p>\n<p>(1) 具备唯一确定性。每一个代码都仅代表唯一的实体或属性。</p>\n<p>(2) 标准化与通用性。凡国家和主管部门对某些信息分类和代码有统一规定和要求的，则应采用标准形式的代码，以使其通用化。</p>\n<p>(3) 可扩充且易修改。要考虑今后的发展，为增加新代码留有余地。当某个代码在条件或代表的实体改变时，容易进行变更。</p>\n<p>(4) 短小精悍即选择最小值代码。代码的长度会影响所占据的内存空间、处理速度以及输入时的出错概率，因此要尽量短小。</p>\n<p>(5) 具有规律性、便于编码和识别。代码应具有逻辑性强，直观性好的特点，便于用户识别和记忆。</p>\n<ol start=\"2\">\n<li>分类方法</li>\n</ol>\n<p>目前最常用的分类方案有两种，一种是线分类方法，一种是面分类方法。在实际应用中根据具体情况各有其不同的用途。</p>\n<p>线分类方法：首先给定母项，然后下分若干子项，由对象的母项分大集合，由大集合确定小集合，最后落实到具体对象</p>\n<p>特点：结构清晰，容易识别和记忆，易查找；适应于手工系统；</p>\n<p>缺点：结构不灵活，柔性差。</p>\n<p>线分类时要掌握两个原则：唯一性和不交叉性。</p>\n<p>例：公司生产组织结构。</p>\n<p>面分类方法：它主要从面的角度来考虑分类</p>\n<p>面分类的特点：</p>\n<p>柔性好，面上的增、删、改很容易；</p>\n<p>可实现按任意组配面的信息检索，对机器处理有良好的适应性；</p>\n<p>缺点是不易直观识别，不便于记忆。</p>\n<p>系统设计报告</p>\n<p>系统设计阶段的成果是系统设计报告， 其主要是各种设计方案和设计图表，它是下一步系统实现的基础。</p>\n<h4> 一、系统设计的成果</h4>\n<p>系统设计阶段的成果归纳起来一般有 (点击这里观看“各开发环节之间的关系”动画演示)：</p>\n<p>1.系统总体结构图（包括总体结构图，子系统结构图，计算机流程图等）。</p>\n<p>2.系统设备配置图（系统设备配置图： 主要是计算机系统图，设备在各生产岗位的分布图，主机、网络、终端联系图等）。</p>\n<p>3.系统分布编码方案（分类方案、编码系统）。</p>\n<p>4.数据库结构图（DB的结构，主要指表与表之间的结构，表内部结构（字段、域、数据字典等）。</p>\n<p>5.HIPO图（层次化模块控制图、IPO图等等）。</p>\n<p>6.系统详细设计方案说明书。</p>\n<h2> 二、系统设计说明书的组成</h2>\n<ol>\n<li>引言</li>\n</ol>\n<p>(1) 摘要 系统的目标名称和功能等的说明</p>\n<p>(2) 背景</p>\n<ul>\n<li>项目开发者</li>\n<li>用户</li>\n<li>本项目和其它系统或机构的关系和联系</li>\n</ul>\n<p>(3) 系统环境与限制</p>\n<ul>\n<li>硬件、软件和运行环境方面的限制</li>\n<li>保密和安全的限制</li>\n<li>有关系统软件文本</li>\n<li>有关网络协议标准文本</li>\n</ul>\n<p>(4) 参考资料和专门术语说明</p>\n<h2> 2.系统设计方案</h2>\n<p>(1) 模块设计</p>\n<ul>\n<li>系统的模块结构图</li>\n<li>各个模块的IPO图(包括各模块的名称、功能、调用关系、局部数据项和详细的算法说明等)</li>\n</ul>\n<p>(2) 代码设计</p>\n<p>各类代码的类型、名称、功能、使用范围和使用要求等的设计说明书</p>\n<p>(3) 输入设计</p>\n<p>输入项目</p>\n<p>输入人员(指出所要求的输入操作人员的水平与技术专长，说明与输入数据有关的接口软件及其来源)</p>\n<p>主要功能要求(从满足正确、迅速、简单、经济、方便使用者等方面达到要求的说明)</p>\n<p>输入校验(关于各类输入数据的校验方法的说明)</p>\n<p>(4) 输出设计</p>\n<p>输出项目</p>\n<p>输出接受者</p>\n<p>输出要求(所用设备介质、输出格式、数值范围和精度要求等)</p>\n<p>(5) 文件(数据库)设计说明</p>\n<p>概述(目标、主要功能)</p>\n<p>需求规定(精度、有效性、时间要求及其它专门要求)</p>\n<p>运行环境要求(设备支撑软件，安全保密等要求)</p>\n<p>逻辑结构设计(有关文件及其记录、数据项的标识、定义、长度和它们之间的关系)</p>\n<p>物理结构设计(有关文件的存贮要求、访问方法、存贮单位、设计考虑和保密处理等)</p>\n<p>(6) 模型库和方法库设计(本系统所选用的数学模型和方法以及简要说明)</p>\n<p>(7) 安全保密设计</p>\n<p>(8) 物理系统配置方案报告</p>\n<p>硬件配置设计</p>\n<p>通信与网络配置设计</p>\n<p>软件配置设计</p>\n<p>机房配置设计</p>\n<p>(9) 系统实施方案及说明</p>\n<p>实施方案</p>\n<p>实施计划(包括工作任务的分解、进度安排和经费预算)</p>\n<p>实施方案的审批(说明经过审批的实施方案概况和审批人员的姓名)</p>\n<p>3.案例</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>模块名称</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>无线寻呼管理信息系统-系统设计说明书</td>\n<td>研究开发5-10万用户寻呼机管理信息系统，它可以进行普通寻呼服务；漫游寻呼服务；群呼服务；试机服务；定时服务；系统管理；运行管理。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>库存管理系统-系统设计说明书</td>\n<td>研发库存控制系统的主要目的:1）为顾客订货提供更好的服务；2）控制库存水平；3）决定向厂家订货的时间和批量。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>百货商店业务管理信息系统-系统设计</td>\n<td>实现登记、整理数据，处理核对顾客订货单；向经理提供各种业务统计报表；提供各级查询；销售、采购、会计各部门的业务数据处理实现自动化。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>铁道财务会计管理信息系统-系统设计</td>\n<td>运用系统的方法以计算机和现代通信技术为基本信息处理手段和工具的，能为全国铁道财务会计核算、管理、决策提供信息服务的人—机系统。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>高校选课辅助决策</td>\n<td>本选课系统能够使学生在INTERNET上自主、便捷、准确地进行全校性课程选择的一种软件。学生在选择选修课前，可以上网进行查询，当学生输入其学号与密码后，系统便调出其所有相关信息，包括已修课程、已修课程的成绩、专业培养计划、全校性可选课程，系统进行综合分析后，得到一些可行的方案，供选课学生参考，并提出合理建议。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>条形材料选材优化</td>\n<td>要制造器件,必须先制造一定的零件,而这些零件又由某种原材料截取而得到。例如：用某一种条形材料锯成数种需要的零件，求最少的用料数量。使用运筹学线性规划的思想和解决方法。</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2023-11-23T10:50:49.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计注意事项一",
      "url": "https://ujava.cn/highfreq/attention1.html",
      "id": "https://ujava.cn/highfreq/attention1.html",
      "summary": "简介 架构的本质 其实总结下来就一句话：架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。 分为三部分： 整体：部分的组成，强调合力。 规则：强调部分之前有关联关系，有规则，有约束。 通信：强调部分之间有往来，有交互。 img_18.png 架构的分类 实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。",
      "content_html": "<h2> 简介</h2>\n<h2> 架构的本质</h2>\n<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>\n<p>分为三部分：</p>\n<ul>\n<li>整体：部分的组成，强调合力。</li>\n<li>规则：强调部分之前有关联关系，有规则，有约束。</li>\n<li>通信：强调部分之间有往来，有交互。</li>\n</ul>\n<figure><figcaption>img_18.png</figcaption></figure>\n<h2> 架构的分类</h2>\n<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>\n<h2> 业务架构</h2>\n<p>业务架构是指企业或机构的业务逻辑、流程、组织结构等方面的设计。它着重于企业业务运营的需求和目标，将业务需求转化为技术解决方案。业务架构的设计需要考虑企业的战略规划、组织结构、业务流程、客户需求等多个方面。</p>\n<p>例如：一个银行的业务架构设计需要考虑银行的基本业务逻辑、流程和组织结构，如存款、贷款、投资、支付等，以及银行的安全性、可靠性和效率等方面的需求。</p>\n<h2> 应用架构</h2>\n<p>应用架构是指企业或机构的信息系统中的应用程序、系统、服务等方面的设计。它着重于解决企业业务运营中的具体问题，将业务需求转化为具体的应用程序。应用架构的设计需要考虑企业的业务需求、用户体验、系统性能、安全风险等多个方面。</p>\n<p>例如：一个电商网站的应用架构设计需要考虑用户购物、订单管理、库存管理、支付等多个应用程序的设计，以及这些应用程序之间的交互和集成。</p>\n<h2> 技术架构</h2>\n<p>技术架构是指企业或机构的信息系统中的技术实现、系统架构、软件设计等方面的设计。它着重于解决企业业务运营中的技术问题，如系统的稳定性、可扩展性、可维护性等。</p>\n<p>例如：一个电商网站的技术架构设计需要考虑系统的负载均衡、容错容灾、CDN缓存、自动化部署等多个方面的技术实现。</p>\n<h2> 数据架构</h2>\n<p>数据架构是指企业或机构的信息系统中的数据存储、数据处理、数据安全等方面的设计。它着重于解决企业业务运营中的数据问题，如数据的一致性、完整性、安全性等。</p>\n<p>例如：一个电商网站的数据架构设计需要考虑数据的分层存储、数据备份和恢复、数据加密和权限管理等多个方面的设计，以确保数据的安全和可靠性。</p>\n<h2> 架构设计要考虑的因素</h2>\n<p>架构设计过程中我们要考虑的因素，整体可以分为两大类，一类是功能性因素，一类是非功能性因素。</p>\n<h2> 功能性因素</h2>\n<p>无论什么架构设计，我们首先是要考虑必须满足我们的业务需求，否则我们的设计都是空中楼阁。功能需求会直接决定我们的业务架构设计。所以我们的架构必须完整性地，正确地对业务实现支撑。</p>\n<h2> 非功能性因素</h2>\n<p>满足了功能性因素以后，我们就得要考虑怎么能够稳定地，可靠地，可持续性地支持我们的业务功能，比如性能，可靠性，扩展性，兼容性等等。</p>\n<ul>\n<li>可靠性\n<ul>\n<li>为了更好的服务于功能，我们需要确保架构能够稳定、高效的运行。不会时不时的出现服务崩溃或者不可用的情况。</li>\n</ul>\n</li>\n<li>可用性\n<ul>\n<li>同样的，服务对外要始终处于可用的状态，即使单个服务实例出现问题，我们依然可以正常的对外提供服务。</li>\n</ul>\n</li>\n<li>扩展性\n<ul>\n<li>功能性需求不是一层不变的，尤其在当今盛行敏捷的时代，需求不是一次性提出的。我们需要对系统、服务的整体能力有全面的定位和把控。这就需要我们的架构在新的需求出现的时候，可以方便的进行扩展支持。</li>\n</ul>\n</li>\n<li>治理能力\n<ul>\n<li>好的架构一定是方便运营、管理和监控的。甚至微观到工程管理，代码一定是易于维护、扩展、协同的。</li>\n</ul>\n</li>\n<li>响应性能\n<ul>\n<li>一般的，功能性需求都会对性能有一定的预期。这个业务要我们在架构上做很多工作，比如读写分离、缓存、异步等等的介入，以满足整体架构的响应能力。</li>\n</ul>\n</li>\n</ul>\n<figure><figcaption>img_19.png</figcaption></figure>\n<h2> 设计原则</h2>\n<ul>\n<li>价值为王：系统架构设计应该以实现业务价值为目标，始终关注用户需求和业务场景，确保设计出的系统能够满足用户需求和业务场景，为企业创造价值。</li>\n<li>以终为始：在进行系统架构设计时，需要明确系统的目标和愿景，并以此为起点，进行设计和实现。以确保系统的设计和实现都是为了实现业务价值，满足用户需求。</li>\n<li>分治原则：将系统划分为多个子系统或模块，每个子系统或模块都可以独立地进行开发、测试、部署和维护。这样可以降低系统的复杂度，提高系统的可维护性和可扩展性。</li>\n<li>服务自治：每个服务都应该具备独立的能力，能够独立地进行开发、测试、部署和维护。这样可以提高服务的可用性和可靠性，降低系统的耦合度。</li>\n<li>拥抱变化：系统架构设计应该能够适应业务需求的变化和市场的变化，具备快速响应和灵活应变的能力。</li>\n<li>系统安全性：系统架构设计应该充分考虑系统的安全性，包括数据安全、应用安全、系统安全等方面，确保系统的安全性和稳定性。</li>\n<li>不作不死：系统架构设计应该遵循“最小化变更范围”原则，避免过度设计和复杂度的出现，从而提高系统的可维护性和可扩展性。</li>\n</ul>\n<h2> 常见的架构设计方案</h2>\n<p>之前比较流行的是MVC，MVC有很多的优点，但是缺点也不少：</p>\n<ul>\n<li>视图与控制器的连接过紧，视图如果不依赖控制器，那么它的应用就会十分有限，这妨碍了他们的独立。</li>\n<li>模型对视图数据的访问效率较低，工作量大，并且有一些高级的界面工具或构造器不支持MVC框架。</li>\n<li>MVC架构使得我们面向视图开发，但是视图的变化是不可控的，容易受到用户主观的影响。同时复杂系统必然存在纷繁复杂的依赖，依赖不可能存在于视图，最终表现为接口依赖。</li>\n</ul>\n<p>所以现在比较流行如下几种方案：</p>\n<figure><figcaption>img_20.png</figcaption></figure>\n<h2> 领域驱动架构</h2>\n<p>领域驱动设计是通过将软件实现与核心业务概念的演进紧密相连，从而实现复杂需求的软件开发方法。</p>\n<p>领域驱动设计包括三要素：</p>\n<ul>\n<li>专业知识：就是前期在与客户沟通需求过程中，学习到的关于业务方面的知识。 这类知识并不仅仅只是对需求的理解，更多的要思考业务需求实际要解决的是什么问题。</li>\n<li>抽象能力：一般指发现核心业务对象，简化问题空间的能力。</li>\n<li>细分问题：把业务问题细化为更小更容易处理的子问题。<br>\n领域驱动设计，使得我们不再用数据进行驱动，而是使用领域进行驱动。遇到问题，我们先进行领域上的划分和拆解。这个问题属于哪个问题域，或者需要拆解到哪些问题域里面去，然后再通过领域的组合以及依赖，完成最终问题的解决。</li>\n</ul>\n<h2> 微服务架构</h2>\n<p>微服务架构是一种软件开发架构，它将应用程序拆分成小型、独立的微服务，每个微服务都有自己的功能集，并运行在其独立的进程中。</p>\n<p>微服务架构有以下优点：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化。</li>\n<li>有利于各层逻辑的复用，如PetShop可经过简单的配置实现Sqlserver和Oracle之间的转换。</li>\n<li>扩展性强，不同层负责不同的层面，有利于系统的扩展和维护。</li>\n<li>安全性高，用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。</li>\n<li>项目结构更清楚，分工更明确，有利于后期的维护和升级。</li>\n</ul>\n<h2> 云原生架构</h2>\n<figure><figcaption>img_21.png</figcaption></figure>\n<p>云原生架构是一种创新的软件开发方法，专为充分利用云计算模型而设计。</p>\n<p>云原生架构通过结合使用云计算和各种云服务来创建具有更大可扩展性的可定制模块化基础架构，从而提高了团队的效率，生产力和协作能力。</p>\n<p>云原生架构的核心原则：</p>\n<ul>\n<li>云原生架构是一种设计方法，利用AWS等EC2，S3，Lambda等云服务来支持动态，敏捷的应用程序开发技术，这些技术采用模块化方法通过一套基于云的套件来构建，运行和更新软件微服务与整体应用程序基础架构。</li>\n<li>微服务和容器化通过简化云提供商之间的转移或独立地以不同的语言或框架部署服务而没有冲突或停机的情况，从而支持云本机应用程序的敏捷性和动态性。</li>\n<li>将微服务架构集成到应用程序开发中可支持协作，效率和生产力，因为DevOps团队能够同时独立处理应用程序的不同组件或实现新功能而又不牺牲稳定性。</li>\n</ul>\n<h2> DevOps架构</h2>\n<figure><figcaption>img_22.png</figcaption></figure>\n<p>DevOps架构，它旨在加强软件产品开发与交付过程中的协作、自动化、持续性和监控等方面，以实现更高效、更迅速和更可靠的软件交付。</p>\n<p>DevOps通常包括以下核心组成部分：</p>\n<ul>\n<li>持续集成：将代码频繁地集成到一个共享的代码库中，并对代码进行自动化测试，以确保代码质量和稳定性，并及时发现和解决错误。</li>\n<li>持续交付：通过自动化测试、构建、部署和运行环节，实现快速、可靠和可重复的软件发布，从而减少手动操作和人工干预带来的错误和风险。</li>\n<li>自动化运维：将基础设施的管理、配置和维护工作自动化，并将其作为代码、脚本或配置文件存储在版本控制系统中，以便快速搭建、复制和修改环境。</li>\n<li>容器化技术：使用容器化技术（如Docker）将应用程序和其依赖项打包成独立的、可移植的容器，在不同的环境中快速部署和运行。</li>\n<li>监控和日志分析：通过对软件运行时数据进行采集、储存、分析和可视化，监控系统状态、性能和安全等方面的指标，并及时发现和修复问题。</li>\n</ul>\n<h2> 大数据架构</h2>\n<figure><figcaption>img_23.png</figcaption></figure>\n<p>大数据架构是一种面向海量数据、高并发、高可靠、高性能的计算和存储系统架构，用于管理和处理大规模的结构化、半结构化和非结构化数据。它具有以下几个特点：</p>\n<ul>\n<li>高可扩展性：大数据架构应该能够轻松地扩展到海量数据和高并发请求下。</li>\n<li>高容错性：大数据架构应该在硬件、网络和软件故障等异常情况下保证系统稳定性。</li>\n<li>实时计算：大数据架构需要支持实时计算和流式处理，以满足复杂的业务场景。</li>\n<li>数据安全：大数据架构需要保证数据的机密性、完整性和可用性，避免数据泄露和损坏。</li>\n<li>成本效益：大数据架构应该充分考虑成本问题，尽可能利用开源技术和云平台来降低系统运维和资源开销。<br>\n比如常见的大数据架构包括<code>Hadoop、Spark、Storm、Kafka</code><br>\n等开源软件，它们可以被组合在一起形成一个完整的数据处理流水线。例如，Hadoop可以提供分布式文件系统HDFS和MapReduce计算模型，Spark可以提供内存计算和机器学习功能，Storm可以提供实时数据处理功能，Kafka可以提供高可靠的消息队列服务。使用这些开源软件和云平台，企业可以构建出适合自己场景的大数据处理系统，提升自身的业务竞争力。</li>\n</ul>\n",
      "date_published": "2023-11-17T11:45:50.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计注意事项二",
      "url": "https://ujava.cn/highfreq/attention2.html",
      "id": "https://ujava.cn/highfreq/attention2.html",
      "summary": "简介 一.设计原则 架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。 示例： 是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？ 是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？ 淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？",
      "content_html": "<h2> 简介</h2>\n<h2> 一.设计原则</h2>\n<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>\n<p>示例：</p>\n<ul>\n<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>\n<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>\n<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>\n</ul>\n<h4> 1.合适原则</h4>\n<blockquote>\n<p>合适优于业界领先。</p>\n</blockquote>\n<p>在进行架构设计的同时，需要考虑自身业务，而不是一味的去参照业界顶尖的规模，如：QQ、微信、淘宝架构。真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>\n<h4> 2.简单原则</h4>\n<blockquote>\n<p>简单优于复杂。</p>\n</blockquote>\n<p>软件架构设计是一门技术活，当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>\n<p>软件复杂度的体现，主要有以下两个方面：</p>\n<p>结构的复杂性<br>\n– 组成复杂系统的组件数量更多；<br>\n– 组件之间的关系也更加复杂。</p>\n<p>其问题主要有：</p>\n<ul>\n<li>（1）组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li>\n<li>（2）某个组件改动，会影响关联的所有组件。</li>\n<li>（3）定位一个复杂系统中的问题总是比简单系统更加困难。</li>\n</ul>\n<h4> 逻辑的复杂性</h4>\n<p>逻辑的复杂性来源于一个组件集中了太多的功能，修改协作困难；并且，其中某些业务还可能使用了一些复杂的算法，导致难以理解、修改困难。</p>\n<p>一个组件集中了太多功能，就会表现出一些逻辑复杂性的特征，为了解决这个问题，一般的手段是进行组件的拆分，但随着组件的细化，又会引入结构复杂性的一些特征，所以，在做结构设计的时候，需要权衡这两者。</p>\n<h4> 3.演化原则</h4>\n<blockquote>\n<p>演化优于一步到位。</p>\n</blockquote>\n<p>维基百科对“软件架构”的定义如下：</p>\n<blockquote>\n<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>\n</blockquote>\n<p>这个定义中，将建筑和软件架构做了一个比较，但是，两者之间是有一个本质区别的：对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。<br>\n也就是说，软件架构的本质是：软件架构需要根据业务发展不断变化，所以，我们在做软件架构设计的时候，不要试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>\n<p>架构设计的过程基本上可以总结为下面三个历程：</p>\n<ul>\n<li>首先，设计出来的架构要满足当时的业务需要。</li>\n<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。--<br>\n小重构</li>\n<li>最后，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。--<br>\n大重构</li>\n</ul>\n<p>我们在做架构设计的时候，切勿贪大求全，或者盲目的照搬大公司的做法，而是要牢记软件架构的本质（软件架构需要根据业务发展不断变化）。认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>\n",
      "date_published": "2023-11-17T11:45:50.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计实践经验",
      "url": "https://ujava.cn/highfreq/experience.html",
      "id": "https://ujava.cn/highfreq/experience.html",
      "summary": "简介 记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。 涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。 使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。 使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。 将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用 OAuth2.0 协议来实现多渠道认证。 账号系统在设计维度上一般主要有 登录方式、渠道。 合并登录方式 登录方式以手机号为中心 合并。 渠道分组，按渠道分组分区分服。 事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。 go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。 业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。 使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。 一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。 如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。 业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。 mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。( 例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择",
      "content_html": "<h2> 简介</h2>\n<ul>\n<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>\n<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>\n<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>\n<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>\n<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>\nOAuth2.0 协议来实现多渠道认证。\n<ul>\n<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>\n<li>合并登录方式 登录方式以手机号为中心 合并。</li>\n<li>渠道分组，按渠道分组分区分服。</li>\n</ul>\n</li>\n<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>\n<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>\n<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>\n<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>\n<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>\n<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>\n<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>\n<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>\n例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个操作相对比较耗费性能，要谨慎操作。在数据量超千万的表中进行释放，一定要保证cpu核数至少大于等于2。因为这时候会占用1core的资源全部用来处理。时长可能超过5min。</p>\n",
      "date_published": "2023-11-17T11:18:05.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "一致性Hash算法",
      "url": "https://ujava.cn/highfreq/hash.html",
      "id": "https://ujava.cn/highfreq/hash.html",
      "summary": "简介 在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。 本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。 产生背景 考虑这么一种场景： 我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？",
      "content_html": "<h2> 简介</h2>\n<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>\n<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>\n<h2> 产生背景</h2>\n<p>考虑这么一种场景：</p>\n<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>\n<p>我们可能首先想到的方案是：取模算法hash（key）% N，即：对 key 进行 hash 运算后取模，N 是机器的数量；</p>\n<p>这样，对 key 进行 hash 后的结果对 3 取模，得到的结果一定是 0、1 或者 2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题；</p>\n<figure><figcaption>img_7.png</figcaption></figure>\n<p>取模算法虽然使用简单，但对机器数量取模，在集群扩容和收缩时却有一定的局限性：因为在生产环境中根据业务量的大小，调整服务器数量是常有的事；</p>\n<p>而服务器数量 N 发生变化后hash（key）% N计算的结果也会随之变化！</p>\n<figure><figcaption>img_8.png</figcaption></figure>\n<p>比如：一个服务器节点挂了，计算公式从hash（key）% 3变成了hash（key）% 2，结果会发生变化，此时想要访问一个 key，这个 key 的缓存位置大概率会发生改变，那么之前缓存 key 的数据也会失去作用与意义；</p>\n<p>大量缓存在同一时间失效，造成缓存的雪崩，进而导致整个缓存系统的不可用，这基本上是不能接受的；</p>\n<p>为了解决优化上述情况，一致性 hash 算法应运而生~</p>\n<h2> 什么是一致性哈希算法</h2>\n<p>一致性哈希算法是一种用于分布式系统中的数据分片和负载均衡的算法。它将整个哈希空间划分为一个环，并且每个节点在这个环上都有一个对应的位置。当需要读写某个数据时，先将其进行哈希运算得到一个哈希值，然后根据这个哈希值在环上找到对应的节点，从而实现数据的定位。</p>\n<p>一致性哈希算法的优点在于：当新增或删除节点时，只会影响到环上的一小部分节点，因此不会像传统的哈希算法那样造成大量的数据迁移和重新分片。同时，由于节点数较多，请求可以被更好地平均分配，从而实现了负载均衡的效果。</p>\n<p>另外，一致性哈希算法还可以通过增加虚拟节点来解决节点不均衡的问题，从而进一步提高负载均衡的效果。</p>\n<h2> 一致性哈希算法原理</h2>\n<p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系；</p>\n<p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题；</p>\n<p>一致性 hash 算法本质上也是一种取模算法；</p>\n<p>不过，不同于上边按服务器数量取模，一致性 hash 是对固定值 2^32 取模；</p>\n<p>IPv4 的地址是 4 组 8 位 2 进制数组成，所以用 2^32 可以保证每个 IP 地址会有唯一的映射；</p>\n<ol>\n<li>hash 环<br>\n我们可以将这2^32个值抽象成一个圆环 ⭕️，圆环的正上方的点代表 0，顺时针排列，以此类推：1、2、3…直到2^32-1，而这个由 2 的 32 次方个点组成的圆环统称为hash环；</li>\n</ol>\n<figure><figcaption>img_9.png</figcaption></figure>\n<ol start=\"2\">\n<li>服务器映射到 hash 环<br>\n在对服务器进行映射时，使用hash（服务器ip）% 2^32，即：</li>\n</ol>\n<p>使用服务器 IP 地址进行 hash 计算，用哈希后的结果对2^32取模，结果一定是一个 0 到2^32-1之间的整数；</p>\n<p>而这个整数映射在 hash 环上的位置代表了一个服务器，依次将node0、node1、node2三个缓存服务器映射到 hash 环上；</p>\n<figure><figcaption>img_10.png</figcaption></figure>\n<ol start=\"3\">\n<li>对象 key 映射到服务器<br>\n在对对应的 Key 映射到具体的服务器时，需要首先计算 Key 的 Hash 值：hash（key）% 2^32；</li>\n</ol>\n<p>注：此处的 Hash 函数可以和之前计算服务器映射至 Hash 环的函数不同，只要保证取值范围和 Hash 环的范围相同即可（即：2^32）；</p>\n<p>将 Key 映射至服务器遵循下面的逻辑：</p>\n<p>从缓存对象 key 的位置开始，沿顺时针方向遇到的第一个服务器，便是当前对象将要缓存到的服务器；</p>\n<p>假设我们有 “semlinker”、“kakuqo”、“lolo”、“fer” 四个对象，分别简写为 o1、o2、o3 和 o4；</p>\n<p>首先，使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p>\n<figure><figcaption>img_11.png</figcaption></figure>\n<p>图中对象的映射关系如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同时 3 台缓存服务器，分别为 CS1、CS2 和 CS3：</p>\n<figure><figcaption>img_12.png</figcaption></figure>\n<p>则可知，各对象和服务器的映射关系如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>即：</p>\n<figure><figcaption>img_13.png</figcaption></figure>\n<p>以上便是一致性 Hash 的工作原理；</p>\n<blockquote>\n<p>可以看到，一致性 Hash 就是：将原本单个点的 Hash 映射，转变为了在一个环上的某个片段上的映射！</p>\n</blockquote>\n<h2> 服务器扩缩容场景</h2>\n<ol>\n<li>服务器减少</li>\n</ol>\n<p>假设 CS3 服务器出现故障导致服务下线，这时原本存储于 CS3 服务器的对象 o4，需要被重新分配至 CS2 服务器，其它对象仍存储在原有的机器上：</p>\n<figure><figcaption>img_14.png</figcaption></figure>\n<p>此时受影响的数据只有 CS2 和 CS3 服务器之间的部分数据！</p>\n<ol start=\"2\">\n<li>服务器增加</li>\n</ol>\n<p>假如业务量激增，我们需要增加一台服务器 CS4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p>\n<figure><figcaption>img_15.png</figcaption></figure>\n<p>此时，只有 t1 和 t2 服务器之间的部分对象需要重新分配；</p>\n<p>在以上示例中只有 o3 对象需要重新分配，即它被重新到 CS4 服务器；</p>\n<p>在前面我们已经说过：如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配！</p>\n<h2> 数据偏斜&amp;服务器性能平衡问题</h2>\n<ol>\n<li>引出问题</li>\n</ol>\n<p>在上面给出的例子中，各个服务器几乎是平均被均摊到 Hash 环上；</p>\n<p>但是在实际场景中很难选取到一个 Hash 函数这么完美的将各个服务器散列到 Hash 环上；</p>\n<p>此时，在服务器节点数量太少的情况下，很容易因为节点分布不均匀而造成数据倾斜问题；</p>\n<p>如下图被缓存的对象大部分缓存在node-4服务器上，导致其他节点资源浪费，系统压力大部分集中在node-4节点上，这样的集群是非常不健康的：</p>\n<figure><figcaption>img_16.png</figcaption></figure>\n<p>同时，还有另一个问题：</p>\n<p>在上面新增服务器 CS4 时，CS4 只分担了 CS1 服务器的负载，服务器 CS2 和 CS3 并没有因为 CS4 服务器的加入而减少负载压力；如果 CS4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的；</p>\n<ol start=\"2\">\n<li>虚拟节点</li>\n</ol>\n<p>针对上面的问题，我们可以通过：引入虚拟节点来解决负载不均衡的问题：</p>\n<p>即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器；</p>\n<p>如下图所示：</p>\n<figure><figcaption>img_17.png</figcaption></figure>\n<p>在图中：o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示实际的物理服务器；</p>\n<ol start=\"3\">\n<li>虚拟节点的计算</li>\n</ol>\n<p>虚拟节点的 hash 计算通常可以采用：对应节点的 IP 地址加数字编号后缀 hash（10.24.23.227#1) 的方式；</p>\n<p>举个例子，node-1 节点 IP 为 10.24.23.227，正常计算node-1的 hash 值：</p>\n<ul>\n<li>\n<p>hash（10.24.23.227#1）% 2^32<br>\n假设我们给 node-1 设置三个虚拟节点，node-1#1、node-1#2、node-1#3，对它们进行 hash 后取模：</p>\n</li>\n<li>\n<p>hash（10.24.23.227#1）% 2^32</p>\n</li>\n<li>\n<p>hash（10.24.23.227#2）% 2^32</p>\n</li>\n<li>\n<p>hash（10.24.23.227#3）% 2^32</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>分配的虚拟节点个数越多，映射在 hash 环上才会越趋于均匀，节点太少的话很难看出效果；</li>\n<li>引入虚拟节点的同时也增加了新的问题，要做虚拟节点和真实节点间的映射，对象key-&gt;虚拟节点-&gt;实际节点之间的转换；</li>\n</ul>\n<h2> 使用场景</h2>\n<p>一致性 hash 在分布式系统中应该是实现负载均衡的首选算法，它的实现比较灵活，既可以在客户端实现，也可以在中间件上实现，比如日常使用较多的缓存中间件memcached和redis集群都有用到它；</p>\n<p>memcached 的集群比较特殊，严格来说它只能算是伪集群，因为它的服务器之间不能通信，请求的分发路由完全靠客户端来的计算出缓存对象应该落在哪个服务器上，而它的路由算法用的就是一致性 hash；</p>\n<p>还有 redis 集群中 hash 槽的概念，虽然实现不尽相同，但思想万变不离其宗，看完本篇的一致性 hash，你再去理解 redis 槽位就轻松多了；</p>\n<p>其它的应用场景还有很多：</p>\n<ul>\n<li>RPC框架Dubbo用来选择服务提供者</li>\n<li>分布式关系数据库分库分表：数据与节点的映射关系</li>\n<li>LVS负载均衡调度器</li>\n<li>……</li>\n</ul>\n<h2> 小结</h2>\n<p>一致性哈希是一种用于分布式系统中数据负载均衡的算法。在分布式系统中，多个服务器节点需要负责处理不同的请求，但由于每个请求的负载大小不同，因此会导致服务器节点的负载不平衡，一些节点可能会过度负载，而另一些节点则占用较少的资源。这就需要一种算法来平衡各个节点之间的负载。</p>\n<p>一致性哈希算法通过将服务器节点和请求都映射到一个固定的哈希环上，使得每个请求可以被映射到一个特定的服务器节点上。同时，在哈希环上沿顺时针方向查找离该请求最近的服务器节点，并将该请求路由到该节点上，从而实现了负载均衡。一致性哈希算法还支持添加或删除服务器节点，同时保持大部分请求仍然能够映射到原来的节点上，以避免数据迁移带来的复杂性和成本。</p>\n<p>总之，一致性哈希算法可以提高分布式系统的可扩展性和可靠性，减少系统崩溃等问题的风险，从而更好地满足大规模应用所需的高吞吐量和低延迟要求。</p>\n",
      "date_published": "2023-11-17T10:57:00.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "系统设计原则",
      "url": "https://ujava.cn/highfreq/design.html",
      "id": "https://ujava.cn/highfreq/design.html",
      "summary": "简介 好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。 业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。 在设计系统时，应该多思考墨菲定律: 任何事情都没有表面看起来那么简单 所有的事情都会比你预计的时间长 可能会出错的事一定会出错 如果你担心某种情况发生，那么它就更有可能发生",
      "content_html": "<h2> 简介</h2>\n<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>\n<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>\n<p>在设计系统时，应该多思考墨菲定律:</p>\n<ul>\n<li>任何事情都没有表面看起来那么简单</li>\n<li>所有的事情都会比你预计的时间长</li>\n<li>可能会出错的事一定会出错</li>\n<li>如果你担心某种情况发生，那么它就更有可能发生</li>\n</ul>\n<p>在系统划分时，也要思考康威定律:</p>\n<ul>\n<li>系统架构是公司组织架构的反映</li>\n<li>应该按照业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚/低耦合，减少沟通成本</li>\n<li>如果沟通出现问题，那么就应该考虑进行系统和组织架构的调整</li>\n<li>在合适时机进行系统拆分，不要一开始就把系统/服务拆得非常细，虽然闭环，但是每个人维护的系统多，维护成本高该处使用的url网络请求的数据。</li>\n</ul>\n<h2> 一、系统的技术设计原则</h2>\n<h3> 1.1.高并发原则</h3>\n<h4> 1.1.1.无状态</h4>\n<p>如果设计的是无状态的，那么应用比较容易进行水平扩展。</p>\n<p>实际生产环境可能是这样的：应用无状态，配置文件有状态。比如，不同的机房需要读取不同的数据源，此时，就需要通过配置文件或配置中心指定。比如后台系统使用session共享机制保证分布式部署。</p>\n<h4> 1.1.2.拆分</h4>\n<p>在系统设计时，要考虑到系统是否做拆分。如果资源有限，并且用户并没有那么多，可以做一个大而全的系统。</p>\n<p>而高并发的应用，通常是要做拆分的。拆分可以依据多个维度：</p>\n<ul>\n<li>系统维度 ：如订单、库存、商品系统等</li>\n<li>功能维度 ：如，对登录系统再拆分，划分为 ：验证码登录、微信登录、密码登录等功能。</li>\n<li>读写维度 ：针对读写再做分离，读服务可以使用缓存、写服务使用分库分表。</li>\n</ul>\n<h4> 1.1.3.服务化</h4>\n<p>首先判断单点服务是否可以满足。如果不能满足，集群可以吗？使用Nginx做负载均衡是否可以解决？</p>\n<p>服务越来越多，是否要使用服务自动注册与发现？某些服务访问量太大，导致整个系统不可用，要不要上服务降级和限流？哪些是主要服务？</p>\n<h4> 1.1.4.消息队列</h4>\n<p>消息队列的作用有三个 ：削峰、解耦、异步。</p>\n<p>使用消息队列可以实现服务解耦（一对多消费）、异步处理、流量削峰/缓冲等。但是订阅者太多，那么订阅单个消息队列就会成为瓶颈，此时需要考虑对消息队列进行多个镜像复制。</p>\n<p>使用消息队列时，需要注意消息丢失、重复接收的场景。这对于不能容忍生产失败的业务场景来说，一定要做好后续的数据处理工作，比如持久化数据同时要增加日志、报警等，或者在生产失败后发送http请求来保证成功。还有消息重复问题，特别是一些分布式消息队列，出于对性能和开销的考虑，在一些场景下会发送消息重复接收，需要在代码层面进行防重处理。</p>\n<h4> 1.1.5.缓存</h4>\n<p>缓存对读服务来说，是扛流量的必选技术。不同的场景缓存不同的信息，以解决不同的问题：</p>\n<ul>\n<li>浏览器端缓存</li>\n<li>客户端缓存</li>\n<li>CDN缓存</li>\n<li>接入层缓存: 使用Nginx做一层缓存</li>\n<li>应用层缓存</li>\n<li>分布式缓存</li>\n<li>异步与并发:某些资源实时性没那么高，可以考虑使用异步加载，如用户评价、商品打分这种。获取多个资源时，采用并发的方式获取，可以大大的加快访问速度。</li>\n</ul>\n<h4> 1.1.6.数据异构</h4>\n<p>所谓数据异构，是把数据按需（数据结构、存取方式、存取形式）异地构建存储。比如将mysql里面的数据缓存到redis里面去，就是一种数据异构的方式。</p>\n<p>分库分表中有一个最为常见的场景，为了提升数据库的查询能力，我们都会对数据库做分库分表操作。比如订单库，开始的时候是按照订单ID维度去分库分表，那么后来的业务需求按照商家维度去查询。相同的数据需要做多种异构可以使用MQ机制接收数据的变更，然后存储到合适的存储引擎，如订单id纬度的分库分表、商家纬度的分库分表、用户纬度的分库分表、redis、Elasticsearch等。</p>\n<p>另外，还需要考虑对历史订单数据进行归档处理，以提升服务的性能和稳定性。而有些数据异构的意义不大，如库存架构，可以考虑异步加载，或者合并并发请求。</p>\n<p>总结起来大概有以下几种场景：</p>\n<ul>\n<li>\n<p>数据库镜像</p>\n</li>\n<li>\n<p>数据库实时备份</p>\n</li>\n<li>\n<p>多级索引</p>\n</li>\n<li>\n<p>search build（比如分库分表后的多维度数据查询）</p>\n</li>\n<li>\n<p>业务cache刷新</p>\n</li>\n<li>\n<p>价格、库存变化等重要业务消息<br>\n常见的异构方式：</p>\n</li>\n<li>\n<p>完全克隆。做数据备份。将数据库A，全部拷贝一份到数据库B，这样的使用场景是离线统计跑任务脚本的时候可以。缺点也很突出，不适用于持续增长的数据。</p>\n</li>\n<li>\n<p>binlog方式。比如使用比较广泛的canal是基于mysql数据库binlog的增量订阅和消费组件。订阅mysql的binlog日志，消费这些日志做主从同步、缓存更新。</p>\n</li>\n<li>\n<p>MQ方式。业务数据写入DB的同时，也发送MQ一份，也就是业务里面实现双写，消费MQ的数据做各种异构处理。这种方式比较简单，但也很难保证数据一致性，对简单的业务场景可以采用这种方式。</p>\n</li>\n</ul>\n<h3> 1.2.高可用原则</h3>\n<h4> 1.2.1.降级</h4>\n<p>对于一个高可用服务，很重要的一个设计就是降级开关，提前写好降级逻辑。</p>\n<p>可以手动降级，也可以自动降级。自动降级触发的条件可以使用：超时的请求数超过阈值、异常的请求数超过阈值时。阈值具体设置为多少，通过压测初步确认，上线观察后，再次调整。</p>\n<p>降级的手段：停止读数据库、准确结果转为近似结果、使用静态结果、同步转异步、功能裁剪、禁止写（高峰期减少不必要的写）、分用户降级、工作量证明POW(<br>\n验证码、数学题、拼图、滑块)。</p>\n<p>主要依据如下思路：</p>\n<ul>\n<li>开关集中化管理：通过推送机制把开关推送到各个应用。</li>\n<li>可降级的多级读服务：可以指定服务调用降级为只读本地缓存、只读分布式缓存、只读默认数据。</li>\n<li>开关前置化: 如架构是Nginx—&gt;Apache，可以将开关前置到Nginx接入层，在Nginx层做开关，请求流量汇源后端应用或者只是一小部分流量回源</li>\n<li>业务降级：当高并发流量来袭，保证核心业务是正常的，并保障数据最终一致性即可。这样就把一些同步调用改成异步调用，优先处理高优先级数据或特殊特征的数据，合理分配进入系统的流量，以保障系统可用。</li>\n</ul>\n<h4> 1.2.2.限流</h4>\n<p>当监控发现外部流量超过阈值或内部资源使用达到阈值（通过压测、上线观察、调整）时，告知各系统限流打开。</p>\n<p>限流的目的是防止恶意请求流量，或者防止流量超出系统峰值。思路如下：</p>\n<ul>\n<li>\n<p>基于请求的限流：</p>\n<ul>\n<li>限制请求总量。如腾讯会议最多500人。</li>\n<li>限制时间量。如一个时间窗口内最多接受100个请求。</li>\n</ul>\n</li>\n<li>\n<p>基于关键资源的限流：</p>\n<ul>\n<li>统计连接数、线程数、cup等硬件参数。难点是如何确定哪些是关键资源、阈值是多少。</li>\n<li>使用池化技术：线程池、连接池；使用队列排队；</li>\n</ul>\n</li>\n</ul>\n<p>相关限流的算法：</p>\n<ul>\n<li>滑动时间窗口：有突刺</li>\n<li>漏桶: 请求进入队列的速度不受限制，但是超过队列的大小就拒绝，请求出队列的速度固定。请求会匀速出队列。</li>\n<li>令牌桶：系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。有突刺。<br>\n有些大流量是正常的用户，这种是要临时的水平扩容。</li>\n</ul>\n<p>原则是限制流量穿透到后端薄弱的应用层</p>\n<h4> 1.2.3.熔断</h4>\n<p>熔断发生的三个必要条件，缺一不可，必须全部满足才能开启 hystrix 的熔断功能：</p>\n<ul>\n<li>\n<p>有一个统计的时间周期，滚动窗口；如1000毫秒</p>\n</li>\n<li>\n<p>请求次数必须达到一定数量；如20次</p>\n</li>\n<li>\n<p>失败率达到阈值；如50%<br>\n熔断器的三个状态：</p>\n</li>\n<li>\n<p>关闭状态。关闭状态时用户请求是可以到达服务提供方的。</p>\n</li>\n<li>\n<p>开启状态。开启状态时用户请求是不能到达服务提供方的，直接会走降级方法。</p>\n</li>\n<li></li>\n</ul>\n<p>半开状态。当熔断器开启时，过一段时间后，熔断器就会由开启状态变成半开状态。半开状态的熔断器是可以接受用户请求并把请求传递给服务提供方的，这时候如果远程调用返回成功，那么熔断器就会有半开状态变成关闭状态，反之，如果调用失败，熔断器就会有半开状态变成开启状态。<br>\nHystrix功能建议在并发比较高的方法上使用，并不是所有方法都得使用的。</p>\n<p>Sentinel的熔断策略是根据响应时间，响应时间超过阈值，熔断开关打开。</p>\n<h4> 1.2.4.恢复</h4>\n<p>撤出限流、消除降级、关闭熔断</p>\n<p>熔断使用半开状态，完成吞吐量爬升、缓存预热。</p>\n<p>灰度发布，限流阈值逐步提升。</p>\n<h4> 1.2.5.隔离</h4>\n<ul>\n<li>数据隔离：数据按照重要性排序、分库</li>\n<li>机器隔离：给重要的用户单独配置服务器，用用户标识去路由</li>\n<li>线程池隔离：线程池分配。hystrix</li>\n<li>信号量隔离：计数器。hystrix</li>\n<li>集群隔离：服务分组（注册中心）、秒杀</li>\n<li>机房隔离：3个服务。局域网IP、路由。</li>\n<li>读写隔离：主从</li>\n<li>动静隔离：识别静态资源。nginx CDN</li>\n<li>爬虫隔离：对IP的访问频率</li>\n<li>冷热隔离：秒杀、抢购。读：缓存；写：缓存+队列</li>\n</ul>\n<h4> 1.2.6.异地多活</h4>\n<p>异地机房部署相同的服务，同时对外提供服务（不是备份）。防止因为停电、火灾、水灾、地震、战争等问题导致服务不可用。</p>\n<p>异地多活通常考虑RTT(round trip time):网络请求一个来回消耗的传输时间。光纤光速计算 300000 KM/s，两个机房如果一个在上海，一个在新疆，隔5000KM，<br>\nrtt = 300000 / 5000 * 2 = 120毫秒的往返时延。</p>\n<p>多活要求：</p>\n<ul>\n<li>\n<p>请求任何一个节点，都能正常响应</p>\n</li>\n<li>\n<p>某些系统故障，用户访问其他系统也能访问<br>\n分类：</p>\n</li>\n<li>\n<p>同城异区：距离较近，可以防止停电、机房起火</p>\n</li>\n<li>\n<p>跨域异地：距离较近，可以防止停电、机房起火、火灾、水灾、地震。</p>\n</li>\n<li>\n<p>跨国异地（隔离）：延迟，已经无法让系统提供服务了。通常在异国开展业务，数据和服务就放在异国，和国内数据是隔离的。<br>\n异地多活容易出现数据不一致问题，要保证核心业务的多活。如用户系统有注册、登陆、修改用户信息等功能，保证正常注册、登陆多活，修改用户信息可以根据时间合并数据。</p>\n</li>\n</ul>\n<h4> 1.2.7.可回滚</h4>\n<p>灰度发布。版本化机制，当程序出错时，回滚到上一个版本。</p>\n<h2> 二、业务设计原则</h2>\n<h3> 2.1.防重、幂等</h3>\n<p>重复提交业务，消息中间件重复消费消息。使用分布式锁、数据库唯一键等保证。</p>\n<h3> 2.2.模块复用</h3>\n<p>相同的功能只开发一次，模块化。不要到处拷贝相同的代码。</p>\n<h3> 2.3.可追溯</h3>\n<p>可以快速追踪到问题涉及的这个数据链路，快速定位问题。traceId</p>\n<h3> 2.4.反馈原则</h3>\n<p>给出精确友好的结果反馈。如http接口调用异常时尽量给出精确的异常原因，降低内外部沟通成本。</p>\n<h3> 2.5.流程可定义</h3>\n<p>相关工作有明确的流程规范</p>\n<h3> 2.6.系统审批化</h3>\n<p>系统变更需要审批</p>\n<h3> 2.7.文档和注释</h3>\n<p>完善文档和注释</p>\n<h3> 2.8.备份</h3>\n<ul>\n<li>代码备份：git、分支</li>\n<li>数据备份：运维备份，操作记录备份。</li>\n<li>人员备份：不因个人离职导致项目停滞。</li>\n</ul>\n<h3> 2.9.规范</h3>\n<p>制定规范，定期review。</p>\n<h2> 三、系统性能常见指标</h2>\n<h3> 3.1.响应时间（Response time）</h3>\n<p>响应时间就是用户感受软件系统为其服务所耗费的时间，对于网站系统来说，响应时间就是从点击了一个页面计时开始，到这个页面完全在浏览器里展现计时结束的这一段时间间隔，看起来很简单，但其实在这段响应时间内，软件系统在幕后经过了一系列的处理工作，贯穿了整个系统节点。</p>\n<p>根据“管辖区域”不同，响应时间可以细分为：</p>\n<ul>\n<li>服务器端响应时间这个时间指的是服务器完成交易请求执行的时间，不包括客户端到服务器端的反应（请求和耗费在网络上的通信时间），这个服务器端响应时间可以度量服务器的处理能力。</li>\n<li>网络响应时间，这是网络硬件传输交易请求和交易结果所耗费的时间。</li>\n<li>客户端响应时间，这是客户端在构建请求和展现交易结果时所耗费的时间，对于普通的瘦客户端Web应用来说，这个时间很短，通常可以忽略不计；但是对于胖客户端Web应用来说，比如Java<br>\napplet、AJAX，由于客户端内嵌了大量的逻辑处理，耗费的时间有可能很长，从而成为系统的瓶颈，这是要注意的一个地方。<br>\n那么客户感受的响应时间其实是等于客户端响应时间+服务器端响应时间+网络响应时间。细分的目的是为了方便定位性能瓶颈出现在哪个节点上。</li>\n</ul>\n<h3> 3.2.吞吐量（Throughput）</h3>\n<p>吞吐量是我们常见的一个软件性能指标，对于软件系统来说，“吞”进去的是请求，“吐”出来的是结果，而吞吐量反映的就是软件系统的“饭量”，也就是系统的处理能力，具体说来，就是指软件系统在每单位时间内能处理多少个事务/请求/单位数据等。但它的定义比较灵活，在不同的场景下有不同的诠释，比如数据库的吞吐量指的是单位时间内，不同SQL语句的执行数量；而网络的吞吐量指的是单位时间内在网络上传输的数据流量。吞吐量的大小由负载（如用户的数量）或行为方式来决定。举个例子，下载文件比浏览网页需要更高的网络吞吐量。</p>\n<h3> 3.3.资源使用率（Resource utilization）</h3>\n<p>常见的资源有：CPU占用率、内存使用率、磁盘I/O、网络I/O。</p>\n<h3> 3.4.点击数（Hits per second）</h3>\n<p>点击数是衡量Web Server处理能力的一个很有用的指标。需要明确的是：点击数不是我们通常理解的用户鼠标点击次数，而是按照客户端向Web<br>\nServer发起了多少次http请求计算的，一次鼠标可能触发多个http请求，这需要结合具体的Web系统实现来计算。</p>\n<h3> 3.3.并发用户数（Concurrent users）</h3>\n<p>并发用户数用来度量服务器并发容量和同步协调能力。在客户端指一批用户同时执行一个操作。并发数反映了软件系统的并发处理能力，和吞吐量不同的是，它大多是占用套接字、句柄等操作系统资源。</p>\n<p>另外，度量软件系统的性能指标还有系统恢复时间等，其实凡是用户有关资源和时间的要求都可以被视作性能指标，都可以作为软件系统的度量，而性能测试就是为了验证这些性能指标是否被满足。</p>\n<h2> 四、总结</h2>\n<p>一个系统的设计，不仅需要考虑实现业务功能，还要保证系统高并发、高可用等。在系统容量规划（流量、容量等）、SLA制定（吞吐量、响应时间、可用性、降级方案等）、压测方案（线上、test等）、监控报警（机器负载、响应时间、可用率等）、应急预案（容灾、降级、限流、隔离、切流量、可回滚）等方面，也要有一些原则来进行设计。</p>\n",
      "date_published": "2023-11-17T10:34:42.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计时可使用的工具",
      "url": "https://ujava.cn/highfreq/tool.html",
      "id": "https://ujava.cn/highfreq/tool.html",
      "summary": "简介 JUnit test JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。 EclEmma EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。 Checkstyle",
      "content_html": "<h2> 简介</h2>\n<h2> JUnit test</h2>\n<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>\n<h2> EclEmma</h2>\n<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>\n<h2> Checkstyle</h2>\n<p>Checkstyle是一个静态代码分析工具，用于帮助开发团队遵循一致的编码规范。它可以检查代码中的格式错误、命名约定、代码风格和其他潜在的问题，并生成相应的报告。通过使用Checkstyle，团队可以提高代码质量、可读性和可维护性。</p>\n<h2> SpotBugs</h2>\n<p>SpotBugs是一个静态代码分析工具，用于检测Java程序中的潜在缺陷和错误。它可以发现常见的编程错误、空指针引用、资源泄漏、线程安全问题等。SpotBugs提供了详细的报告和建议，帮助开发人员改进代码质量和可靠性。</p>\n<h2> VisualVM</h2>\n<p>VisualVM是一个功能强大的Java虚拟机（JVM）监视和性能分析工具。它可以显示应用程序的内存使用情况、线程活动、垃圾收集行为等，并提供实时的性能监控和分析。VisualVM还支持插件和扩展，可以与其他工具集成以提供更丰富的功能。</p>\n<h2> Git</h2>\n<p>版本控制系统，用于管理和跟踪源代码的变更。可以查看历史提交记录、分支、合并代码等。</p>\n<h2> Eclipse Memory Analyzer</h2>\n<p>Eclipse Memory Analyzer (MAT) 是一个用于分析 Java<br>\n应用程序的内存使用情况的工具。它可以通过分析堆转储文件（例如通过jmap生成的文件）来查找内存泄漏、大对象、过多的对象等问题，而无需执行正在开发的软件代码。MAT提供了强大的内存分析功能，可以帮助开发人员定位和解决内存相关的问题。</p>\n<h2> JMap</h2>\n<p>jmap是Java虚拟机（JVM）的一个诊断工具，它可以生成Java堆转储文件，其中包含了Java应用程序在运行时的内存使用情况。通过使用jmap生成堆转储文件，可以将其提供给Eclipse<br>\nMemory Analyzer（MAT）等工具进行进一步的分析，而无需执行正在开发的软件代码。</p>\n<h2> Jenkins</h2>\n<p>jenkins：一个开源的持续集成和交付工具，可自动构建、测试和部署软件项目。它可以设置为监控代码库的变更，并在发生变更时触发自动构建和测试过程。</p>\n<h2> 自动化测试架构</h2>\n<h4> TestNG + Mocktio</h4>\n<p>JUnit是Java单元测试的一站式解决方案，它把测试驱动的开发思想介绍给了Java开发人员，并教会他们如何有效地编写单元测试。但是在过去的几年中，JUnit的改进并不大，所以为当前复杂的环境编写测试任务已经变得越来越困难，即JUnit必须与其他一些补充性测试框架集成起来。TestNG是一个测试Java应用程序的新框架，功能十分强大。</p>\n<p>EasyMock和Mockito可以极大地简化单元测试的编写过程，因而被许多程序员应用在日常工作中。这两个工具无法实现对静态函数、构造函数、私有函数、Final函数和系统函数的模拟，而这些函数在大型系统中必不可少。</p>\n<h4> JUnit + JMock</h4>\n<p>单元测试一般只测试某一个功能，但是由于类之间的耦合，往往难以把功能隔离开来。例如，想要测试某个业务逻辑处理数据的功能，但是数据是从Database取回的，这就涉及DAO层的类调用。但是很多时候，你不想让单元测试函数去访问数据库（，而是希望有一个假的DAO类刚好可以返回你需要的测试数据。此时即可使用Mock，它的作用是在单元测试里模拟类的行为和状态。</p>\n<p>JMock与Mocktio都是提供Mock功能的框架。</p>\n<h2> 自动化持续集成部署架构</h2>\n<h4> Git/SVN + Jenkins</h4>\n<p>Git和SVN都是版本控制器。Git是分布式管理的版本控制器，通常被用于分布式模式，也就是说，每个开发人员从中心版本库或服务器上检出代码后都会在自己的机器上克隆一个与中心版本库一模一样的本地版本库。而SVN是集中式管理的版本控制器。</p>\n<p>Jenkins是一个开源的、提供友好操作界面的持续集成工具，主要用于持续、自动地构建或测试软件项目、监控外部任务的运行。Jenkins是用Java语言编写的，既可以在Tomcat等流行的Servlet容器中运行，也可以独立运行。Jenkins通常与版本管理工具（SCM）和构建工具结合使用。</p>\n<p>常用的版本控制工具有SVN和Git等，常用的构建工具有Maven、Ant和Gradle等。</p>\n<p>Jenkins涉及持续集成（Continuous Integration，CI）和持续交付（Continuous Delivery，CD）。持续集成强调开发人员在提交新代码之后，立刻进行构建和（单元）测试。根据测试结果，确定新代码和原有代码能否正确地集成在一起。持续交付是在持续集成的基础上，将集成后的代码部署到类生产环境中。</p>\n<p>Jenkins可以把FTP、SVN或Git中存储的Java程序持续构建到生产与测试环境中。也就是说，在微服务分布式环境下，不需要每次更新都在各个服务器上上传代码。一个项目的服务器越多，Jenkins的优势越明显。与Jenkins类似的软件有Travis CI等，不再赘述。</p>\n<h4> Puppet</h4>\n<p>Puppet是Linux、UNIX和Windows操作系统的自动管理引擎，它根据集中式规范执行管理任务（例如，添加用户、安装软件包和更新服务器配置等）。Puppet的简单陈述规范语言的能力提供了强大的代理服务，制定了主机之间的相似之处，同时使它们能够提供尽可能具体的、必要的管理内容，它依赖的先决条件和对象之间的关系清楚且明确。</p>\n<p>Puppet主要解决的是环境部署的难点，例如，需要给50台服务器安装JDK，或者给10台服务器的MongoDB升级版本。如果在升级过程中出现意外的Bug和错误，此时就可以通过Puppet编写相关配置文件，一键安装到所有服务器上。与Puppet类似的软件有Homebrew等。</p>\n<h2> 高并发架构</h2>\n<h4> FreeMaker/Thymeleaf + FastDFS</h4>\n<p>页面静态化指将部分前端需要经常请求的内容，通过页面静态化引擎转换成独立的HTML页面进行缓存。也就是说，不再需要请求后端代码，即可直接返回独立的HTML页面，减轻后端的压力。例如，在某小说网站中如果对某本热门小说的每一章内容都去请求后端，则服务器和数据库的压力会过大，通过页面静态化技术，可以把该热门小说的每一章内容都制作成独立的HTML页面，当返回该页面时，服务器承受的压力几乎可以忽略不计。除小说网站外，门户网站、新闻网站、博客网站和视频网站都可以通过这样的技术进行架构。</p>\n<p>FreeMaker/Thymeleaf + FastDFS是一种页面静态化+文件管理系统的高并发架构，多用于视频、电商、小说等网站。这里的FastDFS也可以换成其他软件，其目的是减少对数据库的读取，将静态化页面存储在某存储引擎或文件管理系统中。</p>\n<p>传统SSM项目架构在上传静态文件时通常上传至SSM项目服务器的本地，无法针对存储进行加卷之类的扩展性操作，因而FastDFS应运而生。FastDFS是专门为了管理静态文件制作的独立运行的应用程序，静态文件可能包含图片、GIF、TXT等。</p>\n<p>在Spring Boot + FastDFS + Thymeleaf架构中，FastDFS主要负责保存Thymeleaf生成的静态文件，并提供给Spring Boot进行读写操作。这是一种很常见的以空间换时间的架构模式。当文件管理系统中的数据量过大时，可以进行定时删除操作，极大地减少对MySQL的访问量。</p>\n<p>当然，电商网站用Elasticsearch引擎或MongoDB缓存的也非常多，方便在读取页面时返回不同的数据，减少对MySQL数据库的访问量。页面静态化+文件管理系统的架构更加细致，返回速度更快，压力更小。</p>\n<p>下面用一个简单的例子介绍Spring Boot + FastDFS + Thymeleaf架构的业务流程。假设前端需要请求一页新闻，首先，请求Redis查看缓存中是否包含Thymeleaf生成的静态页面标识。若没有，则通过MySQL请求静态页面标识。其次，在拿到静态页面标识后，即可通过FastDFS请求到HTML静态页面，并直接将其返回给前端进行处理。另外，管理员或定时任务可以定时修改FastDFS中的新闻（相当于更新FastDFS中的缓存）。</p>\n<p>如果不使用该架构，仍假设前端需要请求一页一万字的新闻，则先在Redis中查询是否包含这一万字的新闻。若没有，再在MySQL中查询一万字的String字符串，转化速度极慢。这种架构相当于将大量的字符都缓存了起来 ， 减 少 了 后 端 的 压 力 。 但 是 将 N 篇 一 万 字 的 新 闻 都 缓 存 在 Redis 或Elasticsearch中并不是好的选择。</p>\n<h4> Spring Boot +Netty+ gRpc + Protobuf</h4>\n<p>Spring Boot + Netty + gRPC +Protobuf是一种多语言多协议的集成架构，多用于金融、医疗等网站。</p>\n<p>Protobuf是一个与平台和语言无关，可扩展且轻便高效的序列化数据结构协议，可用于网络通信和数据存储。Protobuf像XML和JSON一样，可以让由不同语言编写并在不同平台上运行的应用程序交换数据。例如，用Go语言编写的发送程序可以在Protobuf中对用Go语言编写的销售订单数据进行编码，然后用Java语言编写的接收方对它进行解码，以获取所接收订单数据的Java表示方式。Protobuf传输的是二进制数据。Protobuf和其他编码系统对结构化数据进行序列化和反序列化。</p>\n<p>远程过程调用（Remote Procedure Call，RPC）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，而且遵从C/S模型。在使用时，客户端调用服务器端提供的接口就像调用本地的函数一样。</p>\n<p>gRPC是Google公司针对远程过程调用提供的一种实现框架，通过gRPC框架配合ProtoBuf序列化传输协议，可以使数据如同本地调用一样轻松跨语言传输。例如，对于一些特定内容，若C++性能比Java性能更加优秀，则可以使用C++代码编写，之后再通过gRPC+ Protobuf架构让Java代码直接调用。</p>\n<h4> Spring Batch + Quartz + Kettle</h4>\n<p>Spring Batch是Spring全家桶的一个组件，是一个批处理应用框架。它不是调度框架，但需要和调度框架合作来构建并完成批处理任务。它只关注批处理任务相关的问题，如事务、并发、监控、执行等，并不提供相应的调度功能。如果需要使用调度框架，则可以使用Quartz、Tivoli、Control-M、Cron等企业级调度框架。Spring Batch擅长数据迁移、数据同步、数据批处理等工作。</p>\n<p>Quartz是OpenSymphony开源组织在Job Scheduling领域的又一个开源项目，它既可以与J2EE和J2SE应用程序相结合，也可以单独使用。Quartz可以用来创建简单的或者可以运行上万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p>\n<p>Spring Batch + Quartz通常与Kettle、MySQL一起使用。Kettle是一款国外开源的ETL（Extract-Transform-Load）数据仓库技术工具，可以在Window、Linux、UNIX操作系统上运行，数据抽取高效稳定。Spring Batch +Quartz可将多个数据源的数据统一置入数据仓库中，由数据仓库导出各种所需要的数据。例如，原本的数据为用户表、购物车表和商品表，经数据仓库处理之后，可直接返回所需要的数据格式，而非多个表或多个值。除此之外，Kettle包含界面化导出Excel的功能，可以由非技术类人员导出相关数据。</p>\n<h2> 响应式编程架构</h2>\n<p>响应式编程（Reactive Programming）是一种面向数据流和变化传播的范式，可以在编程语言中很方便地表达静态或动态的数据流，相关的计算模型会自动将变化的值通过数据流进行传播。例如，c=a+b表示将a+b表达式的结果赋给c。在传统编程中，改变a或b的值不会影响c；但在响应式编程中，c的值会随着a或b值的变化而变化。</p>\n<p>Reactor是一个基于JVM之上的异步应用框架。为Java、Groovy和其他JVM语言提供构建基于事件和数据驱动应用的抽象库。Reactor的性能相当高，在最新的硬件平台上，使用无堵塞分发器每秒可以处理1500万个事件。</p>\n<p>Reactor框架是Spring之前的项目，实现了Reactive Programming思想，符合Reactive Streams规范。。Spring WebFlux是在Ractor框架基础上实现的响应式Web框架，完全无阻塞，支持Reactive Streams背压，并且可以在Netty、Undertow和Servlet 3.1+等服务器上运行。</p>\n<p>Spring WebFlux的功能较多，下面通过代码展示部分功能：<br>\n<br>\n</p>\n<p>此时分别调用controller1接口与controller2接口，后台日志输出如下所示：<br>\n</p>\n<h2> 负载均衡架构</h2>\n<p>负载均衡的含义是通过多台服务器共同承载压力。例如，一个HTTP请求通过Nginx中间件转发给多台Tomcat的架构形式即为负载均衡架构。</p>\n<p>负载均衡架构有多种表现形式，如下所示：</p>\n<ul>\n<li>服务器端静态反向代理负载均衡架构：Keepalived + Nginx + Java。该架构被负载的实际地址是在配置文件中直接编写的IP地址与端口。该架构形式无法在正在运行的过程中进行修改。</li>\n<li>服务器端动态反向代理负载均衡架构：Nginx + UpSync + Consul +Java。该架构被负载的实际地址是通过Consul注册中心记录的。Nginx会通过UpSync插件获得到实际地址并进行负载均衡。该架构形式可以在系统正常运行时更新Java程序的节点。</li>\n<li>客 户 端 负 载 均 衡 架 构 Spring Cloud + Consul + Spring BootRibbon。在该架构中，当Java1程序请求Java2程序时，Java1程序会通过Consul获取Java2程序的节点信息，若Java2程序在Consul中注册了N个节点，则Java1程序在获得所有Java2程序的节点信息之后，会通过算法请求Java2程序的其中一个节点，即以客户端请求直接进行分发的方式达到负载均衡的目的</li>\n<li>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，以便将客户端的访问引导到不同的服务器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。这种负载均衡技术通常由云服务商提供。与DNS负载均衡类似的是CDN负载均衡，不再赘述。</li>\n<li>硬件负载均衡技术：通常由硬件直接进行数据与请求分发，达到负载均衡的结果。市场上常见的硬件有NetScaler和Radware等。</li>\n<li>协议性负载均衡架构。例如，通过HTTP协议的重定向功能进行负载均衡，或通过自研协议进行负载均衡。</li>\n<li>混合型负载均衡架构。使用多种负载均衡架构的混合架构，不同的应用程序可以采用不同的负载均衡架构。</li>\n</ul>\n<h2> 监控工具与监控架构</h2>\n<h4> 性能监控设计</h4>\n<p>性能监控通常指监控Linux服务器的CPU、内存、I/O、硬盘、应用程序接口耗时等，常见的性能监控架构如下所示：</p>\n<ul>\n<li>Telegraf + InfluxDB + Chronograf + Kapacitor架构。</li>\n<li>Prometheus + Grafana架构。</li>\n<li>Elasticsearch + Logstash + Kibana + Filebeat架构。</li>\n<li>Zabbix + Grafana架构。<br>\n在Telegraf + InfluxDB + Chronograf + Kapacitor架构（简称TICK架构）中，InfluxDB为时序数据库，负责数据存储；Telegraf为独立运行的采集软件，负责数据采集；Chronograf负责数据可视化；Kapacitor负责告警、预警。Telegraf从Linux系统或相关文件中获取数据，通过HTTP接口传到InfluxDB数据库中，Chronograf会定时从InfluxDB数据库中获取相关数据并进行展示。</li>\n</ul>\n<p>TICK架构可转换成Telegraf + InfluxDB + Grafana架构（简称TIG架构），其中，Grafana提供数据可视化与报警、预警功能。TICK架构也可转换成Prometheus + Grafana架构（简称PG架构），即由Prometheus负责数据的采集与存储。</p>\n<p>在 Elasticsearch + Logstash + Kibana 架 构 （ 简 称 ELK 架 构 ） 中 ，Logstash负责数据的采集，Elasticsearch负责数据的存储，Kibana负责数据的展示。当Logstash在大型项目中采集能力不足时，偶尔会增加Filebeat来采集数据，之后通过Logstash管道传输给Elasticsearch。</p>\n<p>ELK架构与TICK架构、TIG架构和PG架构的相似之处在于各个角色的划分几乎相同，并且都可以采集CPU、内存等信息，与TICK架构、TIG架构和PG架构相比，ELK架构更着重于采集不同类型的数据，具有更丰富的生态，不过在构建一些监控图表时，较为费时费力。TICK架构、TIG架构和PG架构的监控图表更加美观，搭建与报警也更加简便，所以业内通常采用TICK架构和TIG架构作为性能监控设计，采集CPU、内存、硬盘等相关信息；采用ELK架构作为业务监控设计，采集程序日志、Nginx日志、接口请求等相关信息。采用TICK架构、TIG架构作为性能监控设计主要。采用PG架构采集MySQL相关的信息。</p>\n<p>Zabbix与上面的软件都不同，它是一套自我完善的监控软件，也就是说，只使用Zabbix，也可以完成对CPU、内存等相关信息的监控。Zabbix是一个基于Web界面的提供分布式系统监视和网络监视功能的企业级的开源解决方案。Zabbix能控各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制，以便让系统管理员快速定位并解决存在的问题。</p>\n<p>Zabbix由两部分组成，zabbix server与可选组件zabbix agent。zabbixserver可以通过SNMP、zabbix agent、ping、端口监视等实现对远程服务器或网络状态的监控、数据收集等功能，它可以运行在Linux、Solaris、OS X等平台上。</p>\n<p>Zabbix自带图表功能，但图表并不美观，所以通常结合Grafana使用。</p>\n<h2> 全链路监控</h2>\n<p>Pinpoint是一款全链路分析工具，提供了无侵入式的调用链监控和方法执行详情查看、应用状态信息监控等功能，与另一款开源的全链路分析工具Zipkin类似。与Zipkin相比，Pinpoint提供了无侵入式等特性，支持的功能较为丰富，可以帮助分析系统的总体结构，以及分布式应用程序组件之间是如何进行数据互联的。</p>\n<p>服务拓扑图：对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的详细信息，比如当前节点状态、请求数量等</p>\n<p>实时活跃线程图：监控应用内活跃线程的执行情况，可以直观地了解应用的线程执行性能。请求响应散点图：以时间维度进行请求计数和响应时间的展示，通过拖动图表可以选择对应的请求，查看执行的详细情况。</p>\n<p>请求调用栈查看：对分布式环境中的每个请求都提供了代码维度的可见性，可以在页面中查看请求针对代码维度的执行详情，帮助查找请求的瓶颈和故障原因。</p>\n<p>应用状态、机器状态检查：查看相关应用程序的其他详细信息，比如CPU的使用情况、内存状态、垃圾收集状态、TPS和JVM信息等参数。</p>\n<p>与Pinpoint类似的还有Zorka和Scouter等。</p>\n",
      "date_published": "2023-11-17T10:18:13.000Z",
      "date_modified": "2024-03-03T03:00:03.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    }
  ]
}