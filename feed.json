{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "UJava",
  "home_page_url": "https://ujava.cn/",
  "feed_url": "https://ujava.cn/feed.json",
  "description": " 【Java学习 + Java面试】首选UJava！  ",
  "favicon": "https://ujava.cn/favicon.ico",
  "items": [
    {
      "title": "组件DevOps",
      "url": "https://ujava.cn/assembly/devops.html",
      "id": "https://ujava.cn/assembly/devops.html",
      "summary": "1. DevOps 维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。 为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？ 项目管理模式的演变是受项目的规模大小影响的。 最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。 后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。",
      "content_html": "<h2> 1. DevOps</h2>\n<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>\n<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>\n<p>项目管理模式的演变是受项目的规模大小影响的。</p>\n<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>\n<br>\n后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>\n<p><br>\n再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>\n<br>\n再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>\n<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>\n<p><br>\nDevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>\n<ul>\n<li>DevOps = 人 + 流程 + 平台</li>\n<li>人 + 流程 = 文化</li>\n<li>流程 + 平台 = 工具</li>\n<li>平台 + 人 = 赋能</li>\n</ul>\n<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>\n<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>\n<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>\n<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>\n<h2> 2. CI/CD</h2>\n<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>\n<p><br>\nCI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>\n<p><strong>持续集成</strong>：</p>\n<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>\n</p>\n<p><strong>持续交付</strong>：</p>\n<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>\n</p>\n<p><strong>持续部署</strong>：</p>\n<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>\n</p>\n<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>\n<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>\n<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>\n<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>\n<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件ElasticSearch",
      "url": "https://ujava.cn/assembly/elasticsearch.html",
      "id": "https://ujava.cn/assembly/elasticsearch.html",
      "summary": "一、 简介 Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作: 一个分布式的实时文档存储，每个字段可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 1.ES优点 1.支持全文搜索，并基于倒排索引，检索速度特别快 2.高可用性，支持集群部署，任何节点失效系统自动调整。",
      "content_html": "<h2> 一、 简介</h2>\n<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>\n<ul>\n<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>\n<li>一个分布式实时分析搜索引擎</li>\n<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>\n</ul>\n<h3> 1.ES优点</h3>\n<ul>\n<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>\n<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>\n</ul>\n<h3> 2.ES缺点</h3>\n<ul>\n<li>1.对硬件要求较高，es比较吃内存，需要存储资源来支持大量数据的处理。</li>\n<li>2.不支持事务等ACID属性。</li>\n</ul>\n<h3> 3.ES使用场景</h3>\n<p>1.聊天消息</p>\n<ul>\n<li>数据量大，业务关系简单，会通过关键字搜索聊天信息</li>\n<li>非核心业务，不会频繁crud</li>\n<li>没有事务的场景，可以不用支持事务</li>\n</ul>\n<p>2.日志纪录</p>\n<p>Elasticsearch 一个典型应用就是 ELK 日志分析系统。如nginx接入请求的访问日志纪录。</p>\n<p>3.热点数据搜索</p>\n<p>如电商业务的商品搜索等。</p>\n<h3> 4.DSL语言高级查询</h3>\n<h4> 1.Query DSL概述</h4>\n<p>Domain Specific Language 领域专用语言</p>\n<ul>\n<li>Elasticsearch provides a ful1 Query DSL based on JSON to define queries</li>\n<li>Elasticsearch提供了基于JSON的DSL来定义查询。</li>\n</ul>\n<p>DSL由叶子查询子句和复合查询子句两种子句组成。</p>\n<figure><figcaption>img_111.png</figcaption></figure>\n<h4> 2.模糊匹配</h4>\n<p>模糊匹配主要是针对文本类型的字段，文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据，模糊匹配主要通过match等参数来实现</p>\n<ul>\n<li>match : 通过match关键词模糊匹配条件内容</li>\n<li>prefix : 前缀匹配</li>\n<li>regexp : 通过正则表达式来匹配数据</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.精确匹配</h4>\n<ul>\n<li>term : 单个条件相等</li>\n<li>terms : 单个字段属于某个值数组内的值</li>\n<li>range : 字段属于某个范围内的值</li>\n<li>exists : 某个字段的值是否存在</li>\n<li>ids : 通过ID批量查询</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.聚合搜索</h4>\n<p><strong>1.bucket和metric</strong></p>\n<p>bucket就是一个聚合搜索时的数据分组。</p>\n<p>如：销售部门有员工张三和李四，开发部门有员工王五和赵六。那么根据部门分组聚合得到结果就是两个bucket。销售部门bucket中有张三和李四，开发部门 bucket中有王五和赵六。</p>\n<p>metric就是对一个bucket数据执行的统计分析。如上述案例中，开发部门有2个员工，销售部门有2个员工，这就是metric。</p>\n<p>metric有多种统计，如：求和，最大值，最小值，平均值等。</p>\n<p>用一个大家容易理解的SQL语法来解释，如：select count() from table group by column。那么group by column分组后的每组数据就是bucket。对每个分组执行的count()就是metric。</p>\n<p>es最重要的核心功能是数据检索，统计分析我认为不是es最核心的功能，想这种离线统计应该由其他的替代方案去做，所以如果想了解更多es聚合搜索相关知识可以参考官网或者其他博客</p>\n<h3> 5.文档映射</h3>\n<p>ES中映射可以分为动态映射和静态映射</p>\n<h4> 1.动态映射</h4>\n<p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。<br>\n动态映射规则如下：</p>\n<figure><figcaption>img_112.png</figcaption></figure>\n<h4> 2.静态映射</h4>\n<p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。</p>\n<h4> 3.核心类型（Core datatype）</h4>\n<ul>\n<li>字符串：string，string类型包含 text 和 keyword。</li>\n<li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li>\n<li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li>\n<li>数值型：long、integer、short、byte、double、float</li>\n<li>日期型：date</li>\n<li>布尔型：boolean</li>\n</ul>\n<h4> 4.数据建模</h4>\n<p>就是针对于关系型数据库的一对多数据模型，而我自己认为es的主要应用场景是全文搜索引擎，这种复杂的业务关系就应该由关系型数据库如mysql去完成数据建模和存储，而不是交给es去建模存储，当然es也是提供了Parent / Child相关机制继续数据建模，如果有场景使用到，自己去参考对应的官方文档了解即可，但我自己不建议这样做。</p>\n<h4> 5.分页查询</h4>\n<p>1.语法</p>\n<p>在存在大量数据时，一般我们进行查询都需要进行分页查询。例如：我们指定页码、并指定每页显示多少条数据，然后Elasticsearch返回对应页码的数据。</p>\n<p>在执行查询时，可以指定from（从第几条数据开始查起）和size（每页返回多少条）数据，就可以轻松完成分页。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2.scroll解决深分页问题</p>\n<p>前面使用from和size方式，查询在1W条数据以内都是OK的，但如果数据比较多的时候，会出现性能问题。Elasticsearch做了一个限制，不允许查询的是10000条以后的数据。如果要查询1W条以后的数据，需要使用Elasticsearch中提供的scroll游标来查询。</p>\n<p>在进行大量分页时，每次分页都需要将要查询的数据进行重新排序，这样非常浪费性能。</p>\n<p>使用scroll是将要用的数据一次性排序好，然后分批取出,性能要比from + size好得多。</p>\n<p>使用scroll查询后，排序后的数据会保持一定的时间，后续的分页查询都从该快照取数据即可。</p>\n<p>第一次使用scroll分页查询</p>\n<p>此处，我们让排序的数据保持1分钟，所以设置scroll为1m</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行后，我们注意到，在响应结果中有一项：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>后续，我们需要根据这个_scroll_id来进行查询</p>\n<p>第二次直接使用scroll id进行查询</p>\n<h3> 6.suggest search</h3>\n<p>suggest search（completion suggest）：就是建议搜索或称为搜索建议，也可以叫做自动完成-auto completion。类似百度中的搜索联想提示功能。</p>\n<p>ES实现suggest的时候，性能非常高，其构建的不是倒排索引，也不是正排索引，就是纯的用于进行前缀搜索的一种特殊的数据结构，而且会全部放在内存中，所以suggest search进行的前缀搜索提示，性能是非常高。</p>\n<p>需要使用suggest的时候，必须在定义index时，为其mapping指定开启suggest。</p>\n<p>具体如下:</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>suggest 搜索：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、ES核心原理</h2>\n<p>ES存储模型</p>\n<p>Elasticsearch与关系数据库结构对应</p>\n<figure><figcaption>img_113.png</figcaption></figure>\n<p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p>\n<h3> 1.索引（Index）</h3>\n<p>相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</p>\n<p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引<br>\n一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</p>\n<h3> 2.文档类型（Type）</h3>\n<p>相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</p>\n<p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p>\n<h3> 3.文档（Document）</h3>\n<p>相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；</p>\n<p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示；</p>\n<h3> 4.字段（Field）</h3>\n<p>文档的一个Key/Value对；</p>\n<ul>\n<li>词（Term）：表示文本中的一个单词；</li>\n<li>标记（Token）：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li>\n</ul>\n<p>相当于是数据表的字段|列</p>\n<h3> 5.倒排索引</h3>\n<p>全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。</p>\n<p>之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。</p>\n<p>假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。</p>\n<p>正排索引示例：</p>\n<figure><figcaption>img_114.png</figcaption></figure>\n<p>（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）</p>\n<p>正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了“面向对象葵花宝典是什么”，网站根据文章标题查询文章的内容展示给用户。</p>\n<p>倒排索引示例：</p>\n<figure><figcaption>img_115.png</figcaption></figure>\n<p>（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）</p>\n<p>倒排索引适用于根据关键词来查询文档内容，它是根据文章内容中的关键字建立索引，而值对应于文档ID，而搜索出来的结果就是文档ID所在行的所有内容。</p>\n<p>例如，用户只是想看“设计”相关的文章，网站需要将文章内容中包含“设计”一词的文章都搜索出来展示给用户。</p>\n<p>要注意倒排索引的两个重要细节：</p>\n<ul>\n<li>倒排索引中的所有词项对应一个或多个文档；</li>\n<li>倒排索引中的词项根据字典顺序升序排列<br>\nElasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。</li>\n</ul>\n<h3> 6.分词器</h3>\n<p>对于英文来说，分词比较简单，只需要按照单词的空格来进行分词。<br>\n如下所示<br>\n</p>\n<p>如果要搜索hello这个关键词，则匹配的结果将是下面两个内容</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果。</p>\n<p>这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。</p>\n<p>ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。</p>\n<p>修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分词器工作流程<br>\n<br>\n分词器由三部分组成：</p>\n<ul>\n<li>Character Filter：将文本中html标签剔除掉。</li>\n<li>Tokenizer：按照规则进行分词，在英文中按照空格分词</li>\n<li>Token Filter：将切分的单词进行加工，小写，删除 stopwords(停顿词，a、an、the、is等),增加同义词</li>\n</ul>\n<p>每个组件的作用，可参考下面的例子</p>\n<p>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签</p>\n<p>tokenizer：分词，hello you and me --&gt; hello, you, and, me</p>\n<p>token filter：lowercase，stop word，synonymom，liked --&gt; like，Tom --&gt; tom，a/the/an --&gt; 干掉，small --&gt; little</p>\n<p>ES内置分词器</p>\n<ul>\n<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>\n<li>Simple Analyzer - 按照非字母切分(符号被过滤), 小写处理</li>\n<li>Stop Analyzer - 小写处理，停用词过滤(the,a,is)</li>\n<li>Whitespace Analyzer - 按照空格切分，不转小写</li>\n<li>Keyword Analyzer - 不分词，直接将输入当作输出</li>\n<li>Patter Analyzer - 正则表达式，默认\\W+(非字符分割)</li>\n<li>Language - 提供了30多种常见语言的分词器</li>\n<li>Customer Analyzer 自定义分词器</li>\n</ul>\n<p>每个内置分词器的作用，可参考下面的例子</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定制分词器</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定制化自己的分词器</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>IK热更新</p>\n<p>每次都是在es的扩展词典中，手动添加新词语，很坑</p>\n<p>（1）每次添加完，都要重启es才能生效，非常麻烦</p>\n<p>（2）es是分布式的，可能有数百个节点，你不能每次都一个一个节点上面去修改</p>\n<p>es不停机，直接我们在外部某个地方添加新的词语，es中立即热加载到这些新词语<br>\nIKAnalyzer.cfg.xml</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 7.es评分机制</h3>\n<p>当你通过关键字搜索相关文档时，可能会出现多个文档，这些文档的顺序是通过一个max_score属性的大小从高到低顺序展现出来的，max_score属性就是我们所说的评分。</p>\n<p>打分算法</p>\n<p>relevance score算法，简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度</p>\n<p>Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法</p>\n<p>总公式</p>\n<p>max_score = boost * idf * tf</p>\n<figure><figcaption>img_118.png</figcaption></figure>\n<p>对于查询权重我们可以自己定义</p>\n<p>如下面所示：</p>\n<figure><figcaption>img_119.png</figcaption></figure>\n<p>TF算法</p>\n<p>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关</p>\n<ul>\n<li>搜索请求：hello world</li>\n<li>doc1：hello you, and world is very good</li>\n<li>doc2：hello, how are you</li>\n</ul>\n<p>doc1这个文档匹配了2个单词，所以doc1的得分要高一些。</p>\n<p>2.IDF算法<br>\nInverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关</p>\n<ul>\n<li>搜索请求：hello world</li>\n<li>doc1：hello, tuling is very good</li>\n<li>doc2：hi world, how are you</li>\n</ul>\n<p>比如说，在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次；world这个单词在所有的document中，一共出现了100次，所以world这个单词得分就更高。</p>\n<p>那么匹配world的doc得分就越高,越有可能排在搜索结果前面。</p>\n<p>Field-length norm：field长度，field越长，相关度越弱<br>\n搜索请求：hello world</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>hello world在整个index中出现的次数是一样多的，那么doc1更相关，title field更短</p>\n<p><strong>2.空间向量模型（vector space model）</strong></p>\n<p>每个doc vector计算出对query vector的弧度，最后基于这个弧度给出一个doc相对于query中多个term的总分数</p>\n<p>弧度越大，分数月底; 弧度越小，分数越高</p>\n<p>如果是多个term，那么就是线性代数来计算，无法用图表示</p>\n<figure><figcaption>img_120.png</figcaption></figure>\n<p>了解即可，掌握对应的打分算法我自己认为就足够了，不用砖牛角尖</p>\n<h2> 三、ElasticSearch架构设计</h2>\n<p>es集群架构</p>\n<p>如下图 ，就是一个三个节点组成的es集群，p0、p1、p2表示一个节点中的分片，R0、R1、R2表示分片对应的副本<br>\n<br>\n在Elasticsearch主要分成两类节点，一类是Master，一类是DataNode。</p>\n<h3> 1.Master节点</h3>\n<p>在Elasticsearch启动时，会选举出来一个Master节点。</p>\n<p>当某个节点启动后，然后使用Zen Discovery机制找到集群中的其他节点，并建立连接。</p>\n<p>discovery.seed_hosts: [“192.168.21.130”, “192.168.21.131”, “192.168.21.132”]</p>\n<p>并从候选主节点中选举出一个主节点。</p>\n<p>cluster.initial_master_nodes: [“node1”, “node2”,“node3”]</p>\n<p>Master节点主要负责</p>\n<ul>\n<li>管理索引（创建索引、删除索引）、分配分片</li>\n<li>维护元数据</li>\n<li>管理集群节点状态</li>\n<li>不负责数据写入和查询，比较轻量级</li>\n</ul>\n<p>一个Elasticsearch集群中，只有一个Master节点。在生产环境中，内存可以相对小一点，但机器要稳定。</p>\n<h3> 2.DataNode节点</h3>\n<p>在Elasticsearch集群中，会有N个DataNode节点。</p>\n<p>DataNode节点主要负责：</p>\n<p>数据写入、数据检索，</p>\n<p>大部分Elasticsearch的压力都在DataNode节点上在生产环境中，内存最好配置大一些</p>\n<h3> 3.分片</h3>\n<p>Elasticsearch是一个分布式的搜索引擎，索引的数据也是分成若干部分，分布在不同的服务器节点中，分布在不同服务器节点中的索引数据，就是分片（Shard）。</p>\n<p>Elasticsearch会自动管理分片，如果发现分片分布不均衡，就会自动迁移一个索引（index）由多个shard（分片）组成，而分片是分布在不同的服务器上的.</p>\n<h3> 4.副本</h3>\n<p>为了对Elasticsearch的分片进行容错，假设某个节点不可用，会导致整个索引库都将不可用。所以，需要对分片进行副本容错，每一个分片都会有对应的副本。</p>\n<p>在Elasticsearch中，默认创建的索引为1个分片、每个分片有1个主分片和1个副本分片。</p>\n<p>每个分片都会有一个Primary Shard（主分片），也会有若干个Replica Shard（副本分片）</p>\n<p>Primary Shard和Replica Shard不在同一个节点上</p>\n<h3> 5.es集群读写流程</h3>\n<p>es 写数据流程</p>\n<figure><figcaption>img_122.png</figcaption></figure>\n<p>1.选择任意一个DataNode发送请求，例如：node2。此时，node2就成为一个coordinating node（协调节点）</p>\n<p>2.计算得到文档要写入的分片</p>\n<p><code>shard = hash(routing) % number_of_primary_shards</code><br>\nrouting 是一个可变值，默认是文档的 _id</p>\n<p>3.coordinating node会进行路由，将请求转发给对应的primary shard所在的DataNode（假设primary shard在node1、replica shard在node2）</p>\n<p>4.node1节点上的Primary Shard处理请求，写入数据到索引库中，并将数据同步到Replica shard</p>\n<p>5.Primary Shard和Replica Shard都保存好了文档，返回client</p>\n<p>es 读数据流程</p>\n<figure><figcaption>img_123.png</figcaption></figure>\n<p>1.client发起查询请求，某个DataNode接收到请求，该DataNode就会成为协调节点（Coordinating Node）</p>\n<p>2.协调节点（Coordinating Node）将查询请求广播到每一个数据节点，这些数据节点的分片会处理该查询请求</p>\n<p>3.每个分片进行数据查询，将符合条件的数据放在一个优先队列中，并将这些数据的文档ID、节点信息、分片信息返回给协调节点</p>\n<p>4.协调节点将所有的结果进行汇总，并进行全局排序</p>\n<p>5.协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据返回给客户端</p>\n<p>注意：写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>\n<p>自己总结：es的检索流程和mysql数据表查询非主键索引的思路有些相似，先从索引表查询出对应的主键索引值，在进行回表查询具体的行数据。</p>\n<p>es删除/更新数据底层原理</p>\n<p>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</p>\n<p>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p>\n<p>es 底层写数据原理</p>\n<figure><figcaption>img_124.png</figcaption></figure>\n<p>简述：先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；然后刷新到os cache中（同时将数据备份到translog日志文件），最后刷新到 segment file磁盘文件中</p>\n<p>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件作备份（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。最后存入到commit point磁盘文件中。</p>\n<p>refresh到文件系统缓存</p>\n<p>当数据写入到ES分片时，会首先写入到内存中，然后通过内存的buffer生成一个segment，并刷到文件系统缓存中。</p>\n<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。</p>\n<p>这个过程就是 refresh 。</p>\n<p>只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。</p>\n<p>定时 refresh到文件系统缓存机制</p>\n<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file ，每秒钟会产生一个新的磁盘文件 segment file ，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。<br>\n但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>\n<p>segment file合并</p>\n<p>buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，此时会定期执行 merge，减少索引查询时IO开销。<br>\n每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉（之前执行过的delete的数据），然后将新的 segment file 写入到一个 commit point磁盘 。</p>\n<p>知识扩展</p>\n<p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache ，先进入操作系统级别的一个内存缓存中去。</p>\n<p>备份到translog磁盘</p>\n<p>刷新到translog文件以保障数据不丢失，translog的设计思想和mysql的redo log是相似的。</p>\n<p>每隔5s,从os cache 中同步到translog磁盘里面去做备份。</p>\n<p>那么translog 日志文件的作用是什么？</p>\n<p>你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>\n<p>flush到磁盘文件</p>\n<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file文件系统缓存中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p>\n<p>数据最终被flush到磁盘文件就完成了数据的最终归宿。</p>\n<figure><figcaption>img_125.png</figcaption></figure>\n<p>commit操作流程</p>\n<p>commit 操作首先就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。<br>\n然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。<br>\n最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>\n<p>这个 commit 操作叫做 flush 。</p>\n<p>默认 30 分钟自动执行一次 flush ，将文件系统缓存的数据刷入到磁盘。<br>\n但如果 translog 过大，也会触发 flush 。</p>\n<p>flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>\n<p>es准实时机制</p>\n<p>为什么叫 es 是准实时的？</p>\n<p>NRT ，全称 near real-time 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</p>\n<p>可以通过 es 的 restful api 或者 java api ，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>\n<p>es会数据丢失吗？</p>\n<p>可能会丢失有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果备份到translog过程中宕机，会导致 5 秒的数据丢失。</p>\n<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。<br>\n也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>\n<p>es集群脑裂</p>\n<p>关于集群脑裂的定义请参考我的另一篇博文</p>\n<p><a href=\"https://blog.csdn.net/sinat_34814635/article/details/129914369\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/sinat_34814635/article/details/129914369</a></p>\n<p>那么es是如何解决脑裂问题的？</p>\n<p>es是直到有足够的master候选节点时，才可以选举出一个master，否则就不要选举出一个master。</p>\n<p>这个参数必须被设置为集群中master候选节点的quorum数量，也就是大多数，至于quorum的算法，就是：master候选节点数量 / 2 + 1。</p>\n<p>综上所述，一个生产环境的es集群，至少要有3个节点，同时将这个参数设置为quorum，也就是2。discovery.zen.minimum_master_nodes设置为2</p>\n<p>那么这个是参数是如何避免脑裂问题的产生的呢？比如我们有3个节点，quorum是2.现在网络故障，1个节点在一个网络区域，另外2个节点在另外一个网络区域，不同的网络区域内无法通信。</p>\n<p>这个时候有两种情况情况：</p>\n<p>（1）如果master是单独的那个节点，另外2个节点是master候选节点，那么此时那个单独的master节点因为没有指定数量的候选master node在自己当前所在的集群内，因此就会取消当前master的角色，尝试重新选举，但是无法选举成功。然后另外一个网络区域内的node因为无法连接到master，就会发起重新选举，因为有两个master候选节点，满足了quorum，因此可以成功选举出一个master。此时集群中就会还是只有一个master。</p>\n<p>（2）如果master和另外一个node在一个网络区域内，然后一个node单独在一个网络区域内。那么此时那个单独的node因为连接不上master，会尝试发起选举，但是因为master候选节点数量不到quorum，因此无法选举出master。而另外一个网络区域内，原先的那个master还会继续工作。这也可以保证集群内只有一个master节点。</p>\n<p>综上所述，集群中master节点的数量至少3台，三台主节点通过在elasticsearch.yml中配置discovery.zen.minimum_master_nodes: 2，就可以避免脑裂问题的产生。</p>\n<h2> 四、ElasticSearch应用</h2>\n<h3> 1.Elasticsearch SQL</h3>\n<figure><figcaption>img_126.png</figcaption></figure>\n<p>Elasticsearch SQL允许执行类SQL的查询，可以使用REST接口、命令行或者是JDBC，都可以使用SQL来进行数据的检索和数据的聚合。</p>\n<p>Elasticsearch SQL特点：</p>\n<p>本地集成</p>\n<p>Elasticsearch SQL是专门为Elasticsearch构建的。每个SQL查询都根据底层存储对相关节点有效执行。</p>\n<p>没有额外的要求</p>\n<p>不依赖其他的硬件、进程、运行时库，Elasticsearch SQL可以直接运行在Elasticsearch集群上</p>\n<p>轻量且高效</p>\n<p>像SQL那样简洁、高效地完成查询</p>\n<p>Elasticsearch SQL提供了sql转换的功能，但是只能满足一些简单的查询，例如：不支持JOIN、不支持较复杂的子查询。官方还是推荐使用DSL语句来实现</p>\n<h3> 2.Java客户端</h3>\n<p>这个就自己看官网吧</p>\n<h3> 3.es和mysql的双写</h3>\n<p>双写的流程：</p>\n<ul>\n<li>1.先写数据库，然后写es，es只存常搜索的索引字段。</li>\n<li>2.读取时先读es，找到对应主键后，然后根据主键在读mysql。（这种场景主要出现在mysql是分表的，而主键配置的是分片键，非分片键的查询将扫描全表）<br>\n首先不建议进行双写，因为会造成数据不一致这样新的问题。造成不一致的原因为写入es或者更新es字段失败，加上补充机制后也没有成功。</li>\n</ul>\n<p>双写的同步</p>\n<p>分页查询mysql中的数据，放入mq中（放入mq中的原因，为读取mysql的线程会远比执行同步的线程速度快），同步线程从mq中拉起数据，然后和es对比，如果不同，与mysql中的数据为准，进行删除复制。</p>\n<p>补偿机制</p>\n<p>我认为任何对es写失败，更新失败，删除失败都应该纪录下来，然后去手动操作使其同步。</p>\n<h2> 五、ElasticSearch安装配置</h2>\n<h3> 1.安装ElasticSearch</h3>\n<p>解压下载的压缩包，本次使用7.14.0版本</p>\n<p>从v7开始，elasticsearch不用单独安装JDK，因为它在下载时会自动下载对应的jdk包。因此不用额外下载jdk和配置环境变量。</p>\n<p>在终端cd到elasticsearch的bin目录，运行命令./elasticsearch即可开启es数据库服务（在终端通过按control + c可停止服务）。在网页中访问localhost:9200看到json结果即启动成功。</p>\n<p>如下图所示：</p>\n<figure><figcaption>img_127.png</figcaption></figure>\n<h3> 2.安装Kibana</h3>\n<p>下载可视化工具Kibanahttps://www.elastic.co/cn/downloads/kibana</p>\n<p>解压下载的压缩包，并将其复制粘贴至自己想要存放的目录。Kibana的版本最好和es保持一致，如这次同样使用7.14.0版本</p>\n<p>启动Kibana</p>\n<p>在终端cd到Kibana目录下，运行命令./Kibana即可开启Kibana的端口访问。在网页中访问http://localhost:5601跳转到如下界面即访问成功。</p>\n<p>访问下面地址：<a href=\"http://localhost:5601/app/dev_tools#/console\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:5601/app/dev_tools#/console</a> 可进入管理后台</p>\n<figure><figcaption>img_128.png</figcaption></figure>\n<p>ElasticSearch可视化工具之cerebro</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Jenkins",
      "url": "https://ujava.cn/assembly/jenkins.html",
      "id": "https://ujava.cn/assembly/jenkins.html",
      "summary": "1.背景 在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试； 或者前后端分离后，经常会修改接口，然后重新部署； 这些情况都会涉及到频繁的打包部署； 手动打包常规步骤： 1.提交代码 2.问一下同组小伙伴有没有要提交的代码 3.拉取代码并打包（war包，或者jar包） 4.上传到Linux服务器 5.查看当前程序是否在运行 6.关闭当前程序 7.启动新的jar包 8.观察日志看是否启动成功 9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）",
      "content_html": "<h2> 1.背景</h2>\n<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>\n<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>\n<p>这些情况都会涉及到频繁的打包部署；</p>\n<p>手动打包常规步骤：</p>\n<ul>\n<li>1.提交代码</li>\n<li>2.问一下同组小伙伴有没有要提交的代码</li>\n<li>3.拉取代码并打包（war包，或者jar包）</li>\n<li>4.上传到Linux服务器</li>\n<li>5.查看当前程序是否在运行</li>\n<li>6.关闭当前程序</li>\n<li>7.启动新的jar包</li>\n<li>8.观察日志看是否启动成功</li>\n<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>\n</ul>\n<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>\n<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>\n<p>只是Jenkins相对来说，使用得更广泛。</p>\n<h2> 2.Jenkins服务器搭建及基本配置</h2>\n<h3> 2.1.简介</h3>\n<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<h3> 2.2.Jenkins自动化部署实现原理</h3>\n<figure><figcaption>img_70.png</figcaption></figure>\n<h3> 2.3.Jenkins部署环境</h3>\n<p>基本环境：</p>\n<ul>\n<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>\n<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>\n<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>\n</ul>\n<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>\n<h3> 2.4.Jenkins安装</h3>\n<ul>\n<li>1.下载安装包jenkins.war；</li>\n<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>\n<li>3.打开浏览器进入链接 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080</a>.</li>\n<li>4.填写初始密码，激活系统</li>\n</ul>\n<figure><figcaption>img_71.png</figcaption></figure>\n<ul>\n<li>5.进入插件安装选择</li>\n</ul>\n<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>\n<figure><figcaption>img_72.png</figcaption></figure>\n<p>选择后，进入插件安装页面<br>\n</p>\n<ul>\n<li>\n<p>6.设置初始用户和密码<br>\n</p>\n</li>\n<li>\n<p>7.进入系统，安装完成<br>\n</p>\n</li>\n</ul>\n<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>\n<h3> 2.5.Jenkins基本配置</h3>\n<h4> 2.5.1.系统初始化配置</h4>\n<figure><figcaption>img_76.png</figcaption></figure>\n<p><strong>1.Configure System (系统设置)</strong></p>\n<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>\n<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>\n<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>\n</p>\n<p><strong>2.Configure Global Security (全局安全配置)</strong></p>\n<p>a.配置用户相关的权限</p>\n<figure><figcaption>img_78.png</figcaption></figure>\n<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>\n<p>默认是勾选上了的，这里去掉勾选</p>\n<figure><figcaption>img_79.png</figcaption></figure>\n<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>\n<p>a.配置maven的全局settings路径<br>\n</p>\n<p>b.配置jdk<br>\n</p>\n<p>c.配置git</p>\n<figure><figcaption>img_82.png</figcaption></figure>\n<p>d.配置maven的安装路径</p>\n<figure><figcaption>img_83.png</figcaption></figure>\n<p><strong>4.配置必要插件</strong></p>\n<p>主要是检查如下这两个插件是否已安装</p>\n<ul>\n<li>插件1：Publish over SSH</li>\n<li>插件2：Deploy to container Plugin</li>\n</ul>\n<figure><figcaption>img_84.png</figcaption></figure>\n<p>添加图片注释，不超过 140 字（可选）</p>\n<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>\n<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>\n<h3> 3.1.Jenkins服务器上创建项目和配置</h3>\n<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>\n<p><strong>1.创建一个工程</strong></p>\n<figure><figcaption>img_85.png</figcaption></figure>\n<p><strong>2.General(基础配置)</strong></p>\n<p>仅需填写标准部分，其他可不填写</p>\n<figure><figcaption>img_86.png</figcaption></figure>\n<p><strong>3.源码管理</strong><br>\n</p>\n<p>上图中点击“添加”按钮添加一组账号和密码<br>\n</p>\n<p><strong>4.构建触发器</strong></p>\n<figure><figcaption>img_89.png</figcaption></figure>\n<p>如上图：当前项目的回调地址为：</p>\n<p><a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>\n<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>\n<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>\n<p><strong>5.构建环境（无需配置）</strong></p>\n<p><strong>6.构建</strong></p>\n<figure><figcaption>img_90.png</figcaption></figure>\n<p><strong>7.构建后操作</strong></p>\n<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>\n<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>\n<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>\n</p>\n<p>案例中给出的stop.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>案例中给出的start.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>\n<h3> 3.2.Linux服务器配置</h3>\n<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>\n<figure><figcaption>img_92.png</figcaption></figure>\n<h3> 3.3.GitHub服务器配置</h3>\n<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>\n<p>特别注意：为了保证回调地址网可以使用，</p>\n<p>我已经将地址：<a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>\n<p>通过花生壳进行外网映射为：<a href=\"http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>所以，下面配置的是外网映射地址。</p>\n<figure><figcaption>img_93.png</figcaption></figure>\n<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>\n<h2> 4.测试</h2>\n<p><strong>1.测试代码</strong><br>\n</p>\n<p><strong>2.提交代码到git,触发构建</strong></p>\n<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>\n</p>\n<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>\n<p>从下图中可以看出，正在构建</p>\n<figure><figcaption>img_96.png</figcaption></figure>\n<p><strong>5.查看当次构建的控制台日志</strong></p>\n<figure><figcaption>img_97.png</figcaption></figure>\n<p>说明已经启动成功</p>\n<p><strong>6.查看Linux服务器，是否上传代码</strong></p>\n<figure><figcaption>img_98.png</figcaption></figure>\n<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>\n<figure><figcaption>img_99.png</figcaption></figure>\n<p><strong>8.浏览器上访问，看是否能用</strong></p>\n<figure><figcaption>img_100.png</figcaption></figure>\n<p>说明，已经正常启动可以使用。</p>\n<p><strong>9.再次确认是否能自动化部署</strong></p>\n<p>修改代码，重新提交代码，循环1到8步查看。</p>\n<p>如果测试结果是你预期的，那么自动化部署成功。</p>\n<h2> 5.总结&amp;资料下载</h2>\n<h3> 5.1.总结</h3>\n<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>\n<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>\n<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>\n<p>但是，本着学习是为了解决生产的原则，</p>\n<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>\n<p>没必要把Jenkins的所有功能都学完在使用，</p>\n<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>\n<h3> 5.2.相关资料</h3>\n<ul>\n<li>1.案例中的源码地址：<a href=\"https://github.com/processfactory/demo01.git\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/processfactory/demo01.git</a></li>\n<li>2.官方文档：Jenkins 用户手册</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件K8S",
      "url": "https://ujava.cn/assembly/k8s.html",
      "id": "https://ujava.cn/assembly/k8s.html",
      "summary": "一、K8S简介 Kubernetes中文官网：Kubernetes GitHub：github.com/kubernetes/kubernetes Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。",
      "content_html": "<h2> 一、K8S简介</h2>\n<p>Kubernetes中文官网：<a href=\"https://kubernetes.io/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a></p>\n<p>GitHub：<a href=\"http://github.com/kubernetes/kubernetes\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/kubernetes</a></p>\n<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>\n<p>Kubernetes集群组件逻辑图<br>\n</p>\n<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>\n<p>Master节点组件及功能<br>\n</p>\n<p>Slave节点组件及功能<br>\n</p>\n<p>安装部署</p>\n<p>生产环境部署k8s主要有两种方式：</p>\n<p>二进制包</p>\n<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>\n<p>kubeadm工具</p>\n<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>\n<ul>\n<li>kubeadm init：初始化一个Master节点</li>\n<li>kubeadm join：将Worker节点加入集群</li>\n<li>kubeadm upgrade：升级K8s版本</li>\n<li>kubeadm token：管理 kubeadm join 使用的令牌</li>\n<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>\n<li>kubeadm version：打印 kubeadm 版本</li>\n<li>kubeadm alpha：预览可用的新功能</li>\n</ul>\n<h2> 二、准备工作</h2>\n<p>软硬件要求</p>\n<ul>\n<li>Linux操作系统，Ubuntu 或 CentOS</li>\n<li>每台节点至少2G</li>\n<li>Master节点至少2C</li>\n<li>集群节点网络互通</li>\n</ul>\n<p>集群规划</p>\n<figure><figcaption>img_104.png</figcaption></figure>\n<p>环境配置</p>\n<p>修改hosts配置</p>\n<p>配置所有节点的IP和域名映射</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置SSH免密登录</p>\n<p>先生成公钥对，再把公钥远程复制到所有节点。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关闭Swap分区</p>\n<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>禁用SELinux</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关闭防火墙</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改内核参数</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置集群时钟同步</p>\n<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置k8s的Yum源</p>\n<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、安装Docker</h2>\n<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>\n<h2> 四、安装K8S集群</h2>\n<p>安装三大组件-kubeadm、kubelet、kubectl</p>\n<ul>\n<li>kubeadm：用来初始化k8s集群的指令。</li>\n<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>\n<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化k8s集群</p>\n<ul>\n<li>apiserver-advertise-address：apiserver监听地址</li>\n<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>\n<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>\n<li>service-cidr：为Service分配的IP地址段</li>\n<li>pod-network-cidr：为pod分配的IP地址段</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>成功界面：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>\n<p>加入节点</p>\n<p>所有Node节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>修改角色：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>安装网络插件</p>\n<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>\n</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、测试K8S集群</h2>\n<p>创建nginx pod</p>\n<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对外暴露访问</p>\n<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>访问nginx</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>\n<h2> 六、安装Dashboard</h2>\n<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>\n<p>Github：<a href=\"http://github.com/kubernetes/dashboard\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/dashboard</a></p>\n<p>通过kubectl命令安装</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看service</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浏览器输入访问地址：<a href=\"https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://192.168.5.10:31128/，需要token才能访问。</a></p>\n<figure><figcaption>img_107.png</figcaption></figure>\n<p>创建访问账号</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取token</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>登录界面</p>\n<p>输入上面的token，进入dashboard首页</p>\n<figure><figcaption>img_108.png</figcaption></figure>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Mock",
      "url": "https://ujava.cn/assembly/mock.html",
      "id": "https://ujava.cn/assembly/mock.html",
      "summary": "简介 通过Mock方式，测试编写的程序 通用类定义 @SpringBootTest(classes = Application.class) @RunWith(SpringJUnit4ClassRunner.class) @Slf4j public class BaseTest { @BeforeClass public static void before() { } }",
      "content_html": "<h2> 简介</h2>\n<p>通过Mock方式，测试编写的程序</p>\n<p>通用类定义</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式一（直接操作库表）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式二（启动容器）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式三（不启动容器）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Mock静态数据</h2>\n<p>在实际工作当中，我们经常会遇到需要对静态方法进行 mock 的情况。在 mockito 2.x 的时代，我们需要借助 powmock 才能实现。当<br>\nmockito 进化到了 3.4.0 版本以后，也开始对静态方法 mock 进行了支持（主要是通过 mockito-inline 包）。</p>\n<p>简单的介绍就到这里，下面让我们进入主题吧。</p>\n<p>首先确保 pom 文件中 mockito 相关 jar 包的版本（这里我用的版本是 3.7.7），如下：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用方式</p>\n<p>Mockito.mockStatic(Class mockClass)，如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样基本上就 OK 了。唯一需要注意下的就是 httpClient.close()。</p>\n<p>如果项目中未引入 mockito-inline，会出现如下错误信息：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>错误提示 static mocking is already registered in the current thread To create a new mock, the existing static mock<br>\nregistration must be deregistered</p>\n<p>当多个单元测试都使用了同一个 static mock 对象，且使用完成后都没有进行 close。此时，若这几个单元测试用一起执行，第一个单元测试占用了<br>\nstatic mock 对象，第二个单元测试就没有办法再占用了。</p>\n<p>如果出现了这种情况，解决办法也很简单，就是关闭 static mock 对象，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果你的很多单元测试中都用到了 mockStatic(HTTPClient.class)，且觉得在每个单元测试当中都写一遍 mockStatic()…close()<br>\n很低效，可以采用下边的方式：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Mock缓存数据</h2>\n<p>在Mockito中，你可以使用Mockito.when配合相应的调用记录方法来模拟缓存场景。以下是一个简单的例子，展示了如何使用Mockito来模拟一个缓存方法的行为：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子中，我们首先通过ConcurrentHashMap模拟了一个简单的缓存。然后我们使用Mockito.spy创建了一个被测试方法所在类的模拟实例。通过Mockito.doReturn我们配置了当调用getFromCache方法并传递特定的key时，模拟方法返回预先定义的值。最后，我们使用Mockito.verify来验证缓存访问方法是否被调用了。这个例子展示了如何使用Mockito来模拟和验证缓存相关的行为。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Reactor",
      "url": "https://ujava.cn/assembly/reactor.html",
      "id": "https://ujava.cn/assembly/reactor.html",
      "summary": "前言 说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。 一、经典的同步阻塞模型 img_46.png 这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。",
      "content_html": "<h2> 前言</h2>\n<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>\n<h2> 一、经典的同步阻塞模型</h2>\n<figure><figcaption>img_46.png</figcaption></figure>\n<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>\n<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>\n<ul>\n<li>read：从socket读取数据。</li>\n<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>\n<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>\n<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>\n1.下面看传统的BIO代码：</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>\n<p>我们的目标是：</p>\n<ul>\n<li>随着负载的增加可以优雅降级；</li>\n<li>能够随着资源的改进，性能可以持续提升；</li>\n<li>同时还要满足可用性和性能指标：</li>\n<li>低延迟</li>\n<li>满足高峰需求</li>\n<li>可调节的服务质量</li>\n</ul>\n<p>阻塞 （针对的是被调用方）</p>\n<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>\n让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>\n<p>同步 （针对的是调用方）</p>\n<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>\n如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>\n<p>NIO就很好的解决了传统Socket问题：</p>\n<ul>\n<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>\n<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>\n</ul>\n<p>2.client端代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>\n<h2> 二、单reactor单线程设计</h2>\n<figure><figcaption>img_47.png</figcaption></figure>\n<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>\n<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>\n<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>\n<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>\n<p>代码示例</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义了一个Reactor类。</p>\n<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>\n<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>\n监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>\n<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>\n<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>\n<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>\n<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>\n<p>下面我们可以进行测试了：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>\n那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>\n<h2> 三、单reactor多线程设计</h2>\n<figure><figcaption>img_48.png</figcaption></figure>\n<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>\n<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>\n<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看测试结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>\n<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>\n<h2> 四、多reactor多线程设计</h2>\n<figure><figcaption>img_49.png</figcaption></figure>\n<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>\n只负责处理客户端的写事件。</p>\n<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>\n<h2> 五、Reactor模型结构图</h2>\n<figure><figcaption>img_50.png</figcaption></figure>\n<ul>\n<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>\n<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>\n<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>\n<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>\n<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件SpringCloud",
      "url": "https://ujava.cn/assembly/springcloud.html",
      "id": "https://ujava.cn/assembly/springcloud.html",
      "summary": "SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。 一、SpringCloud概述 SpringCloud：SpringCloud官网",
      "content_html": "<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>\n<h2> 一、SpringCloud概述</h2>\n<p>SpringCloud：<a href=\"https://spring.io/projects/spring-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud官网</a></p>\n<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>\n<h2> 二、Spring Cloud 和 Dubbo 对比</h2>\n<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>\nSpring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>\nDubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>\n下面是Spring Cloud和Dubbo的一些比较：<br>\n</p>\n<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>\n<p>需要根据具体的业务需求来选择合适的微服务框架。</p>\n<h2> 三、Spring Cloud 优缺点</h2>\n<p>其主要优点有：</p>\n<ul>\n<li>\n<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>\n</li>\n<li>\n<p>约定优于配置，基于注解，没有配置文件。</p>\n</li>\n<li>\n<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>\n</li>\n<li>\n<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>\n</li>\n<li>\n<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>\n接下来，我们看下它的缺点：</p>\n</li>\n<li>\n<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>\n</li>\n<li>\n<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>\nSpring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>\n</li>\n</ul>\n<h2> 四、SpringCloud组件</h2>\n<h3> 1、Eureka</h3>\n<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2、Feign</h3>\n<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3、Ribbon</h3>\n<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4、Hystrix</h3>\n<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5、Config</h3>\n<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、SpringCloud应用场景</h2>\n<h3> 1、微服务架构</h3>\n<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>\n<h3> 2、分布式配置中心</h3>\n<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>\n<h3> 3、服务调用和负载均衡</h3>\n<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>\n<h3> 4、高可用和容错机制</h3>\n<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>\n<h2> 六、结语</h2>\n<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件WebFlux",
      "url": "https://ujava.cn/assembly/webflux.html",
      "id": "https://ujava.cn/assembly/webflux.html",
      "summary": "因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。 然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。 所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。 我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。",
      "content_html": "<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>\n<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>\n<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>\n<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>\n<p>话说这么多，开始今天的学习吧。</p>\n<h2> 什么是 WebFlux</h2>\n<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>\n<figure><figcaption>img_51.png</figcaption></figure>\n<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>\n<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>\n<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>\n<h2> 反应式库</h2>\n<h3> 1. Reactive Stream</h3>\n<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>\n<p>我们先看下这个概念：</p>\n<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>\n<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>\n<p>它由以下几个组件组成：</p>\n<ul>\n<li>发布者：发布元素到订阅者</li>\n<li>订阅者：消费元素</li>\n<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>\n<li>处理器：发布者与订阅者之间处理数据</li>\n</ul>\n<h3> 2. Reactor</h3>\n<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>\n<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>\nReactor 就是 Spring WebFlux 的首选 反应式库。</p>\n<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>\n<ul>\n<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>\n<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>\n两个都是发布者 Publisher。</li>\n</ul>\n<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>\n<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>\n<ul>\n<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>\n<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>\n<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>\n</ul>\n<p>代码初体验</p>\n<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>\n<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>\n</p>\n<ol>\n<li>Mono</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>\n<ul>\n<li>接口耗时：0</li>\n<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>\n</ul>\n<ol start=\"2\">\n<li>Flux</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>\n<h2> 操作数据库</h2>\n<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>\n<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>\n<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>\n<h3> 1. 创建项目</h3>\n<p>选择这几个依赖，创建新的 project:</p>\n<figure><figcaption>img_53.png</figcaption></figure>\n<p>pom.xml 文件里是这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后是 application.properties:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2. 创建数据库表</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个简单的 test_user 表。</p>\n<h3> 3. 创建相关类</h3>\n<p>实体类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserRepository，就相当于 DAO</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserController 控制器</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>\n<h3> 4. 启动测试</h3>\n<p>项目启动之后，我们使用 Postman 测试一下。</p>\n<h3> 请求地址路由</h3>\n<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>\n<p>创建 Userhandler.java</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建 RouterConfiguration</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>\n<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>\n<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>\n<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>\n<li>通过 addRoute 方法可以配置多个路由策略。<br>\n测试</li>\n</ul>\n<p>修改：</p>\n<p>查询和前面一样：</p>\n<h3> 适用性</h3>\n<p>官网上是这样建议的：</p>\n<ul>\n<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>\n<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>\n<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>\n<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>\n</ul>\n<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "架构分类",
      "url": "https://ujava.cn/attention/attention1.html",
      "id": "https://ujava.cn/attention/attention1.html",
      "summary": "架构的本质 其实总结下来就一句话：**架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。 ** 分为三部分： 整体：部分的组成，强调合力。 规则：强调部分之前有关联关系，有规则，有约束。 通信：强调部分之间有往来，有交互。 img_18.png 架构的分类 实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。",
      "content_html": "<h2> 架构的本质</h2>\n<p>其实总结下来就一句话：**架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。<br>\n**</p>\n<p>分为三部分：</p>\n<ul>\n<li>整体：部分的组成，强调合力。</li>\n<li>规则：强调部分之前有关联关系，有规则，有约束。</li>\n<li>通信：强调部分之间有往来，有交互。</li>\n</ul>\n<figure><figcaption>img_18.png</figcaption></figure>\n<h2> 架构的分类</h2>\n<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>\n<h2> 业务架构</h2>\n<p>业务架构是指企业或机构的业务逻辑、流程、组织结构等方面的设计。它着重于企业业务运营的需求和目标，将业务需求转化为技术解决方案。业务架构的设计需要考虑企业的战略规划、组织结构、业务流程、客户需求等多个方面。</p>\n<p>例如：一个银行的业务架构设计需要考虑银行的基本业务逻辑、流程和组织结构，如存款、贷款、投资、支付等，以及银行的安全性、可靠性和效率等方面的需求。</p>\n<h2> 应用架构</h2>\n<p>应用架构是指企业或机构的信息系统中的应用程序、系统、服务等方面的设计。它着重于解决企业业务运营中的具体问题，将业务需求转化为具体的应用程序。应用架构的设计需要考虑企业的业务需求、用户体验、系统性能、安全风险等多个方面。</p>\n<p>例如：一个电商网站的应用架构设计需要考虑用户购物、订单管理、库存管理、支付等多个应用程序的设计，以及这些应用程序之间的交互和集成。</p>\n<h2> 技术架构</h2>\n<p>技术架构是指企业或机构的信息系统中的技术实现、系统架构、软件设计等方面的设计。它着重于解决企业业务运营中的技术问题，如系统的稳定性、可扩展性、可维护性等。</p>\n<p>例如：一个电商网站的技术架构设计需要考虑系统的负载均衡、容错容灾、CDN缓存、自动化部署等多个方面的技术实现。</p>\n<h2> 数据架构</h2>\n<p>数据架构是指企业或机构的信息系统中的数据存储、数据处理、数据安全等方面的设计。它着重于解决企业业务运营中的数据问题，如数据的一致性、完整性、安全性等。</p>\n<p>例如：一个电商网站的数据架构设计需要考虑数据的分层存储、数据备份和恢复、数据加密和权限管理等多个方面的设计，以确保数据的安全和可靠性。</p>\n<h2> 架构设计要考虑的因素</h2>\n<p>架构设计过程中我们要考虑的因素，整体可以分为两大类，一类是功能性因素，一类是非功能性因素。</p>\n<h2> 功能性因素</h2>\n<p>无论什么架构设计，我们首先是要考虑必须满足我们的业务需求，否则我们的设计都是空中楼阁。功能需求会直接决定我们的业务架构设计。所以我们的架构必须完整性地，正确地对业务实现支撑。</p>\n<h2> 非功能性因素</h2>\n<p>满足了功能性因素以后，我们就得要考虑怎么能够稳定地，可靠地，可持续性地支持我们的业务功能，比如性能，可靠性，扩展性，兼容性等等。</p>\n<ul>\n<li>可靠性\n<ul>\n<li>为了更好的服务于功能，我们需要确保架构能够稳定、高效的运行。不会时不时的出现服务崩溃或者不可用的情况。</li>\n</ul>\n</li>\n<li>可用性\n<ul>\n<li>同样的，服务对外要始终处于可用的状态，即使单个服务实例出现问题，我们依然可以正常的对外提供服务。</li>\n</ul>\n</li>\n<li>扩展性\n<ul>\n<li>功能性需求不是一层不变的，尤其在当今盛行敏捷的时代，需求不是一次性提出的。我们需要对系统、服务的整体能力有全面的定位和把控。这就需要我们的架构在新的需求出现的时候，可以方便的进行扩展支持。</li>\n</ul>\n</li>\n<li>治理能力\n<ul>\n<li>好的架构一定是方便运营、管理和监控的。甚至微观到工程管理，代码一定是易于维护、扩展、协同的。</li>\n</ul>\n</li>\n<li>响应性能\n<ul>\n<li>一般的，功能性需求都会对性能有一定的预期。这个业务要我们在架构上做很多工作，比如读写分离、缓存、异步等等的介入，以满足整体架构的响应能力。</li>\n</ul>\n</li>\n</ul>\n<figure><figcaption>img_19.png</figcaption></figure>\n<h2> 设计原则</h2>\n<ul>\n<li>价值为王：系统架构设计应该以实现业务价值为目标，始终关注用户需求和业务场景，确保设计出的系统能够满足用户需求和业务场景，为企业创造价值。</li>\n<li>以终为始：在进行系统架构设计时，需要明确系统的目标和愿景，并以此为起点，进行设计和实现。以确保系统的设计和实现都是为了实现业务价值，满足用户需求。</li>\n<li>分治原则：将系统划分为多个子系统或模块，每个子系统或模块都可以独立地进行开发、测试、部署和维护。这样可以降低系统的复杂度，提高系统的可维护性和可扩展性。</li>\n<li>服务自治：每个服务都应该具备独立的能力，能够独立地进行开发、测试、部署和维护。这样可以提高服务的可用性和可靠性，降低系统的耦合度。</li>\n<li>拥抱变化：系统架构设计应该能够适应业务需求的变化和市场的变化，具备快速响应和灵活应变的能力。</li>\n<li>系统安全性：系统架构设计应该充分考虑系统的安全性，包括数据安全、应用安全、系统安全等方面，确保系统的安全性和稳定性。</li>\n<li>不作不死：系统架构设计应该遵循“最小化变更范围”原则，避免过度设计和复杂度的出现，从而提高系统的可维护性和可扩展性。</li>\n</ul>\n<h2> 常见的架构设计方案</h2>\n<p>之前比较流行的是MVC，MVC有很多的优点，但是缺点也不少：</p>\n<ul>\n<li>视图与控制器的连接过紧，视图如果不依赖控制器，那么它的应用就会十分有限，这妨碍了他们的独立。</li>\n<li>模型对视图数据的访问效率较低，工作量大，并且有一些高级的界面工具或构造器不支持MVC框架。</li>\n<li>MVC架构使得我们面向视图开发，但是视图的变化是不可控的，容易受到用户主观的影响。同时复杂系统必然存在纷繁复杂的依赖，依赖不可能存在于视图，最终表现为接口依赖。</li>\n</ul>\n<p>所以现在比较流行如下几种方案：</p>\n<figure><figcaption>img_20.png</figcaption></figure>\n<h2> 领域驱动架构</h2>\n<p>领域驱动设计是通过将软件实现与核心业务概念的演进紧密相连，从而实现复杂需求的软件开发方法。</p>\n<p>领域驱动设计包括三要素：</p>\n<ul>\n<li>专业知识：就是前期在与客户沟通需求过程中，学习到的关于业务方面的知识。 这类知识并不仅仅只是对需求的理解，更多的要思考业务需求实际要解决的是什么问题。</li>\n<li>抽象能力：一般指发现核心业务对象，简化问题空间的能力。</li>\n<li>细分问题：把业务问题细化为更小更容易处理的子问题。<br>\n领域驱动设计，使得我们不再用数据进行驱动，而是使用领域进行驱动。遇到问题，我们先进行领域上的划分和拆解。这个问题属于哪个问题域，或者需要拆解到哪些问题域里面去，然后再通过领域的组合以及依赖，完成最终问题的解决。</li>\n</ul>\n<h2> 微服务架构</h2>\n<p>微服务架构是一种软件开发架构，它将应用程序拆分成小型、独立的微服务，每个微服务都有自己的功能集，并运行在其独立的进程中。</p>\n<p>微服务架构有以下优点：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化。</li>\n<li>有利于各层逻辑的复用，如PetShop可经过简单的配置实现Sqlserver和Oracle之间的转换。</li>\n<li>扩展性强，不同层负责不同的层面，有利于系统的扩展和维护。</li>\n<li>安全性高，用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。</li>\n<li>项目结构更清楚，分工更明确，有利于后期的维护和升级。</li>\n</ul>\n<h2> 云原生架构</h2>\n<figure><figcaption>img_21.png</figcaption></figure>\n<p>云原生架构是一种创新的软件开发方法，专为充分利用云计算模型而设计。</p>\n<p>云原生架构通过结合使用云计算和各种云服务来创建具有更大可扩展性的可定制模块化基础架构，从而提高了团队的效率，生产力和协作能力。</p>\n<p>云原生架构的核心原则：</p>\n<ul>\n<li>云原生架构是一种设计方法，利用AWS等EC2，S3，Lambda等云服务来支持动态，敏捷的应用程序开发技术，这些技术采用模块化方法通过一套基于云的套件来构建，运行和更新软件微服务与整体应用程序基础架构。</li>\n<li>微服务和容器化通过简化云提供商之间的转移或独立地以不同的语言或框架部署服务而没有冲突或停机的情况，从而支持云本机应用程序的敏捷性和动态性。</li>\n<li>将微服务架构集成到应用程序开发中可支持协作，效率和生产力，因为DevOps团队能够同时独立处理应用程序的不同组件或实现新功能而又不牺牲稳定性。</li>\n</ul>\n<h2> DevOps架构</h2>\n<figure><figcaption>img_22.png</figcaption></figure>\n<p>DevOps架构，它旨在加强软件产品开发与交付过程中的协作、自动化、持续性和监控等方面，以实现更高效、更迅速和更可靠的软件交付。</p>\n<p>DevOps通常包括以下核心组成部分：</p>\n<ul>\n<li>持续集成：将代码频繁地集成到一个共享的代码库中，并对代码进行自动化测试，以确保代码质量和稳定性，并及时发现和解决错误。</li>\n<li>持续交付：通过自动化测试、构建、部署和运行环节，实现快速、可靠和可重复的软件发布，从而减少手动操作和人工干预带来的错误和风险。</li>\n<li>自动化运维：将基础设施的管理、配置和维护工作自动化，并将其作为代码、脚本或配置文件存储在版本控制系统中，以便快速搭建、复制和修改环境。</li>\n<li>容器化技术：使用容器化技术（如Docker）将应用程序和其依赖项打包成独立的、可移植的容器，在不同的环境中快速部署和运行。</li>\n<li>监控和日志分析：通过对软件运行时数据进行采集、储存、分析和可视化，监控系统状态、性能和安全等方面的指标，并及时发现和修复问题。</li>\n</ul>\n<h2> 大数据架构</h2>\n<figure><figcaption>img_23.png</figcaption></figure>\n<p>大数据架构是一种面向海量数据、高并发、高可靠、高性能的计算和存储系统架构，用于管理和处理大规模的结构化、半结构化和非结构化数据。它具有以下几个特点：</p>\n<ul>\n<li>高可扩展性：大数据架构应该能够轻松地扩展到海量数据和高并发请求下。</li>\n<li>高容错性：大数据架构应该在硬件、网络和软件故障等异常情况下保证系统稳定性。</li>\n<li>实时计算：大数据架构需要支持实时计算和流式处理，以满足复杂的业务场景。</li>\n<li>数据安全：大数据架构需要保证数据的机密性、完整性和可用性，避免数据泄露和损坏。</li>\n<li>成本效益：大数据架构应该充分考虑成本问题，尽可能利用开源技术和云平台来降低系统运维和资源开销。<br>\n比如常见的大数据架构包括<code>Hadoop、Spark、Storm、Kafka</code><br>\n等开源软件，它们可以被组合在一起形成一个完整的数据处理流水线。例如，Hadoop可以提供分布式文件系统HDFS和MapReduce计算模型，Spark可以提供内存计算和机器学习功能，Storm可以提供实时数据处理功能，Kafka可以提供高可靠的消息队列服务。使用这些开源软件和云平台，企业可以构建出适合自己场景的大数据处理系统，提升自身的业务竞争力。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计注意"
      ]
    },
    {
      "title": "架构原则",
      "url": "https://ujava.cn/attention/attention2.html",
      "id": "https://ujava.cn/attention/attention2.html",
      "summary": "一.设计原则 架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。 示例： 是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？ 是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？ 淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？",
      "content_html": "<h2> 一.设计原则</h2>\n<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>\n<p>示例：</p>\n<ul>\n<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>\n<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>\n<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>\n</ul>\n<h4> 1.合适原则</h4>\n<blockquote>\n<p>合适优于业界领先。</p>\n</blockquote>\n<p>在进行架构设计的同时，需要考虑自身业务，而不是一味的去参照业界顶尖的规模，如：QQ、微信、淘宝架构。真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>\n<h4> 2.简单原则</h4>\n<blockquote>\n<p>简单优于复杂。</p>\n</blockquote>\n<p>软件架构设计是一门技术活，当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>\n<p>软件复杂度的体现，主要有以下两个方面：</p>\n<p>结构的复杂性<br>\n– 组成复杂系统的组件数量更多；<br>\n– 组件之间的关系也更加复杂。</p>\n<p>其问题主要有：</p>\n<ul>\n<li>（1）组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li>\n<li>（2）某个组件改动，会影响关联的所有组件。</li>\n<li>（3）定位一个复杂系统中的问题总是比简单系统更加困难。</li>\n</ul>\n<h4> 逻辑的复杂性</h4>\n<p>逻辑的复杂性来源于一个组件集中了太多的功能，修改协作困难；并且，其中某些业务还可能使用了一些复杂的算法，导致难以理解、修改困难。</p>\n<p>一个组件集中了太多功能，就会表现出一些逻辑复杂性的特征，为了解决这个问题，一般的手段是进行组件的拆分，但随着组件的细化，又会引入结构复杂性的一些特征，所以，在做结构设计的时候，需要权衡这两者。</p>\n<h4> 3.演化原则</h4>\n<blockquote>\n<p>演化优于一步到位。</p>\n</blockquote>\n<p>维基百科对“软件架构”的定义如下：</p>\n<blockquote>\n<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>\n</blockquote>\n<p>这个定义中，将建筑和软件架构做了一个比较，但是，两者之间是有一个本质区别的：对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。<br>\n也就是说，软件架构的本质是：软件架构需要根据业务发展不断变化，所以，我们在做软件架构设计的时候，不要试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>\n<p>架构设计的过程基本上可以总结为下面三个历程：</p>\n<ul>\n<li>首先，设计出来的架构要满足当时的业务需要。</li>\n<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。--<br>\n小重构</li>\n<li>最后，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。--<br>\n大重构</li>\n</ul>\n<p>我们在做架构设计的时候，切勿贪大求全，或者盲目的照搬大公司的做法，而是要牢记软件架构的本质（软件架构需要根据业务发展不断变化）。认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计注意"
      ]
    },
    {
      "title": "服务器高并发之提高TCP连接数",
      "url": "https://ujava.cn/highfreq/tcpcount.html",
      "id": "https://ujava.cn/highfreq/tcpcount.html",
      "summary": "前言 测试服务器系统：ubuntu server 20.04.3 nginx负载均衡服务器：centos 7 服务器上我放了一个web系统用来测试连接数：开源的支持高并发的服务器 发出请求的是我的电脑，电脑系统：win7 发出请求用的是python的压测工具：locust TCP连接能连接多少",
      "content_html": "<h2> 前言</h2>\n<ul>\n<li>测试服务器系统：ubuntu server 20.04.3</li>\n<li>nginx负载均衡服务器：centos 7</li>\n<li>服务器上我放了一个web系统用来测试连接数：<a href=\"https://github.com/yedf/handy\" target=\"_blank\" rel=\"noopener noreferrer\">开源的支持高并发的服务器</a></li>\n<li>发出请求的是我的电脑，电脑系统：win7</li>\n<li>发出请求用的是python的压测工具：locust</li>\n</ul>\n<h2> TCP连接能连接多少</h2>\n<p>要想弄清楚一个服务器能接受多少连接数，就需要根据socket五元组来看，即源IP+源端口+目标IP+目标端口+类型（TCP/UDP）。只要五元组不重复，就可以新增tcp连接。不过由于测试的时候一般类型都是相同的，所有大多数都是称为四元组。<br>\n由于服务器的IP和web系统的端口一般是固定的，每个客户端的IP又不相同，那么照这样看连接数应该基本上相当于没限制才对。其实不然，实际上每个连接还要占用一定的内存和一个文件描述符。</p>\n<p><strong>那么一个TCP socket占用多少内存呢？</strong><br>\n大约是3K多，当然如果有发送或者接收的缓存区文件存在则另算，在响应较快、缓存文件不大的情况下内存应该不会成为瓶颈。</p>\n<p><strong>服务器又能打开多少文件描述符呢？</strong><br>\n可以通过以下命令查看<br>\n系统级：当前系统可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/file-max</code>&nbsp;查看<br>\n用户级：指定用户可打开的最大数量，通过&nbsp;<code>cat /etc/security/limits.conf</code>&nbsp;查看<br>\n进程级：单个进程可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/nr_open</code>&nbsp;查看</p>\n<p>修改方式<br>\n修改单个进程可打开的最大文件描述符为10000，即可打开10000个连接：<code>echo 10000 &gt; /proc/sys/fs/nr_open</code><br>\n用户级修改：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然，每创建一个tcp连接，还需要消耗一个线程来处理（也可以采用IO多路复用的方式，一个线程管理多个TCP连接），所以和CPU也有关系，不能通过单纯的提高内存的方式来增加连接数。<br>\n常用查看连接数命令：<br>\n<code>netstat -nat | grep -i \"8085\" | wc -l # 查询指定端口的连接数</code><br>\n<code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # 查看TCP连接数及状态命令</code></p>\n<h2> 实际测试</h2>\n<p>此时是使用我的电脑向nginx负载均衡服务器发送请求，然后转发给web服务器。</p>\n<h3> 测试1 未调整的情况下测试</h3>\n<p><strong>客户端情况：</strong><br>\n初始：可用端口55000个，性能够用<br>\n结果：本地性能未达瓶颈，但是设置的1000并发人数，请求数平均只有437.3。<br>\n</p>\n<p><strong>nginx服务器情况：</strong><br>\n初始：可用端口60000个，用户级65535，性能够用<br>\n结果：本地性能未达瓶颈，但是出现很多TIME_WAIT数，最高时8000多。<br>\n</p>\n<p><strong>服务器情况：</strong><br>\n初始：用户级65535。<br>\n结果：最高连接数23，平均2.<br>\n</p>\n<h3> 测试1分析</h3>\n<p>先分析一下TIME_WAIT、CLOSE_WAIT出现的原因及解决方法<br>\n分析这里，就必须要简短回顾一下四次挥手（当client发起结束请求时）<br>\n<br>\n简短来说：<br>\n1、一端没有close，那么另一端将有大量的close_wait状态；<br>\n2、主动close的一端，在量特别大的情况下将造成大量的time_wait状态（由于Linux中一般默认的2msl为60s，那么正常情况下每秒1000的请求会造成60*1000=60000个time_wait记录，几百几千问题不大）</p>\n<p>既然主动close的一方才会有time_wait记录，那么这里就说明nginx服务器是主动关闭的一方，那nginx服务器关闭的对象又是谁呢？<br>\n在仅修改了nginx的代理地址，未改变其他配置情况下，通过wireshark抓包得知：</p>\n<ul>\n<li>客户端与nginx端相互通信都是http/1.1的链接，这里是nginx端先发起的fin请求；</li>\n<li>nginx端到服务器端的请求是http/1.0，服务器端返回的请求是http/1.1，这里是nginx端先发起的fin请求。</li>\n</ul>\n<h3> 测试1优化</h3>\n<p>依上面的场景分析，如果要减少time_wait数，提高连接数，则需要从以下方面来解决</p>\n<ol>\n<li>调整负载均衡服务器和web服务器/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，修改成&nbsp;<code>net.ipv4.ip_local_port_range=1024 65535</code>，保证至少可以使用6万个随机端口，就算保留1分钟，也能支持每秒1000的并发；</li>\n<li>加多负载均衡服务器的ip，直接翻番；</li>\n<li>负载均衡与服务器端也建立长连接，不关闭就不会有等待；</li>\n<li>扩大nginx的keep-alive超时时间，最大请求数，使得长连接不会这么早关闭；</li>\n<li>在nginx服务器上调整time_wait参数net.ipv4.tcp_tw_reuse=1，尽可能去复用连接（另外net.ipv4.tcp_tw_recycle参数在4.10以上内核中被移除了）。</li>\n</ol>\n<p>另外还有一些参数可以调整，不过一般默认是够用的</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>待优化测试验证</p>\n",
      "date_published": "2024-04-15T02:55:40.000Z",
      "date_modified": "2024-04-15T02:55:40.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "高并发场景下如何优化微服务的性能",
      "url": "https://ujava.cn/highfreq/performance.html",
      "id": "https://ujava.cn/highfreq/performance.html",
      "summary": "1.背景介绍 随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。 在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。 2.核心概念与联系",
      "content_html": "<h2> 1.背景介绍</h2>\n<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>\n<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>\n<h2> 2.核心概念与联系</h2>\n<p>在微服务架构中，计算性能的重构主要包括以下几个方面：</p>\n<p>分布式计算：将计算任务分散到多个节点上，通过网络间通信实现数据交换和任务协同。<br>\n并发处理：利用多核处理器和多线程技术，实现并发处理，提高计算效率。<br>\n数据分区：将数据划分为多个部分，每个服务只处理自己的数据，减少通信开销。<br>\n负载均衡：将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>\n这些概念和技术在微服务架构中相互联系，共同实现高性能计算。</p>\n<h2> 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解</h2>\n<p>在微服务架构中，重构计算的核心算法原理包括以下几个方面：</p>\n<h1> 分布式计算：使用MapReduce算法实现分布式计算，将大型数据集划分为多个子任务，每个子任务在多个节点上并行执行，最后通过reduce阶段将结果聚合到一个最终结果中。<br>\nMapReduce=(Map,Shuffle,Reduce)<br>\nMapReduce</h1>\n<h1> (<br>\nMap<br>\n,<br>\nShuffle<br>\n,<br>\nReduce<br>\n)<br>\n并发处理：使用线程池技术实现并发处理，将任务分配到多个线程中执行，提高计算效率。<br>\n线程池=(核心线程数,最大线程数,工作队列)<br>\n线程池</h1>\n<h1> (<br>\n核心线程数<br>\n,<br>\n最大线程数<br>\n,<br>\n工作队列<br>\n)<br>\n数据分区：使用哈希分区算法实现数据分区，将数据按照某个关键字划分为多个部分，每个服务只处理自己的数据。<br>\n哈希分区=(关键字,哈希函数,分区数)<br>\n哈希分区</h1>\n<h1> (<br>\n关键字<br>\n,<br>\n哈希函数<br>\n,<br>\n分区数<br>\n)<br>\n负载均衡：使用Consistent Hashing算法实现负载均衡，将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>\n一致性哈希=(虚拟节点,哈希函数,节点集)<br>\n一致性哈希</h1>\n<p>(<br>\n虚拟节点<br>\n,<br>\n哈希函数<br>\n,<br>\n节点集<br>\n)</p>\n<h2> 4.具体代码实例和详细解释说明</h2>\n<p>在这里，我们以一个简单的Word Count示例来展示如何在微服务架构中实现高性能计算。</p>\n<p>使用MapReduce算法实现分布式计算：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用线程池技术实现并发处理：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用哈希分区算法实现数据分区：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用一致性哈希算法实现负载均衡：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 5.未来发展趋势与挑战</h2>\n<p>随着大数据和人工智能的发展，微服务架构在计算性能方面面临着越来越大的挑战。未来的发展趋势包括：</p>\n<ul>\n<li>\n<p>更高性能的分布式计算：通过优化算法和数据结构，提高分布式计算的性能。</p>\n</li>\n<li>\n<p>更智能的负载均衡：通过学习算法和自适应机制，实现更智能的负载均衡。</p>\n</li>\n<li>\n<p>更高效的数据存储和处理：通过新的存储技术和处理方法，提高数据存储和处理的效率。<br>\n挑战包括：</p>\n</li>\n<li>\n<p>系统复杂性：微服务架构的系统复杂性增加，导致开发、测试和维护的难度增加。</p>\n</li>\n<li>\n<p>数据一致性：在分布式计算中，保证数据的一致性变得越来越难以实现。</p>\n</li>\n<li>\n<p>安全性和隐私：在大数据时代，数据安全性和隐私保护成为关键问题。</p>\n</li>\n</ul>\n<h2> 6.附录常见问题与解答</h2>\n<p>Q: 微服务架构与传统架构有什么区别？</p>\n<p>A: 微服务架构将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。而传统架构通常是基于大型应用程序和单个进程结构的。</p>\n<p>Q: 如何选择合适的算法和数据结构？</p>\n<p>A: 在选择算法和数据结构时，需要考虑问题的特点，如问题规模、时间复杂度、空间复杂度等。同时，也需要考虑算法和数据结构的实现难度和性能。</p>\n<p>Q: 如何保证微服务架构的高性能？</p>\n<p>A: 要保证微服务架构的高性能，需要关注分布式计算、并发处理、数据分区和负载均衡等方面。同时，还需要关注系统的设计和优化，如选择合适的算法和数据结构、减少通信开销、提高系统可扩展性等。</p>\n<p>Q: 如何处理微服务架构中的数据一致性问题？</p>\n<p>A: 在微服务架构中，数据一致性问题可以通过使用分布式事务、版本控制和幂等性等方法来解决。同时，还可以通过设计合理的系统架构和算法来减少数据一致性问题的影响。</p>\n<p>Q: 如何保证微服务架构的安全性和隐私？</p>\n<p>A: 保证微服务架构的安全性和隐私需要关注多方面，如身份验证、授权、加密、审计等。同时，还需要关注数据存储和处理的安全性，如使用安全的存储技术和处理方法。</p>\n",
      "date_published": "2024-04-15T02:24:32.000Z",
      "date_modified": "2024-04-15T02:24:32.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "微服务架构构建之微服务拆分",
      "url": "https://ujava.cn/highfreq/split.html",
      "id": "https://ujava.cn/highfreq/split.html",
      "summary": "简介 微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。 一、微服务拆分的原则 微服务拆分原则有以下几个： 单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。 服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。",
      "content_html": "<h2> 简介</h2>\n<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>\n<h2> 一、微服务拆分的原则</h2>\n<p>微服务拆分原则有以下几个：</p>\n<p>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</p>\n<p>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</p>\n<p>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</p>\n<p>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</p>\n<p>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</p>\n<p>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</p>\n<p>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</p>\n<p>同样，也可以参考一下，这篇文章对服务拆分原则的理解。以下摘自该文章。</p>\n<p>使用有界上下文。</p>\n<p>确定核心域并保持竞争优势。</p>\n<p>对通用域进行成本优化。</p>\n<p>考虑支持领域。</p>\n<p>引入反腐层。</p>\n<p>识别数据通信模式。</p>\n<p>引入事件驱动架构。</p>\n<p>使API简洁明了。</p>\n<p>将相关的微服务合并为更大的服务。</p>\n<p>引入无缝开发支持工具。</p>\n<p>不管是哪种拆分原则，目标都是需要将相同或相似的服务聚合在一起，形成一个独立的自治服务。</p>\n<h2> 二、微服务拆分的时机</h2>\n<p>通过《02-微服务架构的概念与优缺点》可以了解到微服务架构具备很多的优点，能够有效解决项目业务扩大所带来的问题。然而，并非所有公司都适合采用微服务架构，尤其是规模较小且业务相对固定的公司。对于这些公司来说，从服务层面，他们不会有更多变化，通过优化现有服务即可满足需求。从成本方面，构建微服务架构，需要很多资源和配套的中间件。因此，对于那些规模较大，业务服务复杂度高，同时业务也在不断更新或新增的项目，微服务架构则是非常适合的选择。</p>\n<p>在确定使用微服务架构后，服务的拆分是一项重要任务。根据拆分原则，我们可以在恰当的时机进行服务拆分。然而，根据行业经验来看，并不建议在项目构建初期进行服务拆分。主要原因有以下几点：</p>\n<p>项目构建初期，服务单一，数据量较少，及时是单体系统都可以支撑业务。</p>\n<p>项目构建初期，服务没有形成体系，更没有规模服务，很难做到微服务的单一职责和服务自治。</p>\n<p>业务架构不够成熟，目前提供的服务，很有可能会优化，甚至更改技术栈重构。</p>\n<p>因此，项目构建初期无需将其拆分，因为强行拆分此时可能会产生适得其反的效果。而遇到下面这些情况就可以进行服务拆分了。</p>\n<p>项目足够成熟并且业务稳定，团队成员不断扩大并且目前的服务想要扩展很难。只有在项目成熟的情况下，业务专家才可以从精确的划分出业务领域，进而将各个服务分解到业务领域内，最终形成各自独立的微服务。</p>\n<p>项目要求CI/CD（持续集成/持续交付）。尤其是很多新兴的互联网公司，要求系统在尽可能不停机的情况下，还需要持续上线新的功能。使用敏捷开发，可以更好地让开发者在完成周期形的业务交付，而DevOps则可以将这些代码，进行自动化测试、构建和集成，不断的完成新的需求提交，并保证代码的质量和稳定性。</p>\n<p>正式运行的项目，部分服务需要停机。当上线一些有问题的服务时，将该部分服务停机，这个情况对单体应用是非常有困难的。而微服务架构中，可以对存在问题的微服务进行下线处理，从而达到快速解决问题的目的。</p>\n<h2> 三、微服务拆分的方法</h2>\n<p>在掌握了准确的微服务拆分时机和有了强有力的拆分原则后，拆分方法将成为下一个关键环节。现在微服务拆分的方法有很多种，常见的包括：</p>\n<p>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。</p>\n<p>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>\n<p>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。</p>\n<p>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。</p>\n<p>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>\n<p>从行业经验来看，可以确定领域驱动设计（Domain Driven Design，简称DDD）在微服务拆分方面具有显著优势。</p>\n<p>DDD是一种软件开发方法论，它强调将软件划分为不同的领域，每个领域都由一个核心模型驱动。 微服务架构的核心概念是将单一的应用程序拆分为一组小型、自治的服务。而DDD则提供了一种方法来设计这些微服务的边界和交互。 领域驱动设计引入了领域模型的概念，该模型描述了业务领域的核心概念和实体，而不关注技术实现细节。这使得团队可以专注于业务逻辑，而不被底层技术细节所干扰。 通过将领域模型作为微服务拆分的基础，可以确保每个微服务都是高内聚的，并且只关注自己领域内的业务逻辑。这种拆分方式使得每个微服务都能够独立开发、部署和维护，从而提高了系统的可伸缩性和可靠性。 此外，DDD还强调了领域驱动设计的语言在业务团队和开发团队之间的沟通和理解的重要性。通过共享统一的语言和概念，可以确保业务需求能够准确地传达给开发团队，并且开发团队能够将其转化为可行的技术解决方案。 因此，DDD是一种非常适合成为微服务拆分的方法论。它能够帮助开发人员更好地理解业务需求，找到合适的服务边界，构建高质量的领域模型和微服务。</p>\n",
      "date_published": "2024-04-15T02:16:22.000Z",
      "date_modified": "2024-04-15T02:16:22.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "4种MySQL同步ES方案",
      "url": "https://ujava.cn/highfreq/synchronousdata.html",
      "id": "https://ujava.cn/highfreq/synchronousdata.html",
      "summary": "简介 本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具 img_129.png 1.前言 在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。 这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。 我们先看看下面 4 种常用的数据同步方案。",
      "content_html": "<h2> 简介</h2>\n<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>\n<figure><figcaption>img_129.png</figcaption></figure>\n<h1> <strong>1.前言</strong></h1>\n<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>\n这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>\n我们先看看下面 4 种常用的数据同步方案。</p>\n<h1> <strong>2.数据同步方案</strong></h1>\n<h2> <strong>2.1同步双写</strong></h2>\n<p>这是一种最为简单的方式，在将数据写到 MySQL 时，同时将数据写到 ES。</p>\n<figure><figcaption>img_130.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>业务逻辑简单；</li>\n<li>实时性高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>硬编码，有需要写入 MySQL 的地方都需要添加写入 ES 的代码；</li>\n<li>业务强耦合；</li>\n<li>存在双写失败丢数据风险；</li>\n<li>性能较差，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。</li>\n</ul>\n<h2> <strong>2.2异写同步</strong></h2>\n<p>针对多数据源写入的场景，可以借助 MQ 实现异步的多源写入。</p>\n<figure><figcaption>img_131.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>性能高；</li>\n<li>不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息；</li>\n<li>多源写入之间相互隔离，便于扩展更多的数据源写入。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>硬编码问题，接入新的数据源需要实现新的消费者代码；</li>\n<li>系统复杂度增加，引入了消息中间件；</li>\n<li>MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时。</li>\n</ul>\n<h2> <strong>2.3基于SQL抽取</strong></h2>\n<p>上面两种方案中都存在硬编码问题，代码的侵入性太强，如果对实时性要求不高的情况下，可以考虑用定时器来处理：</p>\n<ol>\n<li>数据库的相关表中增加一个字段为 timestamp 的字段，任何 CURD 操作都会导致该字段的时间发生变化；</li>\n<li>原来程序中的 CURD 操作不做任何变化；</li>\n<li>增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；</li>\n<li>逐条写入到 ES 中。</li>\n</ol>\n<figure><figcaption>img_132.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>不改变原来代码，没有侵入性、没有硬编码；</li>\n<li>没有业务强耦合，不改变原来程序的性能；</li>\n<li>Worker 代码编写简单不需要考虑增删改查。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>时效性较差，由于是采用定时器根据固定频率查询表来同步数据，尽管将同步周期设置到秒级，也还是会存在一定时间的延迟；</li>\n<li>对数据库有一定的轮询压力，一种改进方法是将轮询放到压力不大的从库上。</li>\n</ul>\n<p><strong>经典方案：借助 Logstash 实现数据同步，其底层实现原理就是根据配置定期使用 SQL 查询新增的数据写入 ES 中，实现数据的增量同步。</strong></p>\n<h2> <strong>2.4基于Binlog实现同步</strong></h2>\n<p>上面三种方案要么有代码侵入，要么有硬编码，要么有延迟，那么有没有一种方案既能保证数据同步的实时性又没有代入侵入呢？</p>\n<p>当然有，可以利用 MySQL 的 Binlog 来进行同步。</p>\n<figure><figcaption>img_133.png</figcaption></figure>\n<p>具体步骤如下：</p>\n<ul>\n<li>读取 MySQL 的 Binlog 日志，获取指定表的日志信息；</li>\n<li>将读取的信息转为 MQ；</li>\n<li>编写一个 MQ 消费程序；</li>\n<li>不断消费 MQ，每消费完一条消息，将消息写入到 ES 中。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>没有代码侵入、没有硬编码；</li>\n<li>原有系统不需要任何变化，没有感知；</li>\n<li>性能高；</li>\n<li>业务解耦，不需要关注原来系统的业务逻辑。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>构建 Binlog 系统复杂；</li>\n<li>如果采用 MQ 消费解析的 Binlog 信息，也会像方案二一样存在 MQ 延时的风险。</li>\n</ul>\n<h1> <strong>3.数据迁移工具</strong></h1>\n<p>对于上面 4 种数据同步方案，“基于 Binlog 实时同步”方案是目前最常用的，也诞生了很多优秀的数据迁移工具，这里主要对这些迁移工具进行介绍。</p>\n<p>这些数据迁移工具，很多都是基于 Binlog 订阅的方式实现，<strong>模拟一个 MySQL Slave 订阅 Binlog 日志，从而实现 CDC</strong>（Change Data Capture），将已提交的更改发送到下游，包括 INSERT、DELETE、UPDATE。</p>\n<p>至于如何伪装？大家需要先了解 MySQL 的主从复制原理，需要学习这块知识的同学，可以看我之前写的高并发教程，里面有详细讲解。</p>\n<h2> <strong>3.1Canal</strong></h2>\n<p>基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持 MySQL。</p>\n<p>Canal 原理就是伪装成 MySQL 的从节点，从而订阅 master 节点的 Binlog 日志，主要流程为：</p>\n<ol>\n<li>Canal 服务端向 MySQL 的 master 节点传输 dump 协议；</li>\n<li>MySQL 的 master 节点接收到 dump 请求后推送 Binlog 日志给 Canal 服务端，解析 Binlog 对象（原始为 byte 流）转成 Json 格式；</li>\n<li>Canal 客户端通过 TCP 协议或 MQ 形式监听 Canal 服务端，同步数据到 ES。</li>\n</ol>\n<figure><figcaption>img_134.png</figcaption></figure>\n<h2> <strong>3.2阿里DTS</strong></h2>\n<p>数据传输服务 DTS（Data Transmission Service）支持 RDBMS、NoSQL、OLAP 等多种数据源之间的数据传输。</p>\n<p>它提供了数据迁移、实时数据订阅及数据实时同步等多种数据传输方式。相对于第三方数据流工具，DTS 提供丰富多样、高性能、高安全可靠的传输链路，同时它提供了诸多便利功能，极大方便了传输链路的创建及管理。</p>\n<p>特点：</p>\n<ul>\n<li>多数据源：支持 RDBMS、NoSQL、OLAP 等多种数据源间的数据传输；</li>\n<li>多传输方式：支持多种传输方式，包括数据迁移、实时数据订阅及数据实时同步；</li>\n<li>高性能：底层采用了多种性能优化措施，全量数据迁移高峰期时性能可以达到70MB/s，20万的TPS，使用高规格服务器来保证每条迁移或同步链路都能拥有良好的传输性能；</li>\n<li>高可用：底层为服务集群，如果集群内任何一个节点宕机或发生故障，控制中心都能够将这个节点上的所有任务快速切换到其他节点上，链路稳定性高；</li>\n<li>简单易用：提供可视化管理界面，提供向导式的链路创建流程，用户可以在其控制台简单轻松地创建传输链路；</li>\n<li>需要付费。</li>\n</ul>\n<h2> <strong>3.3Databus</strong></h2>\n<p>Databus 是一个低延迟、可靠的、支持事务的、保持一致性的数据变更抓取系统。由 LinkedIn 于 2013 年开源。</p>\n<p>Databus 通过挖掘数据库日志的方式，将数据库变更实时、可靠的从数据库拉取出来，业务可以通过定制化 client 实时获取变更并进行其他业务逻辑。</p>\n<p>特点：</p>\n<ul>\n<li>多数据源：Databus 支持多种数据来源的变更抓取，包括 Oracle 和 MySQL。</li>\n<li>可扩展、高度可用：Databus 能扩展到支持数千消费者和事务数据来源，同时保持高度可用性。</li>\n<li>事务按序提交：Databus 能保持来源数据库中的事务完整性，并按照事务分组和来源的提交顺寻交付变更事件。</li>\n<li>低延迟、支持多种订阅机制：数据源变更完成后，Databus 能在毫秒级内将事务提交给消费者。同时，消费者使用D atabus 中的服务器端过滤功能，可以只获取自己需要的特定数据。</li>\n<li>无限回溯：对消费者支持无限回溯能力，例如当消费者需要产生数据的完整拷贝时，它不会对数据库产生任何额外负担。当消费者的数据大大落后于来源数据库时，也可以使用该功能。</li>\n</ul>\n<h2> <strong>3.4其他</strong></h2>\n<p><strong>Flink</strong></p>\n<ul>\n<li>有界数据流和无界数据流上进行有状态计算分布式处理引擎和框架。</li>\n<li>官网地址：<a href=\"https://flink.apache.org\" target=\"_blank\" rel=\"noopener noreferrer\">https://flink.apache.org</a></li>\n</ul>\n<p><strong>CloudCanal</strong></p>\n<ul>\n<li>数据同步迁移系统，商业产品。</li>\n<li>官网地址：<a href=\"https://www.clougence.com/?utm_source=wwek\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.clougence.com/?utm_source=wwek</a></li>\n</ul>\n<p><strong>Maxwell</strong></p>\n<ul>\n<li>使用简单，直接将数据变更输出为json字符串，不需要再编写客户端。</li>\n<li>官网地址：<a href=\"http://maxwells-daemon.io\" target=\"_blank\" rel=\"noopener noreferrer\">http://maxwells-daemon.io</a></li>\n</ul>\n<p><strong>DRD</strong></p>\n<ul>\n<li>阿里巴巴集团自主研发的分布式数据库中间件产品，专注于解决单机关系型数据库扩展性问题，具备轻量(无状态)、灵活、稳定、高效等特性。</li>\n<li>官方地址：<a href=\"https://www.aliyun.com/product/drds\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.aliyun.com/product/drds</a></li>\n</ul>\n<p><strong>yugong</strong></p>\n<ul>\n<li>帮助用户完成从 Oracle 数据迁移到 MySQL。</li>\n<li>访问地址：<a href=\"https://github.com/alibaba/yugong\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/yugong</a></li>\n</ul>\n",
      "date_published": "2024-04-12T08:16:59.000Z",
      "date_modified": "2024-04-12T08:16:59.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "微服务架构和分布式架构的区别",
      "url": "https://ujava.cn/highfreq/microservice.html",
      "id": "https://ujava.cn/highfreq/microservice.html",
      "summary": "微服务架构和分布式架构的区别有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。 1、含义不同 微服务架构：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。",
      "content_html": "<blockquote>\n<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>\n</blockquote>\n<h2> 1、含义不同</h2>\n<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>\n<p><strong>分布式架构</strong>：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。</p>\n<h2> 2、概念层面不同</h2>\n<p><strong>微服务架构</strong>：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。</p>\n<p><strong>分布式架构</strong>：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。</p>\n<h2> 3、解决问题不同</h2>\n<p><strong>微服务架构</strong>：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。</p>\n<p><strong>分布式架构</strong>：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。</p>\n<h2> 4、部署方式不同</h2>\n<p><strong>微服务架构</strong>：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。</p>\n<p><strong>分布式架构</strong>：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。</p>\n<h2> 5、耦合度不同</h2>\n<p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势，不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>\n<h3> 拓展阅读</h3>\n<h2> 分布式是否属于微服务？</h2>\n<p>答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p>\n",
      "date_published": "2024-04-12T07:48:57.000Z",
      "date_modified": "2024-04-12T07:48:57.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计限流",
      "url": "https://ujava.cn/highfreq/throttling.html",
      "id": "https://ujava.cn/highfreq/throttling.html",
      "summary": "简介 漏桶和令牌桶的区别 漏桶 漏桶 令牌桶 令牌桶",
      "content_html": "<h2> 简介</h2>\n<p>漏桶和令牌桶的区别</p>\n<h2> 漏桶</h2>\n<figure><figcaption>漏桶</figcaption></figure>\n<h2> 令牌桶</h2>\n<figure><figcaption>令牌桶</figcaption></figure>\n",
      "date_published": "2024-03-21T13:06:03.000Z",
      "date_modified": "2024-03-22T03:28:44.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "反应器(Reactor)模式",
      "url": "https://ujava.cn/design/other/reactor.html",
      "id": "https://ujava.cn/design/other/reactor.html",
      "summary": "概述 Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。",
      "content_html": "<h2> 概述</h2>\n<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "读写锁模式",
      "url": "https://ujava.cn/design/other/readerwriterlock.html",
      "id": "https://ujava.cn/design/other/readerwriterlock.html",
      "summary": "概述 当访问数据结构模式时，常规锁不会区分“读锁”和“写锁” 由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。 众所周知，读写器锁的存在解决了这个问题 “多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成 并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者 正在修改或写入数据，并被取消阻止，直到写入程序完成写入。",
      "content_html": "<h2> 概述</h2>\n<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>\n由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>\n众所周知，读写器锁的存在解决了这个问题<br>\n“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>\n并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>\n正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "注册(Registry)模式",
      "url": "https://ujava.cn/design/other/registry.html",
      "id": "https://ujava.cn/design/other/registry.html",
      "summary": "概述 存储单个类的对象，并提供对它们的全局访问点。 与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。",
      "content_html": "<h2> 概述</h2>\n<p>存储单个类的对象，并提供对它们的全局访问点。<br>\n与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "存储库(Repository)模式",
      "url": "https://ujava.cn/design/other/repository.html",
      "id": "https://ujava.cn/design/other/repository.html",
      "summary": "概述 存储库层添加在域和数据映射层之间，以将域对象与 数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个 存储库模式在域类数量很大或很重的系统中特别有用 利用查询。",
      "content_html": "<h2> 概述</h2>\n<p>存储库层添加在域和数据映射层之间，以将域对象与<br>\n数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>\n存储库模式在域类数量很大或很重的系统中特别有用<br>\n利用查询。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "资源获取即初始化模式",
      "url": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "id": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "summary": "概述 资源获取即初始化模式可用于实现异常安全的资源管理。",
      "content_html": "<h2> 概述</h2>\n<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "重试(Retry)模式",
      "url": "https://ujava.cn/design/other/retry.html",
      "id": "https://ujava.cn/design/other/retry.html",
      "summary": "概述 透明地重试涉及与外部资源通信的某些操作， 特别是在网络上，将调用代码与重试实现细节隔离开来。",
      "content_html": "<h2> 概述</h2>\n<p>透明地重试涉及与外部资源通信的某些操作，<br>\n特别是在网络上，将调用代码与重试实现细节隔离开来。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "角色对象(Role Object)模式",
      "url": "https://ujava.cn/design/other/roleobject.html",
      "id": "https://ujava.cn/design/other/roleobject.html",
      "summary": "概述 通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色 对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为 单独的对象、不同的上下文是分开的，并且简化了系统配置。",
      "content_html": "<h2> 概述</h2>\n<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>\n对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>\n单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务(Saga)模式",
      "url": "https://ujava.cn/design/other/saga.html",
      "id": "https://ujava.cn/design/other/saga.html",
      "summary": "概述 这种模式用于分布式服务，以原子方式执行一组操作。 这是数据库中事务的模拟，但就微服务架构而言，这是执行的 在分布式环境中",
      "content_html": "<h2> 概述</h2>\n<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>\n这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>\n在分布式环境中</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分离接口模式",
      "url": "https://ujava.cn/design/other/separatedinterface.html",
      "id": "https://ujava.cn/design/other/separatedinterface.html",
      "summary": "概述 在不同的包中分离接口定义和实现。这允许客户端 完全不知道实现。",
      "content_html": "<h2> 概述</h2>\n<p>在不同的包中分离接口定义和实现。这允许客户端<br>\n完全不知道实现。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "序列化实体模式",
      "url": "https://ujava.cn/design/other/serializedentity.html",
      "id": "https://ujava.cn/design/other/serializedentity.html",
      "summary": "概述 序列化实体模式。 序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。",
      "content_html": "<h2> 概述</h2>\n<p>序列化实体模式。<br>\n序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "雇工(Servant)模式",
      "url": "https://ujava.cn/design/other/servant.html",
      "id": "https://ujava.cn/design/other/servant.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务层模式",
      "url": "https://ujava.cn/design/other/servicelayer.html",
      "id": "https://ujava.cn/design/other/servicelayer.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务定位模式",
      "url": "https://ujava.cn/design/other/servicelocator.html",
      "id": "https://ujava.cn/design/other/servicelocator.html",
      "summary": "概述 使用封装获取服务所涉及的过程 强抽象层。",
      "content_html": "<h2> 概述</h2>\n<p>使用封装获取服务所涉及的过程<br>\n强抽象层。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务工作者模式",
      "url": "https://ujava.cn/design/other/serviceworker.html",
      "id": "https://ujava.cn/design/other/serviceworker.html",
      "summary": "概述 将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。",
      "content_html": "<h2> 概述</h2>\n<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分区(Sharding)模式",
      "url": "https://ujava.cn/design/other/sharding.html",
      "id": "https://ujava.cn/design/other/sharding.html",
      "summary": "概述 Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。 shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。",
      "content_html": "<h2> 概述</h2>\n<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>\nshard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "空间分区模式",
      "url": "https://ujava.cn/design/other/spatialpartition.html",
      "id": "https://ujava.cn/design/other/spatialpartition.html",
      "summary": "概述 正如《游戏编程模式》一书中所解释的那样 Bob Nystrom认为，空间分区模式通过将对象存储在 按位置组织的数据结构。",
      "content_html": "<h2> 概述</h2>\n<p>正如<a href=\"http://gameprogrammingpatterns.com/spatial-partition.html\" target=\"_blank\" rel=\"noopener noreferrer\">《游戏编程模式》</a>一书中所解释的那样<br>\nBob Nystrom认为，空间分区模式通过将对象存储在<br>\n按位置组织的数据结构。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "特殊例子模式",
      "url": "https://ujava.cn/design/other/specialcase.html",
      "id": "https://ujava.cn/design/other/specialcase.html",
      "summary": "概述 定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。",
      "content_html": "<h2> 概述</h2>\n<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "规范(Specification)模式",
      "url": "https://ujava.cn/design/other/specification.html",
      "id": "https://ujava.cn/design/other/specification.html",
      "summary": "概述 规范模式将如何匹配候选对象的语句与候选对象分开 与之匹配的。它不仅在选择中有用，而且对 验证和按订单建造。",
      "content_html": "<h2> 概述</h2>\n<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>\n与之匹配的。它不仅在选择中有用，而且对<br>\n验证和按订单建造。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "步骤建立者模式",
      "url": "https://ujava.cn/design/other/stepbuilder.html",
      "id": "https://ujava.cn/design/other/stepbuilder.html",
      "summary": "概述 Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。 用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。",
      "content_html": "<h2> 概述</h2>\n<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>\n用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扼杀者(Strangler)模式",
      "url": "https://ujava.cn/design/other/strangler.html",
      "id": "https://ujava.cn/design/other/strangler.html",
      "summary": "概述 通过逐步替换特定的功能，逐步迁移遗留系统 新的应用程序和服务。随着旧系统的功能被替换 系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后 扼杀旧系统，让你退役。",
      "content_html": "<h2> 概述</h2>\n<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>\n新的应用程序和服务。随着旧系统的功能被替换<br>\n系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>\n扼杀旧系统，让你退役。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "子类沙盒模式",
      "url": "https://ujava.cn/design/other/subclasssandbox.html",
      "id": "https://ujava.cn/design/other/subclasssandbox.html",
      "summary": "概述 子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。",
      "content_html": "<h2> 概述</h2>\n<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "表模块(Table Module)模式",
      "url": "https://ujava.cn/design/other/tablemodule.html",
      "id": "https://ujava.cn/design/other/tablemodule.html",
      "summary": "概述 表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。",
      "content_html": "<h2> 概述</h2>\n<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模版方法模式",
      "url": "https://ujava.cn/design/other/templatemethod.html",
      "id": "https://ujava.cn/design/other/templatemethod.html",
      "summary": "概述 在操作中定义算法的骨架，将一些步骤推迟到子类中。样板 方法允许子类在不更改算法的情况下重新定义算法的某些步骤 结构",
      "content_html": "<h2> 概述</h2>\n<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>\n方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>\n结构</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:22:04.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "本地线程存储模式",
      "url": "https://ujava.cn/design/other/threadlocalstorage.html",
      "id": "https://ujava.cn/design/other/threadlocalstorage.html",
      "summary": "概述 提供为每个线程提供一个变量副本的功能，使其线程安全。",
      "content_html": "<h2> 概述</h2>\n<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "线程池模式",
      "url": "https://ujava.cn/design/other/threadpool.html",
      "id": "https://ujava.cn/design/other/threadpool.html",
      "summary": "概述 通常情况下，要执行的任务是短暂的，并且任务数量很大。 为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁 线程而不是执行实际任务。线程池通过重用现有的 线程，并消除创建新线程的延迟。",
      "content_html": "<h2> 概述</h2>\n<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>\n为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>\n线程而不是执行实际任务。线程池通过重用现有的<br>\n线程，并消除创建新线程的延迟。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "节流(Throttling)模式",
      "url": "https://ujava.cn/design/other/throttling.html",
      "id": "https://ujava.cn/design/other/throttling.html",
      "summary": "概述 确保给定的客户端访问服务资源的次数不能超过指定的限制。",
      "content_html": "<h2> 概述</h2>\n<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "读者容错模式",
      "url": "https://ujava.cn/design/other/tolerantreader.html",
      "id": "https://ujava.cn/design/other/tolerantreader.html",
      "summary": "概述 Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法 是在从另一个服务读取数据时尽可能宽容。这样，当 交流模式发生变化，读者一定不能断。",
      "content_html": "<h2> 概述</h2>\n<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>\n是在从另一个服务读取数据时尽可能宽容。这样，当<br>\n交流模式发生变化，读者一定不能断。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:22:04.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "蹦床(Trampoline)模式",
      "url": "https://ujava.cn/design/other/trampoline.html",
      "id": "https://ujava.cn/design/other/trampoline.html",
      "summary": "概述 Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法 并且交织功能的执行而不将它们硬编码在一起。",
      "content_html": "<h2> 概述</h2>\n<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>\n并且交织功能的执行而不将它们硬编码在一起。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务脚本模式",
      "url": "https://ujava.cn/design/other/transactionscript.html",
      "id": "https://ujava.cn/design/other/transactionscript.html",
      "summary": "概述 事务脚本按过程组织业务逻辑，其中每个过程处理一个 来自演示文稿的请求。",
      "content_html": "<h2> 概述</h2>\n<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>\n来自演示文稿的请求。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "双(Twin)模式",
      "url": "https://ujava.cn/design/other/twin.html",
      "id": "https://ujava.cn/design/other/twin.html",
      "summary": "概述 双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个 java中的继承",
      "content_html": "<h2> 概述</h2>\n<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>\njava中的继承</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务脚本模式",
      "url": "https://ujava.cn/design/other/typeobject.html",
      "id": "https://ujava.cn/design/other/typeobject.html",
      "summary": "概述 当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。",
      "content_html": "<h2> 概述</h2>\n<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "工作单元模式",
      "url": "https://ujava.cn/design/other/unitofwork.html",
      "id": "https://ujava.cn/design/other/unitofwork.html",
      "summary": "概述 当业务事务完成时，所有更新都作为一个大的工作单元发送 一次性持久化，以最大限度地减少数据库往返。",
      "content_html": "<h2> 概述</h2>\n<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>\n一次性持久化，以最大限度地减少数据库往返。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "更新方法模式",
      "url": "https://ujava.cn/design/other/updatemethod.html",
      "id": "https://ujava.cn/design/other/updatemethod.html",
      "summary": "概述 更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。",
      "content_html": "<h2> 概述</h2>\n<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "值对象模式",
      "url": "https://ujava.cn/design/other/valueobject.html",
      "id": "https://ujava.cn/design/other/valueobject.html",
      "summary": "概述 提供遵循值语义而不是引用语义的对象。 这意味着值对象的相等性不是基于身份的。两个值对象是 当它们具有相同的值时相等，而不一定是同一对象。",
      "content_html": "<h2> 概述</h2>\n<p>提供遵循值语义而不是引用语义的对象。<br>\n这意味着值对象的相等性不是基于身份的。两个值对象是<br>\n当它们具有相同的值时相等，而不一定是同一对象。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "版本号模式",
      "url": "https://ujava.cn/design/other/versionnumber.html",
      "id": "https://ujava.cn/design/other/versionnumber.html",
      "summary": "概述 版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。",
      "content_html": "<h2> 概述</h2>\n<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "页面对象模式",
      "url": "https://ujava.cn/design/other/pageobject.html",
      "id": "https://ujava.cn/design/other/pageobject.html",
      "summary": "概述 Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI 组件。这样一来，它允许测试类本身专注于测试逻辑。",
      "content_html": "<h2> 概述</h2>\n<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>\n组件。这样一来，它允许测试类本身专注于测试逻辑。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "参数对象模式",
      "url": "https://ujava.cn/design/other/parameterobject.html",
      "id": "https://ujava.cn/design/other/parameterobject.html",
      "summary": "概述 Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。",
      "content_html": "<h2> 概述</h2>\n<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "部分响应模式",
      "url": "https://ujava.cn/design/other/partialresponse.html",
      "id": "https://ujava.cn/design/other/partialresponse.html",
      "summary": "概述 根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。",
      "content_html": "<h2> 概述</h2>\n<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "管道(Pipeline)模式",
      "url": "https://ujava.cn/design/other/pipeline.html",
      "id": "https://ujava.cn/design/other/pipeline.html",
      "summary": "概述 通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。",
      "content_html": "<h2> 概述</h2>\n<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "毒丸(Poison Pill)模式",
      "url": "https://ujava.cn/design/other/poisonpill.html",
      "id": "https://ujava.cn/design/other/poisonpill.html",
      "summary": "概述 毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。",
      "content_html": "<h2> 概述</h2>\n<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "演示模型模式",
      "url": "https://ujava.cn/design/other/presentationmodel.html",
      "id": "https://ujava.cn/design/other/presentationmodel.html",
      "summary": "概述 演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。",
      "content_html": "<h2> 概述</h2>\n<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "优先级队列模式",
      "url": "https://ujava.cn/design/other/priorityqueue.html",
      "id": "https://ujava.cn/design/other/priorityqueue.html",
      "summary": "概述 对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。",
      "content_html": "<h2> 概述</h2>\n<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "私有类数据模式",
      "url": "https://ujava.cn/design/other/privateclassdata.html",
      "id": "https://ujava.cn/design/other/privateclassdata.html",
      "summary": "概述 私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。",
      "content_html": "<h2> 概述</h2>\n<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "生产者消费者模式",
      "url": "https://ujava.cn/design/other/producerconsumer.html",
      "id": "https://ujava.cn/design/other/producerconsumer.html",
      "summary": "概述 生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。",
      "content_html": "<h2> 概述</h2>\n<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "承诺(Promise)模式",
      "url": "https://ujava.cn/design/other/promise.html",
      "id": "https://ujava.cn/design/other/promise.html",
      "summary": "概述 Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。",
      "content_html": "<h2> 概述</h2>\n<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "属性(Property)模式",
      "url": "https://ujava.cn/design/other/property.html",
      "id": "https://ujava.cn/design/other/property.html",
      "summary": "概述 使用现有对象作为父对象创建对象和新对象的层次结构。",
      "content_html": "<h2> 概述</h2>\n<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T03:06:02.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "基于队列的负载均衡模式",
      "url": "https://ujava.cn/design/other/queuebasedloadlevel.html",
      "id": "https://ujava.cn/design/other/queuebasedloadlevel.html",
      "summary": "概述 使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。",
      "content_html": "<h2> 概述</h2>\n<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>\n",
      "date_published": "2024-03-04T03:06:02.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "页面控制模式",
      "url": "https://ujava.cn/design/other/pagecontroller.html",
      "id": "https://ujava.cn/design/other/pagecontroller.html",
      "summary": "概述 这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。",
      "content_html": "<h2> 概述</h2>\n<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>\n",
      "date_published": "2024-03-04T02:16:14.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "层模式",
      "url": "https://ujava.cn/design/other/layers.html",
      "id": "https://ujava.cn/design/other/layers.html",
      "summary": "概述 层是一种体系结构模式，其中软件职责在不同的 应用程序的层。",
      "content_html": "<h2> 概述</h2>\n<p>层是一种体系结构模式，其中软件职责在不同的</p>\n<p>应用程序的层。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "懒加载模式",
      "url": "https://ujava.cn/design/other/lazyloading.html",
      "id": "https://ujava.cn/design/other/lazyloading.html",
      "summary": "概述 延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。",
      "content_html": "<h2> 概述</h2>\n<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者选举模式",
      "url": "https://ujava.cn/design/other/leaderelection.html",
      "id": "https://ujava.cn/design/other/leaderelection.html",
      "summary": "概述 领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。",
      "content_html": "<h2> 概述</h2>\n<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "领导者跟随者模式",
      "url": "https://ujava.cn/design/other/leaderfollowers.html",
      "id": "https://ujava.cn/design/other/leaderfollowers.html",
      "summary": "概述 领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。",
      "content_html": "<h2> 概述</h2>\n<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "锁定对象模式",
      "url": "https://ujava.cn/design/other/lockableobject.html",
      "id": "https://ujava.cn/design/other/lockableobject.html",
      "summary": "概述 可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。",
      "content_html": "<h2> 概述</h2>\n<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "日志整合模式",
      "url": "https://ujava.cn/design/other/logaggregation.html",
      "id": "https://ujava.cn/design/other/logaggregation.html",
      "summary": "概述 集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。",
      "content_html": "<h2> 概述</h2>\n<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "标记接口模式",
      "url": "https://ujava.cn/design/other/markerinterface.html",
      "id": "https://ujava.cn/design/other/markerinterface.html",
      "summary": "概述 使用空界面作为标记来区分经过特殊处理的对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用空界面作为标记来区分经过特殊处理的对象。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "主从模式",
      "url": "https://ujava.cn/design/other/masterworker.html",
      "id": "https://ujava.cn/design/other/masterworker.html",
      "summary": "概述 当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。",
      "content_html": "<h2> 概述</h2>\n<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "元数据对象关系映射模式",
      "url": "https://ujava.cn/design/other/metadatamapping.html",
      "id": "https://ujava.cn/design/other/metadatamapping.html",
      "summary": "概述 保存元数据中对象关系映射的详细信息。",
      "content_html": "<h2> 概述</h2>\n<p>保存元数据中对象关系映射的详细信息。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模块模式",
      "url": "https://ujava.cn/design/other/module.html",
      "id": "https://ujava.cn/design/other/module.html",
      "summary": "概述 模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。",
      "content_html": "<h2> 概述</h2>\n<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "单体(monad)模式",
      "url": "https://ujava.cn/design/other/monad.html",
      "id": "https://ujava.cn/design/other/monad.html",
      "summary": "概述 基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。 从形式上讲，monad 由一个类型构造函数 M 和两个操作组成： bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。",
      "content_html": "<h2> 概述</h2>\n<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>\n<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>\n<ul>\n<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>\n<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "单态(MonoState)模式",
      "url": "https://ujava.cn/design/other/monostate.html",
      "id": "https://ujava.cn/design/other/monostate.html",
      "summary": "概述 强制执行一种行为，例如在所有实例之间共享相同的状态。",
      "content_html": "<h2> 概述</h2>\n<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "多态(Multiton)模式",
      "url": "https://ujava.cn/design/other/multiton.html",
      "id": "https://ujava.cn/design/other/multiton.html",
      "summary": "概述 确保类只有有限数量的实例，并提供对它们的全局访问点。",
      "content_html": "<h2> 概述</h2>\n<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "静音(Mute Idiom)模式",
      "url": "https://ujava.cn/design/other/muteidiom.html",
      "id": "https://ujava.cn/design/other/muteidiom.html",
      "summary": "概述 提供一个模板来抑制任何已声明但不能发生或只应记录的异常； 同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。",
      "content_html": "<h2> 概述</h2>\n<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>\n同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图控制器(MVC)模式",
      "url": "https://ujava.cn/design/other/mvc.html",
      "id": "https://ujava.cn/design/other/mvc.html",
      "summary": "概述 将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。",
      "content_html": "<h2> 概述</h2>\n<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图反应(MVI)模式",
      "url": "https://ujava.cn/design/other/mvi.html",
      "id": "https://ujava.cn/design/other/mvi.html",
      "summary": "概述 MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。",
      "content_html": "<h2> 概述</h2>\n<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图分离(MVP)模式",
      "url": "https://ujava.cn/design/other/mvp.html",
      "id": "https://ujava.cn/design/other/mvp.html",
      "summary": "概述 应用“关注点分离”原则，使开发人员能够构建和测试用户界面。",
      "content_html": "<h2> 概述</h2>\n<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模型视图视图模型(MVVM)模式",
      "url": "https://ujava.cn/design/other/mvvm.html",
      "id": "https://ujava.cn/design/other/mvvm.html",
      "summary": "概述 应用“关注点分离”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。",
      "content_html": "<h2> 概述</h2>\n<p>应用“<a href=\"https://java-design-patterns.comprinciplesseparate-of-concerns\" target=\"_blank\" rel=\"noopener noreferrer\">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "裸对象(Naked Objects)模式",
      "url": "https://ujava.cn/design/other/nakedobjects.html",
      "id": "https://ujava.cn/design/other/nakedobjects.html",
      "summary": "概述 裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。 裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。 裸对象模式具有许多优点，包括： 1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。 2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。 3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。",
      "content_html": "<h2> 概述</h2>\n<ul>\n<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>\n<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>\n<li>裸对象模式具有许多优点，包括：\n<ul>\n<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>\n<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>\n<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T01:48:41.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象母亲模式",
      "url": "https://ujava.cn/design/other/objectmother.html",
      "id": "https://ujava.cn/design/other/objectmother.html",
      "summary": "概述 它用于定义具有独立构建器和工厂接口的不可变内容的工厂。",
      "content_html": "<h2> 概述</h2>\n<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "对象池模式",
      "url": "https://ujava.cn/design/other/objectpool.html",
      "id": "https://ujava.cn/design/other/objectpool.html",
      "summary": "概述 当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。",
      "content_html": "<h2> 概述</h2>\n<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "乐观线下锁模式",
      "url": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "id": "https://ujava.cn/design/other/optimisticofflinelock.html",
      "summary": "概述 提供避免在关系数据库中同时更改一条记录的能力。",
      "content_html": "<h2> 概述</h2>\n<p>提供避免在关系数据库中同时更改一条记录的能力。</p>\n",
      "date_published": "2024-03-04T01:48:41.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "Flux模式",
      "url": "https://ujava.cn/design/other/flux.html",
      "id": "https://ujava.cn/design/other/flux.html",
      "summary": "概述 Flux避开MVC，转而支持单向数据流。当 用户与视图交互，视图通过中心传播动作 调度器，到保存应用程序数据和业务的各种存储 逻辑，更新所有受影响的视图。",
      "content_html": "<h2> 概述</h2>\n<p>Flux避开MVC，转而支持单向数据流。当<br>\n用户与视图交互，视图通过中心传播动作<br>\n调度器，到保存应用程序数据和业务的各种存储<br>\n逻辑，更新所有受影响的视图。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "Flyweight模式",
      "url": "https://ujava.cn/design/other/flyweight.html",
      "id": "https://ujava.cn/design/other/flyweight.html",
      "summary": "概述 使用共享可以有效地支持大量细粒度对象。",
      "content_html": "<h2> 概述</h2>\n<p>使用共享可以有效地支持大量细粒度对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "前端控制器模式",
      "url": "https://ujava.cn/design/other/frontcontroller.html",
      "id": "https://ujava.cn/design/other/frontcontroller.html",
      "summary": "概述 为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。",
      "content_html": "<h2> 概述</h2>\n<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "游戏循环模式",
      "url": "https://ujava.cn/design/other/gameloop.html",
      "id": "https://ujava.cn/design/other/gameloop.html",
      "summary": "概述 游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入 无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝 控制游戏的速率。 这种模式将游戏时间的进展与用户输入和处理器速度解耦。",
      "content_html": "<h2> 概述</h2>\n<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>\n<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>\n<p>控制游戏的速率。</p>\n<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "保护性暂停模式",
      "url": "https://ujava.cn/design/other/guardedsuspension.html",
      "id": "https://ujava.cn/design/other/guardedsuspension.html",
      "summary": "概述 当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。",
      "content_html": "<h2> 概述</h2>\n<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "半同步半异步模式",
      "url": "https://ujava.cn/design/other/halfsyncasync.html",
      "id": "https://ujava.cn/design/other/halfsyncasync.html",
      "summary": "概述 半同步/半异步模式将同步I/O与 系统中的异步I/O，以简化并发编程工作，而不需要 从而降低执行效率。",
      "content_html": "<h2> 概述</h2>\n<p>半同步/半异步模式将同步I/O与</p>\n<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>\n<p>从而降低执行效率。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "健康检查模式",
      "url": "https://ujava.cn/design/other/healthcheck.html",
      "id": "https://ujava.cn/design/other/healthcheck.html",
      "summary": "概述 通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。",
      "content_html": "<h2> 概述</h2>\n<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "六边形体系结构模式",
      "url": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "id": "https://ujava.cn/design/other/hexagonalarchitecture.html",
      "summary": "概述 允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。",
      "content_html": "<h2> 概述</h2>\n<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "同一性映射模式",
      "url": "https://ujava.cn/design/other/identitymap.html",
      "id": "https://ujava.cn/design/other/identitymap.html",
      "summary": "概述 通过将每个加载的对象保持在地图中，确保每个对象只加载一次。 引用对象时使用地图查找对象。",
      "content_html": "<h2> 概述</h2>\n<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>\n<p>引用对象时使用地图查找对象。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "拦截过滤器模式",
      "url": "https://ujava.cn/design/other/interceptingfilter.html",
      "id": "https://ujava.cn/design/other/interceptingfilter.html",
      "summary": "概述 截取过滤器是一种有用的Java设计模式，用于预处理 或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于 请求，然后再将其提供给目标应用程序。这样的使用示例包括认证， 这是在向应用程序发出请求之前必须处理的。",
      "content_html": "<h2> 概述</h2>\n<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>\n<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>\n<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>\n<p>这是在向应用程序发出请求之前必须处理的。</p>\n",
      "date_published": "2024-03-03T08:20:09.000Z",
      "date_modified": "2024-03-03T08:20:09.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "功能切换模式",
      "url": "https://ujava.cn/design/other/featuretoggle.html",
      "id": "https://ujava.cn/design/other/featuretoggle.html",
      "summary": "概述 软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于 AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。",
      "content_html": "<h2> 概述</h2>\n<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>\nAB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "流接口模式",
      "url": "https://ujava.cn/design/other/fluentinterface.html",
      "id": "https://ujava.cn/design/other/fluentinterface.html",
      "summary": "概述 流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。",
      "content_html": "<h2> 概述</h2>\n<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>\n",
      "date_published": "2024-03-03T03:41:37.000Z",
      "date_modified": "2024-03-03T03:41:37.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "环绕执行模式",
      "url": "https://ujava.cn/design/other/executearound.html",
      "id": "https://ujava.cn/design/other/executearound.html",
      "summary": "概述 环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。",
      "content_html": "<h2> 概述</h2>\n<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扩展对象模式",
      "url": "https://ujava.cn/design/other/extensionobject.html",
      "id": "https://ujava.cn/design/other/extensionobject.html",
      "summary": "概述 预计将来需要扩展对象的接口。其他接口由扩展对象定义。",
      "content_html": "<h2> 概述</h2>\n<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>\n",
      "date_published": "2024-03-03T03:36:58.000Z",
      "date_modified": "2024-03-03T03:36:58.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    }
  ]
}