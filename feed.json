{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "UJava",
  "home_page_url": "https://ujava.cn/",
  "feed_url": "https://ujava.cn/feed.json",
  "description": " 【Java学习 + Java面试】首选UJava！  ",
  "favicon": "https://ujava.cn/favicon.ico",
  "items": [
    {
      "title": "项目管理经验二",
      "url": "https://ujava.cn/manage/project2.html",
      "id": "https://ujava.cn/manage/project2.html",
      "summary": "前言 介于许多人对项目经理这个职位的陌生和含糊，将自己的切身经历和阅读、交流得到的一些经典案例整理出来。 要做好一个项目经理，是很有点难的，他首先必须要是技术和管理的化身，其次要具备较好的形象和极佳的口才，同时拥有一定的人格魅力，另外他还要具备一定的设计头脑和审美观，还有很多，不再赘述....在大多数boss的眼里，是没有体系分工的概念或者基于各种原因分工比较简单，所以很多书里讲的东西拿到现实里多少会有点靠不住，不管你是正在转型做项目经理，还是有打算转型，那一定要转变以前种种思想的包袱了，由内而外的改变自己，很多路子只是苦于我们没有发现，没有人指引。我们不希望每字每句的总结和讨论都能去符合每个人的行走线路，因为那是不可能，只希望当我们遇到困难缺乏指引时它能成为我们的参考和依据，因为沟通才是通往成功最好的桥梁！",
      "content_html": "<p><strong>前言</strong></p>\n<p>介于许多人对项目经理这个职位的陌生和含糊，将自己的切身经历和阅读、交流得到的一些经典案例整理出来。</p>\n<p>要做好一个项目经理，是很有点难的，他首先必须要是技术和管理的化身，其次要具备较好的形象和极佳的口才，同时拥有一定的人格魅力，另外他还要具备一定的设计头脑和审美观，还有很多，不再赘述....在大多数boss的眼里，是没有体系分工的概念或者基于各种原因分工比较简单，所以很多书里讲的东西拿到现实里多少会有点靠不住，不管你是正在转型做项目经理，还是有打算转型，那一定要转变以前种种思想的包袱了，由内而外的改变自己，很多路子只是苦于我们没有发现，没有人指引。我们不希望每字每句的总结和讨论都能去符合每个人的行走线路，因为那是不可能，只希望当我们遇到困难缺乏指引时它能成为我们的参考和依据，因为沟通才是通往成功最好的桥梁！</p>\n<p><strong>正文</strong></p>\n<p>做项目经理工作多年，感到做这个工作最要紧的就是要明白什么是因地制宜、因势利导，只有最合适的，没有什么叫对的，什么叫错的，项目经理最忌讳的就是完美主义倾向，尤其是做技术人员出身的，喜欢寻找标准答案，耽误了工作进度，也迷茫了自己。以下是本人一些做项目的个人体会，写出来供大家指点，在讨论过程中共同提高水平。软件工程跟其它建筑工程之间的区别之一是，总有人会拿各种各样的事来讽刺软件的设计和开发过程中的不确定性，但从没有听说过有什么大桥建成之后和图纸上设计的不一样的。下面有一个漫画《 客户真正的需求是这样的 》已经足够一针见血的了，<br>\n</p>\n<p>还有这幅漫画同样一点情面的不留，虽是漫画，但现实生活中不乏实例<br>\n</p>\n<p>项目开始阶段是一个最重要的阶段。项目经理在接手一个新项目的时候，首先要尽可能地多从各个方面了解项目的情况，如：</p>\n<ol>\n<li>\n<p>这个项目是什么项目，具体大概做什么事情，是谁提出来的，目的是解决什么问题。在国内很多客户都很不成熟的情况下，千万不要根据项目的名称望文生义地去想象项目的目标。一个名为“办公自动化”的项目很有可能在你进场以后一个月才发现客户其实需要的是一个计算机生产管理辅助信息系统。前期了解情况的工作越详细，后面的惊讶就越少，项目的风险就越小。</p>\n</li>\n<li>\n<p>这个项目里牵涉哪些方面的人，如投资方、具体业务干系方、项目建成后的运营方、技术监督方等等，很多项目里除了业主单位的结构很复杂以外，还有一些其他单位也会牵涉进来，如项目监理公司、业主的行业主管机构等。项目经理需要了解每个方面的人对这个项目的看法和期望是什么。事先了解各个方面的看法和期望，可以让你在做项目碰到问题的时候，就每件事情分析哪些人会在什么方面支持你，哪些人会出于什么目的反对你，从而提前准备联合朋友去对抗敌人，让事情向你所希望的方向发展。没有永远的朋友，也没有永远的敌人，只有一致的利益，这句话作为项目经理是一定要记住的。</p>\n</li>\n<li>\n<p>基本了解了客户的情况后，下面的事情就是了解自己公司各方面对这个项目的看法。首先是高层领导是否重视，这个决定了你在需要资源的时候，公司是否会根据你的要求提供最有力的支持。领导口头肯定是说支持的，你需要做的是了解公司对这个项目的实际期望，是想把项目越做越大还是想赚钱？是想做样板工程还是干脆想敷衍了事，公司领导对项目的态度决定了你做这个项目的战略，而这个战略方针将对你做项目计划产生直接的影响。</p>\n</li>\n<li>\n<p>在做整体项目计划前，还要大致计算一下你手上的资源。首先是时间，现在市场竞争激烈，往往很多项目要求在几乎不可能的时间范围里完成。对于这一点，你在做项目的风险控制计划的时候要充分考虑。其次是人员，根据项目预算和已往经验，大致计算一下未来的项目小组有多少种角色，每个角色目前公司是否有人，是否能完全归这个项目使用，是否需要另外招聘一些人员，招聘的准备工作要尽早启动。最后就是一些设备的准备，项目所需大件关键设备要尽早预定，以后不管发生设备等人还是人等设备的情况，浪费的都是你的时间。</p>\n</li>\n<li>\n<p>现在是做项目说明书的时候了。一份好的项目说明书不仅将要做的事情描述得很清楚（主要是讲做什么，而不是说怎么做），而且把如何检查也说明得很透彻。也就是说它不仅说明白了要做哪些事情，也让客户的业务人员（一般不懂技术）知道项目做成什么样就算完成了。简单地说，项目说明书描述项目做哪些事情和每件事情做到什么程度以及如何检查每一个结果。</p>\n</li>\n<li>\n<p>是到做总体计划的时间了吗？不，你现在已经知道了客户的目标和你手上的资源，那么做计划以前，你还需要和你的经理和客户充分沟通资源的问题。因为很多资源是还不明确的，你需要写一份报告，详细分析这个项目的风险以及对资源的需求情况。如果一些问题不能得到解决的话，将发生什么样的后果。如果资源不够，就要高层改变策略，增加对这个项目的投入。甚至在条件许可的情况下，有些公司会放弃这个项目。总之，没有人能完成一个不可能完成的任务，如果项目经理不能尽早发现风险，那么就只能去当烈士了。</p>\n</li>\n<li>\n<p>明白了要做哪些事情和你手上的筹码以及你做这个项目的总体策略，现在是成立项目小组的时候了。很多项目经理都没有自己选择组员的权利，那么，就尽量发挥你的影响力去寻找那些你想要的人吧。成员的组成根据项目不同，相差较大，很难有什么具体要求，但是，一定要有精通客户业务的人，很多小项目里，这个人就是项目经理本人，大项目里会配备行业专家（Industry expert），这样和客户沟通起来才不会鸡同鸭讲，双方才可以相互理解。我经常看到的情况是我们的技术人员和客户交谈时满口的专业术语，结果搞得客户一头雾水，反过来，他还指责客户不懂技术。其实，明白自己想做什么的客户已经是很好的客户了，不知道自己要做什么，更不懂怎么做还要指手画脚的客户到处存在，但是要明白，是客户选择了你，而不是你选择了客户，有了客户你才有工资拿，心平气和一点吧。</p>\n</li>\n</ol>\n<p>对于这种需求天天变的客户，你就一定要事先做好规矩：</p>\n<ul>\n<li>一、统一联系人，客户指定一个人和项目组进行沟通，不能张领导、王领导都来说几句，如果他们意见不一致，那你只有得罪领导的选择了。所以，项目的最初就要定好规矩，我项目组只认一个的意见，有什么要求你们内部先统一再和我谈，我不想卷入你们内部业务部门之间的矛盾之中。</li>\n<li>二、所有需求变更全部要有书面文字，这点切记！这样做好处多多：</li>\n</ul>\n<ul>\n<li>有书面证据，以后他还想改，你有了他以前要求的证据，告诉他：你以前可是这么说的。</li>\n<li>便于需求变更管理，需求如何慢慢演变的历史可以看清楚，从而更深切地体会客户的目。</li>\n<li>对于客户来说，嘴巴一动最方便，反正是你们做，不花他的资源，所以要求是否合理，是否和项目的目的一致，他是不负责任的。但是如果要他写书面要求，还要签字盖章，他就要谨慎多了，而且一写东西，思想就会更加深入，很多无理要求也就这样胎死腹中了。</li>\n</ul>\n<ol start=\"8\">\n<li>\n<p>现在你要面对三群人：你的领导、你的组员和你的客户，和这些人沟通，让他们知道你打算怎么做，什么时候要他们做什么准备，这些事情将是你的主要工作。既然沟通这么重要，那事先定义一下沟通的原则也是一件很要紧的事情。很多沟通原则都是潜规则，如果你在一个部门时间做长了，对这些规则的运用觉得是一件理所应当的事情。但是，你现在面对的是多个部门甚至多个单位，不把沟通规则说清楚，你以后就会吃亏。下面的东西看起来无聊，其实还是很管用的：第一个是规定信息的流动方式和介质，是推还是拉。推的意思就是项目经理将主动发布信息，不管通过电话、邮件还是书面方式，保证将信息传达到每个人。这种情况适合小项目，人少。拉的意思就是项目经理就是一个类似web服务器，你自己需要什么信息就去问他。当然，没有项目经理把自己搞得那么累，他会用发布信息到公共介质的方式公布信息，简单的是白板，复杂一点的是项目的公共信息交互区，潜规则就是我发了你没去看就不要说我没告诉你。说这些看似很无聊，其实里面牵涉信息传达不完全的责任问题。当然，这些都是指一般的方式，而且不要绝对化，一般情况下，主动沟通和被动访问是同时存在的，尤其是对领导，项目经理更加应该主动去和领导沟通。第二个问题就是文档问题，很多人怕写文档，但是项目经理一定要牢记“好记性不如烂笔头”的道理。有理有时候为什么会说不清呢？就是因为没有证据。所以项目经理开始就要和客户说清楚有些文档是必须签字的，比如项目经理的项目日志，每个星期至少让客户签字，另外所有达成共识的东西，比如会议纪要，甚至领导的讲话记录，都要写成文档，双方签字，这样以后扯皮的时候，就能做到有据可查。记住：说了的就和没说一样，只有写下来大家签字后才算真正发生了的。还有一些问题，比如你提交的报告，给领导（包括本方领导和客户领导）做一个选择题，结果领导压住不批，让你无所适从，结果拖延了进度。这时候，你可以等，但是注意要留记录，标明是谁的责任；另外，如果你在开始阶段就和领导商定：如果批示提交三天后没有得到领导答复就算对方同意，这样你就会主动很多。再比如不同事件的审批流程问题：什么等级的事情记录在项目日志里、什么等级的事情要双方项目经理专门签署备忘录、什么等级的事情要双方领导出面签署合同附件等等。事先想得越周到，以后的工作就越主动</p>\n</li>\n<li>\n<p>好了，做了很多前期工作，定义了一些游戏规则，现在是坐下来做计划的时候了。这一节，任意找一本项目管理的书都会说得比我好，所以我就少写一点，说一些自己的体会就是了。首先是找几个关键组员，比如客户业务专家、系统分析员等等，做一下项目模块划分工作。项目分成几块去做，每一块完成什么，模块之间的信息如何交换等等。需求定义的是做什么的问题，而这里说的是怎么做的问题。这里要强调一点：完成一个目标有很多种方式，你要选一种你最熟悉的，而不是看上去最完美的，这个思路会让你的项目减少很多风险。有时候客户会被某种新技术打动，坚持要你采用那种新技术，你就应该告诉他：你选我做这个项目，就应该容许我采用自己最喜欢的方式做事情，新技术之所以有诱惑力，就是因为吃亏的人还不多，我不希望你成为第一批受害者。采用一个计划会让你的工作更加明确，比如用微软的Project软件，你填写完表格以后，就可以知道这个项目有多少件事情要做，每件事情需要什么资源，他们之间的前后关系如何，消耗的时间有多长，完成后有什么标志等。所有的结果最后用一个叫做甘特图的形式表现出来。你做完这个表以后会惊奇地发现，甘特图上项目的结束时间会远远落后于你的计划结束时间（签合同的人永远不会先征求你的意见的）。当然，学过项目管理的人会大谈什么WBS、优化路径之类的东西，但是我的经验是你再优化也不可能把这些东西安排到计划的时间结束。如果你没碰到这个问题，在我恭喜你挑了一个轻松活之前，请你再去确认你是否罗列了所有要做的事情和正确评估了它们所需要的时间。这时候，你就要考虑牺牲一些任务的时间（也意味着质量）了。按照什么标准牺牲？这个项目的战略！我们在第三节提到过的战略。我的经验是如果你什么都赶进度，其结果可能就是十件事情你一件也没做好，想想多么失败啊。所以，把资源投到你熟悉和有把握的事情上，最后的结果是十件事情，你有三件做成了精品，三件完成，还有四件因为某些原因延误，成绩单是否靓丽了很多呢？战略决定优先级，而正确排列事情的优先级是一个项目经理能力的主要体现。</p>\n</li>\n<li>\n<p>好，现在项目已经完成了前期工作，了解了项目的目标、搞清楚了手上的资源，制定了项目的策略，然后编制了项目的整体计划，项目进入实施阶段。进入这个阶段反而是项目经理比较空闲的时候，不像前期的时候项目经理要象记者一样到处和不同的人接触，搞清楚他们在说什么，努力猜测他们在想什么和他们的真正目的，那才是最累人的事情。当然，小项目的项目经理往往自己也是一个资源，要做很多事情，这时候反而比谁都苦。项目经理这段时间的主要工作是保持和客户领导以及自己领导的沟通。和客户领导沟通时特别要注意，除非你需要对方给你支持，那么你才需要讲得具体一点，否则，告诉他一切正常就可以了，而且态度要积极一些，千万不要说一些领导不懂的细节，比如：“王局长，最近项目进度还算正常，就是JVM经常发生一些内存泄漏的情况…”王局长：“(*&amp;$@@”。和自己的领导汇报也要注意这个问题，除非他是一个技术高手，你需要他的技术经验，否则一般就汇报进度是否正常以及有问题时你的对策和打算就可以了，有些需要他支持的地方，比如资源调用需要说详细一点。和组员开会，除了一些项目进度跟踪会议以外，还有很多讨论会，需要大家用头脑风暴方法给出解决问题。与会人员很多都是技术人员，他们的特点是注重细节、缺乏大局观、有点消极悲观、自尊心强（如果总结得不对，欢迎大家拍砖），所以，你作为会议的主持人，只要负责提出问题和记录下他们的观点，千万不要做评判者的角色。一个问题，有很多方面，从不同的角度看，现象是完全不同的，想想盲人摸象的故事吧。这些技术人员，他们往往精通一个方面，就自己的角度发表见解，除非一些很特别的情况，你都应该认为，他们提出的方案，从他们的角度来看是最合理的。你的长处是掌握事情的优先级，评估各个方面的轻重缓急，从而根据他们的意见得出一个合适的（而不是正确的）方案。所以，在会议上，你要充分尊重每一个人和他的意见，夸奖那些意见提得比较好的人，千万不要把会议带入无休止的争论（你要让大家知道事情不是非黑即白的，而是多元的，唉，我们的教育惹的祸…）。会后，你自己写文档，做决定。会议上大家的面子都被照顾了，自己实施起来的阻力就小，如果还有意见的，你就私下找他聊，如果还不能说服他，你就要让他明白，因为你负责这个项目、你担当风险，所以，这个优先级应该你来判断。组织中的高层，并不见得水平会比一般的成员高，但是，他要承担组织的风险，加之信息的不对称性，所以，对事情的优先级的判断肯定比下属强。</p>\n</li>\n</ol>\n<p>终可交付成果一定要是可以被检查的，比如，【界面要求：美观大方、简洁明快】，这个要求我就不知道如何检查。所以，给开发小组布置任务的时候就要考虑如何检查结果，比如我见过一个计划，里面有一个任务【开发人员熟悉EJB编程】，这个任务，除了让这些人去参加一些专业认证考试，否则，结果很难被检查。所以，时刻考虑如何检查结果、如何向客户交付是项目经理一直要注意的事情，我听说有些老项目经理拿到项目是倒排计划的，即首先看如何验收和验收标准，然后决定工作计划。很多项目开始了很久，还不知道如何验收，那么这个项目出问题的可能性就很大了。做项目就是为了验收，我们的角色不是研究机构，我们的目的就是在付出那么多劳动后得到结果。</p>\n<p>另外我插一句：我是极其不主张到客户现场开发的。尤其是一大群技术人员直接和客户交流，很容易引起冲突和矛盾（技术人员的本性决定的）。我的做法是项目经理和项目实施人员到现场，软件开发人员还是在公司做项目。项目实施人员就是初级项目经理，他们了解自己的产品，懂得一些客户的业务，关键是在于他们具有良好的沟通能力，俗称“皮厚”。他们是客户和研发人员的桥梁，其职业方向也是很机动灵活，以后可以有很多方向可以转，比开发人员的路要宽得多。</p>\n<ol start=\"11\">\n<li>\n<p>接着，我们再谈谈最让人头痛的需求变更问题。变更通常分为两种：一种是部分更改了原先的目标，即需求变更；另一种是没改变目标，但是客户不满意目前的实现方式，大到流程的实现，小到界面的布局，都是属于这类。碰到这种情况是难以避免的，主要是事先沟通的不够充分和客户随着项目的进展，慢慢想清楚了问题，改变了以前的思路。这时候，如果需要改并且你的战略是容许这种情况的，那么注意下面几点：</p>\n<ol>\n<li>确保以前的文档，就是记载着以前的结论的东西，客户是否签过字，如果没有，赶紧把你的工作停下来，赶快再和客户自己确认一下你的方案，然后让他签字，避免以后说话没有凭据；</li>\n<li>和客户坐下来，探讨他修改的根本目的是什么，是不是有同样能达到相同目的、但是对你来说有代价更小的选择？</li>\n<li>（项目初期的工作）明确更改流程，一般是客户指定一人签字（否则客户每个领导都有权力来插一杠子，你就废了），以正式项目文件的方式提交给你，然后，你做评估分析，分析对成本、进度的影响，在你的领导同意后，出相应意见书，主要是要说明更改设计的原因和指出由此带来的不确定后果（这个东西先写出来，后面如果真的发生了，至少不是你的错）。然后再让客户在上面签字。见过医院给病人做手术以前让家人签的免责条款吗？对，就学习那个，让大家都意识到任何的更改都有成本和代价。</li>\n</ol>\n</li>\n<li>\n<p>系统开发告一段落后，就进入客户培训、系统验收阶段，这个阶段，我一般会注意以下几个问题：</p>\n</li>\n</ol>\n<p>一、给客户做培训前，多注意一些表面功夫。很多程序员认为，系统的逻辑核心是否正确是关键，至于界面如何，界面上的用词是否准确，那是无关紧要的问题，而且培训的时候也是信手拈来，想到哪里说到哪里，下面听讲的人不知所云，云山雾罩，培训效果自然可以想象。我的体会是，给客户做培训的版本，如果你在做多次测试以后仍然不能确定逻辑是否合乎要求，那么，你至少要在界面上多花一点功夫。注意每个界面的布局、用词、链接的正确性等等，总之不要让客户看到一些他不该看到的东西。文档方面，准备至少两个文档：用户手册和培训手册。这两个文档的内容很多都是一致的，但是角度完全不同。用户手册往往是站在系统设计者的角度，按照自己的思路，分模块讲解系统的操作和功能；而培训手册，一定要站在客户业务人员的角度，根据每个角色面对不同业务的办理，如何通过使用本系统的一系列功能来实现目标。所以，第一次培训以前，系统界面是否完整正确、培训文档是否完备都是很关键的因素，第一炮打不响，以后就麻烦很多</p>\n<p>作为项目经理，其实脑子里就是几样东西：做哪些事情、做到什么程度、怎么交货、手上的资源以及各个事情的优先级。所谓多快好省那是人类的梦想，这四个方面都是相互矛盾的，属于典型的又要马儿跑，又要马儿不吃草的类型。考虑问题的轻重缓急方面，往往是把快放在第一位，各方领导都会给你最后期限，所以保进度是第一位的；省是第二位的，企业的根本目的是盈利，如果收入不能增加的话，至少费用要控制住；好是第三位的，没办法，谁都想精益求精，但是，没有强大的资源保障，质量只好先牺牲了；最后是多，客户的要求源源不断，如何降低客户的期望值，让他们从理想回到现实也是项目经理的分内工作。</p>\n<p>验收前，除了做好文档工作，即可交付成果以外，多花时间搞清楚客户的做事情流程是很重要的事情，这些在前面已经有所提及，这里就不再多说。</p>\n<p>我对验收最大的体会就是举证问题。即千万不要让客户这么想：你必须有证据证明你的系统是没问题的。这样你就没戏了，微软那么多天才，做了XP还天天打补丁，要你的程序没问题，既不可能，你也没办法拿出证据。你要让客户明白，所谓验收，就是我按照测试文档的测试用例跑一遍，结果和预期结果一致就应该算通过了，而且还容许有一些小错误留在验收后改正，他可以对测试用例提意见。所以，验收前双方要确认测试计划和测试用例。如果他认为系统不符合要求，那么他应该举证，证明这个系统和最初设计相背离的。所以，参考法律概念，千万不要举证倒置。另外，认为系统完美了才能验收的想法也是错误的，软件开发合同里一定要注明验收以后维护期的费用问题，否则，客户担心一旦验收就得不到你们的支持，自然不配合验收，那么，你这个项目经理就很难交功课了。</p>\n<p>最后，我想谈谈如何评价项目经理的绩效的问题，我认为，项目经理有以下几个档次：</p>\n<ul>\n<li>最差的项目经理：项目过程中总是出现意外，然后自己又解决不了，结果成为烈士；</li>\n<li>二流的项目经理：项目也经常出现意外，但是他一马当先，奋勇向前，解决了一个又一个问题，最后，勉强算把项目结束了，获得了领导的一致好评；</li>\n<li>一流的项目经理：平时很少见他做具体的事情，整天找人聊天，然后就是写报告、做计划，最后项目顺利结束，整个过程平淡无奇； 项目管理培训</li>\n</ul>\n<p>项目管理到底是一门科学还是一门艺术呢？所谓科学就是经过反复论证，输入和输出有必然规律的东西，种瓜得瓜；而艺术就是思想火花的闪耀，主要靠灵感。项目管理这个东西，据一个前辈说，在国外是科学，80%是有规律可循的；在国内是艺术，主要靠个人魅力、感染能力等东西。看明白了PMBOK，学会了一些做事情的方式，只是搞懂了那个20%的科学的东西，还有80%的空间，属于见仁见智的领域了。所以，加强很多方面的个人能力，如练就出色沟通能力、提升自己的个人魅力对于项目经理来说是多么重要啊，无论是对内还是对外。作为一个一流的专业人士，在顺利让客户签字的同时，如何让自己的领导知道你的价值，这也是体现自己能力的一种途径。</p>\n",
      "date_published": "2024-08-19T15:39:03.000Z",
      "date_modified": "2024-08-19T15:39:03.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "项目管理经验一",
      "url": "https://ujava.cn/manage/project.html",
      "id": "https://ujava.cn/manage/project.html",
      "summary": "img_2.png 一、项目，尤其是涉及到用户日常工作的项目，一定是一个心路历程。 每个项目参与者和被影响者的心态，价值观以及情绪的变化比技术上的变化重要的多，对项目成败的影响也往往更大。因为事情终归是要人去做的，专家可以一夜之间解决所有技术问题，但是人的问题只能一点一滴逐步解决。 所以从项目开始到结束的过程中需要保持关注关键用户以及最终用户对项目和任务的看法，了解他们的心路变化，并且在需要的时候做适当应对或者项目修正。 二、期望所有人都有共同的价值观和奉献精神是不可能的",
      "content_html": "<figure><figcaption>img_2.png</figcaption></figure>\n<h2> 一、项目，尤其是涉及到用户日常工作的项目，一定是一个心路历程。</h2>\n<p>每个项目参与者和被影响者的心态，价值观以及情绪的变化比技术上的变化重要的多，对项目成败的影响也往往更大。因为事情终归是要人去做的，专家可以一夜之间解决所有技术问题，但是人的问题只能一点一滴逐步解决。<br>\n所以从项目开始到结束的过程中需要保持关注关键用户以及最终用户对项目和任务的看法，了解他们的心路变化，并且在需要的时候做适当应对或者项目修正。</p>\n<h2> 二、期望所有人都有共同的价值观和奉献精神是不可能的</h2>\n<p>因此在项目开始前就需要得到<strong>关键用户</strong>和<strong>项目组成员直接主管</strong>的支持与共识，并且得到一定程度上的授权。同时，努力让用户清楚这个项目究竟会带来哪些改变？为什么要改变？有什么好处或者有什么坏处？能够学到什么？让参与者有真正的参与感，而不仅仅是被动的接受者。</p>\n<h2> 三、细化项目任务</h2>\n<p>项目经理需要把每个目标每个任务都细化。尽管项目经理不一定完全懂得项目中所涉及的全部技术问题，但是他一定要能够联系到可用的资源，同时通过询问和调研将任务细化，然后再分配到每个人员身上去。这样，每个人要做的事情都很清晰（指的是每个阶段内的事情），每个细小的目标都会觉得很容易实现，并且不用担心自己没有涉及到的其他任务，因为我很清楚会有别人去做，而且他可以被信任。如果项目经理总是在High Level地讲问题，没有足够的细化，一方面会造成做事的人觉得任务无比艰巨，渐渐失去信心；另一方面会由于责任不清造成部门间的推诿和指责。</p>\n<h2> 四、项目还是控制在自己手里更好</h2>\n<p>除非顾问公司的能力、经验和责任心都是可以完全信赖的，项目还是控制在自己手里更好。再强的项目经验和软件技术都没有对公司业务的了解更重要。掌控在手里，顾问公司也是资源。被顾问公司主导，想到使用这个资源的时候就得吵架。</p>\n<h2> 五、遵守项目规则</h2>\n<p>项目开始时激情澎湃地定下的规矩，一定要遵守并且执行下去。不了了之，或者随意更改都将影响人的心态。这些规矩其实没有绝对的好与坏，但是坚持一定比随意得到的结果更好。</p>\n<h2> 六、面对面的沟通是无法替代的</h2>\n<p>即便是通讯手段如此发达的时代，也一定不要忽略面对面沟通的重要，因为只有在面对面的时候我们才能真实地感受到对方的情绪、情感以及语言背后的内容。很多时候在电子邮件、微信甚至电话中的表达都是经过修饰的，或者是被剥离感情的。</p>\n<h2> 七、项目进度公示</h2>\n<p>所有项目涉及到的部门，就算不是核心部门。也一定要让他们了解项目的进度，尤其是将要对他们产生的影响。人都不喜欢被招之即来挥之即去。</p>\n<h2> 八、重视数据</h2>\n<p>无论任何信息系统，数据都是最重要，最核心的，而不是流程。</p>\n<p>每个系统都有n多的公司在使用，即便是流程的定制也不离其宗。但是你的数据只对你自己有用，而且是独一无二的。数据一定要被重视，给出足够的时间提炼和整理。输入的是垃圾，输出的也一定是垃圾，流程和系统再好也没用。</p>\n<h2> 九、增加员工参与项目的积极性</h2>\n<p>平时就要经常进行跨部门的合作，让大家习惯一起达成目标，而不是相互扯皮（这个无法避免，只能适当消除，但是很多时候部门之间的敌对程度甚至超过了竞争对手）。而且要奖励参加项目的人员，并且尽量让参加项目的人从日常工作中脱离出来。这一点大公司有着先天的优势，因为它储备的人力资源相对较多。参加项目的人学到新技能和知识，顶替他工作的人也学到新技能担负起新任务。所以员工都期望参加项目，而不是拒绝项目。</p>\n",
      "date_published": "2024-08-19T14:44:39.000Z",
      "date_modified": "2024-08-19T15:39:03.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "设计管理",
      "url": "https://ujava.cn/manage/design.html",
      "id": "https://ujava.cn/manage/design.html",
      "summary": "什么是设计管理 管理： 指通过计划，组合，指导以及协调，控制不同的智能元素组合而成的一个设计活动过程，它本身包含决策，领导，调控等智能方面。是管理层面的人员通过较为系统的、协调的或和谐的人类活动来创新、引领、维持和运行有明确目标的组织过程。 而设计管理这一概念主要用于描述在设计作为商业资源语境下对设计及其过程从宏观到微观进行规划和实施的一系列管理实践。 设计是管理的对象，又是管理对象的限定。设计管理相比于设计更侧重项目，平台，战略的管理。",
      "content_html": "<h2> 什么是设计管理</h2>\n<p><strong>管理：</strong> 指通过计划，组合，指导以及协调，控制不同的智能元素组合而成的一个设计活动过程，它本身包含决策，领导，调控等智能方面。是管理层面的人员通过较为系统的、协调的或和谐的人类活动来创新、引领、维持和运行有明确目标的组织过程。</p>\n<p>而<strong>设计管理</strong>这一概念主要用于描述在设计作为商业资源语境下对设计及其过程从宏观到微观进行规划和实施的一系列管理实践。</p>\n<p>设计是管理的<strong>对象</strong>，又是管理对象的<strong>限定</strong>。设计管理相比于设计更侧重项目，平台，战略的管理。</p>\n<p>设计管理作为一门新学科的出现，既是设计的需要，也是管理的需要。设计管理的基本出发点是提高产品开发设计的效率。根据使用者的需求，有计划、有组织地进行研究与开发管理活动，有效地积极调动设计师的创造性思维，把市场与消费者的认识转换在新产品中，以新的、更合理、更科学的方式影响和改变人们的生活，并为企业获得最大限度的利润而进行的一系列设计策略与设计活动的管理。</p>\n<h2> 设计管理的内容</h2>\n<p>设计管理的主要内容是如何在各个不同的层面将设计所包含的各项<strong>资源以及活动进行合理有效地整理汇总</strong>，<strong>并进行协调。</strong><br>\n这些就是设计管理所研究的内容，同时对相应的设计方案、策略以及设计活动进行科学合理的管控，最后达到所预想的目标。</p>\n<h2> 设计管理的分类</h2>\n<p>设计管理的分类从不同角度来看有不同的分类，主要有以下几个方面：</p>\n<p>（一）从管理内容角度的分类：</p>\n<ul>\n<li>1、明确设计<strong>活动方向</strong>的设计战略管理</li>\n<li>2、保证设计活动有效实施的<strong>设计团队</strong>管理</li>\n<li>3、针对<strong>设计项目</strong>的设计营销管理</li>\n<li>4、针对内部的<strong>设计流程</strong>管理</li>\n<li>5、针对<strong>知识产权</strong>的设计成果管理</li>\n</ul>\n<p>（二）宏观与微观角度的分类：</p>\n<p>1、<strong>微观层面：针对项目层面的资源与效率进行管理</strong></p>\n<p>为实现项目目标而对相关项目实施的任务进行的规划和引导，例如，项目意向书，设计简报，合同，预算。</p>\n<p>2、<strong>宏观层面：构建企业宏观战略，深度管理资源与效率</strong></p>\n<p>在企业将设计作为确立竞争优势和实现商业目标为重要资源的视野下所涉及的有关任务（如策略设计），进行规划和引导。进而构建企业宏观战略，对企业层面的资源和效率进行管理。</p>\n<h2> 设计管理的工具方法</h2>\n<p>一般而言，在设计管理系统研究的基础上，设计管理方法体系主要由<strong>设计决策管理方法、设计组织管理方法、设计项目管理方法</strong>构成（其核心是<strong>设计创新要素）</strong>。设计创新始终渗透在每一个具体的设计管理活动之中，它既是设计管理的最终目标，也是设计管理方法的最终指向。<br>\n</p>\n<p>（一）<strong>设计决策管理：</strong></p>\n<p>对产品设计的全部环节——前期、中期、后期，以及最终结果，进行策略制定与执行（计划）。</p>\n<p>（二）<strong>设计组织管理：</strong></p>\n<p>通过设计创新提高企业竞争能力、科学分工、创新协作，提升企业行业环境内的竞争力，激发企业创新力。<br>\n方法：设计组织形态、设计组织类型、设计组织运行、设计组织环境等几种。</p>\n<p>（三）<strong>设计项目管理：</strong></p>\n<p>设计项目管理可视为对整个<strong>设计过程</strong>的管理，与此同时，再实际管理中起到非常重要的作用。设计项目管理主要包括<strong>领导、组织、用人、计划、控制</strong>等五项主要工作。</p>\n<figure><figcaption>img_1.png</figcaption></figure>\n<h2> 企业发展不同阶段的设计管理方法框架</h2>\n<p><strong>层级1：无设计管理</strong></p>\n<p>企业几乎没有预先使用任何实际的设计政策或者设计方案。设计活动只是在某些特殊情况下才会实施，并且预算也相当有限，同时缺乏相应的设计知识和经验。</p>\n<p><strong>层级2：项目层的设计管理</strong></p>\n<p>企业较少使用设计，因为设计活动主要局限在造型、产品线拓展或产品改良等项目中，通常被当作<strong>营销工具</strong><br>\n，通过对产品外观、风格、包装、营销传播或视觉形象的改善提升，以达到对现存产品增值的目的。大部分企业都没有意识到通过设计新产品和服务来创造增值价值的作用。</p>\n<p><strong>层级3：设计管理作为一种企业管理职能</strong></p>\n<p>企业有计划地将设计应用于创新与产品开发，设计活动不再仅仅局限于产品，而是从更<strong>广泛</strong>的层面运用<strong>设计解决创新问题</strong><br>\n。设计活动参与者来自多种专业背景，企业设立了专门的部门或员工负责对整个设计过程进行管理，管控整个设计过程的质量，确保设计成为企业获得竞争力的重要因素。</p>\n<p><strong>层级4：设计管理作为一种企业文化</strong></p>\n<p>企业把设计创新作为建立市场领导力的手段，设计创新成果包括新产品或服务，一种创新的形式和风格，或创新的市场手段如新的零售概念等。这类企业是高度设计驱动的，它们的领导力来自于将设计作为核心所产生的战略所致。高层管理层和各部门都需要深度涉及设计活动，设计成为企业经营活动的一个构成内容。企业重视增强雇员的设计意识，将设计意识融合进企业文化，从而实现对设计价值最大程度的挖掘和体现。</p>\n<p>从设计管理实践角度看，管理者习惯于将设计管理阶梯模型所呈现出的最高层级作为自己的目标。但，不是每个企业都需要把设计作为创新驱力作为策略焦点。须知，要根据自身特点、市场定位和企业发展策略出发，即使是第二层和第三层也足以满足许多企业的需要。实际上，许多企业不可能像第一层级的公司(<br>\n通常是一些本土的、小规模且特别专业领域的供应商)那样完全忽视设计管理在企业中的存在。更多的是在合理确定企业设计能力发展目标的基础上，采用有效的设计管理方法，有助于企业实现获得更强的竞争能力的目标。</p>\n<h2> 当代设计管理和方法的特点</h2>\n<p>就目前来看，当代设计管理和方法的特点，主要有以下四点：</p>\n<ul>\n<li>1.设计管理方法反映出设计管理所具有的显著的集成性和整合性特点。设计以人性价值为中心，融合了人性与技术，艺术与工艺，客户与商业，消费与文化，本身就具有整合多方资源的特点；</li>\n<li>2.设计管理方法侧重产品和品牌的视觉品质管理以及对商业价值实现的支持；</li>\n<li>3.支持对组织内部的设计意识培育和设计文化建设；</li>\n<li>4.想要实现创新驱动企业，需要将设计思维贯穿所有参与商业活动的组织层级和结构部门，将设计意识转化为企业文化，从而实现内部设计创新能力可持续增长。</li>\n</ul>\n<h2> 联系</h2>\n<p><strong>1.设计管理与设计师</strong><br>\n设计专业的划分到现在已经相当精细，一个设计师精通现代设计的每个环节已不可能，相反，<strong>除了设计专长，反而需要具备一定的市场、管理、营销方面的知识，才能够胜任分工合作过程中的定位和协作任务。</strong><br>\n设计师不再总以独立的个体而存在，而是依照管理的要求，成为设计产业链条中的一环、设计生产流水线上的一员。这种改变，使得设计管理上升为一种使组织高效和管理优化的手段，被不断提上议程。</p>\n<p><strong>2.创造性思维与设计管理</strong><br>\n设计管理要以<strong>消费者</strong>为着眼点，整合企业各部门和系统，协调各种资源，对设计的全程进行有效的管理，设计出符合<strong>消费者心理</strong><br>\n的产品与服务，它与传统的管理模式有着许多不同。要更好地促进设计管理的发展，其中<strong>创造性设计思维</strong>是必不可少的。<br>\n将创造性设计思维应用于设计管理之中，不仅能使设计方案更加具有<strong>创新性</strong>，同时也能使设计活动更具有<strong>时效性</strong><br>\n。在两者结合之后，创造性设计思维不仅能带动设计管理的创新与突破，同时设计管理也能以其独特的管理模式促进设计思维的优化，从而达到相辅相成、互相促进的效果。也只有这样，我国的设计管理才能在不久的将来赶超时代的步伐，成为时代的领头羊。</p>\n<h2> 设计管理的优点/意义</h2>\n<ul>\n<li>1、有利于促进技术突破和不同领域的合作，企业社团各方面资源得以充分利用，从而实现设计制造的敏捷化，推动技术迅速转化为商品。</li>\n<li>2、有利于及时获得市场信息，设计针对性产品，由设计改变生活方式，从而为企业创造新的市场。</li>\n<li>3、有利于正确引导资源的利用，利用先进技术实现设计制造的虚拟化，降低了人力物力的消耗，提高了企业产品的竞争力。</li>\n<li>4、有利于正确处理企业各方面关系，创造出健康的工作氛围。</li>\n<li>5、有利于建立一支精干稳定的设计队伍，解决人员流动过频的弊端。</li>\n<li>6、有利于创造清晰、新颖和具备凝聚力的企业形象。</li>\n</ul>\n<h2> 设计管理案例</h2>\n<p><strong>1.宜家：设计降低产品成本</strong></p>\n<p>作为家具和家居相关配件的领先制造商和销售商，宜家将其所有资源集中在以尽可能低的价格为客户提供创新产品。虽然低价创意需要更具挑战性的设计思维，但这一理念的实现使宜家在家具行业的公司中处于世界领先地位。</p>\n<p>设计最重要的功能之一是解决公司的问题，而对于宜家来说，成本被视为将其创意产品销售给消费者的最大障碍。因此，应用自组装和扁平包装解决方案成为了帮助宜家实现其目标的成功设计策略之一。宜家的大部分产品都是按照自组装策略设计的，扁平包装的设计是为了在储存和运输过程中尽可能少地占据体积，从而降低最终产品的价格。扁平包装的设计还便于最终客户使用，他们只需要根据说明书来组装产品。如果需要任何进一步的帮助，消费者也可以致电宜家获得支持。</p>\n<p>自组装和扁平包装不仅有助于宜家降低其产品的最终价格，而且有助于实现其可持续发展目标。较小的存储区域有助于减少运输和燃料的使用，这与其可持续性设计模型一致。</p>\n<p><strong>2.星巴克：设计助力品牌业务</strong></p>\n<p>星巴克成立于 35 年前，现在是咖啡店界的领先公司，它利用设计通过独特的情感营销方式为其业务打造品牌。该公司的战略以设计为工具，在 37 个国家的 12,440 多家门店为全球消费者提供卓越的服务，2006 年的总营业额为 78 亿美元。<br>\n星巴克的设计师负责所有门店的品牌推广和营销材料。目标是最大限度地发挥创造力，以保持星巴克品牌的情感价值。星巴克的设计师被鼓励以商业奇迹和战略家的身份思考。创意团队负责为全球所有星巴克门店建立一致的品牌战略。每年，这些商店都会采用由公司内部的全球创意团队所设计的季节性主题。</p>\n<p><strong>3.苹果：设计创造机会</strong></p>\n<p>Apple 是拥有长期设计战略的公司之一，该战略专注于消费者满意度并在苹果公司与用户之间建立强大的情感营销关系。在 2001<br>\n年底之前，公司与其消费者之间的这种情感关系仅限于桌面应用程序。然而，在这之后推出的 iPhone 和 iPad等创意产品为公司开辟新了的细分市场，并为在移动和手持设备市场上竞争提供了新机会。</p>\n",
      "date_published": "2024-08-19T07:08:59.000Z",
      "date_modified": "2024-08-19T07:20:33.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "战术管理和战略管理",
      "url": "https://ujava.cn/synthesis/tacticalstrategicmanagement.html",
      "id": "https://ujava.cn/synthesis/tacticalstrategicmanagement.html",
      "summary": "战略研究的基础知识 战略研究的基础知识主要涵盖以下几个方面： 战略定义：战略是使用战斗以达到战争目的的理论，它协调个别战斗之间的关系，为实现战争目的而服务。战略关键词包括分配（资源有限的，优先级很重要）、发展（随着时间局势会发生变化，可分为战时和战后）和使用（运用政治、经济、心理、军事权力）。 战略层面：战略可以分为三个层面：总体战略、分类战略和运作（可执行）战略。总体战略居高临下，通过分类战略达到运作战略。 战略研究方法：战略研究方法包括有系统地应用一系列科学的方法手段，以解决分析研究中面临的公正、客观和科学性的要求。这包括信息采集方法（收集有关战争与冲突方面的各种军事、政治、经济和文化的信息），制定研究框架和分析模型（确定研究领域，构造研究模型和参数，明确分析的重点和难点），以及推理判断法、综合评价法和情境模拟法等。 战略研究目的：战略研究的目的是揭示战争规律和战争指导规律，指导制定准备与实施战争的方针和策略，为夺取战争的胜利服务。 战略研究类型：按理论层次，战略研究可以分为战略基础理论研究和战略应用理论研究；按社会历史时期，可以分为古代战略研究、近代战略研究、现代战略研究；按作战性质，可以分为进攻战略研究和防御战略研究；按军种、兵种，可以分为陆军战略研究、海军战略研究、空军战略研究和战略导弹部队战略研究等。 战略研究历史：战略研究源远流长，中国古代战略称为谋略、韬略、方略或兵略，研究活动及方法主要体现在兵学著述或文史典籍中。西方的古希腊、古罗马时期，战略研究也已开始。随着时间的推移，战略研究不断发展，形成了丰富的战略理论体系。",
      "content_html": "<p><strong>战略研究的基础知识</strong></p>\n<p>战略研究的基础知识主要涵盖以下几个方面：</p>\n<ul>\n<li>战略定义：战略是使用战斗以达到战争目的的理论，它协调个别战斗之间的关系，为实现战争目的而服务。战略关键词包括分配（资源有限的，优先级很重要）、发展（随着时间局势会发生变化，可分为战时和战后）和使用（运用政治、经济、心理、军事权力）。</li>\n<li>战略层面：战略可以分为三个层面：总体战略、分类战略和运作（可执行）战略。总体战略居高临下，通过分类战略达到运作战略。</li>\n<li>战略研究方法：战略研究方法包括有系统地应用一系列科学的方法手段，以解决分析研究中面临的公正、客观和科学性的要求。这包括信息采集方法（收集有关战争与冲突方面的各种军事、政治、经济和文化的信息），制定研究框架和分析模型（确定研究领域，构造研究模型和参数，明确分析的重点和难点），以及推理判断法、综合评价法和情境模拟法等。</li>\n<li>战略研究目的：战略研究的目的是揭示战争规律和战争指导规律，指导制定准备与实施战争的方针和策略，为夺取战争的胜利服务。</li>\n<li>战略研究类型：按理论层次，战略研究可以分为战略基础理论研究和战略应用理论研究；按社会历史时期，可以分为古代战略研究、近代战略研究、现代战略研究；按作战性质，可以分为进攻战略研究和防御战略研究；按军种、兵种，可以分为陆军战略研究、海军战略研究、空军战略研究和战略导弹部队战略研究等。</li>\n<li>战略研究历史：战略研究源远流长，中国古代战略称为谋略、韬略、方略或兵略，研究活动及方法主要体现在兵学著述或文史典籍中。西方的古希腊、古罗马时期，战略研究也已开始。随着时间的推移，战略研究不断发展，形成了丰富的战略理论体系。</li>\n</ul>\n<p>综上所述，战略研究的基础知识涉及战略的定义、层面、研究方法、目的、类型和历史等方面，是军事学术研究的重要组成部分。</p>\n<p><strong>战术管理和战略管理的区别</strong></p>\n<p>战术管理和战略管理在企业管理中分别扮演着不同的角色，它们之间的主要区别体现在以下几个方面：</p>\n<ul>\n<li>范围和时间：战略管理通常涉及较长的时间范围，它着眼于企业的长期目标、预算和资源分配等全局性问题。而战术管理则更加关注短期内的行动计划，为实现长期战略目标而制定的具体、短期的行为或计划，通常在几天或几周内完成。</li>\n<li>目标和目的：战略管理的目标和目的是为了实现企业的全局性、长期性目标，如企业的长期发展、市场竞争的胜利等。而战术管理则是为了实现这些战略目标而制定的具体行动计划，如市场推广计划、产品推广策略等。</li>\n<li>决策层次：战略管理通常是由高层领导或管理层制定和决策的，需要全面考虑企业的各个方面和长远发展。而战术管理则是中低层员工根据战略计划制定的具体实施计划，更注重实际操作和执行。</li>\n<li>灵活性和稳定性：战略管理通常需要在较长时期内保持稳定，以利于贯彻执行，但也需要根据外部环境的变化进行适当调整。而战术管理则更加注重灵活性和快速反应能力，以便在实际执行中根据情况进行快速调整和优化。</li>\n<li>综合性和细节性：战略管理需要考虑企业的全局性和多样性，包括市场、竞争对手、技术、经济等各个方面的因素。而战术管理则需要根据这些不同的因素和影响制定具体的行动计划，关注细节和执行力。</li>\n<li>总的来说，战略管理和战术管理在企业管理中都是非常重要的，它们相互依存、相互支持。战略管理为战术管理提供了方向和目标，而战术管理则是实现战略目标的具体手段和方法。只有战略和战术相结合，企业才能在激烈的市场竞争中取得优势。</li>\n</ul>\n",
      "date_published": "2024-05-18T14:49:14.000Z",
      "date_modified": "2024-05-18T14:49:14.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "广域网",
      "url": "https://ujava.cn/synthesis/wan.html",
      "id": "https://ujava.cn/synthesis/wan.html",
      "summary": "广域网（WAN）的重要组成部分确实是通信子网，它一般由公共网络系统充当。以下是一些属于广域网的例子： 公用电话交换网（PSTN）：传统的电话网络，用于语音和数据通信。 数字数据网（DDN）：一种基于数字传输技术的数据通信网，主要用于向用户提供专用的中高速数字数据通信业务。 分组交换网（X.25）：一种面向连接的分组交换和传输网络，它提供了可靠的端到端的数据传输服务。 然而，需要注意的是，FDDI（光纤分布式数据接口）网络并不属于广域网的范畴。FDDI主要用于在局域网（LAN）环境中提供高速数据传输。",
      "content_html": "<p>广域网（WAN）的重要组成部分确实是通信子网，它一般由公共网络系统充当。以下是一些属于广域网的例子：</p>\n<ul>\n<li>公用电话交换网（PSTN）：传统的电话网络，用于语音和数据通信。</li>\n<li>数字数据网（DDN）：一种基于数字传输技术的数据通信网，主要用于向用户提供专用的中高速数字数据通信业务。</li>\n<li>分组交换网（X.25）：一种面向连接的分组交换和传输网络，它提供了可靠的端到端的数据传输服务。</li>\n</ul>\n<p>然而，需要注意的是，FDDI（光纤分布式数据接口）网络并不属于广域网的范畴。FDDI主要用于在局域网（LAN）环境中提供高速数据传输。</p>\n<p>在广域网中，通信子网由一些专用的通信处理机（即节点交换机）及其运行的软件、集中器等设备和连接这些节点的通信链路组成。这些设备和链路共同负责为用户提供数据的传输、转接、加工和转换等通信处理工作。</p>\n",
      "date_published": "2024-05-18T14:49:14.000Z",
      "date_modified": "2024-05-18T14:49:14.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "大数据",
      "url": "https://ujava.cn/synthesis/bigdata.html",
      "id": "https://ujava.cn/synthesis/bigdata.html",
      "summary": "大数据的关键技术有哪些列举，说明大数据技术目前有哪些应用。 大数据的关键技术主要包括以下几个方面： 大数据采集技术：该技术从众多数据源实时或及时地获取各类结构化、半结构化及非结构化数据，是大数据知识服务模型的基础。其关键在于突破高速、高可靠、高速数据采集及大数据整合技术。 大数据预处理技术：主要完成接收数据的分析、提取、清洗等操作，帮助实现快速的数据分析处理。其目的是将多种数据类型转化为单一配置或便于处理的格式，以确保分析效率。 数据分析与挖掘：基于商业目的，旨在通过有目的的收集、整理、加工数据来提取有价值的信息和洞察。该过程采用机器学习、统计分析等技术。 大数据存储和管理：利用内存来存储并管理收集的数据，并对之进行复杂的结构化、半结构化和非结构化处理。其目的是支持关键问题如可靠性、高效传输。 大数据可视化技术：为用户提供清晰直观的数据表现，将复杂数据关系以图表、地图、仪表盘等形式呈现，帮助用户更好地理解与利用分析结果。 人工智能技术：分为三个层级：弱人工智能用于数据计算，采用AI的剪枝理论优化；强人工智能应对受限环境，如传感环境信息、听得懂互动功能；超人工智能实现深度认知，如自认语言理解与知识系统图谱。 数据挖掘技术：从众多数据中搜集有价值的信息与知识，利用挖掘算法。 无线通信技术：通过挖掘无线大数据规律，实现比普适模型更符合真实通信环境的模型，助力系统决策。 数据处理技术：涉及分布式的存储和计算技术，既与Distributed存储形式相关，也与业务数据的冷、热数据有关。主要的技术模型有MapReduce、DAG、BSP等。",
      "content_html": "<p><strong>大数据的关键技术有哪些列举，说明大数据技术目前有哪些应用。</strong></p>\n<p>大数据的关键技术主要包括以下几个方面：</p>\n<ul>\n<li>大数据采集技术：该技术从众多数据源实时或及时地获取各类结构化、半结构化及非结构化数据，是大数据知识服务模型的基础。其关键在于突破高速、高可靠、高速数据采集及大数据整合技术。</li>\n<li>大数据预处理技术：主要完成接收数据的分析、提取、清洗等操作，帮助实现快速的数据分析处理。其目的是将多种数据类型转化为单一配置或便于处理的格式，以确保分析效率。</li>\n<li>数据分析与挖掘：基于商业目的，旨在通过有目的的收集、整理、加工数据来提取有价值的信息和洞察。该过程采用机器学习、统计分析等技术。</li>\n<li>大数据存储和管理：利用内存来存储并管理收集的数据，并对之进行复杂的结构化、半结构化和非结构化处理。其目的是支持关键问题如可靠性、高效传输。</li>\n<li>大数据可视化技术：为用户提供清晰直观的数据表现，将复杂数据关系以图表、地图、仪表盘等形式呈现，帮助用户更好地理解与利用分析结果。</li>\n<li>人工智能技术：分为三个层级：弱人工智能用于数据计算，采用AI的剪枝理论优化；强人工智能应对受限环境，如传感环境信息、听得懂互动功能；超人工智能实现深度认知，如自认语言理解与知识系统图谱。</li>\n<li>数据挖掘技术：从众多数据中搜集有价值的信息与知识，利用挖掘算法。</li>\n<li>无线通信技术：通过挖掘无线大数据规律，实现比普适模型更符合真实通信环境的模型，助力系统决策。</li>\n<li>数据处理技术：涉及分布式的存储和计算技术，既与Distributed存储形式相关，也与业务数据的冷、热数据有关。主要的技术模型有MapReduce、DAG、BSP等。</li>\n</ul>\n<p>至于大数据技术的应用，已经广泛渗透到各行各业中，例如：</p>\n<ul>\n<li>金融行业：银行零售经营新体系通过API、智能感知、挖掘建模等大数据应用技术，提升数据驱动运营能力。</li>\n<li>媒体行业：媒体融合发展需要以新技术新应用来引领和推动，成系统和规模的大数据应用技术成为报业集团系统性转型的核心突破点。</li>\n<li>数据记录：包括音乐、照片、视频、监控视频等音视频资料，以及互联网上的海量数据，这些数据正在以前所未有的数量被所有互联网用户共享。</li>\n<li>移动互联网：移动设备的传感器收集了大量用户点击行为的数据，这些数据由某些公司拥有，并产生大量的用户行为数据。</li>\n<li>电子地图：如高德、百度、谷歌地图等，它们产生大量数据流的数据，数据是不同于传统数据，数据流图表示一个行为，一种习惯，流数据频率分析后将会产生巨大的商业价值。</li>\n<li>搜索引擎：传统门户网站转向搜索引擎后，用户的搜索行为和质疑行为收集了大量的数据。</li>\n</ul>\n<p>总的来说，大数据技术以其独特的技术优势，正在为各行各业提供新的发展机遇。</p>\n",
      "date_published": "2024-05-18T13:53:33.000Z",
      "date_modified": "2024-05-18T13:53:33.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "数字孪生",
      "url": "https://ujava.cn/synthesis/digitaltwin.html",
      "id": "https://ujava.cn/synthesis/digitaltwin.html",
      "summary": "数字孪生是指充分利用物理模型、传感器、运行历史等数据，集成多学科、多尺度的仿真过程，它作为虚拟空间中对实体产品的镜像，反映了相对应物理实体产品的全生命周期过程。 为了便于数字孪生的理解，庄存波等提出了数字孪生体的概念，认为数字孪生是采用信息技术对物理实体的组成、特征、功能和性能进行数字化定义和建模的过程。 数字孪生体是指在计算机虚拟空间存在的与物理实体完全等价的信息模型，可以基于数字孪生体对物理实体进行仿真分析和优化。 数字孪生是技术、过程、方法，数字孪体是对象、模型和数据。 数字孪生的三个组成部分：物理空间的实体产品、虚拟空间的虚拟产品、物理空间和虚拟空间之间的数据和信息交互接口。",
      "content_html": "<p>数字孪生是指充分利用物理模型、传感器、运行历史等数据，集成多学科、多尺度的仿真过程，它作为虚拟空间中对实体产品的镜像，反映了相对应物理实体产品的全生命周期过程。</p>\n<p>为了便于数字孪生的理解，庄存波等提出了数字孪生体的概念，认为数字孪生是采用信息技术对物理实体的组成、特征、功能和性能进行数字化定义和建模的过程。</p>\n<p>数字孪生体是指在计算机虚拟空间存在的与物理实体完全等价的信息模型，可以基于数字孪生体对物理实体进行仿真分析和优化。</p>\n<p>数字孪生是技术、过程、方法，数字孪体是对象、模型和数据。</p>\n<p>数字孪生的三个组成部分：物理空间的实体产品、虚拟空间的虚拟产品、物理空间和虚拟空间之间的数据和信息交互接口。</p>\n<p>数字孪生主要是要创建和物理实体等价的虚拟体或数字模型，虚拟体能够对物理实体进行仿真分析，能够根据物理实体运行的实时反馈信息对物理实体的运行状态进行监控，能够依据采集的物理实体的运行数据完善虚拟体的仿真分析算法，从而对物理实体的后续运行和改进提供更加精确的决策。</p>\n<p>数字孪生体用于解决传统机理模型无法解决的非线性、不确定性问题，数字孪生技术可以与机器学习、深度学习构成一个不断进化的系统。有两种数字优化，一种模型驱动（Model-Driven），一种数据驱动（Data-Driven），即我们可以将机理模型与/或强化学习构建一个适合工业应用的优化方法包。</p>\n<p><strong>数字孪生与传统建模仿真的区别：</strong></p>\n<p>数字孪生是动态的，在数字对象与物理对象之间必须能够实现上下行的数据交互，这样才能让这个数字孪生运行具有持续改善的工业应用价值。</p>\n<p>传统建模仿真和数字孪生存在不同的关注点，前者关注建模的保真度，也就是可否准确荒野物理对象特性和状态，后者关注动态中的变化关系。</p>\n<p><strong>数字孪生技术如何与物联网相结合，以及这种相结合如何增强系统监控和维护能力：</strong></p>\n<p>数字孪生技术与物联网的结合主要通过以下方式实现，并极大地增强了系统监控和维护能力：</p>\n<ul>\n<li>数据集成与模型更新：物联网通过各种传感器和设备获取实时数据，如环境参数、设备状态、生产数据等。这些数据被输入到数字孪生模型中，作为模型运行的输入参数。随着物联网设备实时采集的数据不断更新，数字孪生模型能够准确反映物理实体的当前状态和性能。</li>\n<li>建模过程：在数字孪生技术的应用中，首先需要对物理实体进行建模。这包括物体的几何形状、结构特性、材料属性等方面的建模，并将其转化为数字孪生模型中的参数。同时，根据物理实体的工作原理和行为规律，将其对应的物理模型转化为数字孪生模型中的动力学模型或算法模型。</li>\n</ul>\n<p>这种结合增强了系统监控和维护能力的方式体现在以下几个方面：</p>\n<ul>\n<li>实时监测和追踪：通过将数字孪生与物联网设备结合，可以实现对物理实体的实时监测和追踪。这有助于及时发现潜在问题，减少故障停机时间，提高系统的可用性和可靠性。</li>\n<li>预防性维护：数字孪生技术可以帮助实现设备的预防性维护。通过实时监测和分析设备数字模型的状态和性能数据，系统能够预测设备的潜在故障，并在故障发生前进行干预，从而避免设备停机带来的损失。这种预防性维护模式不仅降低了设备的维修成本，还提高了设备的使用寿命。</li>\n<li>远程维护：传统的设备维护通常需要维修人员亲自到现场进行检修，而数字孪生技术使得远程维护成为可能。维修人员只需通过数字模型对设备进行诊断和操作，即可实现设备的远程修复，大大提高了维护的效率和便捷性。</li>\n<li>智能化管理：数字孪生技术还可以实现设备的智能化管理。通过对设备数字模型的实时监测和分析，系统能够自动生成设备的运行报告、维护计划等信息，为管理人员提供决策支持。同时，系统能够及时发现设备的潜在安全隐患，并采取相应的措施进行防范。</li>\n</ul>\n<p>总之，数字孪生技术与物联网的结合为系统监控和维护带来了革命性的变化，提高了系统的可用性、可靠性和维护效率，降低了维护成本。这种结合不仅适用于工业生产领域，还可以应用于智慧城市、健康医疗、零售业等多个领域。</p>\n",
      "date_published": "2024-05-18T13:53:33.000Z",
      "date_modified": "2024-05-18T13:53:33.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "智慧水利",
      "url": "https://ujava.cn/synthesis/smartwater.html",
      "id": "https://ujava.cn/synthesis/smartwater.html",
      "summary": "随着物联网、云计算、大数据等信息技术在水利行业的广泛应用,实现水利设施和系统的智能化、信息化、自动化已成为发展方向。作为智慧水利解决方案的关键组成部分,水利现场远程监控终端发挥着重要作用。 一、智慧水利解决方案组成 智慧水利解决方案主要由传感测量、现场数据采集、数据传输、云平台分析等子系统组成。其中,现场远程监控终端负责将各类水文、水质、运行参数数据采集汇总后有线或无线传输到远程监控中心,是连接现场与应用的关键设备。 二、远程监控终端选型 目前常用的水利现场远程监控终端包括:",
      "content_html": "<p>随着物联网、云计算、大数据等信息技术在水利行业的广泛应用,实现水利设施和系统的智能化、信息化、自动化已成为发展方向。作为智慧水利解决方案的关键组成部分,水利现场远程监控终端发挥着重要作用。<br>\n</p>\n<p><strong>一、智慧水利解决方案组成</strong></p>\n<p>智慧水利解决方案主要由传感测量、现场数据采集、数据传输、云平台分析等子系统组成。其中,现场远程监控终端负责将各类水文、水质、运行参数数据采集汇总后有线或无线传输到远程监控中心,是连接现场与应用的关键设备。</p>\n<p><strong>二、远程监控终端选型</strong></p>\n<p>目前常用的水利现场远程监控终端包括:</p>\n<ol>\n<li>\n<p>DTU系列数传数据终端:具有串口、以太网、模拟量输入等接口,可连接多种水文水质检测仪表,实现数据汇聚。</p>\n</li>\n<li>\n<p>SG500系列工业网关:提供MODBUS、OPC等协议访问功能,连接PLC、RTU、传感器等,构建现场自动化。<br>\n</p>\n</li>\n</ol>\n<p><strong>三、典型应用案例</strong></p>\n<p>某江河流域建立智慧水利管理系统,系统组态如下:</p>\n<ol>\n<li>\n<p>在水源地、水库等设置水质水文检测仪表,通过DTU200终端采集数据。</p>\n</li>\n<li>\n<p>在水库闸门、抽水站配置SG500工业网关,实现对现场设备的智能化控制。</p>\n</li>\n<li>\n<p>通过4G公网上传各类监测数据到云平台和水利调度中心。</p>\n</li>\n<li>\n<p>云平台对数据进行存储分析,并下发控制指令给现场网关。</p>\n</li>\n<li>\n<p>水利调度中心利用系统实现水情监测、水资源调度、设备优化运行等。<br>\n</p>\n</li>\n</ol>\n<p>该方案充分利用了现场终端的优势,实现了对水利现场的精确采集控制,大幅提升了流域水资源管理和调度的智能化水平,显示了数字化水利建设的巨大潜力。</p>\n<p>智慧水利目前主要由无人值守远程智能控制系统、雨情自动遥测系统、自动水位站监测系统和水利设施安防报警系统组成，可根据客户需求增加其他功能或定制开发。<br>\n</p>\n<h2> <strong>四、无人值守远程控制系统</strong></h2>\n<p>系统组成：该系统主要由水利设施环境（水位、流速流量、降雨量、温湿度、风速风向等）监测预警系统、山洪预警系统（可扩展）、远程视频监控系统、远程开关闸泵系统、太阳能供电系统（无市电供应时）、水利设施安防预警系统组成。</p>\n<p>功能实现：使用无人值守远程智能控制系统后，我们可以在远离现场的控制室里，通过电脑或手机 APP 既可以对现场的水文信息（包括温湿度、风向风速、降雨量、水位流速流量等）实时掌握，又可以实时显示现场的视频监控图像，为合理调度水资源提供第一手数据资料。同时可以对水利设施进行远程精准控制，通过平台软件或手机 APP 就能对现场的设备进行开启、关闭和暂停等操作，极大提高了水利的信息化建设和工作效率，使水利设施的管理更便捷、高效、人性化。<br>\n</p>\n<p><strong>硬件介绍</strong></p>\n<p><strong>(一)</strong>&nbsp;<strong>智能控制器</strong></p>\n<figure><figcaption>img_224.png</figcaption></figure>\n<p><strong>Ø</strong>&nbsp;<strong>智能控制器实现功能</strong></p>\n<p>l 可远程或现场精准控制闸泵的启停及升降；可远程数据采集</p>\n<p><strong>Ø</strong>&nbsp;<strong>智能控制器技术参数</strong></p>\n<p>l 支持现场校准；支持全网通4G/5G通讯；支持本地WEB升级程序；支持远程升级程序；</p>\n<p>l 超低功耗：DC9-36V供电，电流≤500mA；标准RS232通讯接口；RS485接口：最大设备节点255个，防尘防水防雷击设计；4G/5G传输；</p>\n<p>l 以太网接口：10MB/100MB自适应；</p>\n<p>l 智能控制器接口：可支持2-8路开关量输出；支持多种编码器的接入；支持各种水文气象传感设备及供电信息等数据的接入；具有视频监控流媒体传输限流自控功能。</p>\n<p><strong>(一)</strong>&nbsp;<strong>智能控制柜</strong><br>\n</p>\n<p><strong>Ø</strong>&nbsp;<strong>实现功能</strong></p>\n<p>l 各项数据、视频图像实时显示、分析、保存、查询、打印</p>\n<p>l 各设备运行状态监测</p>\n<p>l 现场非法入侵报警</p>\n<p>l 故障报警：太阳能故障、蓄电池电压低、过载保护等</p>\n<p>l 水位报警</p>\n<p>l 闸门开启故障及限位报警</p>\n<p>l 远程自动控制、监测</p>\n<p>l 权限登录和操作</p>\n<p>l 可扩展性‍‍‍‍</p>\n<p><strong>软件介绍</strong></p>\n<figure><figcaption>img_226.png</figcaption></figure>\n<figure><figcaption>img_227.png</figcaption></figure>\n<figure><figcaption>img_228.png</figcaption></figure>\n<p><strong>平台软件（含手机APP)功能</strong></p>\n<p>（1）基于GIS地图开发，界面更直观、易操作；</p>\n<p>（2）含有雨情和水位遥测报警、山洪预警等多功能模块并能根据要求定制开发；</p>\n<p>（3）软件可同时在线实时显示四个监控画面，也可单独画面放大显示；可在线实时显示节制闸和泵站状态数据等信息，并能分析、保存、查询、打印等；</p>\n<p>（3）通过后台工作站或手机APP可远程对节制闸开闸、关闸；远程对泵站进行开泵、关泵；并根据所需调节开关闸的高度及泵站电动阀的开度；实时显示市电或太阳能的电压、电流，负载电流等；各设备运行状态监测；</p>\n<p>（4）现场非法侵入报警；故障报警：远程自动控制、监测；权限登录和操作；</p>\n<p>（5）数据库选用Mysql关系型数据库，实现存储海量历史数据；可扩展性；</p>\n<h2> <strong>五、雨情自动遥测系统</strong></h2>\n<p><strong>系统概述</strong></p>\n<p>雨情自动遥测系统是基于GIS地图开发并能够实时在线显示、统计、上传降雨量的自动化遥测平台，可进行雨情统计及浏览、实时监控、雨情报警、雨情短信自动发送等功能，广泛应用于防汛、气象、城市排涝等。</p>\n<figure><figcaption>img_229.png</figcaption></figure>\n<p><strong>硬件介绍</strong></p>\n<figure><figcaption>img_230.png</figcaption></figure>\n<p>1．可外接雨量传感器；</p>\n<p>2．4G、CDMA任意两种信道相连的接口；</p>\n<p>3．具有定时自报和响应召测兼容的工作体制；</p>\n<p>4．具备主备信道切换、发送确认、自动补发功能；</p>\n<p>5．具备电源检测与管理、报警功能；</p>\n<p>6．具备防盗开关信号接入与检测功能；</p>\n<p>7．具备数据保护不丢失功能；</p>\n<p>8．具备自检自诊断功能，死机自动复位；</p>\n<p>9．具备自动同步时钟功能。</p>\n<p><strong>软件界面</strong></p>\n<figure><figcaption>img_231.png</figcaption></figure>\n<figure><figcaption>img_232.png</figcaption></figure>\n<p><strong>案例展示</strong></p>\n<figure><figcaption>img_233.png</figcaption></figure>\n<h2> <strong>六、自动水位站监测系统</strong></h2>\n<p>该系统应用雷达或压力式水位传感器感知水位变化，设备采用太阳能供电，4G/5G无线通讯方式传输水位数据，具有水位实时采集、自动记录上传、站点档案查看、超限报警、低电量报警等功能；适用于水利或城市管理部门远程监测流域的实时水位、天气等数据，同时支持远程视频监控，为保障流域内的适度蓄水和安全度汛提供了准确、及时的现场信息，实现了河流的信息化管理，在保护人民生命、财产安全方面发挥了重大作用。</p>\n<figure><figcaption>img_234.png</figcaption></figure>\n<p><strong>系统功能</strong></p>\n<p><strong>1)</strong>&nbsp;<strong>GIS地图展示</strong></p>\n<p>直观显示各河流水位监测站分布位置、当前水位以及设备运行状态。</p>\n<p><strong>2)</strong>&nbsp;<strong>水位实时数据</strong></p>\n<p>显示各河流水位测点的实时水位和电池电压，并提供360度现场监控图像，实时展现水位动态曲线。</p>\n<p><strong>3)</strong>&nbsp;<strong>报警管理</strong></p>\n<p>当河流或水库水位高于设定的警戒值时，系统发出报警，并向相关责任人发送手机短信或手机APP预警等多种形式给予提示报警，责任人根据情况可及时采取应对措施并上传预警处置记录。</p>\n<p><strong>4)</strong>&nbsp;<strong>天气预报</strong></p>\n<p>根据具体城市定位，显示卫星云图、雷达图、分时天气预报及七日天气预报。</p>\n<p><strong>软件界面</strong></p>\n<figure><figcaption>img_235.png</figcaption></figure>\n<figure><figcaption>img_236.png</figcaption></figure>\n<p><strong>案例展示</strong></p>\n<figure><figcaption>img_237.png</figcaption></figure>\n<h2> 四、<strong>水利设施安防报警系统</strong></h2>\n<p>水利设施多建设在河道和干渠上，位置偏远，设备被破坏、偷盗的现象时有发生，已严重影响水利设施的正常运行和使用，经济损失巨大。</p>\n<p>旭瑞智能通过不断改进和完善系统性能，已较大程度的提高了设施的安全防护级别。主要措施由五大系统组成，分别是：</p>\n<p>1、自动语音警告系统</p>\n<p>2、远程人工喊话系统</p>\n<p>3、门禁报警系统</p>\n<p>4、智能分析监控系统</p>\n<p>5、存储设备定位追回系统</p>\n<p><strong>系统功能</strong></p>\n<p><strong>(1)</strong>&nbsp;<strong>自动语音警告系统</strong></p>\n<p>当现场有人非法入侵时，语音警告系统自动开启，并循环播放提前录入的语音警告，直至入侵者离开。</p>\n<p>语音警告可实现循环播放录制的语音，配置高保真音箱。可插U盘，可选择语音。</p>\n<figure><figcaption>img_238.png</figcaption></figure>\n<p><strong>(2)</strong>&nbsp;<strong>远程人工喊话系统</strong></p>\n<p>当自动语音警告系统连续开启超过2分钟（时间可调）时，软件平台会弹出报警信息提醒，管理人员可通过电脑或手机对现场非法行为进行远程喊话，现场加装可支持双向语音对讲的呼叫装置。</p>\n<figure><figcaption>img_239.png</figcaption></figure>\n<p><strong>(3)</strong>&nbsp;<strong>门禁报警系统</strong></p>\n<p>当泵房或闸室的门禁系统处于布防状态，门被打开时，通过安装的门磁探测器会立即发出信号，并发送报警信息给声光报警器，同时通过4G DTU给平台发送报警信息。</p>\n<figure><figcaption>img_240.png</figcaption></figure>\n<p><strong>(4)</strong>&nbsp;<strong>智能分析监控系统</strong></p>\n<p>在现场安装具有AI智能分析功能的摄像机，当有人非法入侵时，可实现对入侵人脸进行抓拍、跟踪，能够在连续跟踪进程中保证抓拍到正面人脸，记录质量最高的面部图像并将录像上传。支持镜头遮挡、视频丢失等的报警功能。</p>\n<figure><figcaption>img_241.png</figcaption></figure>\n<p><strong>(5)</strong>&nbsp;<strong>存储设备定位追回系统</strong></p>\n<p>对现场的存储设备加装定位模块，具有电子围栏,轨迹回放,轨迹跟踪等功能。内置7800mAH电池，无外部供电时仅可实现55天正常工作。</p>\n<p>防拆报警：可实现拆除时发送报警信息。</p>\n<p>位移报警：可以实现设备移动时发送报警信息。</p>\n<p>低电压报警：可实现电压低于5%时发送报警信息。</p>\n<p>GPS+北斗定位：(定位精度：2.5m，高灵敏度：-165dBm），4G/5G通讯。</p>\n<figure><figcaption>img_242.png</figcaption></figure>\n",
      "date_published": "2024-05-18T11:54:56.000Z",
      "date_modified": "2024-05-18T12:19:57.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "优化算法",
      "url": "https://ujava.cn/base/optialgorithm.html",
      "id": "https://ujava.cn/base/optialgorithm.html",
      "summary": "最优化方法是一种数学方法，它是研究在给定约束之下如何寻求某些因素(的量)，以使某一(或某些)指标达到最优的一些学科的总称。在学习机器学习的过程中我们发现，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法、拉格朗日数乘法等等。 1. 梯度下降法（Gradient Descent） 梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。**梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。**梯度下降法的搜索迭代示意图如下图所示：",
      "content_html": "<p>最优化方法是一种数学方法，它是研究在给定约束之下如何寻求某些因素(的量)，以使某一(或某些)指标达到最优的一些学科的总称。在学习机器学习的过程中我们发现，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法、拉格朗日数乘法等等。</p>\n<h3> 1. 梯度下降法（Gradient Descent）</h3>\n<p>梯度下降法是最早最简单，也是最为常用的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。**梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。**梯度下降法的搜索迭代示意图如下图所示：<br>\n</p>\n<p><strong>梯度下降法的缺点：</strong></p>\n<p><strong>（1）靠近极小值时收敛速度减慢，如下图所示；</strong></p>\n<p><strong>（2）直线搜索时可能会产生一些问题；</strong></p>\n<p><strong>（3）可能会“之字形”地下降。</strong><br>\n</p>\n<p>从上图可以看出，梯度下降法在接近最优解的区域收敛速度明显变慢，利用梯度下降法求解需要很多次的迭代。</p>\n<p>在机器学习中，基于基本的梯度下降法发展了两种梯度下降方法，分别为随机梯度下降法和批量梯度下降法。</p>\n<p>比如对一个线性回归（Linear Logistics）模型，假设下面的h(x)是要拟合的函数，J(theta)为损失函数，theta是参数，要迭代求解的值，theta求解出来了那最终要拟合的函数h(theta)就出来了。其中m是训练集的样本个数，n是特征的个数。<br>\n</p>\n<figure><figcaption>img_3.png</figcaption></figure>\n<p><strong>1）批量梯度下降法（Batch Gradient Descent，BGD）</strong></p>\n<p>（1）将J(theta)对theta求偏导，得到每个theta对应的的梯度：<br>\n</p>\n<p>（2）由于是要最小化风险函数，所以按每个参数theta的梯度负方向，来更新每个theta：<br>\n</p>\n<p>（3）从上面公式可以注意到，它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果m很大，那么可想而知这种方法的迭代速度会相当的慢。所以，这就引入了另外一种方法——随机梯度下降。</p>\n<p>对于批量梯度下降法，样本个数m，x为n维向量，一次迭代需要把m个样本全部带入计算，迭代一次计算量为m*n2。</p>\n<p><strong>2）随机梯度下降（Stochastic Gradient Descent，SGD）</strong></p>\n<p>（1）上面的风险函数可以写成如下这种形式，损失函数对应的是训练集中每个样本的粒度，而上面批量梯度下降对应的是所有的训练样本：<br>\n</p>\n<p>（2）每个样本的损失函数，对theta求偏导得到对应梯度，来更新theta：<br>\n</p>\n<p>（3）随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p>\n<p>随机梯度下降每次迭代只使用一个样本，迭代一次计算量为n2，当样本个数m很大的时候，随机梯度下降迭代一次的速度要远高于批量梯度下降方法。<strong>两者的关系可以这样理解：随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</strong></p>\n<p><strong>对批量梯度下降法和随机梯度下降法的总结：</strong></p>\n<p><strong>批量梯度下降---最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</strong></p>\n<p><strong>随机梯度下降---最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</strong></p>\n<h3> 2. 牛顿法和拟牛顿法（Newton's method &amp;&nbsp;Quasi-Newton Methods）</h3>\n<p><strong>1）牛顿法（Newton's method）</strong></p>\n<p>牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数_f_&nbsp;(<em>x</em>)的泰勒级数的前面几项来寻找方程_f_&nbsp;(<em>x</em>) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。</p>\n<h2> 具体步骤：</h2>\n<p>首先，选择一个接近函数&nbsp;<em>f</em>&nbsp;(<em>x</em>)零点的&nbsp;_x_0，计算相应的&nbsp;<em>f</em>&nbsp;(<em>x_0)&nbsp;和切线斜率_f &nbsp;'</em>&nbsp;(<em>x_0)（这里_f '</em>&nbsp;表示函数&nbsp;<em>f</em> &nbsp;的导数）。然后我们计算穿过点(_x_0, &nbsp;<em>f</em> &nbsp;(<em>x_0))&nbsp;并且斜率为_f</em>&nbsp;'(_x_0)的直线和&nbsp;<em>x</em>&nbsp;轴的交点的_x_坐标，也就是求如下方程的解：<br>\n</p>\n<p>我们将新求得的点的&nbsp;<em>x</em>&nbsp;坐标命名为_x_1，通常_x_1会比_x_0更接近方程_f_ &nbsp;(<em>x</em>) = 0的解。因此我们现在可以利用_x_1开始下一轮迭代。迭代公式可化简为如下所示：<br>\n</p>\n<p>已经证明，如果_f_ &nbsp;'&nbsp;是连续的，并且待求的零点_x_是孤立的，那么在零点_x_周围存在一个区域，只要初始值_x_0位于这个邻近区域内，那么牛顿法必定收敛。 并且，如果_f_ &nbsp;' (<em>x</em>)不为0, 那么牛顿法将具有平方收敛的性能. 粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。下图为一个牛顿法执行过程的例子。</p>\n<p>由于牛顿法是基于当前位置的切线来确定下一次的位置，所以牛顿法又被很形象地称为是\"切线法\"。牛顿法的搜索路径（二维情况）如下图所示：</p>\n<p>牛顿法搜索动态示例图：<br>\n</p>\n<p><strong>关于牛顿法和梯度下降法的效率对比：</strong></p>\n<p><strong>从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。）</strong></p>\n<p><strong>根据wiki上的解释，从几何上说，牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</strong><br>\n</p>\n<p>注：红色的牛顿法的迭代路径，绿色的是梯度下降法的迭代路径。</p>\n<p><strong>牛顿法的优缺点总结：</strong></p>\n<p><strong>优点：二阶收敛，收敛速度快；</strong></p>\n<p><strong>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</strong></p>\n<p><strong>2）拟牛顿法（Quasi-Newton Methods）</strong></p>\n<p>拟牛顿法是求解非线性优化问题最有效的方法之一，于20世纪50年代由美国Argonne国家实验室的物理学家W.C.Davidon所提出来。Davidon设计的这种算法在当时看来是非线性优化领域最具创造性的发明之一。不久R. Fletcher和M. J. D. Powell证实了这种新的算法远比其他方法快速和可靠，使得非线性优化这门学科在一夜之间突飞猛进。</p>\n<p>**拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。**拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p>\n<p><strong>具体步骤：</strong></p>\n<p>拟牛顿法的基本思想如下。首先构造目标函数在当前迭代xk的二次模型：<br>\n</p>\n<p>这里Bk是一个对称正定矩阵，于是我们取这个二次模型的最优解作为搜索方向，并且得到新的迭代点：<br>\n</p>\n<p>其中我们要求步长ak&nbsp;满足Wolfe条件。这样的迭代与牛顿法类似，区别就在于用近似的Hesse矩阵Bk</p>\n<p>代替真实的Hesse矩阵。所以拟牛顿法最关键的地方就是每一步迭代中矩阵Bk</p>\n<p>的更新。现在假设得到一个新的迭代xk+1，并得到一个新的二次模型：<br>\n</p>\n<p>我们尽可能地利用上一步的信息来选取Bk。具体地，我们要求&nbsp;<br>\n</p>\n<p>从而得到<br>\n</p>\n<p>这个公式被称为割线方程。常用的拟牛顿法有DFP算法和BFGS算法。</p>\n<h3> 3. 共轭梯度法（Conjugate Gradient）</h3>\n<p><strong>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。</strong>&nbsp;在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。</p>\n<p>具体的实现步骤请参加wiki百科共轭梯度法。</p>\n<p>下图为共轭梯度法和梯度下降法搜索最优解的路径对比示意图：<br>\n</p>\n<p>注：绿色为梯度下降法，红色代表共轭梯度法</p>\n<h3> 4. 启发式优化方法</h3>\n<p>启发式方法指人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,利用过去的经验,选择已经行之有效的方法，而不是系统地、以确定的步骤去寻求答案。启发式优化方法种类繁多，包括经典的模拟退火方法、遗传算法、蚁群算法以及粒子群算法等等。</p>\n<p>还有一种特殊的优化算法被称之多目标优化算法，它主要针对同时优化多个目标（两个及两个以上）的优化问题，这方面比较经典的算法有NSGAII算法、MOEA/D算法以及人工免疫算法等。</p>\n<h3> 5. 解决约束优化问题——拉格朗日乘数法</h3>\n<h3> 5.1 拉格朗日乘数法的基本思想</h3>\n<p><strong>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</strong></p>\n<p><strong>如何将一个</strong>含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题？拉格朗日乘数法从数学意义入手，通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解。****</p>\n<p>解决的问题模型为约束优化问题：</p>\n<p><strong>min/max a function f(x,y,z), where x,y,z are not independent and g(x,y,z)=0.</strong></p>\n<p><strong>即：min/max f(x,y,z)</strong></p>\n<p><strong>s.t. g(x,y,z)=0</strong></p>\n<h3> 5.2 数学实例</h3>\n<p>首先，我们先以麻省理工学院数学课程的一个实例来作为介绍拉格朗日乘数法的引子。</p>\n<p>【麻省理工学院数学课程实例】求双曲线xy=3上离远点最近的点。</p>\n<p>解：</p>\n<p>首先，我们根据问题的描述来提炼出问题对应的数学模型，即：</p>\n<p>min f(x,y)=x2+y2（两点之间的欧氏距离应该还要进行开方，但是这并不影响最终的结果，所以进行了简化，去掉了平方）</p>\n<p>s.t. xy=3.</p>\n<p>根据上式我们可以知道这是一个典型的约束优化问题，其实我们在解这个问题时最简单的解法就是通过约束条件将其中的一个变量用另外一个变量进行替换，然后代入优化的函数就可以求出极值。我们在这里为了引出拉格朗日乘数法，所以我们采用拉格朗日乘数法的思想进行求解。</p>\n<p>我们将x2+y2=c的曲线族画出来，如下图所示，当曲线族中的圆与xy=3曲线进行相切时，切点到原点的距离最短。也就是说，当f(x,y)=c的等高线和双曲线g(x,y)相切时，我们可以得到上述优化问题的一个极值（注意：如果不进一步计算，在这里我们并不知道是极大值还是极小值）。<br>\n</p>\n<p>现在原问题可以转化为求当f(x,y)和g(x,y)相切时，x,y的值是多少？</p>\n<p>如果两个曲线相切，那么它们的切线相同，即法向量是相互平行的，▽f//▽g.</p>\n<p>由▽f//▽g可以得到，▽f=λ*▽g。</p>\n<p>这时，我们将原有的约束优化问题转化为了一种对偶的无约束的优化问题，如下所示：</p>\n<p>**原问题：**min f(x,y)=x2+y2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;**对偶问题：**由▽f=λ*▽g得，</p>\n<p>s.t. xy=3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fx=λ*gx，</p>\n<p>fy=λ*gy，</p>\n<p>xy=3.</p>\n<p>约束优化问题 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 无约束方程组问题</p>\n<p>通过求解右边的方程组我们可以获取原问题的解，即</p>\n<p>2x=λ*y</p>\n<p>2y=λ*x</p>\n<p>xy=3</p>\n<p>通过求解上式可得，λ=2或者是-2；当λ=2时，(x,y)=(sqrt(3), sqrt(3))或者(-sqrt(3), -sqrt(3))，而当λ=-2时，无解。所以原问题的解为(x,y)=(sqrt(3), sqrt(3))或者(-sqrt(3), -sqrt(3))。</p>\n<p>通过举上述这个简单的例子就是为了体会拉格朗日乘数法的思想，即通过引入拉格朗日乘子(λ)将原来的约束优化问题转化为无约束的方程组问题。</p>\n<h3> 5.3 拉格朗日乘数法的基本形态</h3>\n<p><strong>求函数在满足下的条件极值，可以转化为函数的无条件极值问题。</strong></p>\n<p>我们可以画图来辅助思考。<br>\n</p>\n<p>绿线标出的是约束g(x,y)=c的点的轨迹。蓝线是f(x,y)的等高线。箭头表示斜率，和等高线的法线平行。</p>\n<p>从图上可以直观地看到在最优解处，f和g的斜率平行。</p>\n<p>▽[f(x,y)+λ(g(x,y)−1)]=0, λ≠0</p>\n<p>一旦求出λ的值，将其套入下式，易求在无约束极值和极值所对应的点。</p>\n<p>F(x,y)=f(x,y)+λ(g(x,y)−c)</p>\n<p>新方程F(x,y)在达到极值时与f(x,y)相等，因为F(x,y)达到极值时g(x,y)−c总等于零。</p>\n<p>上述式子取得极小值时其导数为0，即▽f(x)+▽∑λigi(x)=0，也就是说f(x)和g(x)的梯度共线。</p>\n<p><strong>题目1：</strong></p>\n<p>给定椭球<br>\n</p>\n<p>求这个椭球的内接长方体的最大体积。这个问题实际上就是条件极值问题，即在条件</p>\n<figure><figcaption>img_24.png</figcaption></figure>\n<p>下，求的最大值。</p>\n<p>当然这个问题实际可以先根据条件消去，然后带入转化为无条件极值问题来处理。但是有时候这样做很困难，甚至是做不到的，这时候就需要用<strong>拉格朗日乘数法</strong>了。通过拉格朗日乘数法将问题转化为</p>\n<figure><figcaption>img_27.png</figcaption></figure>\n<p>对求偏导得到<br>\n</p>\n<p>联立前面三个方程得到和，带入第四个方程解之<br>\n</p>\n<p>带入解得最大体积为<br>\n</p>\n<p>拉格朗日乘数法对一般多元函数在多个附加条件下的条件极值问题也适用。</p>\n<p><strong>题目2：</strong></p>\n<p>**题目：**求离散分布的最大熵。</p>\n<p>**分析：**因为离散分布的熵表示如下<br>\n</p>\n<p>而约束条件为<br>\n</p>\n<p>要求函数的最大值，根据<strong>拉格朗日乘数法</strong>，设<br>\n</p>\n<p>对所有的求偏导数，得到<br>\n</p>\n<p>计算出这个等式的微分，得到<br>\n</p>\n<p>这说明所有的都相等，最终解得<br>\n</p>\n<p>因此，使用<strong>均匀分布</strong>可得到最大熵的值。</p>\n<h3> 5.4 拉格朗日乘数法与KKT条件</h3>\n<p>我们上述讨论的问题均为等式约束优化问题，但等式约束并不足以描述人们面临的问题，不等式约束比等式约束更为常见，大部分实际问题的约束都是不超过多少时间，不超过多少人力，不超过多少成本等等。所以有几个科学家拓展了拉格朗日乘数法，增加了KKT条件之后便可以用拉格朗日乘数法来求解不等式约束的优化问题了。</p>\n<p>首先，我们先介绍一下什么是KKT条件。</p>\n<p><strong>KKT条件是指在满足一些有规则的条件下, 一个非线性规划(Nonlinear Programming)问题能有最优化解法的一个必要和充分条件.</strong>&nbsp;这是一个广义化拉格朗日乘数的成果. 一般地, 一个最优化数学模型的列标准形式参考开头的式子, 所谓 Karush-Kuhn-Tucker 最优化条件，就是指上式的最优点x∗必须满足下面的条件:</p>\n<p>1). 约束条件满足gi(x∗)≤0,i=1,2,…,p, 以及,hj(x∗)=0,j=1,2,…,q</p>\n<p>2). ∇f(x∗)+∑i=1μi∇gi(x∗)+∑j=1λj∇hj(x∗)=0, 其中∇为梯度算子;</p>\n<p>3). λj≠0且不等式约束条件满足μi≥0,μigi(x∗)=0,i=1,2,…,p。</p>\n<p>KKT条件第一项是说最优点x∗必须满足所有等式及不等式限制条件, 也就是说最优点必须是一个可行解, 这一点自然是毋庸置疑的. 第二项表明在最优点x∗, ∇f必须是∇gi和∇hj的线性組合, μi和λj都叫作拉格朗日乘子. 所不同的是不等式限制条件有方向性, 所以每一个μi都必须大于或等于零, 而等式限制条件没有方向性，所以λj没有符号的限制, 其符号要视等式限制条件的写法而定.</p>\n<p><strong>为了更容易理解，我们先举一个例子来说明一下KKT条件的由来。</strong></p>\n<p>let&nbsp;L(x,μ)=f(x)+∑k=1μkgk(x)，其中μk≥0,gk(x)≤0</p>\n<p>∵μk≥0 gk(x)≤0 &nbsp;=&gt; &nbsp;μg(x)≤0</p>\n<p>∴maxμL(x,μ)=f(x) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(2)</p>\n<p>∴minxf(x)=minxmaxμL(x,μ) &nbsp; &nbsp; (3)</p>\n<p>maxμminxL(x,μ)=maxμ[minxf(x)+minxμg(x)]=maxμminxf(x)+maxμminxμg(x)=minxf(x)+maxμminxμg(x)</p>\n<p>又∵μk≥0, gk(x)≤0<br>\n</p>\n<p>∴maxμminxμg(x)=0, 此时μ=0 or g(x)=0.</p>\n<p>∴maxμminxL(x,μ)=minxf(x)+maxμminxμg(x)=minxf(x) &nbsp; &nbsp; &nbsp;(4)</p>\n<p>此时μ=0&nbsp;or&nbsp;g(x)=0.</p>\n<p>联合(3),(4)我们得到minxmaxμL(x,μ)=maxμminxL(x,μ),&nbsp;亦即<br>\n</p>\n<p>minxmaxμL(x,μ)=maxμminxL(x,μ)=minxf(x)</p>\n<p>我们把maxμminxL(x,μ)称为原问题minxmaxμL(x,μ)的对偶问题，上式表明当满足一定条件时原问题、对偶的解、以及minxf(x)是相同的，且在最优解x∗处μ=0 or g(x∗)=0。把x∗代入(2)得maxμL(x∗,μ)=f(x∗)，由(4)得maxμminxL(x,μ)=f(x∗)，所以L(x∗,μ)=minxL(x,μ)，这说明x∗也是L(x,μ)的极值点，即<br>\n</p>\n<p>最后总结一下：<br>\n</p>\n<p>KKT条件是拉格朗日乘子法的泛化，如果我们把等式约束和不等式约束一并纳入进来则表现为：<br>\n</p>\n<p>注：x,λ,μ都是向量。<br>\n</p>\n<p>表明f(x)在极值点x∗处的梯度是各个hi(x∗)和gk(x∗)梯度的线性组合。</p>\n",
      "date_published": "2024-04-27T15:25:14.000Z",
      "date_modified": "2024-04-27T15:25:14.000Z",
      "authors": [],
      "tags": [
        "设计基础"
      ]
    },
    {
      "title": "线性规划",
      "url": "https://ujava.cn/synthesis/linear.html",
      "id": "https://ujava.cn/synthesis/linear.html",
      "summary": "1、线性规划 1.1 线性规划的定义 线性规划的标准形式： 其中的 c 和 x 均为 n 维列向量，A、 Aeq 为适当维数的矩阵，b 、beq 为适当维数的列向量。 例如：x1 和 x2 称为决策变量，整个式子分为了目标函数和约束条件 总之， 线性规划问题是在一组线性约束条件的限制下， 求一线性目标函数最大或最小的问题。 1.2 线性规划的解 线性规划问题的标准数学形式： 满足（4）并使（3）达到最大值的可行解称为最优解；可行解构成的域称为可行域。",
      "content_html": "<h1> 1、线性规划</h1>\n<h2> 1.1 线性规划的定义</h2>\n<p>线性规划的标准形式：<br>\n</p>\n<p>其中的 c 和 x 均为 n 维列向量，A、 Aeq 为适当维数的矩阵，b 、beq 为适当维数的列向量。</p>\n<p>例如：x1 和 x2 称为决策变量，整个式子分为了目标函数和约束条件<br>\n</p>\n<p>总之， 线性规划问题是在一组<strong>线性约束条件</strong>的限制下， 求一线性目标函数最大或最小的问题。</p>\n<h2> 1.2 线性规划的解</h2>\n<p>线性规划问题的标准数学形式：<br>\n</p>\n<p>满足（4）并使（3）达到最大值的可行解称为最优解；可行解构成的域称为可行域。</p>\n<h3> 1.2.1 图解法</h3>\n<p>1.1 中例子的约束条件 x1 和 x2 可用域如下，显然，对于目标函数来说，x1 和 x2<br>\n越大，目标函数值越大，最优解为<img src=\"https://gitee.com/sgkurisu/pic-go/raw/master/picture2/20210804193538.png\" alt=\"image-20210804193538356\" loading=\"lazy\"><br>\n，最优目标值为 z* = 26。<br>\n</p>\n<p>有如下结论：</p>\n<ol>\n<li>可行域可出现多种情况，既可能有界，也可能无界。</li>\n<li>可行域非空时，既可存在有限最优解，也可不存在最优解。</li>\n<li>若存在最优解，则必可找到具有可行域的“顶点” 。</li>\n</ol>\n<h3> 1.2.2 MATLAB 解法</h3>\n<p>MATLAB 线性规划标准形式为<br>\n</p>\n<p>线性规划的函数为 linprog ，注意，linprog 求解的为线性规划最小值 min，若想求线性规划最大值，则需要对向量 c 取符号</p>\n<div class=\"language-matlab line-numbers-mode\" data-ext=\"matlab\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>fval 返回目标函数的值， LB 和 UB 分别是变量 x 的下界和上界，x0 是 x 的初始值，</p>\n<blockquote>\n<p>例 1<br>\n</p>\n</blockquote>\n<p>m 文件：注意 linprog 中 c 取了负号<br>\n</p>\n<blockquote>\n<p>例 2<br>\n</p>\n</blockquote>\n<p>m 文件：<br>\n</p>\n<h2> 1.3 可转换为线性规划的问题</h2>\n<figure><figcaption>img_184.png</figcaption></figure>\n<p>可取<br>\n</p>\n<figure><figcaption>img_186.png</figcaption></figure>\n<p>那么问题转化为<br>\n</p>\n<blockquote>\n<p>例 3<br>\n</p>\n</blockquote>\n<p>其中 </p>\n<p>对于以上问题，取  ，那么问题变为线性规划问题<br>\n</p>\n<h2> 1.4 运输问题</h2>\n<p>某产品有 m 个产地，n 个销地，各地产量为 a1，a2 ... am，各地需求量为 b1，b2 ... bn，从 i 到 j 的<strong>单价</strong>运费为<br>\ncij，问如何调度才可使总运费最省？</p>\n<p>解：</p>\n<p>引入 xij，其取值为由 i 产地运往 j 销地的该商品数量，有<br>\n</p>\n<p>对于产销平衡问题，有以下关系：<br>\n</p>\n<h2> 1.5 指派问题</h2>\n<p>n 个人干 n 项工作，若第 i 个人去干第 j 项工作，需要花费 cij 时间，给定矩阵 C = (cij) 问如何分配才可使花费总时间最短？</p>\n<p>解：</p>\n<p>引入变量 xij，用来表示第 i 个人是否做第 j 项工作，xij = 1 表示做，xij = 0 表示不做，那么可得到如下数学模型：<br>\n</p>\n<figure><figcaption>img_195.png</figcaption></figure>\n<p>同理，xij 也可使用矩阵来表示，每行每列仅有一个为 1，其余为 0，因此这为 0-1 规划问题，针对指派问题，可将约束条件写为 xij &gt;= 0<br>\n，m = n = n，ai = bi = 1 ，因此可发现，这个问题进一步简化为了运输问题。<br>\n</p>\n<figure><figcaption>img_197.png</figcaption></figure>\n<h3> 1.5.1 指派问题的匈牙利算法</h3>\n<p>对系数矩阵 C 行或列进行线性变换，得到新的矩阵 B，矩阵 B 和 C 具有相同的最优指派。</p>\n<blockquote>\n<p>例 4</p>\n</blockquote>\n<p>指派问题的系数矩阵为<br>\n</p>\n<p>对其进行行列变换得到：<br>\n</p>\n<p>可发现，最优指派为 x12 = 1, x21 = 1, x33 = 1, x44 = 1<br>\n</p>\n<blockquote>\n<p>例 5</p>\n</blockquote>\n<p>对于较为复杂的指派问题<br>\n</p>\n<p>对其进行线性变换，有<br>\n</p>\n<p>对于第 3 行和第 5 行，都只在第 1 个元素的位置为 0，那么这时无法得到最优指派，只能继续进行线性变换，有<br>\n</p>\n<p>这时，可发现，最优指派为 x12 = 1, x24 = 1, x31 = 1, x43 = 1, x55 = 1<br>\n</p>\n<h2> 1.6 对偶理论与灵敏度分析</h2>\n<h3> 1.6.1 原始问题和对偶问题</h3>\n<figure><figcaption>img_205.png</figcaption></figure>\n<p>称（P）为原始问题， （D）为它的对偶问题。 注意变换时 c 和 b 的位置。</p>\n<p>对于如下线性规划问题：<br>\n</p>\n<p>可改写为<br>\n</p>\n<p>那么对偶问题为<br>\n</p>\n<p>令 y = y1 - y2 ，又可写成<br>\n</p>\n<p>可将原始问题转化为对偶问题进行求解，在求出最优解后，再根据性质反求出原始问题的最优解。</p>\n<h3> 4.2 灵敏度分析</h3>\n<p>灵敏度分析就是系数、常数等发生变化时， 已求得的线性规划问题的最优解会有什么变化；或者这些系数在什么范围内变化时，<br>\n线性规划问题的最优解或最优解不变。也可理解为鲁棒性。</p>\n<h2> 1.7 投资的收益和风险</h2>\n<p>以一个题目为例对本知识点进行总结。</p>\n<h3> 1.7.1 问题描述</h3>\n<p>市场上有 n 种资产 si(i = 1, 2, ..., n)，目前资金总数为 M，资产 si 的收益率为 ri，亏损率为 qi，交易费率为 pi，在不超过金额 ui<br>\n时，交易费按 ui 计算，假设银行存款利率为 r0。r0 = 5%</p>\n<p>n = 4 时<br>\n</p>\n<p>目标是使净收益尽可能大，总风险尽可能小。</p>\n<h3> 1.7.2 符号规定</h3>\n<p>定义 xi 为投资 si 的资金，a 为投资风险度，Q 为总体收益。</p>\n<p>基本假设：</p>\n<ol>\n<li>投资数额 M 相当大，为了便于计算，假设 M = 1</li>\n<li>投资越分散，总的风险越小</li>\n<li>总体风险用所投资的所有项目中最大的一个风险来度量</li>\n<li>n 种资产之间是相互独立的</li>\n<li>ri，pi，qi，r0 为定值，不受外界影响</li>\n</ol>\n<h3> 1.7.3 建模与分析</h3>\n<p>模型为：目标函数第一个为收益，第二个为风险</p>\n<figure><figcaption>img_211.png</figcaption></figure>\n<h3> 1.7.4 模型简化</h3>\n<blockquote>\n<p>固定风险水平，优化收益</p>\n</blockquote>\n<p>在实际中，由于承受风险能力不同，因此规定一个风险界限 a，使得  ，那么模型变为</p>\n<p>模型一：<br>\n</p>\n<blockquote>\n<p>固定盈利水平，极小化风险</p>\n</blockquote>\n<p>若希望总盈利到达 k 以上，则目标函数变为了极小化风险</p>\n<p>模型二：<br>\n</p>\n<blockquote>\n<p>权衡资产风险和预期收益</p>\n</blockquote>\n<p>对风险和收益进行权衡，设置权重 s (0 &lt; s &lt; 1)，s 称为投资偏好系数</p>\n<p>模型三：</p>\n<figure><figcaption>img_215.png</figcaption></figure>\n<h3> 1.7.5 模型的求解</h3>\n<p>以上模型的求解可使用 MATLAB 解法进行解决，以模型一为例<br>\n<br>\n</p>\n<p>从 a = 0 开始，以步长 0.001 循环搜索，MATLAB 代码如下：<br>\n</p>\n<h3> 1.7.6 结果分析</h3>\n<ol>\n<li>风险大，收益也大。</li>\n<li>当投资越分散时，投资者承担的风险越小，冒险的投资者会出现集中投资的情况，保守的投资者则尽量分散投资。</li>\n<li>（根据 MATLAB 图形进行说明）在 a = 0.006<br>\n附近有转折点，在这一点左边，风险增加很少时，利润增长很快。在这一点右边，风险增加很大时，利润增长很缓慢，所以对于风险和收益没有特殊偏好的投资者来说，应该选择曲线的拐点作为最优投资组合，大约<br>\na = 0.6%，Q = 20%，（然后计算投入各个资产的资金数量）x0 = 0, x1 = 0.24, x2 = 0.4, x3 = 0.1091, x4 = 0.2212.</li>\n</ol>\n",
      "date_published": "2024-04-27T14:45:18.000Z",
      "date_modified": "2024-04-27T14:45:18.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "组件ERP",
      "url": "https://ujava.cn/assembly/erp.html",
      "id": "https://ujava.cn/assembly/erp.html",
      "summary": "一、ERP是什么？ ERP是企业资源计划（Enterpise Resource Planning）的简称，蕴含现代企业管理理念，其核心是在制造资源计划基础上进一步发展而成的面向供应链的管理思想。 二、ERP的宗旨是什么？ ERP的主要宗旨是将企业的各方面资源（人力、资金、信息、物料、设备、时间、方法等）进行科学地计划、管理和控制。为企业加强资产管理、提高资金运营水平、建立高效率供应链、规范管理流、提高精益化管理水平、提高客户 服务水平，为实现设备全生命周期管理奠定基础。 三、ERP蕴含的先进理念是什么？",
      "content_html": "<h2> 一、ERP是什么？</h2>\n<p>ERP是企业资源计划（Enterpise Resource Planning）的简称，蕴含现代企业管理理念，其核心是在制造资源计划基础上进一步发展而成的面向供应链的管理思想。</p>\n<h2> 二、ERP的宗旨是什么？</h2>\n<p>ERP的主要宗旨是将企业的各方面资源（人力、资金、信息、物料、设备、时间、方法等）进行科学地计划、管理和控制。为企业加强资产管理、提高资金运营水平、建立高效率供应链、规范管理流、提高精益化管理水平、提高客户</p>\n<p>服务水平，为实现设备全生命周期管理奠定基础。</p>\n<h2> 三、ERP蕴含的先进理念是什么？</h2>\n<p>ERP应用当前国际上最为先进的企业管理模式和理念，主要宗旨是：将企业各方面包括人、财、物、产、供销等在内的资源充分调配和平衡，使企业在激烈的市场竞争中有效</p>\n<p>调动各方资源、充分发挥各方能力，从而取得最好的经济效益。</p>\n<h2> 四、ERP包括以下五个模块</h2>\n<p>（1）项目管理模块（PS）</p>\n<p>项目是指把各种系统、方法和人员结合在一起，在规定的时间、预算、质量和目标范围内完成的各项工作。有效的项目管理是指：在规定用来实现具体目标和指标的时间内，对组织机构中的资源进行计划、引导和控制工作。</p>\n<p>SAP的项目管理PS是SAP ECC的一个集成解决方案，它具有基础管理、项目结构管理、规划管理、预算管理、项目实现、信息系统等功能，它与其它MM、PM、FICO模块有高度的集成性。</p>\n<p>MM模块是解决项目物资和服务采购过程的管理，PM模块解决项目竣工后移交生产设备的管理，FICO模块是实现项目成本核算和结算等，通过PS的集成性可以实现项目的立项申请、计划、执行、结算和决算管理和控制。</p>\n<p>（2） 人资管理模块（HR）</p>\n<p>主要由组织管理、职务岗位管理、人事管理、档案、合同管理、时间管理、工资核算、薪酬和福利管理、培训管理、招聘管理、绩效管理、人才保留、继任计划管理、职业发展管理等功能组成。</p>\n<p>（3） 物资管理模块（MM）</p>\n<p>是指基于物料（含服务）的物流管理操作。主要由物料主数据管理、计划管理、供应商管理、采购管理、库存管理、仓储管理以及票据管理（发票校验）等功能组成。</p>\n<p>（4） 财务管理模块（FI）</p>\n<p>是指必须能够按照有关规定向股东、债权人、以及社会公众披露并提供所需的信息。主要由总分类账、应收帐、固定资产、法定合并报表以及特殊目的的分类账等会计功能组成。</p>\n<p>（5）设备管理模块（PM）</p>\n<p>作为SAP集成系统中的一个功能子模块，涵盖了一个工厂系统的所有维护任务。</p>\n",
      "date_published": "2024-04-27T14:03:48.000Z",
      "date_modified": "2024-04-27T14:05:58.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "运筹学",
      "url": "https://ujava.cn/synthesis/operational.html",
      "id": "https://ujava.cn/synthesis/operational.html",
      "summary": "第一章 1.运筹学（operations Research，简称OR）是一门研究如何有效的组织管理人机系统的科学。 2.运筹学的目的是通过定量分析为决策和揭露新问题提供数量根据 3.运筹学利用计划方法和有关学科的要求把复杂功能关系表示成数学模型，其目的是通过定量分析为决策和揭露新问题提供数量根据 4.运筹学应用分析的经验和数量的方法，对各种可供选择的方案进行比较评价，为制定最优的管理决策提供数量上的依据。 5.对于管理领域，运筹学也是对管理决策工作进行决策的计量方法。 6.在当今信息时代，运筹学和计算机方法的分界线将会消失，并将脱离各自原来的领域，组合成更通用广泛的管理科学的形式",
      "content_html": "<h1> 第一章</h1>\n<h3> 1.运筹学（operations Research，简称OR）是一门研究如何有效的组织管理人机系统的科学。</h3>\n<h3> 2.运筹学的目的是通过定量分析为决策和揭露新问题提供数量根据</h3>\n<h3> 3.运筹学利用计划方法和有关学科的要求把复杂功能关系表示成数学模型，其目的是通过定量分析为决策和揭露新问题提供数量根据</h3>\n<h3> 4.运筹学应用分析的经验和数量的方法，对各种可供选择的方案进行比较评价，为制定最优的管理决策提供数量上的依据。</h3>\n<h3> 5.对于管理领域，运筹学也是对管理决策工作进行决策的计量方法。</h3>\n<h3> 6.在当今信息时代，运筹学和计算机方法的分界线将会消失，并将脱离各自原来的领域，组合成更通用广泛的管理科学的形式</h3>\n<h3> 7.根据决策人员的主观经验或知识而制定的决策，称之为定性决策</h3>\n<h3> 8.必须运用定性和定量两种方法才能制定的决策，称之为混合性决策</h3>\n<h3> 9.借助于某种正规的计量方法而做出的决策，称之为定量决策</h3>\n<h1> 第二章</h1>\n<h3> 1.作为运筹学应用者，接受管理部门的要求，去收集和阐明数据，建立和试验数学模型，预言未来作业，然后制定方案，并推荐给经理部门。</h3>\n<h3> 2.问题域的环境有内部环境和外部环境。</h3>\n<h3> 对企业来说，</h3>\n<ul>\n<li>内部环境一般指问题域内部的人、财、物之间的交互活动。</li>\n<li>外部环境一般指问题域界面与外界的人、财、物之间的交互活动</li>\n</ul>\n<h3> 3.SWOT分析和决策不属于应用运筹学进行决策过程</h3>\n<h3> 4.运筹学科学方法论的六个步骤</h3>\n<h3> ①观察待决策问题所处的环境</h3>\n<h3> ②分析和定义待决策的问题</h3>\n<h3> ③拟定模型</h3>\n<h3> ④选择输入资料</h3>\n<h3> ⑤提出解并验证它的合理性</h3>\n<h3> ⑥实施最优解</h3>\n<h3> 5.应用运筹学方法进行决策过程中，一旦建立成适当的模型，就要准备收集哪个模型所需要的数据</h3>\n<h3> 6.预测是决策基础。企业预测的目的就是为企业决策提供适当的数据或资料</h3>\n<h3> 7.预测就是对未来的不确定的事件进行估计或预判</h3>\n<h3> 8.不属于微观经济学的内容是国民收入增长率</h3>\n<h3> 9.对科学发展趋势和发明、科学发展、产品发展与社会生活的关系等预测属于科学预测</h3>\n<h3> 10.社会预测</h3>\n<ul>\n<li>人口增长预测属于社会预测</li>\n<li>社会购买心里的预测属于社会预测</li>\n</ul>\n<h3> 11.定性预测有两种方法</h3>\n<ul>\n<li>专家小组法（面对面讨论，容易被权威影响、适用于短期预测）</li>\n<li>特尔斐法（专家群、匿名获取意见、多次信息反馈、适用于长期预测）</li>\n</ul>\n<h3> 12.军事预测是研究与战争、军事有关的问题</h3>\n<h3> 13.按内容划分，预测方法中包含经济预测</h3>\n<h3> 14.按内容划分的预测方法</h3>\n<ul>\n<li>经济预测</li>\n<li>社会预测</li>\n<li>科学预测</li>\n<li>军事预测</li>\n</ul>\n<h3> 15.定性预测又称之为直观预测，是指利用直观材料，依靠个人经验的主观经验的主管判断和分析能力，对未来的发展进行预测</h3>\n<h3> 16.科技预测年限范围</h3>\n<ul>\n<li>短期的年限是5~10年</li>\n<li>中期的年限是10~30年</li>\n<li>长期的年限是30~50年</li>\n</ul>\n<h3> 17.外推法包含时间序列分析法</h3>\n<h3> 18.凡利用历史数据来推算事物发展趋势的叫外推法，常用的有时间序列分析法</h3>\n<h3> 19.凡利用事物内部因素发展的因果关系来预测事物发展趋势的叫因果法，常用的有回归分析法、经济计量法、投入产出分析法等</h3>\n<h3> 20.根据历史数据和资料，应用数理统计方法来预测事物的未来，或者利用事物发展的因果关系来预测事物的未来，属于定量预测</h3>\n<h3> 21.经济预测分为两种</h3>\n<ul>\n<li>宏观经济预测：国民经济范围（国民收入增长率）</li>\n<li>微观经济预测：单个实体经济（市场需求、市场占有率、产品的销售额）</li>\n</ul>\n<h3> 22.一般而论，1~3年内的经济预测为中期预测</h3>\n<h3> 23.经济预测的年限范围</h3>\n<ul>\n<li>短期（近期）预测是1年内</li>\n<li>中期预测是1~3年内</li>\n<li>长期预测是3~5年内</li>\n</ul>\n<h3> 24.描述国民经济大系统以及相关经济变量的社会综合值的预测属于宏观经济预测</h3>\n<h3> 25.技术预测包括：新技术发明可能应用的领域范围和速度、新设备、新工艺、新材料的特点、性能及作用等</h3>\n<h3> 26.预测的方法</h3>\n<ul>\n<li>定性预测</li>\n<li>定量预测</li>\n</ul>\n<h3> 27.<a href=\"https://www.cnblogs.com/saoge/p/16079225.html\" target=\"_blank\" rel=\"noopener noreferrer\">滑动平均预测法</a></h3>\n<h3> 28.带权滑动平均数</h3>\n<h3> 29.指数平滑预测法</h3>\n<h3> 30.平滑公式:8月份预测值 = 7月份实际值*平滑系数+(1-平滑系数)*7月份预测值<img src=\"https://img2023.cnblogs.com/blog/2135082/202303/2135082-20230314215503642-1522481382.png\" alt=\"\" loading=\"lazy\"></h3>\n<h3> 31.若是商品看涨或看跌滑动系数大于1较为合理</h3>\n<h3> 32.回归模型预测法(回归分析法)</h3>\n<h3> 33.直线方程:y=a+bx</h3>\n<h3> 34.回归分析法就是依据事物发展的内部因素变化的因果关系来预测事物未来的发展趋势</h3>\n<h3> 35.相关关系是由于变量之间的因果关系存在着其他因素的干扰与影响,使变量间的关系出现不确定性</h3>\n<h3> 36.一元线性回归:只有一个X,表达式:y=a+bx</h3>\n<figure><figcaption>img_148.png</figcaption></figure>\n<h3> 37.多元线性回归:多个X</h3>\n<h3> 38.最小二乘法:寻求使误差平方总和为最小的配合趋势线的方法</h3>\n<figure><figcaption>img_149.png</figcaption></figure>\n<h3> 39.回归模型建立后,还需要经过相关检验,才能应用与预测</h3>\n<h3> 40.可以根据已知数据计算出相关系数R,根据R的大小来判定Y与X的相关程度</h3>\n<h3> 41.R的取值范围是[-1,1],即-1&lt;=R&lt;=1</h3>\n<figure><figcaption>img_150.png</figcaption></figure>\n<h3> 42.置信区间:这个值和实际值达到概率的95%</h3>\n<figure><figcaption>img_151.png</figcaption></figure>\n<h3> 43.季节性变动的预测</h3>\n<figure><figcaption>img_152.png</figcaption></figure>\n<h3> 44.调整成本采用指数平滑法进行预测,依然选用较小的a</h3>\n<h1> 第三章</h1>\n<h3> 1.在不同环境下的决策</h3>\n<ul>\n<li>确定条件的决策:只存在一种状态</li>\n<li>不确定条件下的决策:存在一个以上的状态,不完全了解概率</li>\n<li>风险条件下的决策:根据概率值,有概率就有风险</li>\n</ul>\n<h3> 2.决策的分类</h3>\n<ul>\n<li>计划性决策:制定计划时做的决策</li>\n<li>控制性决策:实施计划时做的决策</li>\n<li>常规性决策:重复性决策(吃饭)</li>\n<li>特殊性决策:无先例的新问题(报专业)</li>\n</ul>\n<h3> 3.西蒙在&lt;管理决策新科学&gt;,管理的关键在于决策</h3>\n<h3> 4.广义的决策的四个程序</h3>\n<ul>\n<li>明确决策的目的</li>\n<li>寻找可行的方案</li>\n<li>在诸多可行方案中进行抉择</li>\n<li>对选定的方案实施后的结果进行总结评价<br>\n</li>\n</ul>\n<h3> 5.决策的概念:明确目标问题,并拟定多个可行方案,在选中最佳方案的全过程</h3>\n<h3> 6.最大最大决策标准:乐观-&gt;先大后大(max{a,b,c})</h3>\n<h3> 7.最大最小决策标准:悲观-&gt;先小后大(先min后max)</h3>\n<figure><figcaption>img_154.png</figcaption></figure>\n<h3> 8.现实主义决策标准:</h3>\n<ul>\n<li>折中主义决策标准</li>\n<li>最佳概率定为a,最差概率定义为(1-a)</li>\n<li>a=折中系数</li>\n<li>范围(0&lt;a&lt;1)</li>\n<li>公式</li>\n<li>先算CV在max</li>\n</ul>\n<h3> 9.最小最大遗憾值决策标准</h3>\n<ul>\n<li>遗憾值 = 后悔值</li>\n<li>画图:收益值改为遗憾值</li>\n<li>用该列最大值-其他值=遗憾值</li>\n<li>最后max所有遗憾值行,后在min结果遗憾值<br>\n</li>\n</ul>\n<h3> 10.最大期望收益值标准:</h3>\n<ul>\n<li>用概率作为其权重,计算加权平均数-期望收益</li>\n<li>公式:收益1 * 概率1 + 收益2 * 概率2 + 收益3 * 概率3 = 期望收益</li>\n<li>根据公式计算期望值收益后,在进行max期望收益</li>\n<li>收益 = 售价 * 售出数量 - 成本 * 生产数量<br>\n</li>\n</ul>\n<h3> 11.最小期望损失值标准</h3>\n<h3> 12.决策树</h3>\n<ul>\n<li>不仅可以解决但阶段决策问题,而且可以应用于复杂的多阶段决策</li>\n<li>方块结点 -&gt; 决策结点 -&gt; 决策两个节点的线叫方案枝</li>\n<li>圆圈结点 -&gt; 状态结点 -&gt;两个节点的线叫状态枝</li>\n</ul>\n<h3> 13.总结</h3>\n<figure><figcaption>img_158.png</figcaption></figure>\n<h3> 14.案例</h3>\n<figure><figcaption>img_159.png</figcaption></figure>\n<h1> 第四章</h1>\n<h3> 1.库存管理的对象</h3>\n<ul>\n<li>原材料,半成品</li>\n<li>在制品</li>\n<li>成品</li>\n</ul>\n<h3> 2.库存管理的意义</h3>\n<ul>\n<li>保证企业按计划实现均衡生产,不能因缺少原材料或卡物质而停工停产</li>\n<li>使库存管理的总费用达到最低</li>\n</ul>\n<h3> 3.存货台套法:以存货台套作为存货管理的单位,在一个存货台套中可以包括有关的各种单项存货,是一种单位</h3>\n<h3> 4.ABC分析法:按照年度需用价值</h3>\n<ul>\n<li>A类:(特殊物品,数量少,但很重要,很值钱)数量10% 年度需用价值70%</li>\n<li>B类:(数量30%,年度需用价值20%)</li>\n<li>C类:(数量60%,年度需用价值10%)不值钱,但数量多</li>\n</ul>\n<h4> 5.原材料库库存费用模型构造: 库存费用 = 订货费 +保管费</h4>\n<ul>\n<li>保管费用:折旧和管理</li>\n<li>订货费用:订货需要的费用(采购人员的工作,差旅费)</li>\n<li>基本都是按年算的,订货费用都是固定的</li>\n<li>订货费 = 每年订货次数 * 每次订货费用</li>\n<li>保管费 = 全年需求量 / 每年订货次数 * 每次原材料保管费</li>\n<li>运费不算订货费,算进厂价</li>\n</ul>\n<h3> 6.半成品和成品库:库存费用 = 工装调整费 + 保管费</h3>\n<ul>\n<li>工装调整费:(设备调整和检验所需费用)</li>\n</ul>\n<h3> 7.年需求量固定的情况下</h3>\n<ul>\n<li>订货次数越多,订货费用越多,订货量越少,保管费用越低</li>\n<li>订货次数越少,订货费用越少,订货量越多,保管费用越高</li>\n</ul>\n<h3> 8.平均库存概念</h3>\n<ul>\n<li>平均库存量等于订货批量大小的一半</li>\n<li>平均库存 = 订货量 / 2</li>\n</ul>\n<h3> 9.订货费用 = 年需要量 / 订货量 * 一次订货费</h3>\n<h3> 10.保管费用 = 平均存货量 * 每一库存台套的年保管费用 =最佳订货量 / 2 * 单价 * 保管费用率</h3>\n<ul>\n<li>平均存货量 = 最佳订货量 / 2</li>\n<li>每一库存台套的年保管费用 = 单价 * 保管费用率</li>\n<li>平均库存量就是平均存货量<br>\n</li>\n</ul>\n<h3> 11.经济订货量(EOQ)是使总存货费用达到最低的某个存货台套的最佳订货批量,使全年保管费用和订货费用的总和达到最小值</h3>\n<h3> 12.当订货费用 = 保管费用 时达到最小</h3>\n<h3> 13.最佳订货量 = 2订需/存 开根号</h3>\n<h3> 14.最佳订货次数 = 年需要量 / 最佳订货量</h3>\n<h3> 15.最佳订货间隔期 = 最佳订货次数 / 365</h3>\n<h3> 16.平均存货量 = 最佳订货量 / 2</h3>\n<h3> 17.平均存货额 = 最佳订货量 / 2 * 单价 = 平均存货量 * 单价</h3>\n<figure><figcaption>img_161.png</figcaption></figure>\n<h3> 18.订货时间的确定</h3>\n<ul>\n<li>前置时间 = &gt; 订货提前期</li>\n<li>再订货点 :再订货的时间或订货的数量</li>\n<li>缺货是指仓库中已没有某项存货可以满足生产需求或销量需要时的状况</li>\n</ul>\n<h3> 19.确定库存模型的前提是:使用量和提前时间都是恒定的</h3>\n<h3> 20.避免缺货</h3>\n<ul>\n<li>增加订货库存</li>\n<li>订货催运</li>\n<li>提高前置时间</li>\n<li>安全库存量=&gt;库存预警:防止缺货的额外库存</li>\n</ul>\n<h3> 21.大批量采购</h3>\n<ul>\n<li>优点:订货费低,降低了订货费用</li>\n<li>缺点:保管费用高</li>\n</ul>\n<h1> 第五章</h1>\n<h3> 1.图解法</h3>\n<ul>\n<li>先设置x1,x2,f公式,和2个不等式,x1&gt;=0,x2&gt;= 0</li>\n<li>根据两个不等式画图,一个不等式一条线,x1和x2分别等于0 带入不等式得到两个点</li>\n<li>解二元一次方程,带入法或加减消除法</li>\n<li>算出图中的交叉点的两个值</li>\n<li>再将三个点的值分别带入f 公式算出值</li>\n<li>最后max算出的三个点值</li>\n</ul>\n<h3> 2.现性规则是一种合理利用资源'合理调配资源的应用数学方法</h3>\n<h3> 3.线性规划的基本特点是模型中的线性函数</h3>\n<h3> 4.线性规划模型结构</h3>\n<ul>\n<li>变量是指实际系统或决策问题中有待确认的未知因素</li>\n<li>目标函数是决策者对决策问题目标的数学描述,是一个极值问题,即极大值或极小值</li>\n<li>约束条件是指实现目标的限制因素</li>\n<li>线性规划的变量为非负值</li>\n</ul>\n<h3> 5.线性规划的基本特点是模型的数学表达式是线性函数</h3>\n<h3> 6.线性规划的解法有图解法和单纯形法两种</h3>\n<ul>\n<li>图解法:适用于解2~3个变量的线性规划问题,满足约束条件的解称之为可行解 (图形的阴影部分)</li>\n<li>可行解区就是全部可行解所分布的区域,又称凸集(图形的阴影部分)</li>\n<li>可行解区域内满足目标函数的解称之为最优解</li>\n</ul>\n<h3> 7.线性规划的基本原理:如果线性规划问题有最优解,最优解必在可行解区边缘折线的凸交点上</h3>\n<h3> 8.单纯形法</h3>\n<ul>\n<li>引入辅助变量(松弛变量)k1和k2,将约束条件的不等式转变成等式</li>\n<li>约束条件的大于等于,则引进剩余变量和人工变量</li>\n<li>k1和k2是多用的原材料(基变量),约束方程组的通解</li>\n<li>非基变量x1和x2一个具体的值,九可以获得到一个特解(特解有多个)</li>\n<li>所有非基变量都等于0的特解称之为基解</li>\n<li>当基解满足非负的要求时,叫可行基解</li>\n<li>一个线性规划问题,若有最优解,那么最优解必然是一个基变量组的可行基解</li>\n<li>一个基变量组有一个通解,一个基解,无数个特解(总结:只有特解是多个,其他只有一个)</li>\n<li>先写不等式解出后,要画图</li>\n</ul>\n<h3> 9.线性规划模型的标准形式中约束条件为等式方程组</h3>\n<h3> 10.线性规划模型因素</h3>\n<ul>\n<li>决策问题目标-&gt;目标函数</li>\n<li>限制因素-&gt;约束条件</li>\n<li>未知因素-&gt;变量</li>\n<li>基本特性-&gt;线性函数</li>\n</ul>\n<h3> 11.单渠道随机排队法:由一个单服务台,随机到达和随即服务时间的情况形成</h3>\n<h1> 第六章</h1>\n<h3> 1.求得一个最初的运输方案</h3>\n<ul>\n<li>西北角法(阶石法)-求最初运输方案</li>\n</ul>\n<h3> 2.初始运输方案数字格的数目应为:(m + n - 1)</h3>\n<h3> 3.寻求改进方案</h3>\n<ul>\n<li>闭合回路法-&gt;改进路线</li>\n</ul>\n<h3> 4.建立改进方案</h3>\n<ul>\n<li>在所有空格中,挑选绝对值最大的负改进指数所在的空格作为调整格</li>\n<li>在调整路线中,选中负号格的最小运量作为调整运量</li>\n</ul>\n<h3> 5.最优方案可以继续改进,改进之后运输费用已经不能进一步降低</h3>\n<h3> 6.当所有空格的改进指数都大于或等于0时,就得到了最优方案</h3>\n<h3> 7.运输问题必然有最优方案,但最优方案不一定是唯一.</h3>\n<h3> 8.修正分配法(位势法)</h3>\n<ul>\n<li>先求每一个空格的改进指数</li>\n<li>再寻求最优改进指数的改进路线</li>\n<li>没有讲,主要用于电脑的</li>\n</ul>\n<h3> 9.修正分配法与闭合回路法的关系</h3>\n<ul>\n<li>闭合回路法是修正分配法的基础</li>\n<li>修正分配法更简便</li>\n<li>两种方法的结果是相同的</li>\n</ul>\n<h3> 10.运输问题属于线性规划问题.</h3>\n<h3> 11.产销不均衡,我们可以通过虚设一个产地或销地解决</h3>\n<h3> 12.可求解运输问题的最简便方法是表上作业法.</h3>\n<h3> 13.运输问题的解是指满足要求的各供应点到各需求点的运量.</h3>\n<h3> 14.平衡运输问题的所有产地的总产量和所有销地的总需求量相等.</h3>\n<h3> 15.表上作业法是指首先把产销平衡表和运价表压缩在一张表格里,然后求出一个初始调运方案,再加以判断和调整,直至求得最优方案的方法</h3>\n<h3> 16.表上作业法的基础是单纯形法</h3>\n<h3> 17.对于供需平衡的运输问题和供需不平衡的运输问题,其结构模型是不同的,所以要分别对待</h3>\n<ul>\n<li>供需平衡</li>\n<li>供大于需</li>\n<li>供小于需</li>\n</ul>\n<h3> 18.当存在最优解时,其中数字格有m+n-1个</h3>\n<h3> 19.改进指数(位势差)就是指循着改进路线,当货物的运输量作为一个单位的变化时,会引起总运输费用的改变量</h3>\n<h3> 20.闭合回路法需要先对各个空格寻求一条闭合的改进路线</h3>\n<h3> 22.都是负数,运量最小,绝对值最大</h3>\n<h3> 23.退化现象:数字格子&lt;m+n-1</h3>\n<figure><figcaption>img_163.png</figcaption></figure>\n<h1> 第七章</h1>\n<h3> 1.网络图的分类</h3>\n<ul>\n<li>线路</li>\n<li>结点</li>\n<li>箭线</li>\n<li>虚活动</li>\n</ul>\n<h3> 2.网络计划技术是综合运用计划评核术和关键路线法的一种比较先进的计划管理方法</h3>\n<ul>\n<li>计划评核术是对计划项目进行核算'评价,然后选定最优计划方案的技术</li>\n<li>关键路线法是再计划项目的各项错综复杂的工作中,抓住其中的关键路线(路长最大的线路)进行计划安排的一种方法</li>\n</ul>\n<h3> 3.网络图分两种</h3>\n<ul>\n<li>结点式网络图以结点代表活动,以箭线代表个活动的先后承接关系(开始和完成)</li>\n<li>箭线式网络图以箭线代表活动(作业),以结点代表活动的开始和完成</li>\n</ul>\n<h3> 4.箭线式网络图</h3>\n<ul>\n<li>线路:起点沿着箭线方向到终点的线</li>\n<li>结点:活动的开始或完成,两个活动之间的交接点,不消耗资源,不占用时间</li>\n<li>箭线(活动:消耗资源,占用时间)</li>\n<li>虚活动:可有可无,不消耗资源,不占用时间</li>\n<li>路长:线路的长度</li>\n<li>关键线路:总作业时间最长(路长最大的线路)</li>\n</ul>\n<h3> 5.活动明细表</h3>\n<ul>\n<li>箭线(活动)</li>\n<li>编号必须是奇数</li>\n<li>如果有两个以上紧前活动,就可以加虚活动</li>\n<li>关键线路:双横线,不等减少工期</li>\n</ul>\n<h3> 6.某工程 各道工具已确定,为使其达到\"成本最低和工期合理\"的要求,进行优化时应采用网络计划技术.</h3>\n<h3> 7.网络计划技术是解决组织生产和进行计划管理的科学方法</h3>\n<h3> 8.网络计划技术的基础是网络图</h3>\n<h3> 9.作业时间(T)就是在一定的生产技术条件下,完成一项活动或一道工序所需的时间</h3>\n<h3> 10.确定作业时间两种方法</h3>\n<ul>\n<li>单一时间估计法:在估计各项活动的作业时,只确定一个时间值</li>\n<li>三种时间估计法\n<ul>\n<li>最乐观时间 -&gt; 最短时间</li>\n<li>最保守时间 -&gt; 最长时间</li>\n<li>最可能时间 -&gt; 可能性最大时间</li>\n<li><figcaption>img_164.png</figcaption></li>\n</ul>\n</li>\n</ul>\n<h3> 11.图上计算法:网络时间的计算方法</h3>\n<h3> 12.结点最迟完成时间</h3>\n<h3> 13.因为不占用时间,所以一个结点的最迟完成时间和最迟开始时间是同一个时间</h3>\n<h3> 14.最早时间:(早大晚小)</h3>\n<h3> 15.最晚时间:(早大晚小)</h3>\n<h3> 16.结点的时间</h3>\n<ul>\n<li>最早开始</li>\n<li>最晚开始</li>\n<li>最早完成</li>\n<li>最晚完成</li>\n</ul>\n<h3> 17.活动最早开始时间是箭尾结点的最早完成时间</h3>\n<h3> 18.活动最迟完成时间是箭头结点的最晚完成时间</h3>\n<h3> 19.最迟开始时间等于他的最迟完成时间减去所需作业时间</h3>\n<h3> 20.表格技计算法</h3>\n<h3> 21.时差为0的点就是关键结点,关键结点从起点到终点合起来就是关键线路</h3>\n<h3> 22.总时差:后大 - 前小 - 作业时间</h3>\n<h3> 23.专用时差:后小 - 前大 - 作业时间</h3>\n<figure><figcaption>img_167.png</figcaption></figure>\n<h3> 24.局部时差:只耽误一边</h3>\n<h3> 25.两个关键结点之间的几个活动连续相接的连线称为线段</h3>\n<h3> 26.线段时差等于线段中各个活动总时差的最长者</h3>\n<figure><figcaption>img_168.png</figcaption></figure>\n<h3> 27.线路时差等于各个线段时差之和</h3>\n<h3> 28.时间优化目的</h3>\n<ul>\n<li>周期最短</li>\n<li>成本最低</li>\n</ul>\n<h3> 29.网络计划优化的内容有已下三个</h3>\n<ul>\n<li>时间优化</li>\n<li>时间与资源优化</li>\n<li>时间与成本优化</li>\n<li>没有单纯的资源优化或成本优化</li>\n</ul>\n<h3> 30.缩短工程周期的方法主要有</h3>\n<ul>\n<li>技术革新</li>\n<li>做好管理工作</li>\n<li>采用标准件,通用件</li>\n<li>组织平行作业</li>\n<li>组织交叉作业</li>\n<li>多班制</li>\n</ul>\n<h3> 31.时间与成本优化</h3>\n<ul>\n<li>费用\n<ul>\n<li>直接费用:材料,直接工人工资,折旧费</li>\n<li>间接费用:管理员工资</li>\n</ul>\n</li>\n<li>时间\n<ul>\n<li>正常时间\n<ul>\n<li>极限费用是完成活动的最低费用</li>\n</ul>\n</li>\n<li>极限时间:加班\n<ul>\n<li>极限时间是完成活动的最短时间</li>\n</ul>\n</li>\n<li>极限费用:加班费</li>\n<li>费用增长与作业时间缩短之间的比率</li>\n</ul>\n</li>\n</ul>\n<h1> 第八章</h1>\n<h3> 1.图的基本概念</h3>\n<ul>\n<li>图的基本要素是:点以及点之间的一些连线</li>\n<li>通常用点表示我们所能要研究的对象</li>\n<li>用线表示对象之间的某种特定关系</li>\n<li>有向线:箭头的线叫</li>\n<li>杈:线旁边表上数</li>\n</ul>\n<h3> 2.连通图是网络图中所有的点相互连通(城市道路,下水道)</h3>\n<h3> 3.最小枝杈树问题</h3>\n<ul>\n<li>长度最短的连通图\n<ul>\n<li>(从起点出发到所有点,全部支线的总长度最小)</li>\n</ul>\n</li>\n<li>解决方案\n<ul>\n<li>普赖姆法</li>\n<li>克鲁斯咯尔法</li>\n</ul>\n</li>\n</ul>\n<h3> 4.特殊的图:连通,但不含圈,称之为树(树的树线等于点数减一)</h3>\n<h3> 5.任何不连通图都不是树</h3>\n<h3> 6.最短连通图</h3>\n<h3> 7.最短路线问题</h3>\n<ul>\n<li>寻找从入口到出口所需的最少时间,最短时间或最少费用的路径问题,称做网络的路线问题</li>\n</ul>\n<h3> 8.最大流量问题</h3>\n<ul>\n<li>当物体,能量或信息作为流量流过网络时,怎样使流过网络的流量最大</li>\n<li>或者使流过的流量的费用或时间最小</li>\n<li>设计这样的流量模型问题,叫做网络的流量问题</li>\n<li>最大流量问题是企图找出在一定时期内,能在起点进入,并通过这个网络,在终点输出的最大流量</li>\n<li>找到完全不同的路线,则最大流量(大于或等于)至少是这几条路线流量之和</li>\n<li>起点相邻的结点流量之和,就是最多的流量(小于或等于)</li>\n</ul>\n<h1> 第九章</h1>\n<h3> 1.马尔柯夫分析的数学原理</h3>\n<ul>\n<li>概率向量:任意一个向量,如果它内部的各个元素为非负数,且总和等于1,则此向量称为概率向量</li>\n<li>一个方阵中,如果其各行都是概率向量,则此方阵称之为概率矩阵或概率方阵</li>\n<li>只要有负数就不是概率向量,如果没有负数,每行累加起来都等于1</li>\n</ul>\n<h3> 3.20世纪初马尔可夫发现未来的发展或演变,往往受现状所支配</h3>\n<h3> 4.转换概率:一种状况转另一种状况,依据紧接的前项情况推算出来,这个过程又叫马尔柯夫过程(就是某个销售者保持/获得/失去的消费者的概率)</h3>\n<h3> 5.马尔柯夫锁链:一连串的马尔柯夫转换过程的整体</h3>\n<h3> 6.马尔柯夫分析:分析/观察/预测锁链或过程的未来变动的趋向</h3>\n<h3> 7.转换概率和市场份额和概率矩阵算题</h3>\n<h3> 8.确定平衡条件:经过概率矩阵算出来的市场份额和上一次的市场份额相同</h3>\n<h1> 第十章</h1>\n<h3> 1.盈亏平衡问题概述:企业的盈亏主要取决于企业产品的销售收入和产品的成本费用</h3>\n<h3> 2.利润 = 销售额 - 成本</h3>\n<h3> 3.销售额 = 单价 * 销量</h3>\n<h3> 4.成本 = 固定成本 + 可变成本</h3>\n<h3> 5.盈亏平衡分析是一种管理决策工具,它用来说明在一定销售量水平上总销售额与总成本之间的关系</h3>\n<h3> 6.盈亏平衡点就是企业经营达到了一个点时,总销售额和总成本完全相等(产量 = 销量),利润为0</h3>\n<h3> 7.产品的成本结构:根据成本费用与产品产量的关系分为固定费用(固定成本)和变动费用(可变成本)</h3>\n<ul>\n<li>固定成本:在一定时期内不随企业产量的增减而变化(车间费用和企业管理费等)</li>\n<li>可变成本:随着企业产品产量的增减而变化,一般随着产量的增加,费用总额也成比例的增加(水电费,原材料等)</li>\n<li>成本 = 固定成本 + 可变成本</li>\n</ul>\n<h3> 8.单位可变成本是不变的</h3>\n<h3> 9.半变动费用:燃料动力费</h3>\n<h3> 10.计划性能法:预付成本和计划成本</h3>\n<ul>\n<li>计划成本:达到预期目标所需的费用(广告费),随着产量的变化成阶梯变化</li>\n<li>预付成本:提供的生产能力(设备等),过去发生的行为结果,不受短期管制,在数量变化的过程中保持不变</li>\n</ul>\n<h3> 11.固定成本 = 计划成本 + 预付成本</h3>\n<figure><figcaption>img_172.png</figcaption></figure>\n<h3> 12.盈亏平衡图中,横轴表示产量,竖轴表示费用</h3>\n<figure><figcaption>img_173.png</figcaption></figure>\n<h3> 13.盈亏平衡点:总销售额 等于 总成本</h3>\n<h3> 14.公式总结</h3>\n<ul>\n<li>边际收益 = 单价 - 单位可变成本</li>\n<li>盈亏平衡点 = 固定成本 / 边际收益(当盈亏平衡点时,利润 = 0 或 总收入 = 总成本)</li>\n<li>边际收益率 = 边际收益 / 价格<br>\n</li>\n</ul>\n<h1> 第十一章</h1>\n<h3> 1.概率:销售天数/总销售天数</h3>\n<h3> 2.累计概率:上次累计概率 + 当前概率 = 当前累计概率</h3>\n<h3> 3.概率分布提供了每个可能值的概率,这些概率加起来必须等于1</h3>\n<h3> 4.累计概率随机数:累计概率 * 100 - 1 = 随机数的最大数 || 最小数 = 上一次累计概率 * 100 || 最后一个格子的最大随机数是99</h3>\n<h3> 5.随机变量是是具有各种不同数值的一个变量,这些不同数值是在一次随机试验中,作为各种结果之一而出现的</h3>\n<h3> 6.如果一个随机变量允许在某个给定的范围内具有有限个数的数值,它就是一个离散的随机变量</h3>\n<h3> 7.如果一个随机变量允许在某个给定的范围具有任何个数的数值,它就是一个连续的随机变量</h3>\n<h3> 8.每一个随机变量的数值和相关的某个范围内累计频率序列数相应,这个累计频率数,称之为随机数</h3>\n<h3> 9.蒙特卡洛法是一个模拟技术,他用一系列的随机数创造发分布函数</h3>\n<h3> 10.如果构成模型的关系相当简单,那么就有可能用各种数学的方法,来取得我们感兴趣问题的精确数据,这就是分析解(数学解)</h3>\n<h3> 11.复杂的模型:必须使用模拟的方法来研究</h3>\n<h3> 12.最常用的模拟方法叫:蒙特卡洛方法 使用随机数进行模拟</h3>\n<h3> 13.使用模拟的原因</h3>\n<ul>\n<li>由于难以观察到实际环境,模拟可能是唯一可以利用的方法</li>\n<li>对一个系统的实际运用和观察可能破坏性太大</li>\n<li>实际观察一个可能太费钱</li>\n<li>不可能有足够的时间来广泛地操作该系统</li>\n</ul>\n<h3> 14.模拟地不足之处</h3>\n<ul>\n<li>模拟是不精确的,它既不是一个最优化过程,也不能得到一个答案</li>\n<li>模拟是一种估算答案的时方法,但不能得出答案本身</li>\n<li>并非所有的方法都可用模拟的方法来估算,只有包含不确定因素的环境才能适用,而且如果没有随即元素是,所有的模拟的实验都会产生相同的结果</li>\n<li>一个良好的模拟模型可能是非常昂贵的</li>\n</ul>\n<h3> 15.使用模拟的原因</h3>\n<ul>\n<li>由于难以观察到实际环境,模拟可能是唯一可以利用的方法</li>\n<li>对一个系统的实际运用和观察可能破坏性太大</li>\n<li>实际观察一个系统可能太费钱</li>\n<li>不可能有足够的时间来广泛的操作该系统</li>\n<li>不可能求出一个数学解(分析解)</li>\n</ul>\n<h3> 16.在排队论中,要求顾客到达人数呈普阿松分布</h3>\n<h3> 17.服务时间呈负指数分布</h3>\n",
      "image": "https://img2023.cnblogs.com/blog/2135082/202303/2135082-20230314215503642-1522481382.png",
      "date_published": "2024-04-27T13:52:48.000Z",
      "date_modified": "2024-04-27T13:52:48.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "组件MatLab",
      "url": "https://ujava.cn/assembly/matlab.html",
      "id": "https://ujava.cn/assembly/matlab.html",
      "summary": "1、什么叫计算？ （1）算术运算。“计算”体现的是一种数学技能，这是人类的基本技能。 （2）较复杂的运算，即根据已知量算出未知量。 对于复杂的数值计算问题，可以利用计算机进行问题求解，即利用计算机运算速度快、计算精度高的特点，通过重复执行简单的操作，完成复杂的计算。 广义的理解： “计算”体现的是问题求解的方法和手段。 “计算”是科学研究和工程应用的重要工具。 2、什么是科学计算？ 利用计算机处理数值问题的方法，称为科学计算（ Scientific Computing）。",
      "content_html": "<p>1、什么叫计算？</p>\n<p>（1）算术运算。“计算”体现的是一种数学技能，这是人类的基本技能。</p>\n<p>（2）较复杂的运算，即根据已知量算出未知量。</p>\n<p>对于复杂的数值计算问题，可以利用计算机进行问题求解，即利用计算机<strong>运算速度快、计算精度高的特点</strong>，通过重复执行简单的操作，完成复杂的计算。</p>\n<p>广义的理解：</p>\n<p>“计算”体现的是问题求解的方法和手段。</p>\n<p>“计算”是科学研究和工程应用的重要工具。</p>\n<p>2、什么是科学计算？</p>\n<p>利用计算机处理数值问题的方法，称为科学计算（ Scientific Computing）。</p>\n<p>科学计算方法既有数学理论上的抽象性和严谨性，又有程序设计技术上的实用性和实验性。</p>\n<p>3、科学计算与MATLAB语言的关系</p>\n<p>科学计算的基本步骤是，先研究数值问题的求解算法，然后在计算机上进行程序实现。<br>\n</p>\n<p>MATLAB的优势：不需要过多了解各种数值计算方法的具体细节和计算公式，专注于实际问题的分析和设计，大大地提高工作效率和质量，</p>\n<p>4、MATLAB语言的主要功能</p>\n<p>MATLAB：MATrix LABoratory（矩阵实验室）</p>\n<p>数值计算、符号计算、图形绘制、程序流程控制、工具箱等优势。</p>\n<p>【例子】求x^2-3x+1=0的根。</p>\n<p>方法一：利用MATLAB<strong>多项式求根函数roots</strong>来求根。</p>\n\n<figure><figcaption>img_138.png</figcaption></figure>\n<p>方法二 ： 利用**求单变量非线性方程根的函数fzero，**求方程在某个初始点附近的实根。</p>\n\n<p>方法三：利用**最优化工具箱中的方程求根函数fsolve。</p>\n\n<p>方法四：利用**solve函数求方程的符号解，**即求得的解是一个表达式。</p>\n\n<p>MATLAB系统环境</p>\n<p>需要掌握：</p>\n<ol>\n<li>\n<p>MATLAB系统环境熟知</p>\n</li>\n<li>\n<p>MATLAB系统数值数据掌握</p>\n</li>\n<li>\n<p>MATLAB矩阵表示及引用</p>\n</li>\n<li>\n<p>MATLAB语言的基本运算</p>\n</li>\n<li>\n<p>MATLAB操作界面的组成</p>\n</li>\n</ol>\n<figure><figcaption>img_139.png</figcaption></figure>\n<p>（1）MATLAB主窗口</p>\n<p>功能区（3个）、快速访问工具栏、当前文件夹工具栏</p>\n<p>（2）命令行窗口</p>\n<p>命令行窗口用于输入命令并显示命令的执行结果。</p>\n<blockquote>\n<blockquote>\n<p>命令提示符，可以接受并执行Matlab命令。<br>\n</p>\n</blockquote>\n</blockquote>\n<p>（3）当前文件夹窗口</p>\n<p>运行时的工作文件夹。方便使用和建立。</p>\n<p>如何设置当前文件夹呢？</p>\n<p>（1）在当前文件夹工具栏或当前文件夹窗口中选择某文件夹为当前文件夹</p>\n<p>（2）使用cd命令</p>\n<p>注意：一定要先建立文件夹，再将这个文件夹设为当前文件夹。<br>\n</p>\n<p>（4）工作区窗口</p>\n<p>工作区：也称工作空间，matlab用于存储各种变量和结果的内存空间。</p>\n<p>工作区窗口：用于变量的显示与操作。也可以对变量进行编辑保存和删除等操作。<br>\n</p>\n<ol start=\"2\">\n<li>MATLAB的搜索路径<br>\n</li>\n</ol>\n<p>命令对象操作举例：</p>\n\n<p><strong>变量名优先哦</strong></p>\n<p>如果这时要调用sin函数，该如何操作？</p>\n<p>可以在MATLAB工作区窗口删除定义的sin变量，那么再用sin就代表内部函数了。</p>\n<p><strong>Tip：在定义变量的时候，一般不使用已有特点含义的词，例如内部函数名。</strong></p>\n<p>如何设置文件的搜索路径呢？——直接搜索到用户工作夹下的文件了</p>\n<p>（1）用path命令设置文件搜索路径。例如：</p>\n\n<p>（2）用对话框设置文件搜索路径。</p>\n<p>主页选项卡，环境命令组中的设置路径命令按钮。<br>\n</p>\n<p>常见问题：</p>\n<p>1、如果在当前文件夹和搜索路径文件夹下建立了一个同名的M 文件，那么在命令行窗口输入文件名时，执行哪个文件？</p>\n<p>问题根据MATLAB的搜索路径，程序文件的搜索<strong>顺序是首先在当前文件夹中搜索，然后再在文件搜索路径中的文件夹中搜索，<strong>所以执行的是</strong>当前文件夹下的M文件。</strong></p>\n<p>2、如果用户建立的文件既没有保存在当前文件夹下，也没有保存在文件搜索路径中，那么在命令行窗口输入文件名时，会出现什么信息？</p>\n<p>同样根据MATLAB的搜索路径，如果用户建立的文件既没有保存在当前文件夹下，也没有保存在文件搜索路径中，<strong>那么MATLAB就找不到这个文件，系统会给出错误提示信息。</strong></p>\n",
      "date_published": "2024-04-27T13:33:19.000Z",
      "date_modified": "2024-04-27T13:33:19.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "Java Arrays类",
      "url": "https://ujava.cn/java/arrays.html",
      "id": "https://ujava.cn/java/arrays.html",
      "summary": "在 Java 中，java.util.Arrays类提供的多种数组操作功能，可以有效地执行各种数组相关的操作，使得数组处理变得简单和高效。 打印数组 String[] arr = new String[] {\"a\", \"b\", \"c\", \"d\"}; System.out.println(Arrays.toString(arr)); // 输出 [a, b, c, d]",
      "content_html": "<p>在 Java 中，<code>java.util.Arrays</code>类提供的多种数组操作功能，可以有效地执行各种数组相关的操作，使得数组处理变得简单和高效。</p>\n<h2> 打印数组</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Arrays.toString(arr)</code>，不过是简单的一个调用，却让你的数组输出从一串地址，变成了清晰可辨的字符。</p>\n<h2> 复制数组</h2>\n<p>要复制一个新的数组么？<code>copyOf</code>&nbsp;和&nbsp;<code>copyOfRange</code>&nbsp;给你全方位的选择：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这&nbsp;<code>copyOf</code>，<code>copyOfRange</code>，无异于为数组之尺，想要复制前 N 个元素，使用&nbsp;<code>copyOf</code>，想要取其中一段，使用&nbsp;<code>copyOfRange</code>。</p>\n<blockquote>\n<p>注意：若范围大于原数组，多出位置以 null 填充。</p>\n</blockquote>\n<h2> 填充数组</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如若数组空空如也，可用&nbsp;<code>Arrays.fill(arr, \"str\")</code>&nbsp;将它填满。每一个元素，都被赋予相同的值。</p>\n<p>也可以使用&nbsp;<code>Arrays.setAll</code>&nbsp;填充，它允许传入一个函数，生成填充值。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组比较</h2>\n<p>数据比较有两种方式，一是使用&nbsp;<code>Arrays.equals</code>，二是使用&nbsp;<code>Arrays.hashCode</code>。</p>\n<h3> Arrays.equals</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是一维数组比较，直接&nbsp;<code>Arrays.equals</code>&nbsp;比较没有问题。如果是多维数组，<code>Arrays.equals</code>&nbsp;并不会比较子数组中的元素值，此时需要使用<code>deepEquals</code>&nbsp;比较。</p>\n<h3> Arrays.hashCode</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>元素可能会变，如何捕捉这一瞬间的改变？<code>hashCode()</code>，<code>deepHashCode()</code>，便是这捕风捉影的法宝。<code>hashCode</code>&nbsp;方法会根据数组元素值计算出一个数字，如果元素值发生改变，则数字改变。但是同样对于多维数字，在计算数字时不会计算子数组中的元素，这种情况应该使用&nbsp;<code>deepHashCode</code>判断。</p>\n<p>输出：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组排序</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Arrays.sort</code>&nbsp;方法可以将元素排序。而&nbsp;<code>parallelSort()</code>可以并发排序，但是在数据量比较小的情况下，<code>Arrays.sort</code>&nbsp;可能效率更高。</p>\n<h2> 二分查找</h2>\n<p>二分搜索可以快速找到数组中的指定元素的利器。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>注意事项：使用&nbsp;<code>binarySearch()</code>&nbsp;前确保数组是排序过的，否则结果将不可预知。</p>\n</blockquote>\n<h2> 数组转 Stream</h2>\n<p>Java 8 引入的 Stream API 让数组操作更加现代化，可以链式操作。使用&nbsp;<code>Arrays.stream</code>&nbsp;可以让数组共享这一便利。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 数组转换</h2>\n<p>如果你想把数组转成 List 怎么办？<code>Arrays.asList()</code>&nbsp;就是你需要的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>注意事项：<code>asList()</code>&nbsp;返回的列表<strong>不支持增删操作</strong>，它和原始数组是共享数据的。</p>\n<h2> 并行前缀计算</h2>\n<p>使用&nbsp;<code>parallelPrefix</code>&nbsp;函数并行地累积给定数组中的每个元素。对于大型数组，并行前缀计算通常比顺序循环更有效。</p>\n<p>示例：每一个元素转换成当前以及之前所有元素的和。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>输出：<code>[0, 1, 3, 6, 10, 15, 21, 28, 36, 45]</code></p>\n",
      "date_published": "2024-04-27T01:32:45.000Z",
      "date_modified": "2024-04-27T01:32:45.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java CollectionUtils类",
      "url": "https://ujava.cn/java/collectionutils.html",
      "id": "https://ujava.cn/java/collectionutils.html",
      "content_html": "",
      "date_published": "2024-04-27T01:32:45.000Z",
      "date_modified": "2024-04-27T01:32:45.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Interceptor、Filter、AOP区别",
      "url": "https://ujava.cn/synthesis/interceptorfilter.html",
      "id": "https://ujava.cn/synthesis/interceptorfilter.html",
      "summary": "Filter过滤器 过滤器拦截web访问url地址。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用Java的回调机制进行实现。 Filter过滤器：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。 过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)，并对请求响应做出像响应的过滤操作， 比如设置字符编码，鉴权操作等",
      "content_html": "<h2> Filter过滤器</h2>\n<blockquote>\n<ul>\n<li><strong>过滤器拦截web访问url地址</strong>。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用<strong>Java的回调机制</strong>进行实现。</li>\n<li>Filter<strong>过滤器</strong>：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li>\n<li><strong>过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)</strong>，并对请求响应做出像响应的过滤操作，</li>\n<li>比如<strong>设置字符编码，鉴权操作</strong>等</li>\n</ul>\n</blockquote>\n<h2> Interceptor拦截器</h2>\n<blockquote>\n<ul>\n<li><strong>拦截器拦截以 .action结尾的url，拦截Action的访问</strong>。 Interfactor是基于<strong>Java的反射机制</strong>（APO思想）进行实现，不依赖Servlet容器。</li>\n<li><strong>拦截器可以在方法执行之前(preHandle)和方法执行之后(afterCompletion)进行操作，回调操作(postHandle)</strong>，<strong>可以获取执行的方法的名称</strong>，请求(HttpServletRequest)</li>\n<li>Interceptor：<strong>可以控制请求的控制器和方法</strong>，但<strong>控制不了请求方法里的参数(只能获取参数的名称，不能获取到参数的值)</strong></li>\n<li>**（**用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等）。</li>\n</ul>\n</blockquote>\n<h2> Spring AOP拦截器</h2>\n<blockquote>\n<ul>\n<li>\n<p><strong>只能拦截Spring管理Bean的访问（业务层Service）</strong>。 具体AOP详情参照&nbsp;<a href=\"https://blog.csdn.net/fly910905/article/details/84025425\" target=\"_blank\" rel=\"noopener noreferrer\">Spring AOP：原理、 通知、连接点、切点、切面、表达式</a></p>\n</li>\n<li>\n<p>实际开发中，AOP常和事务结合：<a href=\"https://blog.csdn.net/fly910905/article/details/83547744\" target=\"_blank\" rel=\"noopener noreferrer\">Spring的事务管理:声明式事务管理(切面)</a></p>\n</li>\n<li>\n<p><strong>AOP操作可以对操作进行横向的拦截</strong>，最大的优势在于他可<strong>以获取执行方法的参数( ProceedingJoinPoint.getArgs() )</strong>，对方法进行统一的处理。</p>\n</li>\n<li>\n<p>Aspect : 可以自定义切入的点，有方法的参数，<strong>但是拿不到http请求，可以通过其他方式如RequestContextHolder</strong>获得(</p>\n<div class=\"language-cobol line-numbers-mode\" data-ext=\"cobol\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>)。</p>\n</li>\n<li>\n<p>常见<strong>使用日志，事务，请求参数安全验证</strong>等</p>\n</li>\n</ul>\n</blockquote>\n<h3> Spring对AOP的支持</h3>\n<p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。</p>\n<blockquote>\n<p>Spring创建代理的规则为：<br>\n1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了<br>\n2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB</p>\n</blockquote>\n<p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</p>\n<blockquote>\n<p>1、定义普通业务组件<br>\n2、定义切入点，一个切入点可能横切多个业务组件<br>\n3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</p>\n</blockquote>\n<ul>\n<li>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，</li>\n<li>即：代理对象的方法=增强处理+被代理对象的方法。</li>\n</ul>\n<h2> Filter与Interceptor联系与区别</h2>\n<blockquote>\n<ul>\n<li>拦截器是基于java的反射机制，使用代理模式，而过滤器是基于函数回调。</li>\n<li>拦截器不依赖servlet容器，过滤器依赖于servlet容器。</li>\n<li>拦截器只能对action起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。</li>\n<li>拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。</li>\n<li>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</li>\n</ul>\n</blockquote>\n<p>从上面对拦截器与过滤器的描述来看，它俩是非常相似的，都能对客户端发来的请求进行处理，它们的区别如下：</p>\n<ul>\n<li><strong>作用域不同</strong>\n<ul>\n<li>过滤器依赖于servlet容器，只能在 servlet容器，web环境下使用</li>\n<li>拦截器依赖于spring容器，可以在spring容器中调用，不管此时Spring处于什么环境</li>\n</ul>\n</li>\n<li><strong>细粒度的不同</strong>\n<ul>\n<li>过滤器的控制比较粗，只能在请求进来时进行处理，对请求和响应进行包装</li>\n<li>拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，也可以在渲染视图呈现给用户之后调用</li>\n</ul>\n</li>\n<li><strong>中断链执行的难易程度不同</strong>\n<ul>\n<li>拦截器可以&nbsp;<code>preHandle</code>方法内返回 false 进行中断</li>\n<li>过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面</li>\n</ul>\n</li>\n</ul>\n<h3> 小结</h3>\n<p>简单总结一下，拦截器相比过滤器有更细粒度的控制，依赖于Spring容器，可以在请求之前或之后启动，过滤器主要依赖于servlet，过滤器能做的，拦截器基本上都能做。</p>\n<h2> Filter、Interceptor、aop拦截方向和抛出异常方向图</h2>\n<figure><figcaption>img_147.png</figcaption></figure>\n",
      "date_published": "2024-04-25T03:33:51.000Z",
      "date_modified": "2024-04-25T03:33:51.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "Future和CompletableFuture的区别",
      "url": "https://ujava.cn/java/future.html",
      "id": "https://ujava.cn/java/future.html",
      "summary": "1.Future 在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现Runnable接口，就可以让线程池去执行： class Task implements Runnable { public String result; public void run() { this.result = longTimeCalculation(); } }",
      "content_html": "<h1> 1.Future</h1>\n<p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现<code>Runnable</code>接口，就可以让线程池去执行：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>\n<p>现在的问题是，如何获得异步执行的结果？</p>\n<p>如果仔细看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当我们提交一个<code>Callable</code>任务后，我们会同时获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用<code>Future</code>对象的<code>get()</code>方法，就可以获得异步执行的结果。在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>\n<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>\n<ul>\n<li><code>get()</code>：获取结果（可能会等待）</li>\n<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>\n<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>\n<li><code>isDone()</code>：判断任务是否已完成。</li>\n</ul>\n<h3> 小结</h3>\n<p>对线程池提交一个<code>Callable</code>任务，可以获得一个<code>Future</code>对象；</p>\n<p>可以用<code>Future</code>在将来某个时刻获取结果。</p>\n<h1> 2.CompletableFuture</h1>\n<p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会*等待。</p>\n<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>\n<p>我们以获取股票价格为例，看看如何使用<code>CompletableFuture</code>：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>price: 7.468336731107743</p>\n<p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里我们用lambda语法简化了一下，直接传入<code>Main::fetchPrice</code>，因为<code>Main.fetchPrice()</code>静态方法的签名符合<code>Supplier</code>接口的定义（除了方法名外）。</p>\n<p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这里我们都用lambda语法简化了代码。</p>\n<p>可见<code>CompletableFuture</code>的优点是：</p>\n<ul>\n<li>异步任务结束时，会自动回调某个对象的方法；</li>\n<li>异步任务出错时，会自动回调某个对象的方法；</li>\n<li>主线程设置好回调后，不再关心异步任务的执行。</li>\n</ul>\n<p>如果只是实现了异步回调机制，我们还看不出<code>CompletableFuture</code>相比<code>Future</code>的优势。<code>CompletableFuture</code>更强大的功能是，多个<code>CompletableFuture</code>可以串行执行，例如，定义两个<code>CompletableFuture</code>，第一个<code>CompletableFuture</code>根据证券名称查询证券代码，第二个<code>CompletableFuture</code>根据证券代码查询证券价格，这两个<code>CompletableFuture</code>实现串行操作如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>price: 21.019102834733275</p>\n<p>除了串行执行外，多个<code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p>\n<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上述逻辑实现的异步查询规则实际上是：</p>\n<div class=\"language-ascii line-numbers-mode\" data-ext=\"ascii\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>\n<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>\n<ul>\n<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>\n<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>\n</ul>\n<h3> 小结</h3>\n<p><code>CompletableFuture</code>可以指定异步处理流程：</p>\n<ul>\n<li><code>thenAccept()</code>处理正常结果；</li>\n<li><code>exceptional()</code>处理异常结果；</li>\n<li><code>thenApplyAsync()</code>用于串行化另一个<code>CompletableFuture</code>；</li>\n<li><code>anyOf()</code>和<code>allOf()</code>用于并行化多个<code>CompletableFuture</code>。</li>\n</ul>\n",
      "date_published": "2024-04-25T01:39:12.000Z",
      "date_modified": "2024-04-25T01:39:12.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "组件MyBatis",
      "url": "https://ujava.cn/assembly/mybatis.html",
      "id": "https://ujava.cn/assembly/mybatis.html",
      "content_html": "",
      "date_published": "2024-04-24T02:36:00.000Z",
      "date_modified": "2024-04-24T02:36:00.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "MySQL死锁SQL",
      "url": "https://ujava.cn/synthesis/mysqllocksql.html",
      "id": "https://ujava.cn/synthesis/mysqllocksql.html",
      "summary": "在MySQL中，死锁通常发生在多个事务相互占用对方需要的资源，导致每个事务都在等待其他事务释放资源时无法向前推进。 解决死锁问题通常需要调整事务的隔离级别、保持事务尽可能短、避免事务中的锁竞争、使用索引来加快查询速度，并确保应用程序能够处理事务回滚。 以下是一个简单的例子，演示如何通过索引来减少死锁的可能性： 假设有两个表&nbsp;orders&nbsp;和&nbsp;inventory，以下SQL可能导致死锁： -- 事务A BEGIN; UPDATE orders SET status = 'shipped' WHERE order_id = 100; UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 5; COMMIT; -- 事务B BEGIN; UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 5; UPDATE orders SET status = 'shipped' WHERE order_id = 100; COMMIT;",
      "content_html": "<p>在MySQL中，死锁通常发生在多个事务相互占用对方需要的资源，导致每个事务都在等待其他事务释放资源时无法向前推进。</p>\n<p>解决死锁问题通常需要调整事务的隔离级别、保持事务尽可能短、避免事务中的锁竞争、使用索引来加快查询速度，并确保应用程序能够处理事务回滚。</p>\n<p>以下是一个简单的例子，演示如何通过索引来减少死锁的可能性：</p>\n<p>假设有两个表&nbsp;<code>orders</code>&nbsp;和&nbsp;<code>inventory</code>，以下SQL可能导致死锁：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>为了减少死锁的风险，可以确保对于经常出现在一起的操作的字段建立索引：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>索引可以帮助数据库优化查询，并且通常按顺序存储数据，减少了不同事务之间互相锁定对方所需资源的可能性。</p>\n<p>此外，确保事务尽可能小，并尽快提交，也有助于减少死锁的发生。</p>\n",
      "date_published": "2024-04-24T02:36:00.000Z",
      "date_modified": "2024-04-24T02:36:00.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "Java锁机制",
      "url": "https://ujava.cn/java/lock.html",
      "id": "https://ujava.cn/java/lock.html",
      "summary": "Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录： 1. 乐观锁 VS 悲观锁[ 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。",
      "content_html": "<p>Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p>\n<p>Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录：<br>\n</p>\n<h2> 1. 乐观锁 VS 悲观锁[</h2>\n<p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>\n<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>\n<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>\n<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。<br>\n</p>\n<p>根据从上面的概念描述我们可以发现：</p>\n<ul>\n<li>\n<p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p>\n</li>\n<li>\n<p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p>\n</li>\n</ul>\n<p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：<br>\n</p>\n<p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p>\n<p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p>\n<p>CAS算法涉及到三个操作数：</p>\n<ul>\n<li>\n<p>需要读写的内存值 V。</p>\n</li>\n<li>\n<p>进行比较的值 A。</p>\n</li>\n<li>\n<p>要写入的新值 B。</p>\n</li>\n</ul>\n<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<p>之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：<br>\n</p>\n<p>根据定义我们可以看出各属性的作用：</p>\n<ul>\n<li>\n<p>unsafe： 获取并操作内存的数据。</p>\n</li>\n<li>\n<p>valueOffset： 存储value在AtomicInteger中的偏移量。</p>\n</li>\n<li>\n<p>value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。</p>\n</li>\n</ul>\n<p>接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：<br>\n</p>\n<p>根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。</p>\n<p>后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</p>\n<p>CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：</p>\n<p>1.&nbsp;ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。</p>\n<p>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</p>\n<p>2.&nbsp;循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p>\n<p>3.&nbsp;只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</p>\n<p>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p>\n<h2> 2. 自旋锁 VS 适应性自旋锁</h2>\n<p>在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。</p>\n<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>\n<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>\n<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。<br>\n</p>\n<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>\n<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。<br>\n</p>\n<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>\n<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>\n<p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，本文中仅做名词介绍，不做深入讲解，感兴趣的同学可以自行查阅相关资料。</p>\n<h2> 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h2>\n<p>这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。</p>\n<p>首先为什么Synchronized能实现线程同步？</p>\n<p>在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。</p>\n<p>Java对象头</p>\n<p>synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？</p>\n<p>我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>\n<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>\n<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>\n<p>Monitor</p>\n<p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>\n<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>\n<p>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>\n<p>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。</p>\n<p>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>\n<p>通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：<br>\n</p>\n<p>无锁</p>\n<p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p>\n<p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p>\n<p>偏向锁</p>\n<p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p>\n<p>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>\n<p>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。</p>\n<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>\n<p>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p>\n<p>轻量级锁</p>\n<p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。</p>\n<p>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。</p>\n<p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。</p>\n<p>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。</p>\n<p>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p>\n<p>重量级锁</p>\n<p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p>\n<p>整体的锁状态升级流程如下：<br>\n</p>\n<p>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>\n<h2> 4. 公平锁 VS 非公平锁</h2>\n<p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>\n<p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>\n<p>直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。<br>\n</p>\n<p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>\n<p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：<br>\n</p>\n<p>接下来我们通过ReentrantLock的源码来讲解公平锁和非公平锁。<br>\n</p>\n<p>根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>\n<p>下面我们来看一下公平锁与非公平锁的加锁方法的源码:<br>\n</p>\n<p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。<br>\n</p>\n<p>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p>\n<p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>\n<h2> 5. 可重入锁 VS 非可重入锁</h2>\n<p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：<br>\n</p>\n<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p>\n<p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>\n<p>而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。</p>\n<p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。<br>\n</p>\n<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。<br>\n</p>\n<p>之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>\n<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。</p>\n<p>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>\n<p>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。<br>\n</p>\n<h2> 6. 独享锁 VS 共享锁</h2>\n<p>独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。</p>\n<p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p>\n<p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>\n<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>\n<p>下图为ReentrantReadWriteLock的部分源码：<br>\n</p>\n<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。</p>\n<p>在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。</p>\n<p>那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。</p>\n<p>在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。</p>\n<p>在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）。如下图所示：<br>\n</p>\n<p>了解了概念之后我们再来看代码，先看写锁的加锁源码：<br>\n</p>\n<ul>\n<li>\n<p>这段代码首先取到当前锁的个数c，然后再通过c来获取写锁的个数w。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（&nbsp;int w = exclusiveCount(c);&nbsp;），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</p>\n</li>\n<li>\n<p>在取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁（c!=0），则查看当前写锁线程的数目，如果写线程数为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败（涉及到公平锁和非公平锁的实现）。</p>\n</li>\n<li>\n<p>如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</p>\n</li>\n<li>\n<p>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</p>\n</li>\n<li>\n<p>如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功！</p>\n</li>\n</ul>\n<p>tryAcquire()除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。</p>\n<p>因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p>\n<p>接着是读锁的代码：<br>\n</p>\n<p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>\n<p>此时，我们再回头看一下互斥锁ReentrantLock中公平锁和非公平锁的加锁源码：<br>\n</p>\n<p>我们发现在ReentrantLock虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。根据源码所示，当某一个线程调用lock方法获取锁时，如果同步资源没有被其他线程锁住，那么当前线程在使用CAS更新state成功后就会成功抢占该资源。而如果公共资源被占用且不是被当前线程占用，那么就会加锁失败。所以可以确定ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</p>\n",
      "date_published": "2024-04-23T09:31:40.000Z",
      "date_modified": "2024-04-23T09:31:40.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "Java原子类",
      "url": "https://ujava.cn/java/atomic.html",
      "id": "https://ujava.cn/java/atomic.html",
      "summary": "一、原子类简介 1 什么是原子类 Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。原子性的意思是对于一组操作，要么全部执行成功，要么全部执行失败，不能只有其中某几个执行成功。在多线程的情况下能够保证操作&nbsp;不会被中断，从而能保证并发安全 2. 与锁的区别 原子类作用和锁挺像，都可以保证并发情况下的线程安全。但是原子类比锁更具有优势： 粒度更细： 原子变量可以把多线程竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度都要比原子变量的粒度大 效率更高： 通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况",
      "content_html": "<h2> 一、原子类简介</h2>\n<h3> 1 什么是原子类</h3>\n<p>Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。原子性的意思是对于一组操作，要么全部执行成功，要么全部执行失败，不能只有其中某几个执行成功。在多线程的情况下能够保证操作&nbsp;<code>不会被中断</code>，从而能保证并发安全</p>\n<h3> 2. 与锁的区别</h3>\n<p>原子类作用和锁挺像，都可以保证并发情况下的<code>线程安全</code>。但是原子类比锁更<code>具有优势</code>：</p>\n<ul>\n<li>\n<p>粒度更细：</p>\n<p>原子变量可以把多线程竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度都要比原子变量的粒度大</p>\n</li>\n<li>\n<p>效率更高：</p>\n<p>通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况</p>\n</li>\n</ul>\n<h3> 3. 原子类的底层实现</h3>\n<p>目前Java中提供的原子类大部分底层使用了CAS锁（CompareAndSet自旋锁），如AtomicInteger、AtomicLong等；也有使用了分段锁+CAS锁的原子类，如LongAdder等。</p>\n<h3> 4. 原子类种类</h3>\n<p>在JDK中J.U.C包下提供了种类丰富的原子类，以下所示：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Atomic* 基本类型原子类</td>\n<td>AtomicInteger、AtomicLong、AtomicBoolean</td>\n</tr>\n<tr>\n<td>Atomic*Array 数组类型原子类</td>\n<td>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>Atomic*Reference 引用类型原子类</td>\n<td>AtomicReference、AtomicStampedReference、AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>Atomic*FieldUpdater 升级类型原子类</td>\n<td>AtomicIntegerfieldupdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater</td>\n</tr>\n<tr>\n<td>Adder 累加器</td>\n<td>LongAdder、DoubleAdder</td>\n</tr>\n<tr>\n<td>Accumulator 积累器</td>\n<td>LongAccumulator、DoubleAccumulator</td>\n</tr>\n</tbody>\n</table>\n<h2> 二、原子类使用案例</h2>\n<h3> 1. Atomic* 基本类型原子类</h3>\n<p>这里以 AtomicInteger 为例，下面是 AtomicInteger常用方法 ，其他的两种AtomicLong、AtomicBoolean和它相似：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public final int get()</td>\n<td>获取当前的值</td>\n</tr>\n<tr>\n<td>public final int getAndSet(int newValue)</td>\n<td>获取当前的值，并设置新的值</td>\n</tr>\n<tr>\n<td>public final int getAndIncrement()</td>\n<td>获取当前的值，并自增+1</td>\n</tr>\n<tr>\n<td>public final int getAndDecrement()</td>\n<td>获取当前的值，并自减-1</td>\n</tr>\n<tr>\n<td>public final int getAndAdd(int delta)</td>\n<td>获取当前的值，并加上预期的值。getAndIncrement和getAndDecrement不满足，可使用当前方法</td>\n</tr>\n<tr>\n<td>boolean compareAndSet(int expect, int update)</td>\n<td>如果输入的数值等于预期值，则以原子方式将该值更新为输入值（update）</td>\n</tr>\n</tbody>\n</table>\n<p>代码演示：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_25.png</figcaption></figure>\n<p>以上截图可以看出，普通基本类型由于多线程冲突，导致累加结果不准确，但是如果使用<code>synchronized</code>修饰普通变量的自增，那么就和原子变量atomicInteger 的数据结果一致了，如下</p>\n<div class=\"language-cpp line-numbers-mode\" data-ext=\"cpp\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_26.png</figcaption></figure>\n<h3> 2. Atomic*Array数组类型原子类</h3>\n<p>代码演示：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_27.png</figcaption></figure>\n<p>长度为1000的数组，使用100个线程执行自增，100个线程执行自减，执行完毕后，数组内的所有元素的值均为0，可见，AtomicIntegerArray的每一个元素的操作都是原子性的。</p>\n<h3> 3. Atomic*Reference引用类型原子类</h3>\n<p>代码演示如下，这是一个实现自旋锁的例子，该例子出自&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NDgyMTIxMw==&amp;mid=2247484834&amp;idx=1&amp;sn=21a528f8abdfca34c1759f778f69eb2c&amp;chksm=fd2dc390ca5a4a868e2f15126ae9fc87df6db082dc51b7c13d6b7042e5b07a1263631300f46c#rd\" target=\"_blank\" rel=\"noopener noreferrer\">Java并发之 Lock 锁</a>：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_28.png</figcaption></figure>\n<p>其中，compareAndSet() 方法的源码如下：<br>\n</p>\n<h3> 4. Atomic*FieldUpdater 升级类型原子类</h3>\n<p>以AtomicIntegerFieldUpdater 为例，&nbsp;<code>AtomicIntegerFieldUpdater</code>可以对普通变量进行<code>升级</code>。</p>\n<p><strong>使用场景</strong></p>\n<ul>\n<li>这个普通变量，只偶尔需要一个原子get/set操作（如晚上某个时刻他存在大量并发修改，其他时刻就正常）</li>\n<li>这个变量是其他人定义的，我们无权将他定义为原子类型，只能对他进行临时升级</li>\n</ul>\n<p><strong>代码演示</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_30.png</figcaption></figure>\n<p>被升级的变量有两个<strong>限制</strong>：</p>\n<ul>\n<li>不支持<code>被static修饰</code>的变量</li>\n<li>可见范围，<code>由public修饰的变量</code>，private不行</li>\n</ul>\n<h2> 三、Adder累加器</h2>\n<p>这里以 LongAdder 为例，</p>\n<h3> 1. LongAdder 简介：</h3>\n<ul>\n<li>Java8引入</li>\n<li>高并发下LongAdder比AtomicLong<code>效率高</code>，本质还是<code>空间换时间</code></li>\n<li>竞争激烈的情况下，LongAdder会把不同线程对应到不同的Cell上进行修改，降低冲突的概率，是<code>多段锁</code>的理念，提高了并发性</li>\n</ul>\n<h3> 2. 代码演示</h3>\n<p>对比AddderLong &amp; AtomicLong的高并发性能：</p>\n<h4> （1）AtomicLong，20个线程并发，每个线程执行10000次</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_31.png</figcaption></figure>\n<h4> (2) LongAdder，20个线程并发，每个线程执行10000次</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><br>\n通过两个代码的耗时对比，可以得出结论：在多线程的情况下，LongAdder比AtomicLong的性能更好</p>\n<h3> 3. LongAdder 高并发性能好的原因</h3>\n<h4> （1）<strong>AtomicLong</strong></h4>\n<p>AtomicLong每次执行加法，都需要flush和refresh，导致消耗资源更多。<br>\n</p>\n<h4> （2）<strong>LongAdder</strong></h4>\n<p>LongAdder中，每个线程他自己有<code>独立的计数器</code>，只有在执行&nbsp;<code>sum()</code>方法时才会将各个线程德计数器汇总<br>\n</p>\n<p>LongAdder引入了分段累加的概念，内部有一个base变量和一个Cell[] 数组共同参与计数:</p>\n<ul>\n<li>base变量：在竞争不激烈的时候，加法运算会直接累加到该变量上</li>\n<li>Cel[]数组：在竞争激烈的时候，LongAdder内部的&nbsp;<code>Cell[]</code>数组就会派上用场，各个线程都会有一个对应的<code>Cell[i]</code>,计数的结果会存到各自的<code>Cell[i]</code>中.</li>\n<li>在执行<code>sum</code>方法时，会将 base变量和 Cel[]数组中的结果都汇总。<br>\n</li>\n</ul>\n<p><strong>sum() 源码如下</strong></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>上面源码中会判断，如果as变量不为null 也就是cell[]数组中有值，就会对<code>Cell[]</code>和<code>base</code>一起相加后返回最后的结果</p>\n<blockquote>\n<p>上面的源码看出，这个方法没有加锁，也就是说如果之前已经汇总了的数组元素发生了变动，他就不会实时的反映在最终返回的sum总和中，也就是说<code>返回的sum结果可能不是最新的值</code></p>\n</blockquote>\n<h4> （3）AtomicLong &amp; LongAdder对比</h4>\n<p>LongAdder的特点：</p>\n<ul>\n<li>消耗更多的空间；</li>\n<li>在高并发的情况下性能更好；</li>\n<li>适用于统计求和计数场景；</li>\n<li>类方法相对较少</li>\n</ul>\n<p>在低争用下，AtomicLong和LongAdder这两个类的性能差不多。但是在竞争激烈的情况下，LongAdder的预期吞吐量要高得多，但要消耗更多的空间；</p>\n<p>LongAdder适合的场景是统计求和计数的场景，而且LongAdder基本只提供了加法，而AtomicLong还具有&nbsp;<a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NDgyMTIxMw==&amp;mid=2247484848&amp;idx=1&amp;sn=2af8f0a333f8f87c053fc7c5e067ce24&amp;chksm=fd2dc382ca5a4a943f3869625f06af461d97cd7613ea4bb39867a40c4fee0e68557a32c6a3c6#rd\" target=\"_blank\" rel=\"noopener noreferrer\">CAS</a>&nbsp;方法</p>\n<h2> 四. Accumulator累加器</h2>\n<p>Accumulator 和 Adder 非常相似，实际上 Accumulator 就是一个更通用版本的 Adder，比如 LongAccumulator 是 LongAdder 的功能增强版，因为 LongAdder 的 API 只有对数值的加减，而 LongAccumulator 提供了自定义的函数操作。</p>\n<h3> 1. 基本用法演示</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_36.png</figcaption></figure>\n<h3> 2. 灵活使用</h3>\n<p>自定义表达式：&nbsp;<em>求1加到9中最大的数</em></p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_37.png</figcaption></figure>\n<h3> 3.&nbsp;<strong>使用场景</strong>：</h3>\n<p>并行计算，且不要求计算有顺序，也就是即使执行顺序不同，结果依然一样的情况。比如以下场景：</p>\n<ul>\n<li>相加</li>\n<li>相乘</li>\n<li>最大值、最小值</li>\n</ul>\n",
      "date_published": "2024-04-23T07:07:33.000Z",
      "date_modified": "2024-04-23T07:07:33.000Z",
      "authors": [],
      "tags": [
        "Java"
      ]
    },
    {
      "title": "组件Hystrix",
      "url": "https://ujava.cn/assembly/hystrix.html",
      "id": "https://ujava.cn/assembly/hystrix.html",
      "summary": "为什么需要容错限流 复杂分布式系统通常有很多依赖，如果一个应用不能对来自依赖 故障进行隔离，那么应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，将会在数秒内导致 所有应用资源被耗尽（一个臭鸡蛋影响一篮筐）。 如秒杀、抢购、双十一等场景，在某一时间点会有爆发式的网络流量涌入，如果没有好的网络流量限制，任由流量压到后台服务实例，很有可能造成资源耗尽，服务无法响应，甚至严重的导致应用崩溃。 Hystrix是什么 Hystrix 能使你的系统在出现依赖服务失效的时候，通过隔离系统所依赖的服务，防止服务级联失败，同时提供失败回退机制，更优雅地应对失效，并使你的系统能更快地从异常中恢复。",
      "content_html": "<h2> 为什么需要容错限流</h2>\n<ul>\n<li>复杂分布式系统通常有很多依赖，如果一个应用不能对来自依赖 故障进行隔离，那么应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，将会在数秒内导致 所有应用资源被耗尽（一个臭鸡蛋影响一篮筐）。</li>\n<li>如秒杀、抢购、双十一等场景，在某一时间点会有爆发式的网络流量涌入，如果没有好的网络流量限制，任由流量压到后台服务实例，很有可能造成资源耗尽，服务无法响应，甚至严重的导致应用崩溃。</li>\n</ul>\n<h2> Hystrix是什么</h2>\n<p>Hystrix 能使你的系统在出现依赖服务失效的时候，通过隔离系统所依赖的服务，防止服务级联失败，同时提供失败回退机制，更优雅地应对失效，并使你的系统能更快地从异常中恢复。</p>\n<h2> Hystrix能做什么</h2>\n<ul>\n<li>在通过第三方客户端访问（通常是通过网络）依赖服务出现高延迟或者失败时，为系统提供保护和控制</li>\n<li>在分布式系统中防止级联失败</li>\n<li>快速失败（Fail fast）同时能快速恢复</li>\n<li>提供失败回退（Fallback）和优雅的服务降级机制</li>\n<li>提供近似实时的监控、报警和运维控制手段</li>\n</ul>\n<h2> Hystrix设计原则</h2>\n<ul>\n<li>防止单个依赖耗尽容器（例如 Tomcat）内所有用户线程</li>\n<li>降低系统负载，对无法及时处理的请求快速失败（fail fast）而不是排队</li>\n<li>提供失败回退，以在必要时让失效对用户透明化</li>\n<li>使用隔离机制（例如『舱壁』/『泳道』模式，熔断器模式等）降低依赖服务对整个系统的影响</li>\n<li>针对系统服务的度量、监控和报警，提供优化以满足近似实时性的要求</li>\n<li>在 Hystrix 绝大部分需要动态调整配置并快速部署到所有应用方面，提供优化以满足快速恢复的要求</li>\n<li>能保护应用不受依赖服务的整个执行过程中失败的影响，而不仅仅是网络请求</li>\n</ul>\n<h2> Hystrix设计思想来源</h2>\n<h3> 舱壁隔离模式</h3>\n<p>货船为了进行防止漏水和火灾的扩散,会将货仓分隔为多个，当发生灾害时，将所在货仓进行隔离就可以降低整艘船的风险。<br>\n</p>\n<h3> 断路器模式</h3>\n<p>熔断器就像家里的保险丝，当电流过载了就会跳闸，不过Hystrix的熔断机制相对复杂一些。<br>\n</p>\n<p>熔断器开关由关闭到打开的状态转换是通过当前服务健康状况和设定阈值比较决定的.</p>\n<ul>\n<li>当熔断器开关关闭时，请求被允许通过熔断器。如果当前健康状况高于设定阈值，开关继续保持关闭。如果当前健康状况低于设定阈值，开关则切换为打开状态。</li>\n<li>当熔断器开关打开时，请求被禁止通过。</li>\n<li>当熔断器开关处于打开状态，经过一段时间后，熔断器会自动进入半开状态，这时熔断器只允许一个请求通过。当该请求调用成功时，熔断器恢复到关闭状态。若该请求失败，熔断器继续保持打开状态， 接下来的请求被禁止通过。</li>\n</ul>\n<h2> Hystrix工作流程</h2>\n<h3> 官网原图</h3>\n<figure><figcaption>img_130.png</figcaption></figure>\n<h3> 中文版</h3>\n<figure><figcaption>img_131.png</figcaption></figure>\n<h3> 流程说明</h3>\n<ol>\n<li>每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</li>\n<li>执行execute()/queue做同步或异步调用.</li>\n<li>当前调用是否已被缓存，是则直接返回结果，否则进入步骤 4</li>\n<li>判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤 8,进行降级策略,如果关闭进入步骤 5</li>\n<li>判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤 6</li>\n<li>调用HystrixCommand的run方法.运行依赖逻辑</li>\n</ol>\n<ul>\n<li>6.1. 调用是否出现异常，否：继续，是进入步骤8，</li>\n<li>6.2. 调用是否超时，否：返回调用结果，是进入步骤8</li>\n</ul>\n<ol start=\"7\">\n<li>搜集5、6步骤所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态</li>\n<li>getFallback()降级逻辑.四种触发getFallback调用情况（图中步骤8的箭头来源）：<br>\n返回执行成功结果</li>\n</ol>\n<h2> 两种资源隔离模式</h2>\n<h3> 线程池隔离模式</h3>\n<p>使用一个线程池来存储当前的请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求堆积入线程池队列。这种方式需要为每个依赖的服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理）。</p>\n<h3> 信号量隔离模式</h3>\n<p>使用一个原子计数器（或信号量）来记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃改类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）。</p>\n<h3> 线程池隔离模式 VS 信号量隔离模式</h3>\n<figure><figcaption>img_132.png</figcaption></figure>\n<h2> Hystrix主要配置项</h2>\n<p><br>\n</p>\n<h2> 快速上手</h2>\n<h3> pom.xml</h3>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> HystrixConfig</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> HelloService</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 启动类</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 测试</h3>\n<p>访问 http://localhost:80809/hi?name=zhangsan</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>返回</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div>",
      "date_published": "2024-04-23T01:46:32.000Z",
      "date_modified": "2024-04-23T01:46:32.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Eureka",
      "url": "https://ujava.cn/assembly/eureka.html",
      "id": "https://ujava.cn/assembly/eureka.html",
      "summary": "1.&nbsp; Eureka是什么 Eureka是一个基于REST的服务，主要用于AWS云中的定位服务，以实现中间层服务器的负载平衡和故障转移 在 Spring Cloud&nbsp;微服务架构中通常用作注册中心 我们称这个服务为 Eureka Server，还有一个与之交互的客户端称之为 Eureka Client 2.&nbsp; Eureka高级架构 img_114.png",
      "content_html": "<h2> 1.&nbsp; Eureka是什么</h2>\n<p>Eureka是一个基于REST的服务，主要用于AWS云中的定位服务，以实现中间层服务器的负载平衡和故障转移</p>\n<p>在 Spring Cloud&nbsp;<strong>微服务</strong>架构中通常用作<strong>注册中心</strong></p>\n<p>我们称这个服务为 Eureka Server，还有一个与之交互的客户端称之为 Eureka Client</p>\n<h2> 2.&nbsp; Eureka高级架构</h2>\n<figure><figcaption>img_114.png</figcaption></figure>\n<p>如上图所示，其中</p>\n<p>Application Server 表示服务提供方</p>\n<p>Application Client&nbsp; 表示服务消费方</p>\n<p>Make Remote Call 表示远程调用</p>\n<p>服务在Eureka上注册，然后每隔30秒发送心跳来更新它们的租约。如果客户端不能多次续订租约，那么它将在大约90秒内从服务器注册表中剔除。注册信息和更新被复制到集群中的所有eureka节点。来自任何区域的客户端都可以查找注册表信息（每30秒发生一次）来定位它们的服务（可能在任何区域）并进行远程调用。</p>\n<p>（PS：Eureka Client需要每30秒给Eureka Server发一次心跳，同时更新Server上最新的注册信息到本地，如果Server多次没有收到来自客户端的心跳，那么在90秒内会被Server上剔除）</p>\n<h2> 3.&nbsp; Eureka 客户端与服务器之间的通信</h2>\n<p>服务发现有两种模式：一种是客户端发现模式，一种是服务端发现模式。Eureka采用的是客户端发现模式。</p>\n<p>3.1.&nbsp;&nbsp;Register（注册）</p>\n<p>Eureka客户端将关于运行实例的信息注册到Eureka服务器。注册发生在第一次心跳。</p>\n<p>3.2.&nbsp; Renew（更新 / 续借）</p>\n<p>Eureka客户端需要更新最新注册信息（续借），通过每30秒发送一次心跳。更新通知是为了告诉Eureka服务器实例仍然存活。如果服务器在90秒内没有看到更新，它会将实例从注册表中删除。建议不要更改更新间隔，因为服务器使用该信息来确定客户机与服务器之间的通信是否存在广泛传播的问题。</p>\n<p>3.3.&nbsp;&nbsp;Fetch Registry（抓取注册信息）</p>\n<p>Eureka客户端从服务器获取注册表信息并在本地缓存。之后，客户端使用这些信息来查找其他服务。通过在上一个获取周期和当前获取周期之间获取增量更新，这些信息会定期更新(每30秒更新一次)。获取的时候可能返回相同的实例。Eureka客户端自动处理重复信息。</p>\n<p>3.4.&nbsp; Cancel（取消）</p>\n<p>Eureka客户端在关机时向Eureka服务器发送一个取消请求。这将从服务器的实例注册表中删除实例，从而有效地将实例从流量中取出。</p>\n<h2> 4.&nbsp; Eureka自我保护模式</h2>\n<p>如果 Eureka 服务器检测到超过预期数量的注册客户端以一种不优雅的方式终止了连接，并且同时正在等待被驱逐，那么它们将进入自我保护模式。这样做是为了确保灾难性网络事件不会擦除eureka注册表数据，并将其向下传播到所有客户端。</p>\n<p>任何客户端，如果连续3次心跳更新失败，那么它将被视为非正常终止，病句将被剔除。当超过当前注册实例15%的客户端都处于这种状态，那么自我保护将被开启。</p>\n<p>当自我保护开启以后，eureka服务器将停止剔除所有实例，直到：</p>\n<ol>\n<li>它看到的心跳续借的数量回到了预期的阈值之上，或者</li>\n<li>自我保护被禁用</li>\n</ol>\n<p>默认情况下，自我保护是启用的，并且，默认的阈值是要大于当前注册数量的15%</p>\n<h2> 5.&nbsp; Eureka&nbsp; VS&nbsp; Zookeeper</h2>\n<p>5.1.&nbsp; Eureka保证AP</p>\n<p>Eureka服务器节点之间是对等的，只要有一个节点在，就可以正常提供服务。</p>\n<p>Eureka客户端的所有操作可能需要一段时间才能在Eureka服务器中反映出来，随后在其他Eureka客户端中反映出来。也就是说，客户端获取到的注册信息可能不是最新的，它并不保证强一致性</p>\n<p>5.2.&nbsp; Zookeeper保证CP</p>\n<p>Zookeeper集群中有一个Leader，多个Follower。Leader负责写，Follower负责读，ZK客户端连接到任何一个节点都是一样的，写操作完成以后要同步给所有Follower以后才会返回。如果Leader挂了，那么重新选出新的Leader，在此期间服务不可用。</p>\n<p>5.3.&nbsp; 为什么用Eureka</p>\n<p>分布式系统大都可以归结为两个问题：数据一致性和防止单点故障。而作为注册中心的话，即使在一段时间内不一致，也不会有太大影响，所以在A和C之间选择A是比较适合该场景的。</p>\n",
      "date_published": "2024-04-23T01:11:56.000Z",
      "date_modified": "2024-04-23T01:11:56.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Nocas",
      "url": "https://ujava.cn/assembly/nocas.html",
      "id": "https://ujava.cn/assembly/nocas.html",
      "summary": "1、Nacos概述 1.1、什么是Nacos Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。（英文全称Dynamic Naming and Configuration Service，Na为naming/nameServer即注册中心，co为configuration即配置中心，service是指该注册/配置中心都是以服务为核心。服务在nacos是一等公民） Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。",
      "content_html": "<h2> <strong>1、Nacos概述</strong></h2>\n<h3> <strong>1.1、什么是Nacos</strong></h3>\n<p>Nacos 是阿里巴巴推出来的一个新开源项目，这是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。（英文全称Dynamic Naming and Configuration Service，Na为naming/nameServer即注册中心，co为configuration即配置中心，service是指该注册/配置中心都是以服务为核心。服务在nacos是一等公民）</p>\n<p>Nacos 致力于帮助您<strong>发现、配置和管理微服务</strong>。Nacos 提供了一组简单易用的特性集，帮助您快速实现<strong>动态服务发现、服务配置、服务元数据及流量管理</strong>。</p>\n<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建<strong>以“服务”为中心</strong>的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>\n<p><strong>Nacos 支持如下核心特性：</strong></p>\n<p>**1）服务发现：**支持&nbsp;<strong>DNS 与 RPC 服务发现</strong>，也提供原生 SDK 、OpenAPI 等多种服务注册方式和 DNS、HTTP 与 API 等多种服务发现方式。</p>\n<p>**2）服务健康监测：**Nacos&nbsp;<strong>提供对服务的实时的健康检查</strong>，<strong>阻止向不健康的主机或服务实例发送请求。</strong></p>\n<p><strong>3）动态配置服务：<strong>Nacos 提供</strong>配置统一管理功能</strong>，能够帮助我们<strong>将配置以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置</strong>。</p>\n<p><strong>4）动态 DNS 服务：<strong>Nacos&nbsp;<strong>支持动态 DNS 服务权重路由</strong>，能够让我们</strong>很容易地实现中间层负载均衡、更灵活的路由策略</strong>、流量控制以及数据中心内网的简单 DNS 解析服务。</p>\n<p>**5）服务及其元数据管理：**Nacos&nbsp;<strong>支持从微服务平台建设的视角管理数据中心的所有服务及元数据</strong>，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>\n<h3> <strong>1.2、常见的注册中心</strong></h3>\n<p>Eureka（原生，2.0遇到瓶颈，停止维护）</p>\n<p>Zookeeper（支持，专业的独立产品。例如：dubbo）</p>\n<p>Consul（原生，GO语言开发）</p>\n<p>Nacos</p>\n<p>相对于&nbsp;<strong>Spring Cloud Eureka 来说，Nacos 更强大</strong>。</p>\n<p>Nacos = Spring Cloud Eureka + Spring Cloud Config</p>\n<p>Nacos 可以<strong>与 Spring，Spring Boot，Spring Cloud 集成，并能代替 Spring Cloud Eureka， Spring Cloud Config。</strong></p>\n<ul>\n<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config&nbsp;<strong>实现配置的动态变更</strong>。</li>\n<li>通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery&nbsp;<strong>实现服务的注册与发现</strong>。</li>\n</ul>\n<p><strong>注</strong>：nacos与eureka的区别（简单介绍）</p>\n<p>1）nacos和eureka的范围不同，Nacos的阈值是针对某个具体Service的，而<strong>不是针对所有服务</strong>的；但Eureka的自我保护阈值是针对所有服务的。<strong>nacos支持CP和AP两种；eureka只支持AP</strong>。nacos使用netty，<strong>是长连接</strong>；eureka是<strong>短连接，定时发送</strong>。</p>\n<p>2）Eureka保护方式：当在短时间内，统计续约失败的比例，<strong>如果达到一定阈值，则会触发自我保护的机制</strong>，在该机制下，Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server. enab1e-self-preservation:false)</p>\n<p>Nacos保护方式：<strong>当域名健康实例(Instance)占总服务实例(Instance)的比例小于阈值时</strong>，<strong>无论实例(Instance)是否健康，都会将这个实例(Instance)返回给客户端</strong>。这样做虽然损失了一部分流量，但是保证了集群的剩余健康实例(Instance)能正常工作。</p>\n<h3> <strong>1.3、Nacos结构图</strong></h3>\n<figure><figcaption>img_115.png</figcaption></figure>\n<h3> 1.4、Nacos下载和安装</h3>\n<p><strong>1）软件环境</strong></p>\n<p>Nacos 版本：2.0.4</p>\n<p>mysql版本：5.7</p>\n<p><strong>2）安转步骤</strong></p>\n<p>此处使用docker安转nacos（单节点）</p>\n<p>**注：**注意启动时需要配置这个环境配置&nbsp;<strong>-e MODE=standalone 否则默认启动为占用内存为1G</strong>。</p>\n<blockquote>\n<p>1、先拉取镜像<br>\n命令：docker pull nacos/nacos-server:v2.0.4<br>\n2、运行容器<br>\n命令： docker run --name nacos(容器名称) -d -p 8848(外部访问端口):8848(容器内端口) -p 9848:9848<br>\n-p 9849:9849 --privileged=true --restart=always -e JVM_XMS=256m -e JVM_XMX=256m -e MODE=standalone -e PREFER_HOST_MODE=hostname -v /home/nacos/logs(数据卷主机地址):/home/nacos/logs（数据卷容器内部地址） -v /home/nacos/conf:/home/nacos/conf ea54f31c46e4（容器id）</p>\n</blockquote>\n<p><strong>3）查看容器是否启动</strong></p>\n<p>命令：docker ps<br>\n</p>\n<p><strong>4)查看容器相关日志</strong></p>\n<p>命令：docker logs --since 10m nacos的容器id #查看指定容器的输出日志<br>\n</p>\n<p><strong>注意</strong>：如果查看日志发现报错如下截图<br>\n</p>\n<p>证明缺少日志文件，我们可以在宿主机配置文件目录下添加如下内容</p>\n<p>1）新建文件nacos-logback.xml，在我们宿主机挂载的对应的保存配置文件的目录下，并在下方添加如下配置；</p>\n<p>2）<strong>注意</strong>log.path 中的value配置要和日志数据卷挂载的目录一致</p>\n<div class=\"language-XML line-numbers-mode\" data-ext=\"XML\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>5）进行访问</p>\n<p>本机IP地址：8848/nacos<br>\n</p>\n<p><strong>注</strong>：记得开放对应端口</p>\n<p>登录账号 登录密码</p>\n<p>nacos nacos<br>\n</p>\n<h2> 2、注册服务</h2>\n<h3> 1.1、整合nacos</h3>\n<p>引入依赖</p>\n<div class=\"language-XML line-numbers-mode\" data-ext=\"XML\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在对应模块的配置文件中添加nacos配置</p>\n<div class=\"language-csharp line-numbers-mode\" data-ext=\"cs\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在启动类上添加注解<br>\n</p>\n<h3> 2.2、重启服务，查看</h3>\n<p>重新启动服务，登录nacos页面查看(下图发现服务成功注册上nacos中)<br>\n</p>\n<h2> 3、整合外部的mysql（单节点）</h2>\n<h3> 3.1、建库建表</h3>\n<p>可以直接根据里面的内容创建建表链接</p>\n<p><strong>注</strong>：对应nacos版本建表可能出现的问题<br>\n</p>\n<h3> 3.2、修改数据卷挂载出来的nacos配置</h3>\n<p>进入数据卷保存路面<br>\n此处我们nacos配置保存在宿主机的/home/nacos/conf中<br>\n</p>\n<p>修改下面内容即可<br>\n</p>\n<p>重启 Nacos 即可，验证。</p>\n<p>再次创建相关信息、重启服务之后依然存在。</p>\n<h2> 4、Nacos集群化部署</h2>\n<p>之前我们搭建的nacos是standalone（单节点模式），nacos是支持集群化部署的，<strong>最好使用单数节点进行集群化部署（因为此处会有投票机制）</strong>，此处因为只有两台机器，所以只演示两台机器如何部署</p>\n<h3> 4.1、使用docker，分别在不同的服务器上运行两台nacos容器</h3>\n<p><strong>注意</strong>：2.x版本的nacos需要开放9848 和 9849 端口的映射端口</p>\n<p>下面为示例命令：</p>\n<div class=\"language-cobol line-numbers-mode\" data-ext=\"cobol\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4.2、查看nacos控制台（通过每个节点都可以看到对应信息）</h3>\n<figure><figcaption>img_126.png</figcaption></figure>\n<h3> 4.3、集群简介</h3>\n<p><strong>leader节点</strong>：负责事务型请求（事务型：创建配置、修改配置、删除配置）</p>\n<p><strong>follow节点</strong>：负责读（查询请求）</p>\n<p><strong>宕机情况</strong>：当leader节点宕机时，follow节点进行投票选举出新的leader节点（与传统的redis等不同的是，follow会自动进行重新选举，不需要借助类似于哨兵机制这种机制进行选举）<br>\n</p>\n<h2> 5、可能遇到的问题</h2>\n<p>1、conf无法挂载出来</p>\n<blockquote>\n<p>在使用docker运行时，将容器内的conf挂载出来时，发现并没有对应的配置文件</p>\n</blockquote>\n<p>1）先运行一个测试nacos容器</p>\n<div class=\"language-cobol line-numbers-mode\" data-ext=\"cobol\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>2）将容器内的文件复制出来</p>\n<div class=\"language-ruby line-numbers-mode\" data-ext=\"rb\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3）强制关闭容器</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>4）然后在重新运行，包含数据卷挂载命令的启动命令</p>\n<p><strong>docker运行命令介绍</strong></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>MODE</td>\n<td>系统启动方式: 集群/单机 cluster/standalone</td>\n<td>默认 cluster</td>\n</tr>\n<tr>\n<td>NACOS_SERVERS</td>\n<td>集群地址</td>\n<td>p1:port1空格ip2:port2 空格ip3:port3</td>\n</tr>\n<tr>\n<td>PREFER_HOST_MODE</td>\n<td>支持IP还是域名模式</td>\n<td>hostname/ip 默认 ip</td>\n</tr>\n<tr>\n<td>NACOS_SERVER_PORT</td>\n<td>Nacos 运行端口</td>\n<td>默认 8848</td>\n</tr>\n<tr>\n<td>NACOS_SERVER_IP</td>\n<td>多网卡模式下可以指定IP</td>\n<td></td>\n</tr>\n<tr>\n<td>SPRING_DATASOURCE_PLATFORM</td>\n<td>单机模式下支持MYSQL数据库</td>\n<td>mysql / 空 默认:空</td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_HOST</td>\n<td>数据库 连接地址</td>\n<td></td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_PORT</td>\n<td>数据库端口</td>\n<td>默认 : 3306</td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_DB_NAME</td>\n<td>数据库库名</td>\n<td></td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_USER</td>\n<td>数据库用户名</td>\n<td></td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_PASSWORD</td>\n<td>数据库用户密码</td>\n<td></td>\n</tr>\n<tr>\n<td>MYSQL_SERVICE_DB_PARAM</td>\n<td>数据库连接参数</td>\n<td>default :</td>\n</tr>\n<tr>\n<td>MYSQL_DATABASE_NUM</td>\n<td>数据库编号</td>\n<td>默认 :1</td>\n</tr>\n<tr>\n<td>JVM_XMS</td>\n<td>-Xms</td>\n<td>默认 :1g</td>\n</tr>\n<tr>\n<td>JVM_XMX</td>\n<td>-Xmx</td>\n<td>默认 :1g</td>\n</tr>\n<tr>\n<td>JVM_XMN</td>\n<td>-Xmn</td>\n<td>默认 :512m</td>\n</tr>\n<tr>\n<td>JVM_MS</td>\n<td>-XX:MetaspaceSize</td>\n<td>默认 :128m</td>\n</tr>\n<tr>\n<td>JVM_MMS</td>\n<td>-XX:MaxMetaspaceSize</td>\n<td>默认 :320m</td>\n</tr>\n<tr>\n<td>NACOS_DEBUG</td>\n<td>是否开启远程DEBUG y/n</td>\n<td>默认 :n</td>\n</tr>\n<tr>\n<td>TOMCAT_ACCESSLOG_ENABLED</td>\n<td>server.tomcat.accesslog.enabled</td>\n<td>默认 :false</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_SYSTEM_TYPE</td>\n<td>权限系统类型选择,目前只支持nacos类型</td>\n<td>默认 :nacos</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_ENABLE</td>\n<td>是否开启权限系统</td>\n<td>默认 :false</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_TOKEN_EXPIRE_SECONDS</td>\n<td>token 失效时间</td>\n<td>默认 :18000</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_TOKEN</td>\n<td>token</td>\n<td>默认 :SecretKey012345678901234567890123456789012345678901234567890123456789</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_CACHE_ENABLE</td>\n<td>权限缓存开关 ,开启后权限缓存的更新默认有15秒的延迟</td>\n<td>默认 : false</td>\n</tr>\n<tr>\n<td>MEMBER_LIST</td>\n<td>通过环境变量的方式设置集群地址</td>\n<td>例子:192.168.16.101:8847?raft_port=8807,192.168.16.101?raft_port=8808,192.168.16.101:8849?raft_port=8809</td>\n</tr>\n<tr>\n<td>EMBEDDED_STORAGE</td>\n<td>是否开启集群嵌入式存储模式 embedded</td>\n<td>默认 : none</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_CACHE_ENABLE</td>\n<td>nacos.core.auth.caching.enabled</td>\n<td>default : false</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_USER_AGENT_<br><br>AUTH_WHITE_ENABLE</td>\n<td>nacos.core.auth.enable.userAgentAuthWhite</td>\n<td>default : false</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_IDENTITY_KEY</td>\n<td>nacos.core.auth.server.identity.key</td>\n<td>default : serverIdentity</td>\n</tr>\n<tr>\n<td>NACOS_AUTH_IDENTITY_VALUE</td>\n<td>nacos.core.auth.server.identity.value</td>\n<td>default : security</td>\n</tr>\n<tr>\n<td>NACOS_SECURITY_IGNORE_URLS</td>\n<td>nacos.security.ignore.urls</td>\n<td>default : /,/error,/<strong>/*.css,/</strong>/<em>.js,/**/</em>.html,/<strong>/*.map,/</strong>/<em>.svg,/**/</em>.png,/<strong>/*.ico,/console-fe/public/</strong>,/v1/auth/<strong>,/v1/console/health/</strong>,/actuator/<strong>,/v1/console/server/</strong></td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2024-04-23T01:11:56.000Z",
      "date_modified": "2024-04-23T01:29:32.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Flink",
      "url": "https://ujava.cn/assembly/flink.html",
      "id": "https://ujava.cn/assembly/flink.html",
      "summary": "Flink前言 Flink和spark的功能很相似，spark能做的flink也能做，flink能做的spark也能做； 1、flink和spark本质的区别 flink：侧重于做实时计算 spark：侧重于做离线计算",
      "content_html": "<h4> Flink前言</h4>\n<blockquote>\n<p>Flink和spark的功能很相似，spark能做的flink也能做，flink能做的spark也能做；</p>\n</blockquote>\n<h5> 1、flink和spark本质的区别</h5>\n<div class=\"language-undefined line-numbers-mode\" data-ext=\"undefined\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>实时计算和离线计算的特点<br>\n</li>\n</ul>\n<h5> 2、流处理和批处理</h5>\n<blockquote>\n<p>流处理和批处理：也可以叫做实时计算和离线计算</p>\n</blockquote>\n<div class=\"language-undefined line-numbers-mode\" data-ext=\"undefined\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<p>流处理<br>\n</p>\n</li>\n<li>\n<p>批处理<br>\n</p>\n</li>\n</ul>\n<h5> 3、无界流和有界流</h5>\n<blockquote>\n<p>从一开始不断地有数据过来-----无界流</p>\n<p>有界流可以称为无界流的特例</p>\n</blockquote>\n<div class=\"language-lua line-numbers-mode\" data-ext=\"lua\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><figure><figcaption>img_93.png</figcaption></figure>\n<h5> 4、实时计算需要考虑的问题</h5>\n<div class=\"language-scss line-numbers-mode\" data-ext=\"scss\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> Flink简介</h4>\n<h5> 1、什么是Flink</h5>\n<div class=\"language-scss line-numbers-mode\" data-ext=\"scss\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 2、Flink的特征</h5>\n<blockquote>\n<p>1、可以做批处理（处理历史数据集）<br>\n2、可以做流处理（处理实时数据流）<br>\n3、事件驱动应用（监控事件的服务），spark是时间驱动</p>\n</blockquote>\n<div class=\"language-scss line-numbers-mode\" data-ext=\"scss\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 3、Blink--基于Flink开发的一个分支</h5>\n<div class=\"language-mipsasm line-numbers-mode\" data-ext=\"mipsasm\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h5> 4、Flink技术栈</h5>\n<figure><figcaption>img_94.png</figcaption></figure>\n<p><strong>部署方式：Deploy</strong></p>\n<ul>\n<li>\n<p>Local本地模式<br>\nFlink部署在单个JVM进程上，主要用于调试</p>\n</li>\n<li>\n<p>Cluster集群模式<br>\nStandAlone模式：不依赖第三方资源管理框架，JobManager负责任务调度和资源管理，通过ZK保障高可用性；</p>\n</li>\n</ul>\n<p>​ YARN模式：YARN负责资源管理，JobManager负责任务调度；</p>\n<ul>\n<li>Cloud模式<br>\nFlink上云，发挥云的优势：弹性（快速的硬件升级以及扩容和缩容等），比如Amazon的EC2、Alibaba的ECS等；</li>\n</ul>\n<p><strong>Runtime</strong><br>\n  Flink引擎，负责计算逻辑（流计算和批处理）的执行；</p>\n<p><strong>API &amp; Libraries</strong><br>\n  Flink的目标是批流一体，很可惜API层并没有做到统一。</p>\n<p>​ DataStremAPI为流处理的API，DataSetAPI为批处理的API，以及基于API的各种Libraries，用户在使用时需要 感知流计算和批处理。</p>\n<h5> 5、Flink APIs</h5>\n<figure><figcaption>img_95.png</figcaption></figure>\n<h5> 6、数据流编程模型</h5>\n<figure><figcaption>img_96.png</figcaption></figure>\n<h5> 7、Flink的代码结构</h5>\n<figure><figcaption>img_97.png</figcaption></figure>\n",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-22T01:07:39.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Flume",
      "url": "https://ujava.cn/assembly/flume.html",
      "id": "https://ujava.cn/assembly/flume.html",
      "content_html": "",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-20T07:53:29.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Hadoop",
      "url": "https://ujava.cn/assembly/hadoop.html",
      "id": "https://ujava.cn/assembly/hadoop.html",
      "summary": "1．&nbsp;Hadoop介绍 Hadoop是Apache旗下的一个用java语言实现开源软件框架，是一个开发和运行处理大规模数据的软件平台。允许使用简单的编程模型在大量计算机集群上对大型数据集进行分布式处理。 狭义上说，Hadoop指Apache这款开源框架，它的核心组件有： HDFS（分布式文件系统）：解决海量数据存储 YARN（作业调度和集群资源管理的框架）：解决资源任务调度 MAPREDUCE（分布式运算编程框架）：解决海量数据计算 广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。",
      "content_html": "<h2> 1．&nbsp;Hadoop介绍</h2>\n<p>Hadoop是Apache旗下的一个用java语言实现开源软件框架，是一个开发和运行处理大规模数据的软件平台。允许使用简单的编程模型在大量计算机集群上对大型数据集进行分布式处理。<br>\n</p>\n<p>狭义上说，Hadoop指Apache这款开源框架，它的核心组件有：</p>\n<p>HDFS（分布式文件系统）：解决海量数据存储</p>\n<p>YARN（作业调度和集群资源管理的框架）：解决资源任务调度</p>\n<p>MAPREDUCE（分布式运算编程框架）：解决海量数据计算</p>\n<p>广义上来说，Hadoop通常是指一个更广泛的概念——Hadoop生态圈。<br>\n</p>\n<p>当下的Hadoop已经成长为一个庞大的体系，随着生态系统的成长，新出现的项目越来越多，其中不乏一些非Apache主管的项目，这些项目对HADOOP是很好的补充或者更高层的抽象。比如：</p>\n<p>HDFS：分布式文件系统</p>\n<p>MAPREDUCE：分布式运算程序开发框架</p>\n<p>HIVE：基于HADOOP的分布式数据仓库，提供基于SQL的查询数据操作</p>\n<p>HBASE：基于HADOOP的分布式海量数据库</p>\n<p>ZOOKEEPER：分布式协调服务基础组件</p>\n<p>Mahout：基于mapreduce/spark/flink等分布式运算框架的机器学习算法库</p>\n<p>OOZIE：工作流调度框架</p>\n<p>Sqoop：数据导入导出工具（比如用于mysql和HDFS之间）</p>\n<p>FLUME：日志数据采集框架</p>\n<p>IMPALA：基于hive的实时sql查询分析</p>\n<h2> 2．&nbsp;Hadoop发展简史</h2>\n<p>Hadoop是Apache Lucene创始人&nbsp;Doug Cutting创建的。最早起源于Nutch，它是Lucene的子项目。Nutch的设计目标是构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题：如何解决数十亿网页的存储和索引问题。</p>\n<p>2003年Google发表了一篇论文为该问题提供了可行的解决方案。论文中描述的是谷歌的产品架构，该架构称为：谷歌分布式文件系统（GFS）,可以解决他们在网页爬取和索引过程中产生的超大文件的存储需求。</p>\n<p>2004年&nbsp;Google发表论文向全世界介绍了谷歌版的MapReduce系统。</p>\n<p>同时期，Nutch的开发人员完成了相应的开源实现HDFS和MAPREDUCE，并从Nutch中剥离成为独立项目HADOOP，到2008年1月，HADOOP成为Apache顶级项目，迎来了它的快速发展期。</p>\n<p>2006年Google发表了论文是关于BigTable的，这促使了后来的Hbase的发展。</p>\n<p>因此，Hadoop及其生态圈的发展离不开Google的贡献。</p>\n<h2> 3．&nbsp;Hadoop特性优点</h2>\n<p>扩容能力（Scalable）：Hadoop是在可用的计算机集群间分配数据并完成计算任务的，这些集群可用方便的扩展到数以千计的节点中。</p>\n<p>成本低（Economical）：Hadoop通过普通廉价的机器组成服务器集群来分发以及处理数据，以至于成本很低。</p>\n<p>高效率（Efficient）：通过并发数据，Hadoop可以在节点之间动态并行的移动数据，使得速度非常快。</p>\n<p>可靠性（Rellable）：能自动维护数据的多份复制，并且在任务失败后能自动地重新部署（redeploy）计算任务。所以Hadoop的按位存储和处理数据的能力值得人们信赖。</p>\n<h2> 4．&nbsp;Hadoop国内外应用</h2>\n<p>不管是国内还是国外，Hadoop最受青睐的行业是互联网领域，可以说互联网公司是hadoop的主要使用力量。</p>\n<p>国外来说，Yahoo、Facebook、IBM等公司都大量使用hadoop集群来支撑业务。比如：</p>\n<p>Yahoo的Hadoop应用在支持广告系统、用户行为分析、支持Web搜索等。</p>\n<p>Facebook主要使用Hadoop存储内部日志与多维数据，并以此作为报告、分析和机器学习的数据源。</p>\n<p>国内来说，BAT领头的互联网公司是当仁不让的Hadoop使用者、维护者。比如Ali云梯（14年国内最大Hadoop集群）、百度的日志分析平台、推荐引擎系统等。<br>\n</p>\n<p>国内其他非互联网领域也有不少hadoop的应用，比如：</p>\n<p>金融行业： 个人征信分析</p>\n<p>证券行业： 投资模型分析</p>\n<p>交通行业： 车辆、路况监控分析</p>\n<p>电信行业： 用户上网行为分析</p>\n<p>总之：hadoop并不会跟某种具体的行业或者某个具体的业务挂钩，它只是一种用来做海量数据分析处理的工具。</p>\n<h2> 总结：</h2>\n<h2> Hadoop是什么？</h2>\n<h5> 答：狭义上：是指Apache的一款java语言开发的开源软件，大数据问题处理平台！</h5>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Hadoop HDFS：分布式文件系统，解决海量数据存储问题  <br>Hadoop MapReduce：分布式计算框架，解决海量数据计算问题。  <br>Hadoop YARN：资源管理任务调度系统</td>\n</tr>\n</tbody>\n</table>\n<p>广义上：是指hadoop生态圈，包括了大数据解决各不同步骤的软件</p>\n<p>其中一些非Apache的项目也在其中</p>\n<h2> Hadoop框架组成：</h2>\n<h3> Hadoop框架的组成</h3>\n<blockquote>\n<p>HDFS(Hadoop Distributed File System)，Hadoop分布式文件系统。</p>\n</blockquote>\n<blockquote>\n<p>Map/Reduce分布式计算系统<br>\n</p>\n</blockquote>\n<ul>\n<li>\n<p>1、什么是HDFS分布式文件系统</p>\n<ul>\n<li>HDFS是一个的文件系统，可以创建、移动、删除和重命名文件。</li>\n<li>是一个基于网络的分布式文件系统。</li>\n<li>由多个机器联网组成，其中一台为NameNode，其他的是DataNode。</li>\n<li>NameNode为HDFS提供元数据服务，管理保存在不同节点上的数据信息。</li>\n<li>DataNode管理本节点上的数据。</li>\n<li>NameNode将一个大的数据文件分成多个数据块保存到不同的DataNode节点上，并记录所有数据块所在节点的信息，DataNode管理本节点上的数据块，数据块的大小默认为128M。</li>\n<li>HDFS上NameNode和DataNode通信基于TCP/IP协议</li>\n</ul>\n</li>\n<li>\n<p>2、HDFS(分布式文件系统)</p>\n<ul>\n<li>HDFS分布式文件系统是基于网络的。</li>\n<li>是由多台机器组成的。</li>\n<li>是由一个NameNode和多个DataNode组成，NameNode运行在主服务器上，管理文件系统的命名空间和客户端对文件系统的访问操作。DataNode运行在其他的多台机器上，主要管理数据的存储，包括要分析的数据，历史数据等。</li>\n<li>在主服务器上的NameNode是HDFS分布式文件系统的主守护进程，分布在其他机器上的DataNode从进程定时向主进程NameNode发送报告，报告节点数据和磁盘的情况。NameNode进程向不同的DataNode节点发送指令，要求节点下载数据并管理数据。</li>\n<li><figcaption>img_102.png</figcaption></li>\n</ul>\n</li>\n<li>\n<p>3、什么是MapReduce(分布式计算系统)</p>\n<ul>\n<li>MapReduce是处理数据的编程模型。</li>\n<li>关系数据库可以采用SQL语句对数据进行操作查询。</li>\n<li>MapReduce可以通过Java、C等其他语言对数据进行查询分析。</li>\n<li>MapReduce分为两个阶段，map阶段和reduce阶段，map阶段将原始数据进行过滤操作，以键/值对的方式输出，map阶段的输出是reduce阶段的输入，reduce阶段对数据处理后输出最终的结果。</li>\n<li>MapReduce处理的数据文件保存在HDFS上，并且最终的计算结果同样会保存到HDFS上。</li>\n<li>MapReduce和HDFS相对独立由相互联系。</li>\n</ul>\n</li>\n<li>\n<p>4、MapReduce(分布式计算系统)</p>\n<ul>\n<li>Hadoop1.0版本的MapReduce\n<ul>\n<li>由一个JobTracker和多个TaskTracker组成。 JobTracker运行在主服务器上， TaskTracker运行在集群中的从节点上。</li>\n<li>JobTracker进程负责调度一个作业的所有任务的执行，这些任务会分配到不同的节点上。JobTracker主进程监控所有从节点的TaskTracker进程的作业执行情况，重新执行失败的任务。TaskTracker执行JobTracker指定的任务。当一个Job(数据分析作业)提交时，JobTracker接收到提交的任作业后，将作业执行需要的配置信息和其他数据信息分发给相应的TaskTracker。同时要调度任务并监控TaskTracker的执行。</li>\n<li><figcaption>img_103.png</figcaption></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>5、YARN(分布式计算系统)</p>\n<ul>\n<li>Hadoop2.0版本的MapReduceV2(YARN)</li>\n<li>YARN ( Yet Another Resource Negotiator )\n<ul>\n<li>由一个ResourceManager和多个NodeManager组成。 ResourceManager运行在主服务器上， NodeManager运行在集群中的从节点上。</li>\n<li>ResourceManager是集群所有可用资源的仲裁者。是一个单纯的资源控制器和调度器。主要职责是接收应用程序的资源请求并严格控制系统的可用资源。动态的分配资源。</li>\n<li>NodeManager是集群中每个节点上的管理进程，职责是对节点中的资源进行管理并与ResourceManager保持通信，报告节点的各种状态信息。与ResourceManager共同管理整个集群资源，资源包括内存、CPU等。</li>\n<li><figcaption>img_104.png</figcaption></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>6、Hadoop2.0在Hadoop1.0上的改变</p>\n<ul>\n<li>\n<p>YARN将JobTracker分为两个组件：ResourceManager和ApplicationMaster。ResourceManager作为资源管理和调度不需要关心应用程序的执行和监控。而与应用程序相关的是ApplicationMaster。</p>\n</li>\n<li>\n<figure><figcaption>img_105.png</figcaption></figure>\n</li>\n<li>\n<p>ResourceManager进程运行在主节点上，作为集群资源的管理者和总调度，不在需要关心应用程序的执行和监控。ApplicationMaster进程运行在从节点上，主要管理应用程序的执行和应用程序的生命周期，当应用程序执行结束，ApplicationMaster的生命周期结束。</p>\n</li>\n<li>\n<p>客户端发出应用程序执行请求，ResourceManager会创建与应用程序对应的ApplicationMaster实例。</p>\n</li>\n<li>\n<p>好处是，分工明确，粒度细化和多应用程序的同步执行。</p>\n</li>\n<li>\n<p>不同的应用对应不同的ApplicationMaster。MapReduce计算框架对应相应的ApplicationMaster。不同的计算框架对应不同的ApplicationMaster实现。</p>\n</li>\n<li>\n<p>好处是：职责的分离带来的是扩展性的提升。如：程序在运行阶段发生异常带来的节点任务失败是需要重新启动作业的，这些相关的容错机制在Hadoop1.0是由JobTracker负责的。使得JobTracker成为重量级，代码的维护相当困难，并且框架的耦合度高，功能模块粒度粗。在YARN中这些容错职责由ApplicationMaster担任，实现了容错机制局部化，而不是以往的全局管理。此外需要注意的是应用程序和ResourceManager的分离使ResourceManager轻量化。某个应用的执行不会影响到整个集群。</p>\n</li>\n<li>\n<p>Hadoop2.0和Hadoop1.0的结构图</p>\n</li>\n<li>\n<figure><figcaption>img_106.png</figcaption></figure>\n</li>\n<li>\n<p>不同应用对应不同的ApplicationMaster。只需要增加不同计算框架的ApplicationMaster实现即可实现多种框架使用YARN，如MapReduce、MPI和图计算等。实现上是把所有与应用程序相关的代码都放到ApplicationMaster类中。并提供不同的接口满足不同用户的需求。</p>\n<ul>\n<li><br>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2> hadoop优点及应用：</h2>\n<h4> 优点：</h4>\n<h5> 扩展能力强，使用分布式思想解决海量数据存储问题，使用简单方便，相比较之前的处理方式，效率提高。</h5>\n<h4> 应用：</h4>\n<h5> hadoop精确的区分了what to do(做什么？ 业务) &nbsp;how to do (这么做？技术)</h5>\n<h5> hadoop 提供了大数据存储能力，计算能力，跟具体的行业不会挂钩，通用的大数据解决方案</h5>\n",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-22T05:57:38.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Hbase",
      "url": "https://ujava.cn/assembly/hbase.html",
      "id": "https://ujava.cn/assembly/hbase.html",
      "summary": "简介 Hbase是一种 分布式存储 的数据库，技术上来讲，它更像是分布式存储而不是 分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。 Hbase有如下特性: 强读写一致，但是不是“最终一致性”的 数据存储，这使得它非常适合高速的计算聚合 自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配 自动的故障转移 Hadoop/HDFS集成，和HDFS开箱即用 丰富的“简洁，高效”API，Thrift/REST API，Java API 块缓存，布隆过滤器，可以高效的列查询优化 操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标",
      "content_html": "<h4> 简介</h4>\n<p>Hbase是一种 分布式存储 的数据库，技术上来讲，它更像是分布式存储而不是 分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。</p>\n<p>Hbase有如下特性:</p>\n<ul>\n<li>强读写一致，但是不是“最终一致性”的 数据存储，这使得它非常适合高速的计算聚合</li>\n<li>自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配</li>\n<li>自动的故障转移</li>\n<li>Hadoop/HDFS集成，和HDFS开箱即用</li>\n<li>丰富的“简洁，高效”API，Thrift/REST API，Java API</li>\n<li>块缓存，布隆过滤器，可以高效的列查询优化</li>\n<li>操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标</li>\n</ul>\n<h5> Hbase的使用场景</h5>\n<ul>\n<li>首先数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>\n<li>不需要辅助索引，静态类型的列，事务等特性</li>\n<li>保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode</li>\n</ul>\n<h4> Hbase架构</h4>\n<figure><figcaption>img_87.png</figcaption></figure>\n<p>Hbase是三层架构体系。</p>\n<ul>\n<li>其中Hbase表底层是存储在HDFS上，可以分为多个Region， Region分布在Region Server上</li>\n<li>Master负责协调Region和负载</li>\n<li>Zookeeper负责记录一些元数据</li>\n</ul>\n<p>HBase中有两张特殊的表： Root和META， META表负责记录Region的分区信息， Root表负责记录META的分区信息， Root表的位置信息则有Hadoop集群的zookeeper来记录。</p>\n<p>那么Hbase检索一条数据的流程应该是这样的:<br>\n</p>\n<h5> 存储结构</h5>\n<p>Hbase 是一种专门为半结构化数据和水平扩展性设计的数据库。它把数据存储在表中，表按“行健(rowkey)，列簇，列限定符和时间版本”的四维坐标系来组织。Hbase 是无模式数据库，只需要提前定义列簇，并不需要指定列限定符。同时它也是无类型数据库，所有数据都是按二进制字节方式存储的，对 Hbase 的操作和访问有 5 个基本方式，即 Get、Put、Delete 和 Scan 以及 Increment。Hbase 基于非行健值查询的唯一途径是通过带过滤器的扫描。<br>\n</p>\n<p>从上图我们可以看出 Hbase 的组成部件，HBase 中的每张表都通过行键按照一定的范围被分割成多个子表（HRegion），由 HRegionServer 管理，管理哪些 HRegion 由 HMaster 分配。</p>\n<p>HRegionServer 存取一个子表时，会创建一个 HRegion 对象，然后对表的每个列族 (Column Family) 创建一个 Store 实例，每个 Store 都会有 0 个或多个 StoreFile 与之对应，每个 StoreFile 都会对应一个 HFile，HFile 就是实际的存储文件。因此，一个 HRegion 有多少个列族就有多少个 Store。此外，每个 HRegion 还拥有一个 MemStore 内存缓存实例。</p>\n<ul>\n<li>HFile：HBase 中 KeyValue 数据的存储格式，HFile 是 Hadoop 的二进制格式文件，实际上 StoreFile 就是对 HFile 做了轻量级包装，即 StoreFile 底层就是 HFile</li>\n<li>HLog: HBase记录写入记录，WAL机制保证数据可靠性，即首先写日志再写缓存，即使发生宕机，也可以通过恢复HLog还原出原始数据。该步骤就是将数据构造为WALEdit对象，然后顺序写入HLog中。</li>\n<li>MemStore：MemStore 即内存里放着的保存 KEY/VALUE 映射的 MAP，当 MemStore（默认 64MB）写满之后，会开始 flush 到磁盘（即 Hadoop 的 HDFS 上）的操作</li>\n</ul>\n<h5> HLog之WAL(write ahead log)机制</h5>\n<p>WAL(Write-Ahead Logging)是一种高效的日志算法,基本原理是在数据写入之前首先顺序写入日志，然后再写入缓存，等到缓存写满之后统一落盘。之所以能够提升写性能，是因为WAL将一次随机写转化为了一次顺序写加一次内存写。提升写性能的同时，WAL可以保证数据的可靠性，即在任何情况下数据不丢失。假如一次写入完成之后发生了宕机，即使所有缓存中的数据丢失，也可以通过恢复日志还原出丢失的数据。</p>\n<h6> HBase写入流程分析</h6>\n<ol>\n<li>zookeeper中存储了meta表的region信息，从meta表获取相应region信息，然后找到meta表的数据</li>\n<li>根据meta表的数据找到写入数据对应的region信息, 找到对应的RegionServer</li>\n<li>把数据分别写到HLog和MemStore上一份</li>\n<li>MemStore达到一个阈值后则把数据刷成一个StoreFile文件。若MemStore中的数据有丢失，则可以总HLog上恢复</li>\n<li>当多个StoreFile文件达到一定的大小后，会触发Compact合并操作，合并为一个StoreFile，这里同时进行版本的合并和数据删除</li>\n<li>当Compact后，逐步形成越来越大的StoreFIle后，会触发Split操作，把当前的StoreFile分成两个，这里相当于把一个大的region分割成两个region</li>\n</ol>\n",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-22T01:01:35.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Hive",
      "url": "https://ujava.cn/assembly/hive.html",
      "id": "https://ujava.cn/assembly/hive.html",
      "content_html": "",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-20T07:53:29.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件MongoDB",
      "url": "https://ujava.cn/assembly/mongodb.html",
      "id": "https://ujava.cn/assembly/mongodb.html",
      "summary": "一、简介 1.1 Mongodb MongoDb是一个基于分布式文件存储的数据库，官方地址 https://www.mongodb.com/ 1.2 数据库 数据库(DataBase)是按照数据结构来组织、存储和管理数据的应用程序。 作用：数据库的主要作用就是管理数据，对数据进行增(c)、删(d)、改(u)、查(r)。 核心概念：",
      "content_html": "<h1> 一、简介</h1>\n<h2> 1.1 Mongodb</h2>\n<p>MongoDb是一个基于分布式文件存储的数据库，官方地址 <a href=\"https://www.mongodb.com/\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/</a></p>\n<h2> 1.2 数据库</h2>\n<p>数据库(DataBase)是按照数据结构来组织、存储和管理数据的应用程序。</p>\n<p>作用：数据库的主要作用就是管理数据，对数据进行增(c)、删(d)、改(u)、查(r)。</p>\n<p>核心概念：</p>\n<ul>\n<li>数据库（database）数据库是一个数据仓库，数据库服务下可以创建很多数据库，数据库中可以存放很多集合。</li>\n<li>集合（collection）集合类似于JS中的数组，在集合中可以存放很多文档。</li>\n<li>文档（document）文档是数据库中的最小单位，类似于JS中的对象。</li>\n</ul>\n<blockquote>\n<p>一般情况下：</p>\n<ul>\n<li>一个项目使用一个数据库</li>\n<li>一个集合会存储同一种类型的数据</li>\n</ul>\n</blockquote>\n<figure><figcaption>img_135.png</figcaption></figure>\n<h1> 二、下载安装与启动</h1>\n<p>下载地址：<a href=\"https://www.mongodb.com/try/download/community\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.mongodb.com/try/download/community</a></p>\n<p>建议选择<code>zip</code>类型，通用性更强，配置步骤如下：</p>\n<ol>\n<li>将压缩包移动到<code>C:\\Program Files</code>下，然后解压</li>\n<li>创建<code>C:\\data\\db</code>目录，mongodb会将数据默认保存在这个文件夹</li>\n<li>以mongodb中bin目录作为工作目录，启动命令行</li>\n<li>运行命令<code>mongod</code></li>\n<li>成功运行服务<code>127.0.0.1:27017</code>，如下图</li>\n</ol>\n<figure><figcaption>img_136.png</figcaption></figure>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>为了方便后续使用<code>mongod</code>命令，可以将bin目录配置到环境变量Path中</li>\n<li>千万不要选中服务端窗口的内容，选中会停止服务，可以敲回车取消选中</li>\n</ul>\n</blockquote>\n",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-27T03:03:27.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Spark",
      "url": "https://ujava.cn/assembly/spark.html",
      "id": "https://ujava.cn/assembly/spark.html",
      "summary": "什么是Apache Spark？ 答案：Apache Spark是一个快速、通用的集群计算系统，旨在处理大规模数据处理和分析任务。它提供了高级的编程模型和丰富的库，可以在分布式环境中进行数据处理、机器学习、图计算等。 Spark和Hadoop有什么区别？ 答案：Spark和Hadoop都是用于大数据处理的框架，但有以下区别： 数据处理模型：Spark提供了更灵活和高级的数据处理模型，如RDD（弹性分布式数据集）和DataFrame，而Hadoop使用的是基于MapReduce的批处理模型。 性能：由于Spark的内存计算和任务调度优化，它通常比Hadoop的MapReduce更快。 生态系统：Hadoop拥有更成熟和广泛的生态系统，包括HDFS、YARN和Hive等，而Spark在某些方面的生态系统仍在发展中。",
      "content_html": "<h2> 什么是Apache Spark？</h2>\n<p>答案：Apache Spark是一个快速、通用的集群计算系统，旨在处理大规模数据处理和分析任务。它提供了高级的编程模型和丰富的库，可以在分布式环境中进行数据处理、机器学习、图计算等。</p>\n<h2> Spark和Hadoop有什么区别？</h2>\n<p>答案：Spark和Hadoop都是用于大数据处理的框架，但有以下区别：</p>\n<ul>\n<li>数据处理模型：Spark提供了更灵活和高级的数据处理模型，如RDD（弹性分布式数据集）和DataFrame，而Hadoop使用的是基于MapReduce的批处理模型。</li>\n<li>性能：由于Spark的内存计算和任务调度优化，它通常比Hadoop的MapReduce更快。</li>\n<li>生态系统：Hadoop拥有更成熟和广泛的生态系统，包括HDFS、YARN和Hive等，而Spark在某些方面的生态系统仍在发展中。</li>\n</ul>\n<h2> Spark的核心组件是什么？</h2>\n<p>答案：Spark的核心组件包括：</p>\n<ul>\n<li>Spark Core：提供了Spark的基本功能，包括任务调度、内存管理和分布式数据处理等。</li>\n<li>Spark SQL：用于处理结构化数据的模块，支持SQL查询和DataFrame API。</li>\n<li>Spark Streaming：用于实时数据流处理的模块，支持高吞吐量和低延迟的流处理任务。</li>\n<li>MLlib：Spark的机器学习库，提供了常见的机器学习算法和工具。</li>\n<li>GraphX：Spark的图计算库，用于图处理和分析任务。</li>\n</ul>\n<h2> Spark的数据处理模型是什么？</h2>\n<p>答案：Spark的数据处理模型基于RDD（弹性分布式数据集）。RDD是一个可并行操作的、容错的、不可变的数据集合，可以在集群中进行分布式处理。Spark还引入了DataFrame和Dataset等高级抽象，提供了更丰富和优化的数据处理能力。</p>\n<h2> Spark支持哪些编程语言？</h2>\n<p>答案：Spark主要支持以下编程语言：</p>\n<ul>\n<li>Scala：Scala是Spark的主要编程语言，它是一种面向对象和函数式编程的语言，提供了强大的表达能力和丰富的特性。</li>\n<li>Java：Spark可以通过Java API进行编程，适用于Java开发者。</li>\n<li>Python：Spark提供了Python API（PySpark），可以使用Python语言进行Spark开发。</li>\n<li>R：Spark也支持R语言，通过SparkR库可以在R环境中使用Spark。</li>\n</ul>\n<h2> Spark的调度器是什么？</h2>\n<p>答案：Spark的调度器是负责将任务分配给集群中的执行节点的组件。Spark有两种调度器：</p>\n<ul>\n<li>FIFO调度器：按照任务提交的顺序依次执行，适用于简单的任务场景。</li>\n<li>Fair调度器：根据资源使用情况动态分配资源，以保证每个任务能够公平地获得执行机会。</li>\n</ul>\n<h2> Spark的数据持久化机制是什么？</h2>\n<p>答案：Spark使用RDD的持久化机制来将数据存储在内存或磁盘中，以加快后续操作的速度。它支持将RDD的数据持久化到内存、磁盘或者序列化到外部存储系统。</p>\n<h2> Spark的容错机制是什么？</h2>\n<p>答案：Spark的容错机制基于RDD的不可变性和记录操作的转换日志。当节点发生故障时，Spark可以根据转换日志重新计算丢失的数据，从而保证任务的容错性。</p>\n<h2> Spark的机器学习库是什么？</h2>\n<p>答案：Spark的机器学习库称为MLlib，它提供了常见的机器学习算法和工具，如分类、回归、聚类、推荐等。MLlib使用RDD和DataFrame作为数据接口，提供了易于使用和可扩展的机器学习功能。</p>\n<h2> Spark的图计算库是什么？</h2>\n<p>答案：Spark的图计算库称为GraphX，它提供了图处理和分析的功能，包括图的创建、遍历、连接等操作。GraphX使用RDD作为图数据的表示形式，并提供了丰富的图算法和操作符。</p>\n<h2> Spark支持哪些数据源和数据格式？</h2>\n<p>答案：Spark支持多种数据源和数据格式，包括：</p>\n<ul>\n<li>文件系统：Spark可以读写各种文件系统，如HDFS、本地文件系统、S3等。</li>\n<li>数据库：Spark可以连接和读写关系型数据库，如MySQL、PostgreSQL等，也支持NoSQL数据库，如MongoDB、Cassandra等。</li>\n<li>实时数据流：Spark支持读取实时数据流，如Kafka、Flume等。</li>\n<li>数据格式：Spark支持常见的数据格式，如CSV、JSON、Parquet、Avro等。</li>\n</ul>\n<h2> Spark的集群部署模式有哪些？</h2>\n<p>答案：Spark的集群部署模式包括：</p>\n<ul>\n<li>Standalone模式：在独立的Spark集群上运行，不依赖其他资源管理器。</li>\n<li>YARN模式：在Hadoop集群上利用YARN资源管理器进行任务调度和资源分配。</li>\n<li>Mesos模式：在Mesos集群上利用Mesos资源管理器进行任务调度和资源分配。</li>\n<li>Kubernetes模式：在Kubernetes集群上运行Spark作业，利用Kubernetes进行容器管理和资源分配。</li>\n</ul>\n<h2> Spark的优化技术有哪些？</h2>\n<p>答案：Spark的优化技术包括：</p>\n<ul>\n<li>延迟计算：Spark使用惰性求值策略，延迟计算数据，只在需要结果时才执行计算，减少不必要的中间结果。</li>\n<li>数据分区和并行度：合理设置数据分区和并行度，使得任务可以并行执行，提高计算效率。</li>\n<li>内存管理：通过合理配置内存和缓存策略，将常用的数据存储在内存中，减少磁盘IO，提高性能。</li>\n<li>窗口操作：对于窗口操作，使用时间滑动窗口和窗口聚合等技术，减少数据的重复计算。</li>\n<li>数据压缩和序列化：使用压缩和序列化技术减小数据的存储空间和传输成本。</li>\n</ul>\n<h2> Spark支持哪些集群调度器？</h2>\n<p>答案：Spark支持以下集群调度器：</p>\n<ul>\n<li>Hadoop YARN：Spark可以与Hadoop集群上的YARN资源管理器集成，利用YARN进行任务调度和资源分配。</li>\n<li>Apache Mesos：Spark可以与Mesos集群集成，利用Mesos进行任务调度和资源分配。</li>\n<li>Kubernetes：Spark可以在Kubernetes集群上运行，利用Kubernetes进行容器管理和资源分配。</li>\n</ul>\n<h2> Spark的数据处理模型中的RDD是什么？</h2>\n<p>答案：RDD（弹性分布式数据集）是Spark的核心数据结构，代表分布在集群中的不可变的、可分区的数据集合。RDD可以并行操作，支持容错和恢复。它是Spark进行分布式数据处理的基础。</p>\n<h2> Spark的DataFrame是什么？</h2>\n<p>答案：DataFrame是Spark提供的高级数据结构，用于处理结构化数据。DataFrame类似于传统数据库中的表格，具有列和行的概念，支持SQL查询和DataFrame API操作。DataFrame提供了更丰富的数据处理能力和优化技术，比原始的RDD更高效。</p>\n<h2> Spark的机器学习库MLlib有哪些常见的算法？</h2>\n<p>答案：Spark的机器学习库MLlib包含了多种常见的机器学习算法，包括分类算法（如逻辑回归、决策树、随机森林）、回归算法（如线性回归、岭回归）、聚类算法（如K均值聚类、高斯混合模型）、推荐算法（如协同过滤）、降维算法（如主成分分析）、自然语言处理（如文本分类、词嵌入）等。</p>\n<h2> Spark的图计算库GraphX支持哪些图算法？</h2>\n<p>答案：Spark的图计算库GraphX支持多种图算法，包括图的遍历、连接、聚合、PageRank、连通性组件、最短路径等。GraphX提供了丰富的图操作符和API，方便用户进行图处理和分析。</p>\n<h2> Spark Streaming是什么？</h2>\n<p>答案：Spark Streaming是Spark提供的实时数据流处理模块。它可以以微批处理的方式处理实时数据，支持高吞吐量和低延迟的数据处理。Spark Streaming可以与Spark的批处理和机器学习库无缝集成，实现批处理与实时处理的统一。</p>\n<h2> Spark的扩展库和整合工具有哪些？</h2>\n<p>答案：Spark有丰富的扩展库和整合工具，包括：</p>\n<ul>\n<li>Spark SQL：用于处理结构化数据，支持SQL查询和DataFrame操作。</li>\n<li>Spark Streaming：用于实时数据流处理。</li>\n<li>MLlib：Spark的机器学习库。</li>\n<li>GraphX：Spark的图计算库。</li>\n<li>SparkR：提供在R语言中使用Spark的能力。</li>\n<li>PySpark：Spark的Python API。</li>\n<li>Spark on Kubernetes：在Kubernetes集群上运行Spark作业。</li>\n<li>Spark on Mesos：在Mesos集群上运行Spark作业。</li>\n<li>Spark on YARN：在Hadoop YARN集群上运行Spark作业。</li>\n</ul>\n<h2> 什么是宽依赖，什么是窄依赖？哪些算子是宽依赖，哪些是窄依赖？</h2>\n<p>窄依赖就是一个父RDD分区对应一个子RDD分区，如map，filter<br>\n或者多个父RDD分区对应一个子RDD分区，如co-partioned join</p>\n<p>宽依赖是一个父RDD分区对应非全部的子RDD分区，如groupByKey，ruduceByKey<br>\n或者一个父RDD分区对应全部的子RDD分区，如未经协同划分的join</p>\n<h2> Transformation和action算子有什么区别？举例说明</h2>\n<p>Transformation 变换/转换：这种变换并不触发提交作业，完成作业中间过程处理。Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算</p>\n<blockquote>\n<p>map, filter</p>\n</blockquote>\n<p>Action 行动算子：这类算子会触发 SparkContext 提交 Job 作业。<br>\nAction 算子会触发 Spark 提交作业（Job）。</p>\n<blockquote>\n<p>count</p>\n</blockquote>\n<h2> 讲解spark shuffle原理和特性？shuffle write 和 shuffle read过程做些什么？</h2>\n<h2> Shuffle数据块有多少种不同的存储方式？分别是什么</h2>\n<ol>\n<li>RDD数据块：用来存储所缓存的RDD数据。</li>\n<li>Shuffle数据块：用来存储持久化的Shuffle数据。</li>\n<li>广播变量数据块：用来存储所存储的广播变量数据。</li>\n<li>任务返回结果数据块：用来存储在存储管理模块内部的任务返回结果。通常情况下任务返回结果随任务一起通过Akka返回到Driver端。但是当任务返回结果很大时，会引起Akka帧溢出，这时的另一种方案是将返回结果以块的形式放入存储管理模块，然后在Driver端获取该数据块即可，因为存储管理模块内部数据块的传输是通过Socket连接的，因此就不会出现Akka帧溢出了。</li>\n<li>流式数据块：只用在Spark Streaming中，用来存储所接收到的流式数据块</li>\n</ol>\n<h2> 哪些spark算子会有shuffle？</h2>\n<ol>\n<li>去重，distinct</li>\n<li>排序，groupByKey，reduceByKey等</li>\n<li>重分区，repartition，coalesce</li>\n<li>集合或者表操作，interection，join</li>\n</ol>\n<h2> 讲解spark schedule（任务调度）？</h2>\n<figure><figcaption>img_85.png</figcaption></figure>\n<h2> Spark stage是如何划分的？</h2>\n<ol>\n<li>从hdfs中读取文件后，创建 RDD 对象</li>\n<li>DAGScheduler模块介入运算，计算RDD之间的依赖关系。RDD之间的依赖关系就形成了DAG</li>\n<li>每一个JOB被分为多个Stage，划分Stage的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个Stage，避免多个Stage之间的消息传递开销。</li>\n</ol>\n<p>因此spark划分stage的整体思路是：从后往前推，遇到宽依赖就断开，划分为一个stage；遇到窄依赖就将这个RDD加入该stage中。</p>\n<h2> Spark cache一定能提升计算性能么？说明原因？</h2>\n<p>不一定啊，cache是将数据缓存到内存里，当小数据量的时候是能提升效率，但数据大的时候内存放不下就会报溢出。</p>\n<h2> Cache和persist有什么区别和联系？</h2>\n<p>cache调用了persist方法，cache只有一个默认的缓存级别MEMORY_ONLY ，而persist可以根据情况设置其它的缓存级别。</p>\n<h2> RDD是弹性数据集，“弹性”体现在哪里呢？你觉得RDD有哪些缺陷？</h2>\n<ol>\n<li>自动进行内存和磁盘切换</li>\n<li>基于lineage的高效容错</li>\n<li>task如果失败会特定次数的重试</li>\n<li>stage如果失败会自动进行特定次数的重试，而且只会只计算失败的分片</li>\n<li>checkpoint【每次对RDD操作都会产生新的RDD，如果链条比较长，计算比较笨重，就把数据放在硬盘中】和persist 【内存或磁盘中对数据进行复用】(检查点、持久化)</li>\n<li>数据调度弹性：DAG TASK 和资源管理无关</li>\n<li>数据分片的高度弹性repartion</li>\n</ol>\n<p>缺陷：<br>\n惰性计算的缺陷也是明显的：中间数据默认不会保存，每次动作操作都会对数据重复计算，某些计算量比较大的操作可能会影响到系统的运算效率</p>\n<h2> RDD有多少种持久化方式？memory_only如果内存存储不了，会怎么操作？</h2>\n<p>cache和persist</p>\n<ul>\n<li>memory_and_disk，放一部分到磁盘</li>\n<li>MEMORY_ONLY_SER:同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销。</li>\n<li>MEMORY_AND_DSK_SER:同MEMORY_AND_DSK。但是使用序列化方式持久化Java对象。</li>\n<li>DISK_ONLY:使用非序列化Java对象的方式持久化，完全存储到磁盘上。<br>\nMEMORY_ONLY_2或者MEMORY_AND_DISK_2等：如果是尾部加了2的持久化级别，表示会将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可。</li>\n</ul>\n<h2> RDD分区和数据块有啥联系？</h2>\n<h2> 当GC时间占比很大可能的原因有哪些？对应的优化方法是？</h2>\n<p>垃圾回收的开销和对象合数成正比，所以减少对象的个数，就能大大减少垃圾回收的开销。序列化存储数据，每个RDD就是一个对象。缓存RDD占用的内存可能跟工作所需的内存打架，需要控制好</p>\n<h2> Spark中repartition和coalesce异同？coalesce什么时候效果更高，为什么?</h2>\n<div class=\"language-less line-numbers-mode\" data-ext=\"less\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>以上为他们的定义，区别就是repartition一定会触发shuffle，而coalesce默认是不触发shuffle的。</p>\n<p>他们两个都是RDD的分区进行重新划分，repartition只是coalesce接口中shuffle为true的简易实现，（假设RDD有N个分区，需要重新划分成M个分区）</p>\n<p>减少分区提高效率</p>\n<h2> Groupbykey和reducebykey哪个性能更高，为什么？</h2>\n<p>reduceByKey性能高，更适合大数据集</p>\n<h2> 你是如何理解caseclass的？</h2>\n<h2> Scala里trait有什么功能，与class有何异同？什么时候用trait什么时候该用class?</h2>\n<p>它可以被继承，而且支持多重继承，其实它更像我们熟悉的接口（interface），但它与接口又有不同之处是：<br>\ntrait中可以写方法的实现，interface不可以（java8开始支持接口中允许写方法实现代码了），这样看起来trait又很像抽象类</p>\n<h2> Scala 语法中to 和 until有啥区别?</h2>\n<p>to 包含上界，until不包含上界</p>\n<h2> 讲解Scala伴生对象和伴生类?</h2>\n<p>单例对象与类同名时，这个单例对象被称为这个类的伴生对象，而这个类被称为这个单例对象的伴生类。伴生类和伴生对象要在同一个源文件中定义，伴生对象和伴生类可以互相访问其私有成员。不与伴生类同名的单例对象称为孤立对象。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> spark作业执行流程?</h2>\n<ol>\n<li>客户端提交作业</li>\n<li>Driver启动流程</li>\n<li>Driver申请资源并启动其余Executor(即Container)</li>\n<li>Executor启动流程</li>\n<li>作业调度，生成stages与tasks。</li>\n<li>Task调度到Executor上，Executor启动线程执行Task逻辑</li>\n<li>Driver管理Task状态</li>\n<li>Task完成，Stage完成，作业完成</li>\n</ol>\n",
      "date_published": "2024-04-20T07:53:29.000Z",
      "date_modified": "2024-04-27T02:43:03.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件MQ",
      "url": "https://ujava.cn/assembly/mq.html",
      "id": "https://ujava.cn/assembly/mq.html",
      "summary": "想必你在面试或者工作的过程中，被问过以下问题： （1）为什么你们项目要用消息队列？ （2）用了消息队列后有什么好处？ （3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？ （4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？ 如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。 技术选型是开发工作前最重要的，也是最体现技术的环节。",
      "content_html": "<p>想必你在面试或者工作的过程中，被问过以下问题：</p>\n<ul>\n<li>（1）为什么你们项目要用消息队列？</li>\n<li>（2）用了消息队列后有什么好处？</li>\n<li>（3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？</li>\n<li>（4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？</li>\n</ul>\n<p>如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。</p>\n<p>技术选型是开发工作前最重要的，也是最体现技术的环节。</p>\n<p>目前主流的消息队列分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ。</p>\n<p>这篇文章重点介绍这四种消息队列的概述、对比和选型，不深入研究每种队列内部的实现原理。</p>\n<figure><figcaption>img_7.png</figcaption></figure>\n<h2> 消息队列是什么？</h2>\n<p>消息队列是在消息的传输过程中保存消息的容器，简单点理解就是传递消息的队列，具备先进先出的特点，一般用于异步、解耦、流量削锋等问题，实现高性能、高可用、高扩展的架构。一个消息队列可以被一个或多个消费者消费，一般包含以下元素：</p>\n<ul>\n<li>Producer：消息生产者，负责产生和发送消息到 Broker。</li>\n<li>Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue。</li>\n<li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li>\n</ul>\n<h2> 消息队列应用场景</h2>\n<p>常见的消息队列使用场景有 6 个：</p>\n<ul>\n<li>应用解耦：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li>\n<li>异步处理：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li>\n<li>流量削锋：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li>\n<li>日志处理：将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li>\n<li>消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯，比如实现聊天室等。</li>\n<li>消息广播：如果没有消息队列，每当一个新业务方接入，都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁订阅，是下游的事，无疑极大地减少了开发和联调的工作量。<br>\n比较核心的有 3 个：解耦、异步、削峰，下面着重讲下：</li>\n</ul>\n<p>解耦</p>\n<p>假设在没有消息队列的情况下，现在有上游服务 A 用来发布消息，下游服务 B、C 用来接收服务 A 的消息。但随着业务需要，现在有服务<br>\nD、E、F 需要接收服务 A 的消息，那么就出现问题了，每次新加入服务都要改一次代码，可想而知这是极大的工作量。</p>\n<figure><figcaption>img_8.png</figcaption></figure>\n<p>如果引入消息队列，那就好办了，只需要下游服务自己订阅消息队列，而无需改动服务 A 的代码。</p>\n<figure><figcaption>img_9.png</figcaption></figure>\n<p>异步</p>\n<p>先来看没有消息队列的场景下。</p>\n<p>服务 A 的某个接口接收到请求，分别需要在服务A、服务B、服务C、服务D进行写库。假设用户发起请求到服务 A 耗时 10ms，自己写库需要<br>\n50ms，在服务 B 写库需要 250ms，在服务 C 写库需要 300ms，在服务 D 写库需要400ms，在没有消息队列的情况下，也就是同步操作，总耗时会是<br>\n10 + 50ms + 250ms + 300ms + 400ms = 1.01s。用户发送个请求，结果感觉有点卡顿，响应的非常慢，任谁都是很难忍受的。</p>\n<figure><figcaption>img_10.png</figcaption></figure>\n<p>如果使用了消息队列，那么服务 A 只需要把对服务A、B、C、D 进行写库的操作分别放进四个消息队列，假如用户发起请求到服务器耗时是10ms，发送消息到四个消息队列的耗时是10ms，那么总耗时就是<br>\n20 ms 。用户点击了按钮后立马返回，没有卡顿现象，体验效果就会有极大的提升了。</p>\n<figure><figcaption>img_11.png</figcaption></figure>\n<p>一般接口同步处理时间很长，不能通过水平扩容来解决，且业务场景允许异步，就可以使用异步解决，比如文件上传下载受限于用户的网络带宽因素，扩容也无用，以及上述同步操作耗时长等情况，都可以先放进消息队列，等服务再进行拉取消费。</p>\n<p>削峰</p>\n<p>在淘宝双十一活动日，特别是 0<br>\n点的秒杀活动高峰期时，接口流量会飙升，远远高于平时，就像一个山峰，没有做好处理的话，在高峰期数据库就可能被流量打死，从而导致整个服务奔溃。如果为了在高峰期能顶住流量而常备高流量设备，会有极大的成本浪费。如果是在要高峰期前进行临时服务扩容，很可能会出现许多扩容问题，没有那么简单。</p>\n<p>使用消息队列的话，就可以将高峰期过多的流量请求放进消息队列，等高峰期过后，服务再慢慢进行处理，就不会出现峰值流量了，而是一个相对平稳的状态。</p>\n<p>举个例子：</p>\n<ul>\n<li>大量的用户在中午高峰期的时候，每秒有 4k 个请求，那么每秒就有 4k 个请求放到 MQ 里。</li>\n<li>服务A 每秒只能处理 2k 个请求，因为 Mysql 每秒最多处理 2k 个请求。</li>\n<li>服务A 就每秒从 MQ 拉取 2k 个请求进行处理，不会超过自己每秒能处理的最大请求量，所以高峰期服务 A 就不会挂掉。</li>\n<li>对于MQ，每秒 4k 个请求进来，但是却只有 2k 个请求出去，导致在高峰期 1h 内可能有几十万的请求积压在 MQ<br>\n中。这个短暂的高峰期请求积压是可以接受的，因为过了这个时间点，每秒就 100 个请求进 MQ，但这时服务 A 还是会按照每秒 2k 的速度处理<br>\nMQ 积压的请求。</li>\n<li>所以，高峰期一过，服务 A 就会快速的将 MQ 积压的消息处理掉。</li>\n</ul>\n<figure><figcaption>img_12.png</figcaption></figure>\n<h2> 消息队列模型</h2>\n<p>点对点模式：多个生产者可以向同一个消息队列发送消息，一个消息只能被一个消费者消费，在被消费成功后，这条消息会被移除。如果消费者处理消息失败了，那么这条消息会重新被消费。</p>\n<figure><figcaption>img_13.png</figcaption></figure>\n<p>发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。多个生产者可以将多个消息写到同一个 Topic 中，被同一个消费者消费。</p>\n<figure><figcaption>img_14.png</figcaption></figure>\n<h2> 消息队列对比</h2>\n<p>消息队列有 ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ、Kafka，其中 ZeroMQ 太过轻量，主要用于学习，实际是不会应用到生产，所以主要对比<br>\nKafka、RocketMQ、RabbitMQ、ActiveMQ 这四种 MQ。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Kafka</th>\n<th>RocketMQ</th>\n<th>RabbitMQ</th>\n<th>ActiveMQ</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单机吞吐量</td>\n<td>10万级别，吞吐量高是kafka最大的优点</td>\n<td>10万级，RocketMQ 也是可以支撑高吞吐的 MQ</td>\n<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>\n<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>\n</tr>\n<tr>\n<td>支持主题数</td>\n<td>百级，topic 达到百级时吞吐量会大幅度下降，要尽量保证 topic 数量不要过多，否则需要增加更多机器资源</td>\n<td>千级，topic 达到千级时吞吐量会有较小幅度的下降。可以支撑大量 topic 是 RocketMQ 的一大优点</td>\n<td>百万级</td>\n<td>千级</td>\n</tr>\n<tr>\n<td>消息顺序性</td>\n<td>分区有序</td>\n<td>有序</td>\n<td>有序</td>\n<td>有序</td>\n</tr>\n<tr>\n<td>消息重复</td>\n<td>至少一次，最多一次</td>\n<td>至少一次，最多一次</td>\n<td>至少一次</td>\n<td>至少一次</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms级</td>\n<td>ms级</td>\n<td>微秒级，RabbitMQ的一大优点</td>\n<td>ms级</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n<td>非常高，分布式架构</td>\n<td>高，基于主从架构实现高可用性</td>\n<td>高，基于主从架构实现高可用性</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>经过参数优化配置，理论上消息可以做到0丢失</td>\n<td>经过参数优化配置，理论上消息可以做到0丢失</td>\n<td>有较低的概率丢失数据</td>\n<td>有较低的概率丢失数据</td>\n</tr>\n<tr>\n<td>消息回溯</td>\n<td>支持（按offset回溯）</td>\n<td>支持（按时间回溯）</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>\n<td>MQ功能较为完善，还是分布式的，扩展性好</td>\n<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>\n<td>MQ领域的功能极其完备</td>\n</tr>\n<tr>\n<td>伸缩性</td>\n<td>高伸缩性，每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中</td>\n<td>高伸缩性，灵活的分布式横向扩展部署架构，整体架构和 kafka 很像</td>\n<td>一般</td>\n<td></td>\n</tr>\n<tr>\n<td>管理界面</td>\n<td>普通</td>\n<td>完善</td>\n<td>普通</td>\n<td>普通</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>消息可以持久化到磁盘</td>\n<td>消息可以持久化到磁盘</td>\n<td>持久化不好，可以持久化到内存、文件</td>\n<td>可以持久化到内存、文件、数据库</td>\n</tr>\n<tr>\n<td>消息路由</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>语言支持</td>\n<td>支持多语言，Java优先</td>\n<td>支持Java、C++，但C++不成熟</td>\n<td>支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等</td>\n<td>支持多语言，Java优先</td>\n</tr>\n<tr>\n<td>社区活跃度</td>\n<td>高</td>\n<td>一般</td>\n<td>高</td>\n<td>高</td>\n</tr>\n</tbody>\n</table>\n<h2> 消息队列选型</h2>\n<p>Kafka 和 RocketMQ 都支持 10w 级别的高吞吐量。</p>\n<p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用<br>\nKafka 绝对没错，社区活跃度高，业内标准。</p>\n<p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ<br>\n是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用<br>\nRocketMQ。</p>\n<p>RabbitMQ<br>\n适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高，能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用<br>\nErlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p>\n<p>ActiveMQ 现在很少有人用，没怎么经过大规模吞吐量场景的考验，社区不怎么活跃，官方社区现在对 ActiveMQ 5.x 维护也越来越少，所以不推荐使用。</p>\n",
      "date_published": "2024-04-16T08:43:59.000Z",
      "date_modified": "2024-04-16T08:43:59.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Dubbo",
      "url": "https://ujava.cn/assembly/dubbo.html",
      "id": "https://ujava.cn/assembly/dubbo.html",
      "summary": "1、Dubbo的基本介绍 Dubbo 是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 1.1、基本概念 img_15.png 服务提供者**（Provider）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者**（Consumer）**:&nbsp;调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 注册中心**（Registry）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 监控中心**（Monitor）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心",
      "content_html": "<h2> 1、Dubbo的基本介绍</h2>\n<p>Dubbo 是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>\n<h3> 1.1、基本概念</h3>\n<figure><figcaption>img_15.png</figcaption></figure>\n<ul>\n<li><strong>服务提供者</strong>**（<strong><strong>Provider</strong></strong>）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li><strong>服务消费者</strong>**（<strong><strong>Consumer</strong></strong>）**:&nbsp;调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li><strong>注册中心</strong>**（<strong><strong>Registry</strong></strong>）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li>\n<li><strong>监控中心</strong>**（<strong><strong>Monitor</strong></strong>）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</li>\n</ul>\n<p>调用关系说明：</p>\n<ol>\n<li>服务容器负责启动，加载，运行服务提供者。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n</ol>\n<h3> 1.2、RPC</h3>\n<p>RPC（Remote Procedure Call）是一种进程间通信方式。简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务，可以应用在分布式服务、分布式计算、远程服务调用等许多场景。业界有很多开源的优秀 RPC 框架，例如 Dubbo、Thrift、gRPC、Hprose 等等。</p>\n<p>RPC 与 HTTP、RMI、Web Service 都能完成远程调用，但是实现方式和侧重点各有不同。</p>\n<p>RPC是一种协议规范，可以把HTTP看作是一种RPC的实现，也可以把HTTP作为RPC的传输协议来应用。与HTTP相比，RPC的缺点就是相对复杂，学习成本稍高。</p>\n<h4> 1.2.1、序列化和反序列化</h4>\n<ul>\n<li>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程</li>\n<li>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或对象的过程</li>\n<li>为什么需要序列化？转换为二进制串才好进行网络传输嘛</li>\n<li>为什么需要反序列化？将二进制串转换成对象才好进行后续处理嘛</li>\n</ul>\n<h2> 2、zookeeper（注册中心）</h2>\n<p>Zookeeper是一个高性能的，分布式的，开放源码的分布式应用程序协调服务，简称zk。</p>\n<h3> 2.1、zookeeper 下载</h3>\n<p>下载可在官网下载，如 3.4.11 地址参考：<a href=\"https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/\" target=\"_blank\" rel=\"noopener noreferrer\">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></p>\n<h3> 2.2、zookeper安装使用（window版）</h3>\n<p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>\n<figure><figcaption>img_16.png</figcaption></figure>\n<p>zookeeper 下载后直接解压即可。在bin文件下，直接通过命令行执行 zkServer.cmd 即为启动 zookeeper。</p>\n<p>第一次启动时可能会有报错，如下：</p>\n<figure><figcaption>img_17.png</figcaption></figure>\n<p>此时只需在 conf 目录下将 zoo_sample.cfg 文件复制一份，将名字改为 zoo.cfg 即可。打开&nbsp;zoo.cfg 文件，可以看到内容如下：</p>\n<figure><figcaption>img_18.png</figcaption></figure>\n<p>可以将 dataDir 路径修改为我们想要保存文件的路径，如：../data，然后建立相应的目录即可。</p>\n<p>再次启动 zookeeper，可以看到可正常启动，输出如下：</p>\n<figure><figcaption>img_19.png</figcaption></figure>\n<p>可以运行 zkCli.cmd 连接到zookeeper的服务器，如下：</p>\n<figure><figcaption>img_20.png</figcaption></figure>\n<h3> 2.3、zookeper安装使用（Linux版）</h3>\n<p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>\n<figure><figcaption>img_21.png</figcaption></figure>\n<p>将下载的ZooKeeper放到/opt/ZooKeeper目录下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>将tar包解压到/opt/zookeeper目录下</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置zoo.cfg</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改zoo.cfg</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改存储目录：dataDir=/opt/zookeeper/zkdata<br>\n</p>\n<p>启动ZooKeeper</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>看到下图表示ZooKeeper成功启动<br>\n</p>\n<h4> 2.3.1、查看ZooKeeper状态</h4>\n<p>查看ZooKeeper状态</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下图表示zookeeper启动成功。standalone代表zk没有搭建集群，现在是单节点<br>\n</p>\n<p>下图表示zookeeper没有启动<br>\n</p>\n<h2> 3、提供者消费者示例</h2>\n<p>（建议参考&nbsp;3.2、springboot搭建dubbo示例）</p>\n<h3> 3.1、spring搭建dubbo示例</h3>\n<p>基于以下图实现服务 提供者、消费者，即以用户服务作为提供者，订单服务作为消费者。<br>\n</p>\n<p>分别创建 maven 工程 user-service-provider、order-service-consumer，还需要创建一个专门用于存服务接口的工程 dubbo-interface。</p>\n<p>提供者工程 user-service-provider 引入以下依赖：（dubbo依赖会自动引入 spring 的相关依赖），另外需要引入 dubbo-interface 工程。</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>提供者工程添加配置文件 provider.xml，并添加以下配置内容：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>暴露的服务的实现类&nbsp;UserServiceImpl、UserServiceImpl2 代码大概如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动提供者，main 方法如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动提供者后可以在管理控制台看到注册的服务：<br>\n</p>\n<p>在消费者工程引入依赖：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>消费者工程添加配置文件 consumer.xml，并添加以下配置内容：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>消费者建一个实现类，直接使用提供者的方法，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动消费者 main 方法，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以看到输出：<br>\n</p>\n<p>由此，消费者调用提供者提供的服务即完成。</p>\n<p>（上面的示例没有把 dubbo-interface 工程具体写出来，可以参考下面 3.2）</p>\n<h3> 3.2、springboot搭建dubbo示例</h3>\n<p>创建工程 dubbotest01，在该工程下创建 module：dubbo-interface、dubbo-provider、dubbo-consumer。其中，dubbo-provider 和 dubbo-consumer 创建为 springboot 项目，可用于测试服务调用，dubbo-interface 只需创建为普通 maven 项目即可，只需在里面管理一些公共接口类。dubbo-interface 后面被打成 jar 包，它的作用只是提供接口。<br>\n</p>\n<h4> 3.2.1、搭建dubbo-interface 模块</h4>\n<p>在 dubbo-interface 模块中创建接口类&nbsp;HelloService，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.2.2、搭建dubbo-provider模块</h4>\n<p>dubbo-provider 中添加依赖，包括dubbo 、zookeeper以及 dubbo-interface 的依赖，如下：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 application.properties 配置文件中配置 dubbo 相关信息</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实现 HelloService 接口，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>给启动类加上&nbsp;<code>@EnableDubboConfiguration</code>&nbsp;注解开启Dubbo 的自动配置。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.2.3、搭建dubbo-consumer模块</h4>\n<p>dubbo-consumer 中添加依赖，包括dubbo 、zookeeper以及 dubbo-interface 的依赖，如下：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 application.properties 配置文件中配置 dubbo 相关信息</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>编写一个简单 Controller ，HelloController 来调用远程服务，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>给启动类加上&nbsp;<code>@EnableDubboConfiguration</code>&nbsp;注解开启Dubbo 的自动配置。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动 zookeeper，启动 provider 和 consumer 服务，调用 consumer 服务的 HelloController 类，即访问&nbsp;<a href=\"http://localhost:8330/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%BE%93%E5%87%BA%E5%A6%82%E4%B8%8B%EF%BC%9A\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8330/hello，可以看到输出如下：</a><br>\n</p>\n<p>由此，使用SpringBoot+Dubbo 搭建分布式服务成功。</p>\n<h2> 4、zookeeper管理控制台（dubbo-admin）</h2>\n<p>dubbo-admin 管理平台，是图形化的服务管理页面。该平台从注册中心中获取到所有的提供者 / 消费者，可进行配置管理 路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能。</p>\n<h3> 4.1、dubbo-admin的安装使用</h3>\n<h4> 4.1.1、dubbo-admin下载打包</h4>\n<p>dubbo-admin 是一个前后端分离的项目，前端使用vue，后端使用springboot。</p>\n<p>dubbo-admin下载地址 ：<a href=\"https://github.com/apache/dubbo-admin\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/apache/dubbo-admin</a></p>\n<p>下载解压后进入 dubbo-admin-server\\src\\main\\resources 目录，找到&nbsp;<strong>application.properties</strong>&nbsp;配置文件进行配置修改，将 zookeeper 地址修改为正确地址，如：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 dubbo-admin-develop 根目录执行打包命令：mvn clean package -Dmaven.test.skip=true，看到 build success 即打包成功。<br>\n</p>\n<ol>\n<li>或者先在&nbsp;dubbo-admin-server 中打包，使用 mvn package -Dmaven.test.skip=true ，</li>\n<li>然后&nbsp;java&nbsp;-jar 启动打包生成的 jar 包，如：java -jar dubbo-admin-server-0.3.0.jar。</li>\n<li>然后再去&nbsp;dubbo-admin-ui 里面执行 npm install 等待下载前端的依赖，完毕后启动前端 npm run dev</li>\n</ol>\n<p>如果 dubbo-admin-server 编译报错，提示 zookeeper server创建失败什么的，可将上面的 admin.registry.address 配置改为：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.1.2、启动前后端</h4>\n<p>切换到目录打包后的后端 jar 包目录：dubbo-Admin-develop\\dubbo-admin-distribution\\target，执行以下命令启动后台：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 dubbo-admin-ui 目录下执行以下命令启动前端：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动完成后即可通过 localhost:8081 看到后台管理页面了，启动结果如下：（默认登录账户密码都是 root）<br>\n</p>\n<h3> 4.2、dubbo-admin的基本使用</h3>\n<p>可以在服务查询中看到已注册的服务，如下：<br>\n</p>\n<p>点击服务的详情，可以看到该服务的详细信息和该服务的消费者，如下：<br>\n<br>\n</p>\n",
      "date_published": "2024-04-16T01:53:26.000Z",
      "date_modified": "2024-04-16T09:04:18.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件MySQL",
      "url": "https://ujava.cn/assembly/mysql.html",
      "id": "https://ujava.cn/assembly/mysql.html",
      "summary": "img_36.png 一、数据库简介 1. 数据库是什么 数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。 数据是数据库中存储的基本对象，是按一定顺序排列组合的物理符号。数据有多种表现形式，可以是数字、文字、图像，甚至是音频或视频，它们都可以经过数字化后存入计算机。 数据库是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。 在日常生活中，人们可以直接用中文、英文等自然语言描述客观事物。在计算机中，则要抽象出对这些事物感兴趣的特征，并组成一个记录来描述。",
      "content_html": "<figure><figcaption>img_36.png</figcaption></figure>\n<h2> 一、数据库简介</h2>\n<h3> 1. 数据库是什么</h3>\n<p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。</p>\n<ul>\n<li>数据是数据库中存储的基本对象，是按一定顺序排列组合的物理符号。数据有多种表现形式，可以是数字、文字、图像，甚至是音频或视频，它们都可以经过数字化后存入计算机。</li>\n<li>数据库是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。</li>\n<li>在日常生活中，人们可以直接用中文、英文等自然语言描述客观事物。在计算机中，则要抽象出对这些事物感兴趣的特征，并组成一个记录来描述。</li>\n</ul>\n<h3> 2. 数据库在开发中的作用</h3>\n<p>从数据库系统应用角度来看，数据库系统常见的运行与应用结构有：客户端/服务器结构、浏览器/服务器结构。</p>\n<ul>\n<li>在客户端/服务器（Client/Server，C/S）结构中，数据库的使用者（如 DBA、程序设计者）通过命令行客户端、图形化界面管理工具或应用程序等连接到数据库管理系统，可以通过数据库管理系统查询和处理存储在底层数据库中的各种数据。</li>\n<li>数据库使用者与命令行客户端、图形化界面管理工具或应用程序等直接交互，而不与数据库管理系统直接联系。</li>\n<li>在这种结构中，命令行客户端、图形化界面管理工具或应用程序等称为“客户端”或“前台”，主要完成与数据库使用者的交互任务；而数据库管理系统则称为“服务器”或“后台”，主要负责数据管理。这种结构经常被称为“C/S”结构。</li>\n<li>在客户端/服务器模式中，客户端和服务器可以同时工作在同一台计算机上，这种工作方式称为“单机方式”；也可以“网络方式”运行，即服务器被安装和部署在网络中某一台或多台主机上。</li>\n<li>对于客户端应用程序的开发，目前常用的语言工具主要有 Visual C++、Delphi、.NET 框架、Visual Basic、Python 等。</li>\n<li>数据库能有效存储数据，读取数据、查找数据更是方便，其实那些管理软件就是通过软件的界面向内部的数据库进行数据的增、删、改、查操作。</li>\n</ul>\n<h3> 3.常见数据库比较</h3>\n<p><strong>3.1 MySQL数据库</strong><br>\n<strong>定位</strong><br>\n开源、多平台、关系型数据库<br>\n目前使用最广泛、流行度最高的的开源数据库。</p>\n<p><strong>功能</strong><br>\n支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据，有插件式存储引擎，支持多种存储引擎格式</p>\n<p><strong>部署</strong><br>\n用编译安装的方式，或者二进制包的方式，按照“安装软件-创建实例-库表用户初始化”，可以很快完成数据库部署</p>\n<p><strong>使用</strong><br>\n使用标准的SQL语句进行数据库管理，简单SQL语句的并发和性能较好，对视图、存储过程、函数、触发器等支持的不是太好</p>\n<p><strong>监控</strong><br>\n在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有比较多的开源监控工具来监控和记录数据库的状态，比如zabbix，nagios，cacti，lepus等</p>\n<p><strong>备份</strong><br>\n逻辑备份 mysqldump/mysqldumper ，物理备份 用xtrabackup等工具进行备份；</p>\n<p><strong>高可用</strong><br>\nMySQL高可用有多种方案，官方有基础的master-slave主从复制，新版本的innodb cluster，第三方的有MHA等高可用方案；</p>\n<p><strong>扩展</strong><br>\nMySQL水平拆分，可以通过水平拆分proxy中间进行逻辑映射和拆分，扩大MySQL数据库的并发能力和吞吐量。</p>\n<p><strong>适用场景</strong><br>\n默认的innodb存储引擎，支持高并发，简单的绝大部分OLTP场景；<br>\nTokudb存储引擎，使用高并发insert的场景；<br>\nInforbright存储引擎，可以进行列压缩和OLAP统计查询场景；</p>\n<p><strong>选择注意</strong><br>\n使用MySQL进行OLTP业务时，需要注意数据量级，如果数据量级过大，需要进行水平拆分；<br>\n如果有OLAP需求，可以结合其他架构综合考虑。</p>\n<p><strong>3.2 SQL Server数据库</strong><br>\n<strong>定位</strong><br>\n商业、Windows平台、关系型数据库<br>\n最早接触、与微软体系结合紧密的的商业数据库，属于“微软技术体系”</p>\n<p><strong>功能</strong><br>\n支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据</p>\n<p><strong>部署</strong><br>\n在Windows平台，用图形界面进行软件安装；</p>\n<p><strong>使用</strong><br>\n在Windows平台，使用SQL Server Mangement Studio图形界面进行安装；</p>\n<p><strong>监控</strong><br>\n一般通过Windows资源管理和SQL server图形工具进行系统和数据库性能显示；</p>\n<p><strong>备份</strong><br>\n通常用第三方备份恢复软件进行备份恢复；</p>\n<p><strong>高可用</strong><br>\n通过共享存储和双机热备的方式，可以实现SQL Server数据库的高可用；</p>\n<p><strong>扩展</strong><br>\nSQL Server数据库集群采用共存存储的方式，通过硬件垂直升级来对数据库集群进行扩展；</p>\n<p><strong>适用场景</strong><br>\n大多数OLTP场景（与微软体系配合）</p>\n<p><strong>选择注意</strong></p>\n<ul>\n<li>SQL Server与微软技术体系结合比较紧密，绝大多数工作，都是通过图形界面完成，对于习惯使用命令行的DBA可能会有不习惯；</li>\n<li>SQL server对双引号，大小写，元信息的管理和处理方式，与其他数据库很不相同，需要注意；</li>\n<li>使用SQL Server满足OLTP业务，会有比较好的效果，但对于大数据量的OLAP业务，最好还是选用专门的OLAP架构，不要在同一个SQL Server实例上混用OLTP和OLAP业务；</li>\n<li>SQL server属于商业软件，需要注意版权和licence授权费用；</li>\n</ul>\n<p><strong>3.3 Oracle数据库</strong><br>\n<strong>定位</strong><br>\n商业、多平台、关系型数据库<br>\n功能最强大、最复杂、市场占比最高的商业数据库</p>\n<p><strong>功能</strong><br>\n支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据</p>\n<p><strong>部署</strong><br>\nOracle单实例数据库部署相对容易，但Oracle RAC集群环境，部署的步骤和依赖条件都比较多；</p>\n<p><strong>使用</strong><br>\n通常使用命令行工具，进行各种数据库的管理，通常也可以用shell脚本和python脚本提高Oracle数据库管理效率；各种管理功能，都比较强大；</p>\n<p><strong>监控</strong><br>\nOracle官方有比较全面的监控工具，常用的第三方监控平台，如zabbix,cacti,lepus等都有对Oracle数据库的各项指标的完善监控；</p>\n<p><strong>备份</strong><br>\n支持冷备份和热备份，可以用 exp/imp , expdp/impdp等进行逻辑备份和恢复，可以使用强大的RMAN工具进行专业的物理热备份和恢复；</p>\n<p><strong>高可用</strong><br>\nOracle数据库的高可用架构，可以用第三方双机热备软件，结合Oracle单实例实现；可以使用Oracle Dataguard，实现master和standby的备份；可以使用 Oracle RAC集群实现实例级别的高可用和负载均衡，使用ASM实现存储级别的高可用；</p>\n<p><strong>扩展</strong><br>\n由于Oracle集群采用共享存储的方式，一般只能通过垂直硬件升级进行升级；</p>\n<p><strong>适用场景</strong><br>\n绝大多数OLTP场景，部分OLAP</p>\n<p><strong>选择注意</strong><br>\nOracle从架构到运维，可以说是最难的数据库，学习和使用难度较高。</p>\n<p><strong>3.4 Hbase数据库</strong><br>\n<strong>定位</strong></p>\n<ul>\n<li>开源、Linux平台、列存储nosql数据库</li>\n<li>可用于海量数据存储、与Hadoop生态圈结合、定位于“大”的列存储nosql数据库</li>\n</ul>\n<p><strong>功能</strong><br>\n命令执行速度非常看，读写性能可达10万/秒；数据结构是key-value类似字典的功能，可以键过期-缓存，发布订阅-消息系统，简单的事物功能；</p>\n<p><strong>部署</strong><br>\n相对其他数据库，hbase的部署比较复杂，依赖Hadoop，zookeeper等组件，Hbase集群包括一个mater节点，多个regionServer，zookeeper管理所有regionServer，需要依次部署Hadoop、zookeeper之后，再部署HBASE集群；</p>\n<p><strong>使用</strong><br>\n用redis-cli客户端连接，一般用简单的 set ,get,del 进行数据管理； 在单实例redis的基础上，进行可以数据持久化，主从复制，高可用和分布式等功能；</p>\n<p><strong>监控</strong><br>\n在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有开源监控工具来监控和记录数据库的状态，比如cachecloud；</p>\n<p><strong>备份</strong><br>\nHbase一般用作海量数据的仓库，本身通过多层副本来保证数据安全性，不用进行专门的备份</p>\n<p><strong>高可用</strong><br>\nHBASE集群基于Hadoop，需要依次部署Hadoop单机模式、集群模式、HA模式，通过Hadoop HA实现高可用；</p>\n<p><strong>扩展</strong><br>\nHBASE以集群形式，依次是单机模式，伪分布模式，完全分布模式，底层基于HDFS，zookeeper可以很好地进行扩展；</p>\n<p><strong>适用场景</strong><br>\n两大用途：</p>\n<ul>\n<li>用于简单数据写入和海量、结构简单数据查询的业务场景；</li>\n<li>用于成为其他数据库备份和下沉的数据库；</li>\n</ul>\n<p><strong>选择注意</strong></p>\n<ul>\n<li>Hbase不适合的场景：对数据分析需求高，需要能够用sql或者简单的MapReduce实现分析需求的业务场景，不适合用Hbase；</li>\n<li>单表数据量，不超过千万时，使用Hbase，体现不出Hbase的优势，而且会比较慢，不适合用Hbase。</li>\n<li>通过对上面数据库“七种”武器的描述，也可以看到目前常用数据库的使用脉络和选择顺序，对应一个业务，可以优先选择最流行的开源数据库——MySQL；如果出于稳定和商业版考虑，可以选择Oracle数据库，或者SQL Server数据库（与Windows体系结合）；如果想用开源，有想要有足够的功能来应对各种场景，可以使用 postgresql数据库。这四种数据库，都是关系型数据库，可以很好地满足大多数业务场景，解决通用性问题。</li>\n<li>对于一些特殊性问题，尤其是想要在扩展性方面有比较高的要求，可以考虑nosql数据库。Mongodb数据库，介于关系型数据库和非关系型数据库之间，兼具两者的特点，是非常流行的文档型nosql数据库；redis定位于内存型键值nosql数据库；hbase是海量文件存储的列式nosql数据库。根据合适的业务场景，选择适合的nosql数据库，可以对某一类，或某几类业务问题有很好的解决，可以作为关系型数据库的一种补充。</li>\n<li>换个角度，MySQL，Oracle，SQL Server，Postgresql，mongodb这五种数据库，也是DB-Engines排行榜上最流行的排名前五的五种数据库，从使用量和受欢迎程度，也可以看出这些数据库使用的广泛性。</li>\n</ul>\n<h3> 4. 数据库常见功能</h3>\n<figure><figcaption>img_37.png</figcaption></figure>\n<h2> 二、Mysql数据库简介</h2>\n<h3> 1. MySQL的优势</h3>\n<p>MySQL 使用的 SQL 语言是用于访问数据库的最常用的标准化语言。<br>\n  由于 MySQL 数据库体积小、速度快、总体拥有成本低、开放源代码，其有着广泛的应用，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，因此搭配 PHP 和 Apache 服务器可组成良好的开发环境。<br>\n  MySQL 数据库管理系统具有以下系统特性：<br>\n（1） 使用 C 和 C++ 编写，并使用多种编译器进行测试，保证源代码的可移植性。<br>\n（2）支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows 等多种操作系统。<br>\n（3）为多种编程语言提供了 API。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。<br>\n（4）支持多线程，充分利用 CPU 资源。<br>\n（5）优化的 SQL 查询算法，有效地提高查询速度。<br>\n（6）既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入其他的软件中。<br>\n（7）提供多语言支持，常见的编码如中文的 GB 2312、BIG 5，日文的 Shift_JIS 等都可以用作数据表名和数据列名。<br>\n（8）提供 TCP/IP、ODBC 和 JDBC 等多种数据库连接途径。<br>\n（9）提供用于管理、检查、优化数据库操作的管理工具。<br>\n（10）支持大型的数据库。可以处理拥有上千万条记录的大型数据库。<br>\n（11）支持多种存储引擎。</p>\n<h3> 2. MySQL的版本以及版本号</h3>\n<p>针对不同的用户，MySQL分为两个版本：<br>\n（1）MySQL Community Server（社区版）：该版本完全免费，但是官方不提供技术支持。<br>\n（2）MySQL Enterprise Server（企业版）：该版本能够以很高的性价比为企业提供数据仓库应用，支持 ACID 事物处理，提供完整的提交、回滚、崩溃恢复和行级锁定功能，但是该版本需要付费使用，官方提供电话技术支持。<br>\n温馨提示：MySQL Cluster 主要用于架设群服务器，需要在社区服务或企业版的基础上使用。</p>\n<p>MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20：</p>\n<ul>\n<li>第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。</li>\n<li>第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。</li>\n<li>第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。</li>\n</ul>\n<p>在 MySQL 开发过程中，同时存在多个发布系列，每个发布系列的成熟度处在不同阶段。</p>\n<ul>\n<li>MySQL 5.7 是最新开发的稳定（GA）发布系列，是将执行新功能的系列，目前已经可以正常使用。</li>\n<li>MySQL 5.6 是比较稳定的（GA）发布系列，只针对漏洞修复重新发布，不增加会影响稳定性的新功能。</li>\n<li>MySQL 5.1 是一个稳定的（产品质量）发布系列，只针对严重漏洞修复和安全修复重新发布，不增加影响该系列稳定性的重要功能。</li>\n<li>对于 MySQL 4.1 等低于 5.0 的老版本，官方将不再提供支持</li>\n</ul>\n<h3> 3. MySQL 5.7的新特性</h3>\n<p>与 MySQL5.6 相比，MySQL 5.7 具有以下几个方面的新功能。<br>\n（1）随机 root 密码<br>\nMySQL 5.7 数据库初始化完成后，会自动生成一个 root@localhost 用户，root 用户的密码不为空，而是随机产生一个密码。<br>\n（2）自定义 test 数据库<br>\nMySQL 5.7 默认安装完成后没有 test 数据库。用户可以自行创建 test 数据库并对其进行权限控制。<br>\n（3）默认 SSL 加密<br>\nMySQL 5.7 采用了更加简单的 SSL 安全访问机制，默认连接使用 SSL 的加密方式。<br>\n（4）密码过期策略<br>\nMySQL 5.7 支持用户设置密码过期策略，要求用户在一定时间过后必须修改密码。<br>\n（5）用户锁<br>\nMySQL 5.7 为管理员提供了暂时禁用某个用户的功能，使被锁定的用户无法访问和使用数据库。<br>\n（6）全面支持JSON<br>\nMySQL 5.7在服务器端提供了一组便于操作 JSON 的函数。存储的方法是将 JSON 编码成 BLOB 后再由存储引擎进行处理。这样，MySQL 就同时拥有了关系型数据库和非关系型数据库的优点，并且可以提供完整的事务支持。<br>\n（7）支持两类生成列（generated column）<br>\n生成列是通过数据库中的其他列计算得到的一列。当为生成列创建索引时，可以便捷地加快查询速度。MySQL 5.7 支持虚拟生成列和存储生成列。虚拟生成列仅将数据保存在表的元数据中，作为缺省的生成列类型；存储生成列则是将数据永久保存在磁盘上，需要更多的磁盘空间。<br>\n（8）引入系统库（sys schema）<br>\n系统库中包含一系列视图、函数和存储过程，通过多线程、多进程、组合事务提交和基于行的优化方式将复制功能提高 5 倍以上，用户向外扩充其跨商品系统的工作负载时，得以大幅提升复制的效能和效率。<br>\n与 MySQL5.6 相比，MySQL 5.7 具有以下几个方面的新功能。</p>\n<h2> 三、Mysql安装与服务启动（Windows版本）</h2>\n<h3> 1. 下载</h3>\n<p>用户可以根据自身的操作系统类型，从 MySQL官方下载页面免费下载相应的服务器安装包。本书以 MySQL 5.7.20 为例介绍其在 Windows 10 操作系统下的安装和配置过程。</p>\n<p>用户下载 Windows 图形化安装包的步骤如下。</p>\n<p>步骤 1)：打开 MySQL 官方网站（<a href=\"https://www.mysql.com/\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.mysql.com</a>），单击 DOWNLOAD，进入 MySQL 产品的下载界面，如图所示。<br>\n</p>\n<p>步骤 2)：在 MySQL 产品分类中选择 Community 菜单，在下载列表中选择 MySQL Community Server，如图所示。<br>\n</p>\n<p>步骤3)：在下载页面中，操作系统选择 Microsoft Windows，下载的安装文件为 mysql-installer-community-5.7.20.0.msi，如图所示。<br>\n</p>\n<h3> 2. 安装教程</h3>\n<p>Windows 平台下提供两种安装 MySQL 的方式：</p>\n<ul>\n<li>MySQL 二进制分发版（.msi 安装文件）。</li>\n<li>免安装版（.zip 压缩文件）。</li>\n</ul>\n<p>用户使用图形化安装包安装 MySQL 的步骤如下：</p>\n<p>步骤 1)：双击下载的 MySQL 安装文件，进入 MySQL 安装界面，首先进入“License Agreement（用户许可证协议）”窗口，选中“I accept the license terms（我接受系统协议）”复选框，单击“Next（下一步）”按钮，如图所示。<br>\n</p>\n<p>进入MySQL安装界面并接受系统协议</p>\n<p>步骤 2)：进入“Choosing a Setup Type（安装类型选择）”窗口，根据右侧的安装类型描述文件选择适合自己的安装类型，这里选择默认的安装类型，如图所示。<br>\n</p>\n<p>选择默认的安装类型</p>\n<blockquote>\n<p>注意：Developer Default：默认安装类型；Server only：仅作为服务；Client only：仅作为客户端；Full：完全安装；Custom：自定义安装类型。</p>\n</blockquote>\n<p>步骤 3)：根据所选择的安装类型安装 Windows 系统框架（framework），单击 Execute 按钮，安装程序会自动完成框架的安装，如图所示。<br>\n</p>\n<p>检查并生成安装所需要的框架列表</p>\n<p>当弹出安装程序窗口时，勾选“我同意许可条款和条件”复选框，然后单击“安装”按钮，如图所示。<br>\n</p>\n<p>同意安装框架的许可条件</p>\n<p>弹出“设置成功”的界面，表示该框架已经安装完成，单击“关闭”按钮即可。所有的框架安装均可参考本操作，如图所示。<br>\n</p>\n<p>安装框架成功</p>\n<p>步骤 4)：所需框架均安装成功后，单击 “Next（下一步）”按钮，如图所示。<br>\n</p>\n<p>所有框架安装完成</p>\n<p>步骤 5)：进入安装确认窗口，单击 “Execute（执行）”按钮，开始 MySQL 各个组件的安装，如图所示。<br>\n</p>\n<p>准备安装MySQL各个组件</p>\n<p>步骤 6)：开始安装 MySQL 文件，安装完成后在 “Status（状态）”列表下显示 “Complete（安装成功）”，如图所示。<br>\n</p>\n<p>MySQL各个组件安装成功</p>\n<h3> 3. 判断是否安装成功</h3>\n<p><strong>3.1 启动与关闭服务</strong><br>\nnet start mysql为启动服务，net stop mysql为关闭命令<br>\n</p>\n<p><strong>3.2 登录数据库</strong><br>\ncmd进入数据库的bin文件夹中<br>\n</p>\n<p>输入mysql -u root -p命令，再输入登录密码，出现以下结果代表登录成功<br>\n</p>\n<p><strong>3.3 查看数据库名称</strong><br>\n登录完成后，输入show databases<br>\n</p>\n<h2> 四、Mysql图形化工具</h2>\n<p>（1）Navicat（重点推荐）<br>\n</p>\n<p>Navicat是MySQL和MariaDB数据库管理与开发理想的解决方案。它可同时在一个应用程序上连接MySQL和MariaDB数据库。这种兼容前端为数据库提供了一个直观而强大的图形界面管理、开发和维护功能，为初级MySQL和MariaDB开发人员和专业开发人员都提供了一组全面的开发工具。</p>\n<p>（2）Induction<br>\n</p>\n<p>Induction是一款用于理解数据关系的开源管理工具，它可用来探索行/列，运行查询和数据可视化等方面。该工具支持多种数据库，包括PostgreSQL，MySQL，SQLite，Redis以及MongoDB。此外，Induction还可以通过编写添加其他新的适配器。</p>\n<p>（3）SqlWave<br>\n</p>\n<p>SQLWave是一种简单、快速且易用的MySQL客户端。用户可通过该工具轻松地连接到远程主机。SqlWave支持所有MySQL的最新版本，包括它用来管理数据库结构的所有最新功能，如工作表、视图、存储过程、函数、事件、外键和触发器等。</p>\n<h2> 五、Mysql存储引擎精讲</h2>\n<h3> 1. 存储引擎分类</h3>\n<p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。<br>\n  提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。</p>\n<h3> 2. MySQL 5.7 支持的存储引擎</h3>\n<p>MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。<br>\n  MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。<br>\n  MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。<br>\n</p>\n<h3> 3. MySQL 默认存储引擎</h3>\n<ul>\n<li>InnoDB 是系统的默认引擎，支持可靠的事务处理。</li>\n<li>使用下面的语句可以修改数据库临时的默认存储引擎</li>\n<li>SET default_storage_engine=&lt; 存储引擎名 &gt;<br>\n例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。<br>\n</li>\n</ul>\n<p>此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。</p>\n<h2> 六、Mysql数据类型介绍</h2>\n<h3> 1. 基本介绍</h3>\n<p>在 MySQL 中常见的数据类型如下：</p>\n<ol>\n<li>整数类型<br>\n包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。</li>\n<li>日期/时间类型<br>\n包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。</li>\n<li>字符串类型<br>\n包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。</li>\n<li>二进制类型<br>\n包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</li>\n</ol>\n<h3> 2. 整数类型</h3>\n<p>MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。<br>\n  MySQL 主要提供的整数类型有 <strong>TINYINT</strong>、<strong>SMALLINT</strong>、<strong>MEDIUMINT</strong>、<strong>INT</strong>、<strong>BIGINT</strong>，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。<br>\n</p>\n<p>从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。</p>\n<p>根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。<br>\n</p>\n<p>提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。</p>\n<h3> 3. 小数类型</h3>\n<p>MySQL中使用浮点数和定点数来表示小数。</p>\n<ul>\n<li>浮点类型有两种，分别是单精度浮点数（<strong>FLOAT</strong>）和双精度浮点数（<strong>DOUBLE</strong>）；定点类型只有一种，就是 <strong>DECIMAL</strong>。</li>\n<li>浮点类型和定点类型都可以用<code>(M, D)</code>来表示，其中<code>M</code>称为精度，表示总共的位数；<code>D</code>称为标度，表示小数的位数。</li>\n<li>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。</li>\n<li>下表中列出了 MySQL 中的小数类型和存储需求。<br>\n</li>\n</ul>\n<p>FLOAT 类型的取值范围如下：</p>\n<ul>\n<li>有符号的取值范围：-3.402823466E+38～-1.175494351E-38。</li>\n<li>无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。</li>\n</ul>\n<p>DOUBLE 类型的取值范围如下：</p>\n<ul>\n<li>有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。</li>\n<li>无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。</li>\n<li>提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</li>\n<li>FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。</li>\n</ul>\n<p>浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。</p>\n<p>最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p>\n<h3> 4. 日期和时间类型</h3>\n<p>MySQL中有多处表示日期的数据类型：<strong>YEAR</strong>、<strong>TIME</strong>、<strong>DATE</strong>、<strong>DTAETIME</strong>、<strong>TIMESTAMP</strong>。当只记录年信息的时候，可以只使用 YEAR 类型。</p>\n<ul>\n<li>每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。</li>\n<li>下表中列出了 MySQL 中的日期与时间类型。<br>\n</li>\n</ul>\n<p><strong>YEAR 类型</strong></p>\n<ul>\n<li>YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：</li>\n<li>以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 '1901'～'2155'。输入格式为 'YYYY' 或者 YYYY，例如，输入 '2010' 或 2010，插入数据库的值均为 2010。</li>\n<li>以 2 位字符串格式表示的 YEAR，范围为 '00' 到 '99'。'00'～'69' 和 '70'～'99' 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。'0' 与 '00' 的作用相同。插入超过取值范围的值将被转换为 2000。</li>\n<li>以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。</li>\n<li>提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 '0' 或 '00'，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。</li>\n</ul>\n<p><strong>TIME 类型</strong><br>\nTIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。</p>\n<p>TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。</p>\n<p>可以使用各种格式指定 TIME 值，如下所示。</p>\n<ul>\n<li>'D HH：MM：SS' 格式的字符串。还可以使用这些“非严格”的语法：'HH：MM：SS'、'HH：MM'、'D HH' 或 'SS'。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。</li>\n<li>'HHMMSS' 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，'101112' 被理解为'10：11：12'，但是 '106112' 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。</li>\n<li>提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 '1112' 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 '12' 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，'11：12' 表示 11：12：00，而不是 00：11：12。</li>\n</ul>\n<p><strong>DATE 类型</strong><br>\nDATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 'YYYY-MM-DD'，其中 YYYY 表示年，MM 表示月，DD 表示日。</p>\n<ul>\n<li>在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：</li>\n<li>以 'YYYY-MM-DD' 或者 'YYYYMMDD' 字符中格式表示的日期，取值范围为 '1000-01-01'～'9999-12-3'。例如，输入 '2015-12-31' 或者 '20151231'，插入数据库的日期为2015-12-31。</li>\n<li>以 'YY-MM-DD' 或者 'YYMMDD' 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：'00～69' 范围的年值转换为 '20002069'，'7099' 范围的年值转换为 '1970～1999'。例如，输入 '15-12-31'，插入数据库的日期为 2015-12-31；输入 '991231'，插入数据库的日期为 1999-12-31。</li>\n<li>以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。</li>\n<li>使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。</li>\n<li>提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，'98-11-31'、'98.11.31'、'98/11/31'和'98@11@31' 是等价的，这些值也可以正确地插入数据库。</li>\n</ul>\n<p><strong>DATETIME 类型</strong><br>\nDATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 'YYYY-MM-DD HH：MM：SS'，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。</p>\n<ul>\n<li>在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。</li>\n<li>以 'YYYY-MM-DD HH：MM：SS' 或者 'YYYYMMDDHHMMSS' 字符串格式表示的日期，取值范围为 '1000-01-01 00：00：00'～'9999-12-3 23：59：59'。例如，输入 '2014-12-31 05：05：05' 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。</li>\n<li>以 'YY-MM-DD HH：MM：SS' 或者 'YYMMDDHHMMSS' 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，'00～79' 范围的年值转换为 '2000～2079'，'80～99' 范围的年值转换为 '1980～1999'。例如，输入 '14-12-31 05：05：05'，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。</li>\n<li>以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。</li>\n<li>提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，'98-12-31 11：30：45'、'98.12.31 11+30+35'、'98/12/31 11_30_45' 和 '98@12@31 113045' 是等价的，这些值都可以正确地插入数据库。</li>\n</ul>\n<p><strong>TIMESTAMP 类型</strong><br>\nTIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01'UTC～'2038-01-19 03：14：07'UTC。在插入数据时，要保证在合法的取值范围内。<br>\n提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p>\n<ul>\n<li>TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：</li>\n<li>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；</li>\n<li>而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。<br>\n提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 '00：00：00'，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。</li>\n</ul>\n<h3> 5. 字符串类型</h3>\n<p>字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。</p>\n<ul>\n<li>MySQL中的字符串类型有 <strong>CHAR</strong>、<strong>VARCHAR</strong>、<strong>TINYTEXT</strong>、<strong>TEXT</strong>、<strong>MEDIUMTEXT</strong>、<strong>LONGTEXT</strong>、<strong>ENUM</strong>、<strong>SET</strong> 等。</li>\n<li>下表中列出了 MySQL 中的字符串数据类型，括号中的<code>M</code>表示可以为其指定长度。</li>\n</ul>\n<p>VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。</p>\n<p>例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。</p>\n<p>CHAR 和 VARCHAR 类型</p>\n<p>CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。</p>\n<p>例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。</p>\n<p>VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。</p>\n<p>例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。</p>\n<p>【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。</p>\n<p>插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求</p>\n<ul>\n<li>' ' ' ' 4字节 '' 1字节</li>\n<li>'ab' 'ab ' 4字节 'ab' 3字节</li>\n<li>'abc' 'abc ' 4字节 'abc' 4字节</li>\n<li>'abcd' 'abcd' 4字节 'abcd' 5字节</li>\n<li>'abcdef' 'abcd' 4字节 'abcd' 5字节<br>\n对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。</li>\n</ul>\n<p>TEXT 类型</p>\n<p>TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。</p>\n<ul>\n<li>TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。</li>\n<li>TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。</li>\n<li>TEXT 表示长度为 65535（216-1）字符的 TEXT 列。</li>\n<li>MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。</li>\n<li>LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。</li>\n</ul>\n<p><strong>ENUM 类型</strong><br>\nENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：</p>\n<ul>\n<li>&lt;字段名&gt; ENUM( '值1', '值1', …, '值n' )</li>\n<li>字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。</li>\n</ul>\n<p>ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。</p>\n<p>ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。</p>\n<p>例如，定义 ENUM 类型的列（'first'，'second'，'third'），该列可以取的值和每个值的索引如下表所示。</p>\n\n<p>ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。<br>\n提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。</p>\n<p><strong>SET 类型</strong><br>\nSET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：<br>\nSET( '值1', '值2', …, '值n' )<br>\n与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。</p>\n<ul>\n<li>但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</li>\n<li>提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</li>\n</ul>\n<h2> 七、Mysql主要专业名称介绍</h2>\n<h3> 1. 主键</h3>\n<p><strong>1.1 什么是主键</strong><br>\n“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p>\n<p><strong>1.2 选取设置主键约束的字段</strong><br>\n主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：</p>\n<ul>\n<li>每个表只能定义一个主键。</li>\n<li>主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。</li>\n<li>一个列名只能在复合主键列表中出现一次。</li>\n<li>复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。</li>\n</ul>\n<p><strong>1.3 创建主键</strong><br>\n语法规则：&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]<br>\n</p>\n<h3> 2. 外键约束</h3>\n<p><strong>2.1 什么是外键约束</strong><br>\n  MySQL外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。</p>\n<ul>\n<li>外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。</li>\n<li>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。</li>\n<li>外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。</li>\n</ul>\n<ul>\n<li>主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。</li>\n<li>从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。</li>\n</ul>\n<p><strong>2.2 选取设置 MySQL 外键约束的字段</strong><br>\n定义一个外键时，需要遵守下列规则：<br>\n（1）父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。<br>\n（2）必须为父表定义主键。<br>\n（3）主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。<br>\n（4）在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。<br>\n（5）外键中列的数目必须和父表的主键中列的数目相同。<br>\n（6）外键中列的数据类型必须和父表主键中对应列的数据类型相同。</p>\n<p><strong>2.3 在创建表时设置外键约束</strong><br>\n在数据表中创建外键使用 FOREIGN KEY 关键字，具体的语法规则如下：<br>\n[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]<br>\nREFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]</p>\n<p>其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。</p>\n<h3> 3. 唯一约束</h3>\n<p>MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p>\n<h3> 4. 默认值</h3>\n<p><strong>4.1 什么是默认值</strong><br>\n  “默认值（Default）”的完整称呼是“默认值约束（Default Constraint）”。MySQL默认值约束用来指定某列的默认值。<br>\n  例如女性同学较多，性别就可以默认为“女”。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为“女”。</p>\n<p><strong>4.2 在创建表时设置默认值约束</strong><br>\n创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下：<br>\n&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;<br>\n</p>\n<h3> 5. 非空约束</h3>\n<p><strong>5.1 什么是非空约束</strong><br>\n  MySQL非空约束（NOT NULL）可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。<br>\n  非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。</p>\n<p><strong>5.2 在创建表时设置非空约束</strong><br>\n创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法规则如下：<br>\n&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;<br>\n</p>\n<h3> 6. 触发器</h3>\n<p>触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，会激活促发其执行相应的操作。</p>\n<h3> 7. DML</h3>\n<p>DML（data manipulation language）数据操纵语言：<br>\n　　　　就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。</p>\n<div class=\"language-csharp line-numbers-mode\" data-ext=\"cs\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 8. DDL</h3>\n<p>DDL（data definition language）数据库定义语言：其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上</p>\n<div class=\"language-undefined line-numbers-mode\" data-ext=\"undefined\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 9. DCL</h3>\n<p>DCL（Data Control Language）数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。在公司呢一般情况下我们用到的是DDL、DML这两种。</p>\n<h2> 八、Mysql常见sql语句</h2>\n<h3> 1. select语句</h3>\n<p>请在资料下载中进行学习</p>\n<h3> 2. 函数</h3>\n<p>请在资料下载中进行学习</p>\n<h3> 3. 多表查询</h3>\n<p>请在资料下载中进行学习</p>\n<h3> 4. 表的内连与外连‘</h3>\n<p>请在资料下载中进行学习’</p>\n<h2> 九、Mysql设计与语句优化</h2>\n<h3> 1. 数据库创建优化</h3>\n<p>请在资料下载中进行学习</p>\n<h3> 2. sql语句优化</h3>\n<p>请在资料下载中进行学习</p>\n<h2> 十、事务介绍</h2>\n<h3> 1. 事务概述</h3>\n<p>事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p>\n<p>严格上来说，事务必须同时满足4个特性，即通常所说事务的ACID特性。虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的并没有严格满足事务的ACID标准。例如，对于MYSQL的NDB Cluster引擎，虽然支持事务，但是不满足D的要求，即持久性的要求。对于Oracle数据库来说，其默认的事务隔离级别为READ COMMITTED，不满足I的要求，即隔离性的要求。对于InnoDB存储引擎而言，默认的事务隔离级别是READ REPRATABLE，完全遵循和满足事务的ACID特性。</p>\n<p>A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到事务前的状态。</p>\n<p>C（consistency），一致性。一致性是指事务将数据库从一种状态转变为另一种状态。在事务的开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n<p>I（isolation），隔离性。隔离性还有其他的称呼，如并发控制、可串行化、锁。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。数据库系统中提供了一种粒度锁的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。（如果是全表锁，事务之间基本就无法实现并发，但是如果只锁住表中处理的行，可以提高事务的并发度）</p>\n<p>D（durability），持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，持久性只能从事务本身的角度来保证结果的永久性，如事务提交后，所有的变化都是永久的，即使当数据库由于崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。</p>\n<p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>\n<h3> 2. 事务分类</h3>\n<p>（1）扁平事务，最简单，使用最频繁的事务。在扁平事务中，所有的操作都处于一个层次，其有BEGIN WORK开始，有COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么全部执行，要么全部回滚。<br>\n（2）带有保存点的扁平事务，除了扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能有些事务在执行过程中出现的错误并不会对有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。<br>\n（3）链事务可视为保存点模式的一个变种。<br>\n（4）嵌套事务是一个层次结构框架。<br>\n（5）分布式事务</p>\n<h3> 3. 事务控制语句</h3>\n<p>在MYSQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。因此要显示的开启一个事务必须使用命令BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT = 0，以禁用当前会话的自动提交。事务控制语句如下：</p>\n<ul>\n<li>START TRANSACTION | BEGIN：显示的开启一个事务。在存储过程中，MYSQL数据库的分析器会自动将BEGIN识别为BEGIN...END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。</li>\n<li>COMMIT：要想使用这个语句的最简形式，只需发出COMMIT。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的。COMMIT和COMMIT WORK语句基本上是一致的，都是用来提交事务。不同的是COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制，默认该参数是0，表示没有任何操作。在这种设置下，COMMIT和COMMIT WORK是完全等价的。当参数值为1时，COMMIT WORK等价于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。当参数值为1时，COMMIT WORK等价于COMMIT AND RELEASE。当提交事务后会自动断开与服务器连接。</li>\n<li>ROLLBACK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>\n<li>SAVEPOINT identifiter：SAVEPOINT允许用户在事务中创建一个保存点，一个事务可以有很多个保存点。</li>\n<li>RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。</li>\n<li>ROLLBACK to [SAVEPOINT] identifier：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚到此标记点之前的任何工作。注意：虽然有ROLLBACK，但是它并没有真正的结束一个事务，因此即使执行了ROLLBACK TO SAVEPOINT，之后也需要显示的运行COMMIT或ROLLBACK命令。</li>\n<li>SET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</li>\n</ul>\n<h3> 4. 事务的隔离级别</h3>\n<p>ANSI SQL标准定义的四个隔离级别为：</p>\n<ul>\n<li>READ UNCOMMITTED（未提交读），事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。</li>\n<li>READ COMMITTED（提交读），一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。因为在这2次读之间可能有其他事务更改这个数据，每次读到的数据都是已经提交的。</li>\n<li>REPEATABLE READ（可重复读），解决了脏读，也保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重读读隔离级别还是无法解决另外一个幻读的问题，指的是当某个事务在读取某个范围内的记录时，另外一个事务也在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。</li>\n<li>SERIALIZABLE（可串行化），它通过强制事务串行执行，避免了前面说的幻读的问题。<br>\n1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</li>\n</ul>\n<p>2、不可重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</p>\n<p>3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。</p>\n<p>InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影的插入。</p>\n<p>隔离级别越低，事务请求的锁越少或保持锁的时间就越短。所以很多数据库系统默认的事务隔离级别是READ COMMITTED。质疑SERIALIZABLE隔离级别的性能，但是InnoDB存储引擎认为两者的开销是一样的，所以默认隔离级别使用REPEATABLE READ。</p>\n<p>用命令设置当前会话或全局会话的事务隔离级别。</p>\n<p>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL<br>\n{<br>\nREAD UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE<br>\n}<br>\n如果想启动时就设置事务的默认隔离级别，修改MYSQL的配置文件，在[mysqld]中添加如下行：</p>\n<p>[mysqld]<br>\ntransaction-isolation = READ-COMMITTED</p>\n<h2> 十一、Mysql数据库备份与恢复</h2>\n<h3> 1. 数据库备份</h3>\n<p>数据库备份是指通过导出数据或者复制表文件的方式来制作数据库的副本。当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。</p>\n<p>可以使用 SELECT INTO OUTFILE 语句把表数据导出到一个文本文件中进行备份。</p>\n<blockquote>\n<p>注意：这种方法只能导出或导入数据的内容，而不包括表的结构。若表的结构文件损坏，则必须先设法恢复原来表的结构。</p>\n</blockquote>\n<p>【实例】将数据库 test_db 的表 tb_students_info 的全部数据备份到 C 盘的数据备份目录下文件名为 file.txt 的文件中，要求每个字段用逗号分开，并且字符用双引号标注，每行以问号结束。</p>\n<p>输入的SQL语句和执行结果如下所示。</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>用记事本查看 MySQL 备份文件夹下的 file.txt 文件，内容如下图所示。<br>\n</p>\n<h3> 2. MySQL数据库恢复</h3>\n<p>数据库恢复是指以备份为基础，与备份相对应的系统维护和管理操作。</p>\n<p>系统进行恢复操作时，先执行一些系统安全性的检查，包括检查所要恢复的数据库是否存在、数据库是否变化及数据库文件是否兼容等，然后根据所采用的数据库备份类型采取相应的恢复措施。</p>\n<p>数据库恢复机制设计的两个关键问题是：第一，如何建立冗余数据；第二，如何利用这些冗余数据实施数据库恢复。</p>\n<p>建立冗余数据最常用的技术是数据转储和登录日志文件。通常在一个数据库系统中，这两种方法是一起使用的。</p>\n<p>数据转储是 DBA 定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的版本成为后备副本或后援副本。</p>\n<p>可使用 LOAD DATA…INFILE 语句来恢复先前备份的数据。</p>\n<p>【实例】将之前导出的数据备份文件 file.txt 导入数据库 test_db 的表 tb_students_copy 中，其中 tb_students_copy 的表结构和 tb_students_info 相同。</p>\n<p>首先创建表 tb_students_copy，输入的 SQL 语句和执行结果如下所示：</p>\n<div class=\"language-css line-numbers-mode\" data-ext=\"css\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>导入数据与查询表 tb_students_copy 的过程如下所示：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 十二、Mysql分库分表</h2>\n<h3> 1. 分库分表原则</h3>\n<p>关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像Web和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为Sharding、分片）。同时，流行的分布式系统中间件（例如MongoDB、ElasticSearch等）均自身友好支持Sharding，其原理和思想都是大同小异的。</p>\n<ul>\n<li>目前针对海量数据的优化，其分库分表是MySQL永远的话题，一般情况下认为MySQL是个简单的数据库，在数据量大到一定程度之后处理查询的效率降低，如果需要继续保持高性能运转的话，必须分库或者分表了。关于数据量达到多少大是个极限这个事儿，本文先不讨论，研究源码的同学已经证实MySQL或者Innodb内部的锁粒度太大的问题大大限制了MySQL提供QPS的能力或者处理大规模数据的能力。在这点上，一般的使用者只好坐等官方不断推出的优化版本了。</li>\n<li>在一般运维的角度来看，我们什么情况下需要考虑分库分表？</li>\n<li>首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。</li>\n</ul>\n<p><strong>1.1 能不分就不分</strong><br>\n  MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。</p>\n<p><strong>1.2 数据量太大，正常的运维影响正常业务访问</strong><br>\n这里说的运维，例如：<br>\n（1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。<br>\n（2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。<br>\n（3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。</p>\n<p><strong>1.3 某些数据表出现了无穷增长</strong><br>\n  例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。</p>\n<p><strong>1.4 安全性和可用性的考虑</strong><br>\n  这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。</p>\n<p><strong>1.5 业务耦合性考虑</strong><br>\n  这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。</p>\n<h3> 2. 分库分表方案</h3>\n<p><strong>2.1 垂直拆分（垂直分表）</strong><br>\n垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：<br>\n</p>\n<p><strong>2.2 垂直拆分（垂直分库）</strong><br>\n垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br>\n</p>\n<p>小结：<br>\n系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。<br>\n众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。<br>\n然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。<br>\n优势：降低高并发情况下，对于表的锁定。<br>\n不足：对于单表来说，随着数据库的记录增多，读写压力将进一步增大。</p>\n<p><strong>2.3 水平拆分（水平分表）</strong><br>\n水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：<br>\n</p>\n<p>如果单表的IO压力大，可以考虑用水平分割，其原理就是通过hash算法，将一张表分为N多页，并通过一个新的表（总表），记录着每个页的的位置。假如一个门户网站，它的数据库表已经达到了1000万条记录，那么此时如果通过select去查询，必定会效率低下（不做索引的前提下）。为了降低单表的读写IO压力，通过水平分割，将这个表分成10个页，同时生成一个总表，记录各个页的信息，那么假如我查询一条id=100的记录，它不再需要全表扫描，而是通过总表找到该记录在哪个对应的页上，然后再去相应的页做检索，这样就降低了IO压力。</p>\n<p>当下分表有静态分表和动态分表两种：</p>\n<ul>\n<li>静态分表：事先估算出表能达到的量，然后根据每一个表需要存多少数据直接算出需要创建表的数量。如：1亿数据每一个表100W条数据那就要建100张表，然后通过一定的hash算法计算每一条数据存放在那张表。其实就有点像是使用partition table一样。静态分表有一个毙命就是当分的那么多表还不满足时，需要再扩展难度和成本就会很高。</li>\n<li>动态分表：同样也是对大数据量的表进行拆分，他可以避免静态分表带来的后遗症。当然也需要在设计上多一些东西（这往往是我们能接受的）。<br>\n某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）</li>\n</ul>\n<h3> 3. 分库分表难点</h3>\n<p><strong>3.1 跨库join的问题</strong><br>\n在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。<br>\n跨库Join的几种解决思路：</p>\n<ul>\n<li>全局表\n<ul>\n<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>\n</ul>\n</li>\n<li>字段冗余\n<ul>\n<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。</li>\n<li>举个电商业务中很简单的场景：</li>\n<li>“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。</li>\n<li>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？</li>\n</ul>\n</li>\n<li>数据同步\n<ul>\n<li>定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。</li>\n</ul>\n</li>\n<li>系统层组装\n<ul>\n<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。具体情况通常会比较复杂。</li>\n</ul>\n</li>\n</ul>\n<p><strong>3.2 跨库事务（分布式事务）的问题</strong><br>\n按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。想要了解分布式事务，就需要了解“XA接口”和“两阶段提交”。值得提到的是，MySQL5.5x和5.6x中的xa支持是存在问题的，会导致主从数据不一致。直到5.7x版本中才得到修复。Java应用程序可以采用Atomikos框架来实现XA事务（J2EE中JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》</p>\n<p>根据系统架构和公司实际情况来，如果你们的系统还是个简单的单体应用，并且没有什么访问量和数据量，那就别着急折腾“垂直分库”了，否则没有任何收益，也很难有好结果。<br>\n切记，“过度设计”和“过早优化”是很多架构师和技术人员常犯的毛病。</p>\n<h2> 十三、Mysql权限管理</h2>\n<h3> 1. MySQL权限简介</h3>\n<p>关于mysql的权限简单的理解就是mysql允许你做你全力以内的事情，不可以越界。比如只允许你执行select操作，那么你就不能执行update操作。只允许你从某台机器上连接mysql，那么你就不能从除那台机器以外的其他机器连接mysql。<br>\n  那么Mysql的权限是如何实现的呢？这就要说到mysql的两阶段验证，下面详细介绍：第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、某个IP、某个IP段、以及任何地方等，只允许你从配置的指定地方登陆。第二阶段：如果你能连接，Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。比如你要更新某个表、或者查询某个表，Mysql会查看你对哪个表或者某个列是否有权限。再比如，你要运行某个存储过程，Mysql会检查你对存储过程是否有执行权限等。</p>\n<h3> 2. Mysql权限种类</h3>\n<figure><figcaption>img_68.png</figcaption></figure>\n<figure><figcaption>img_69.png</figcaption></figure>\n<figure><figcaption>img_71.png</figcaption></figure>\n<figure><figcaption>img_70.png</figcaption></figure>\n<h3> 3. MySQL权限经验原则</h3>\n<p>权限控制主要是出于安全因素，因此需要遵循一下几个经验原则：<br>\n（1）只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。<br>\n（2）创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。<br>\n（3）初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码。<br>\n（4）为每个用户设置满足密码复杂度的密码。<br>\n（5）定期清理不需要的用户。回收权限或者删除用户。</p>\n<h2> 十四、Mysql数据库之阿里云</h2>\n<h3> 1. 简介</h3>\n<p>经过上面的学习，大家已经对mysql数据库的知识有了很深的了解，我们也知道，一个数据库在实际生产环境中，会面临许多的问题，比如Sql语句审计、sql读写分离、sql备份与恢复、数据库的权限管理、数据库的高可用等等，对于创业公司来讲，数据库是非常重要的，但是花费了很多人力物力去满足这个事情，那么还不如直接使用成熟的第三方平台，比如阿里云的mysql数据库产品。</p>\n<h3> 2. 阿里云数据库产品功能</h3>\n<p><strong>2.1 数据库创建</strong><br>\n</p>\n<p><strong>2.2 连接管理与读写分离</strong><br>\n</p>\n<figure><figcaption>img_74.png</figcaption></figure>\n<p><strong>2.3 监控与报警</strong></p>\n<p>我们可以在线监控到CPU、内存、磁盘、IOPS、网络流量等的使用情况，并设置报警规则<br>\n</p>\n<p><strong>2.4 白名单</strong></p>\n<p>我们可以设置允许连接数据库的IP白名单，以保障数据库连接安全<br>\n</p>\n<p><strong>2.5 服务可用性</strong><br>\n阿里云的数据库可包含高可用，主备切换、主从备份等<br>\n</p>\n<p><strong>2.6 日志管理</strong><br>\n日志管理包括订阅同步、错误日志、慢日志分析、主备切换日志<br>\n</p>\n<p><strong>2.7 SQL洞察</strong><br>\n对sql语句的操作进行记录，包括操作的数据库名、数据库语句、操作时间、客户端IP等信息<br>\n</p>\n<p><strong>2.8 性能优化</strong><br>\n阿里云提供诊断报告、资源分析、SQL分析等服务<br>\n</p>\n<p><strong>2.9 备份恢复</strong><br>\n</p>\n",
      "date_published": "2024-04-16T01:53:26.000Z",
      "date_modified": "2024-04-17T01:10:40.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Redis",
      "url": "https://ujava.cn/assembly/redis.html",
      "id": "https://ujava.cn/assembly/redis.html",
      "summary": "NoSQL:即Not-OnlySQL(泛指非关系型的数据库)，作为关系型数据库的补充。 作用:应对基于海量用户和海量数据前提下的数据处理问题。 Redis介绍 概念 Redis(REmote DlctionaryServer)是用C语言开发的一个开源的高性能键值对(key-value)数据库 特征 1.数据间没有必然的关联关系 2.内部采用单线程机制进行工作 3.高性能 4.支持多种数据类型 5.支持持久化，可以存硬盘。 应用",
      "content_html": "<p>NoSQL:即Not-OnlySQL(泛指非关系型的数据库)，作为关系型数据库的补充。<br>\n作用:应对基于海量用户和海量数据前提下的数据处理问题。</p>\n<h2> Redis介绍</h2>\n<h4> 概念</h4>\n<p>Redis(REmote DlctionaryServer)是用C语言开发的一个开源的高性能键值对(key-value)数据库</p>\n<h4> 特征</h4>\n<p>1.数据间没有必然的关联关系</p>\n<p>2.内部采用单线程机制进行工作</p>\n<p>3.高性能</p>\n<p>4.支持多种数据类型</p>\n<p>5.支持持久化，可以存硬盘。</p>\n<h4> 应用</h4>\n<p>热点信息，时效性信息，分布式数据共享，消息队列，即使信息查询。</p>\n<h3> 在虚拟机上启动redis服务</h3>\n<p>通过指定的配置文件启动redis服务，</p>\n<ol>\n<li>查看进程：ps -ef | grep redis</li>\n<li>进入配置文件的目录cd /usr/local/redis/bin/</li>\n<li>输入 ./redis-server redis.conf</li>\n<li>输入 ./redis-cli</li>\n<li>关闭服务并退出：shutdown 然后：exit</li>\n</ol>\n<h3> 键值对</h3>\n<p>设置键值对</p>\n<p>​ 语法：set key value</p>\n<p>获取键值对</p>\n<p>​ 语法：get key</p>\n<p>判断键是否存在：exist key</p>\n<p><strong>设置过期时间</strong>： expire key 时间</p>\n<p>查看过期时间： ttl key</p>\n<p>查看当前key的数据类型：&gt; type key</p>\n<p>删除key：del key</p>\n<h3> 库</h3>\n<p>redis共有16个库</p>\n<h4> 选择数据库</h4>\n<p>语法：select 数字</p>\n<h4> 查看</h4>\n<p>查看大小：dbsize</p>\n<p>查看数据库所有的键：keys *</p>\n<h4> 清空</h4>\n<p>清空当前数据库：flushdb</p>\n<p>清空所有：flushall</p>\n<h3> 基本数据类型</h3>\n<h4> String</h4>\n<p>追加字符串，不存在则新建：append key1 \"hello\"</p>\n<p>获取字符串长度：strlen key1</p>\n<p>初始浏览量为0 ：set views 0</p>\n<p>设置自增1：incr views</p>\n<p>设置自减1：decr views</p>\n<p>可以设置步长。每次的增长值 : INCRBY views 10 #</p>\n<p>获取指定范围的值: GETRANGE key 起始点 结束点</p>\n<p>获取所有长度的值: GETRANGE key 0 -1</p>\n<p>设置多个值:</p>\n<p>mset key value key value ……</p>\n<p>mget key key key</p>\n<p>msetnx 原子性操作设置多个值</p>\n<p><strong>设置过期时间和值:</strong></p>\n<p>设置key3 的值为 he11o,30秒后过期: setex key3 30 \"he1lo\"</p>\n<p>先get然后在set: getset</p>\n<h2> List</h2>\n<p>LPuSH key value</p>\n<p>LPUSH list one #将一个值或者多个值，插入到列表头部(左)</p>\n<p>RPUSH key value</p>\n<p>Rpush list righr #将一个值或者多个值，插入到列表位部(右)</p>\n<p>lrange key start end</p>\n<p>LRANGE list 0 1 #通过区间获取具体的值!</p>\n<p>LROR key #移出并获取列表的第一个元素</p>\n<p>lindex list 1 #通过下标获得list 中的某一个值!</p>\n<p>Llen list # 返回列表的长度</p>\n<p>lrem key count value</p>\n<p>lrem list 1 one # 移除list集合中指定个数的value，精确匹配</p>\n<p>ltrim list 1 2 #截取指定的长度!</p>\n<p>lset 将列表中指定下标的值替换为另外一个值，更新操作</p>\n<p>lset list 0 item #如果存在，更新当前下标的值</p>\n<p>在指定元素前后插入指定的值</p>\n<p>LINSERT mylist after world new</p>\n<h2> set</h2>\n<p>set集合中添加</p>\n<p>sadd key value</p>\n<p>sadd myset \"hello\"</p>\n<p>查看指定set的所有值</p>\n<p>smembers key</p>\n<p>SMEMBERS myset</p>\n<p>判断某一个值是不是在set集合中!</p>\n<p>sismember key value</p>\n<p>SISMEMBER myset hello</p>\n<p>查看个数</p>\n<p>scard key</p>\n<p>scard myset</p>\n<p>移除set集合中的指定元素</p>\n<p>srem key value</p>\n<p>srem myset hello</p>\n<p>获取随机</p>\n<p>SRANDMEMBER myset</p>\n<p>SRANDMEMBER myset 2</p>\n<p>smove myset myset2 \"kuangshen\"# 将一个指定的值，移动到另外一个set集合!</p>\n<p>SDIFF key1 key2 差集</p>\n<p>SINTER key1 key2 交集</p>\n<p>SUNION key1 key2 并集</p>\n<h2> hash</h2>\n<p>hset 集合名 key value</p>\n<p>hset myhash field1 hello</p>\n<h1> set一个具体key-vlaue</h1>\n<p>获取一个字段值</p>\n<p>hget 集合名 key键</p>\n<p>hget myhash field1</p>\n<p>添加多个 key-vlaue</p>\n<p>hmset 集合 key键1 key键2</p>\n<p>hmset myhash field1 hello field2 world</p>\n<p>获取多个字段值</p>\n<p>hmget 集合名 key1 key2</p>\n<p>hmget myhash field1 field2</p>\n<p>获取全部的数据</p>\n<p>hget 集合名</p>\n<p>hgetall myhash</p>\n<p>删除hash指定key字段!对应的value值也就消失了!</p>\n<p>hdel 集合名 key</p>\n<p>hdel myhash field1</p>\n<p>判断hash中指定字段是否存在!</p>\n<p>HEXISTS myhash field1</p>\n<p>只获得所有field</p>\n<p>hkeys 集合名</p>\n<p>hkeys myhash</p>\n<p>只获得所有value</p>\n<p>hvals 集合名</p>\n<p>hvals myhash</p>\n<p>设置自动增长</p>\n<p>HINCRBY myhash field3 1</p>\n<p>HINCRBY myhash field3 -1</p>\n<p>如果不存在则可以设置</p>\n<p>hsetnx myhash field4 hello</p>\n<p>如果存在则不能设置</p>\n<p>hsetnx myhash field4 world</p>\n<h2> zset</h2>\n<p>zset在set的基础上增加了一个值，set k1 v1 zset k1 score1 v1</p>\n<p>添加一个值</p>\n<p>zadd key score value</p>\n<p>zadd myset 1 one</p>\n<p>添加多个值</p>\n<p>zadd myset 2 two 3 three</p>\n<p>获取范围值</p>\n<p>zrange key start end</p>\n<p>zrange myset 0 -1</p>\n<p>显示全部内容从小到大</p>\n<p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>\n<p>移除元素</p>\n<p>zrem key value</p>\n<hr>\n<h2> 特殊数据类型</h2>\n<h3> 地理位置geostital</h3>\n<p>创建一个元素</p>\n<p>geoadd key 纬度 经度 成员</p>\n<p>geoadd city 116.40 39.90 beijing</p>\n<p>获取坐标</p>\n<p>geopos city beijing</p>\n<p>获取两者之间的距离</p>\n<p>geodist key value1 value2 单位</p>\n<p>geodist city beijing shanghai km</p>\n<p>相关范围内的城市</p>\n<p>georadius key 纬度 经度 距离 单位 withdist</p>\n<p>找出指定位置内的其他元素</p>\n<p>georadiusbymember key value 距离 单位</p>\n<h3> bitmaps</h3>\n<p>位存储</p>\n<p>统计用户信息，活跃，不活跃!登录、未登录!打卡，365打卡!两个状态的，都可以使用Bitmaps!</p>\n<p>Bitmaps位图，数据结构!都是操作二进制位来进行记录，就只有0和1两个状态!</p>\n<p>365天=365 bit 1字节=8bit46个字节左右!</p>\n<p>设置一个元素</p>\n<p>setbit key offset value</p>\n<p>查看</p>\n<p>getbit sign offset</p>\n<hr>\n<h2> 事务</h2>\n<p>Redis 事务本质:一组命令的集合!一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行! 一次性、顺序性、排他性!执行一系列的命令!</p>\n<p>Redis命令保证原子性，但是事务不保证原子性！</p>\n<p>redis事务：</p>\n<p>1 开启事务：开启一个事务</p>\n<blockquote>\n<p>multi</p>\n</blockquote>\n<p>2 命令入队：将命令放入事务</p>\n<blockquote>\n<p>set key value</p>\n</blockquote>\n<p>3 执行事务：执行事务中的命令</p>\n<blockquote>\n<p>exec</p>\n</blockquote>\n<p>4 取消事务:事务中的命令都不会被执行</p>\n<blockquote>\n<p>discard</p>\n</blockquote>\n<p>eg：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果在入队的命令中有错误的命令，</p>\n<p>如果是编译时异常，那么所有命令都不会被执行。</p>\n<p>如果是运行时异常，那么其他命令正常执行，仅有错误的命令抛出错误信息。</p>\n<hr>\n<h2> 锁</h2>\n<h4> 悲观锁</h4>\n<p>很悲观，什么时候都要加锁。</p>\n<h4> 乐观锁</h4>\n<p>很乐观，认为什么时候都不会出问题，所以不会上锁!更新数据的时候去判断一下，在此期间是否有人修改过这个数据，<br>\n获取version<br>\n更新的时候比较version</p>\n<p>使用watch命令当作redis的乐观锁操作</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>unwatch</p>\n</blockquote>\n<p>如果发现事务执行失败，就先解锁</p>\n<hr>\n<h2> jedis</h2>\n<p>Jedis是redis的java版本的客户端实现，使用Jedis提供的Java API对Redis进行操作，是Redis官方推崇的方式；并且，使用Jedis提供的对Redis的支持也最为灵活、全面；不足之处，就是编码复杂度较高。</p>\n<h4> 导入依赖</h4>\n<figure><figcaption>img_84.png</figcaption></figure>\n<h4> 简单语法：</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2> SpringBoot整合</h2>\n<figure><figcaption>img_83.png</figcaption></figure>\n<p><strong>修改配置文件：</strong></p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><strong>测试：</strong></p>\n<p>redisTemplate 操作不同的数据类型，api和我们的指令是一样的<br>\nopsForValue 操作字符串 类似String<br>\nopsForList 操作List 类似List<br>\nopsForSet<br>\nopsForHash<br>\nopsForzset<br>\nopsForGeo<br>\nopsForHyperLogLog</p>\n<p>除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</p>\n<h4> 获取redis的连接对象</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 配置自己的序列化方式</h4>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><hr>\n<h2> Redis配置文件</h2>\n<p>redis里的单位配置，忽略大小写。</p>\n<blockquote>\n<p><strong>导入其他配置文件：</strong></p>\n</blockquote>\n<h1> include /path/to/local.conf</h1>\n<h1> include /path/to/other.conf</h1>\n<blockquote>\n<p>网络</p>\n</blockquote>\n<p>bind 127.0.0.1 #绑定的ip</p>\n<p>protected-mode yes #保护模式<br>\nport 6379 #端口设置</p>\n<blockquote>\n<p>通用 general</p>\n</blockquote>\n<p>daemonize yes #以守护进程的方式运行，默认是no，我们需要自己开启为yes!</p>\n<p>pidfile /var/run/redis_6379.pid #如果以后台的方式运行，我们就需要指定一个pid 文件!</p>\n<p>#日志</p>\n<p>#specify the server verbosity level.</p>\n<p>#This can be one of:</p>\n<p>#debug (a lot of information, useful for development/testing)</p>\n<p>#verbose (many rarely useful info, but not a mess like the debug level)</p>\n<p>#notice (moderately verbose, what you want in production probably) #生产环境</p>\n<p>#warning (only very important / critical messages are 1ogged)</p>\n<p>loglevel notice</p>\n<p>logfile,\"\" #日志的文件位置名</p>\n<p>databases 16 #数据库的数量，默认是16个数据库</p>\n<p>always-show-logo yes #是否总是显示LOGO</p>\n<h2> 持久化</h2>\n<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof<br>\nredis是内存数据库，如果没有持久化，那么数据断电及失!</p>\n<blockquote>\n<p>RDB配置：</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p><strong>设置密码</strong></p>\n</blockquote>\n<p>获取当前的密码：config get requirepass</p>\n<p>设置redis的密码：config set requirepass \"123456\"</p>\n<p>使用密码进行登录: auth 123456</p>\n<blockquote>\n<p>客户端</p>\n</blockquote>\n<p>设置能连接上redis的最大客户端的数量 : maxclients 10000</p>\n<p>redis 配置最大的内存容量: maxmemory (bytes)</p>\n<p>maxmemory-policy noeviction #内存到达上限之后的处理策略</p>\n<p>1、volatile-lru:只对设置了过期时间的key进行LRU(默认值)<br>\n2、al1keys-lru:删除1ru算法的key<br>\n3、volatile-random:随机删除即将过期key<br>\n4、a11keys-random:随机删除<br>\n5、volatile-ttl:删除即将过期的<br>\n6、noeviction :永不过期，返回错误</p>\n<blockquote>\n<p>触发机制</p>\n</blockquote>\n<p>1、save的规则满足的情况下，会自动触发rdb规则<br>\n2、执行 flushall命令，也会触发我们的rdb规则!<br>\n3、退出redis，也会产生rdb文件!<br>\n备份就自动生成一个dump</p>\n<blockquote>\n<p>如何恢复rdb文件</p>\n</blockquote>\n<p>1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的内容<br>\n2、查看需要存在的位置</p>\n<p>config get dir</p>\n<p>1)\"dir\"<br>\n2)\"/usr/local/bin\" # 如果在这个目录下存在dump.rdb 文件，启动就会自动恢复其中的数据</p>\n<p>优点:<br>\n1、适合大规模的数据恢复!<br>\n2、对数据的完整性要不高!<br>\n缺点:<br>\n1、需要一定的时间间隔进程操作!如果redis意外宕机了，这个最后一次修改数据就没有的了<br>\n2、fork进程的时候，会占用一定的内容空间!!</p>\n<blockquote>\n<p>AOF配置</p>\n</blockquote>\n<p>appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用!</p>\n<p>appendfilename \"appendonly.aof\" #持久化的文件的名字</p>\n<p>appendfsync always #每次修改都会 sync。消耗性能<br>\nappendfsync everysec #每秒执行一次sync，可能会丢失这1s的数据!</p>\n<p>appendfsync no #不执行 sync，这个时候操作系统自己同步数据，速度最快!</p>\n<blockquote>\n<p>搜索配置文件内容：</p>\n</blockquote>\n<p>vim 文件</p>\n<p>:/搜索内容 n下一个</p>\n<p>如果这个 aof 文件有错误，这时候redis 是启动不起来的吗，我们需要修复这个aof文件redis 给我们提供了一个工具 redis-check-aof --fix</p>\n<h3> 消息订阅</h3>\n<p>关注消息后，消息发出者可以发出订阅者都收到的消息。</p>\n<blockquote>\n<p>发送端：</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><blockquote>\n<p>接收端</p>\n</blockquote>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> redis主从复制</h2>\n<p>主从复制，读写分离!80%的情况下都是在进行读操作!减缓服务器的压力!架构中经常使用!一主二从!</p>\n<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>\n<p>注意：只配从库不配主库</p>\n<p>查看当前库的信息： info replication</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以测试：</p>\n<p>复制3个配置文件，然后修改对应的信息<br>\n1、端口<br>\n2、pid 名字<br>\n3、log文件名字<br>\n4、dump.rdb 名字</p>\n<p>默认情况下，每台Redis服务器都是主节点</p>\n<p>配置从节点，认老大：</p>\n<blockquote>\n<p>Slaveof host port</p>\n</blockquote>\n<p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的!</p>\n<p>主机负责写，从机负责读</p>\n<p>Slave 启动成功连接到master后会发送一个sync同步命令</p>\n<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送</p>\n<p>整个数据文件到slave，并完成一次完全同步。</p>\n<p>全量复制:而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>\n<p>增量复制:Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>\n<p>但是只要是重新连接master，一次完全同步(全量复制)将被自动执行</p>\n",
      "date_published": "2024-04-16T01:53:26.000Z",
      "date_modified": "2024-04-17T03:53:01.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Spring",
      "url": "https://ujava.cn/assembly/spring.html",
      "id": "https://ujava.cn/assembly/spring.html",
      "content_html": "",
      "date_published": "2024-04-16T01:53:26.000Z",
      "date_modified": "2024-04-16T01:53:26.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件ZooKeeper",
      "url": "https://ujava.cn/assembly/zookeeper.html",
      "id": "https://ujava.cn/assembly/zookeeper.html",
      "summary": "一、Zookeeper简介 Zookeeper 是一个开源的分布式协调服务，目前由 Apache 进行维护。Zookeeper 可以用于实现分布式系统中常见的发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。它具有以下特性： 顺序一致性：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中； 原子性：所有事务请求的处理结果在整个集群中所有机器上都是一致的；不存在部分机器应用了该事务，而另一部分没有应用的情况； 单一视图：所有客户端看到的服务端数据模型都是一致的； 可靠性：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改； 实时性：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据。",
      "content_html": "<h3> 一、Zookeeper简介</h3>\n<p>Zookeeper 是一个开源的分布式协调服务，目前由 Apache 进行维护。Zookeeper 可以用于实现分布式系统中常见的发布/订阅、负载均衡、命令服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。它具有以下特性：</p>\n<ul>\n<li>\n<p><strong>顺序一致性</strong>：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</p>\n</li>\n<li>\n<p><strong>原子性</strong>：所有事务请求的处理结果在整个集群中所有机器上都是一致的；不存在部分机器应用了该事务，而另一部分没有应用的情况；</p>\n</li>\n<li>\n<p><strong>单一视图</strong>：所有客户端看到的服务端数据模型都是一致的；</p>\n</li>\n<li>\n<p><strong>可靠性</strong>：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</p>\n</li>\n<li>\n<p><strong>实时性</strong>：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据。</p>\n</li>\n</ul>\n<h3> 二、Zookeeper设计目标</h3>\n<p>Zookeeper 致力于为那些高吞吐的大型分布式系统提供一个高性能、高可用、且具有严格顺序访问控制能力的分布式协调服务。它具有以下四个目标：</p>\n<h3> 2.1 目标一：简单的数据模型</h3>\n<p>Zookeeper 通过树形结构来存储数据，它由一系列被称为 ZNode 的数据节点组成，类似于常见的文件系统。不过和常见的文件系统不同，Zookeeper 将数据全量存储在内存中，以此来实现高吞吐，减少访问延迟。<br>\n</p>\n<h3> 2.2 目标二：构建集群</h3>\n<p>可以由一组 Zookeeper 服务构成 Zookeeper 集群，集群中每台机器都会单独在内存中维护自身的状态，并且每台机器之间都保持着通讯，只要集群中有半数机器能够正常工作，那么整个集群就可以正常提供服务。<br>\n</p>\n<h3> 2.3 目标三：顺序访问</h3>\n<p>对于来自客户端的每个更新请求，Zookeeper 都会分配一个全局唯一的递增 ID，这个 ID 反映了所有事务请求的先后顺序。</p>\n<h3> 2.4 目标四：高性能高可用</h3>\n<p>ZooKeeper 将数据存全量储在内存中以保持高性能，并通过服务集群来实现高可用，由于 Zookeeper 的所有更新和删除都是基于事务的，所以其在读多写少的应用场景中有着很高的性能表现。</p>\n<h3> 三、核心概念</h3>\n<h3> 3.1 集群角色</h3>\n<p>Zookeeper 集群中的机器分为以下三种角色：</p>\n<ul>\n<li>\n<p><strong>Leader</strong>&nbsp;：为客户端提供读写服务，并维护集群状态，它是由集群选举所产生的；</p>\n</li>\n<li>\n<p><strong>Follower</strong>&nbsp;：为客户端提供读写服务，并定期向 Leader 汇报自己的节点状态。同时也参与写操作“过半写成功”的策略和 Leader 的选举；</p>\n</li>\n<li>\n<p><strong>Observer</strong>&nbsp;：为客户端提供读写服务，并定期向 Leader 汇报自己的节点状态，但不参与写操作“过半写成功”的策略和 Leader 的选举，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p>\n</li>\n</ul>\n<h3> 3.2 会话</h3>\n<p>Zookeeper 客户端通过 TCP 长连接连接到服务集群，会话 (Session) 从第一次连接开始就已经建立，之后通过心跳检测机制来保持有效的会话状态。通过这个连接，客户端可以发送请求并接收响应，同时也可以接收到 Watch 事件的通知。</p>\n<p>关于会话中另外一个核心的概念是 sessionTimeOut(会话超时时间)，当由于网络故障或者客户端主动断开等原因，导致连接断开，此时只要在会话超时时间之内重新建立连接，则之前创建的会话依然有效。</p>\n<h3> 3.3 数据节点</h3>\n<p>Zookeeper 数据模型是由一系列基本数据单元&nbsp;<code>Znode</code>(数据节点) 组成的节点树，其中根节点为&nbsp;<code>/</code>。每个节点上都会保存自己的数据和节点信息。Zookeeper 中节点可以分为两大类：</p>\n<ul>\n<li>\n<p><strong>持久节点</strong>&nbsp;：节点一旦创建，除非被主动删除，否则一直存在；</p>\n</li>\n<li>\n<p><strong>临时节点</strong>&nbsp;：一旦创建该节点的客户端会话失效，则所有该客户端创建的临时节点都会被删除。</p>\n</li>\n</ul>\n<p>临时节点和持久节点都可以添加一个特殊的属性：<code>SEQUENTIAL</code>，代表该节点是否具有递增属性。如果指定该属性，那么在这个节点创建时，Zookeeper 会自动在其节点名称后面追加一个由父节点维护的递增数字。</p>\n<h3> 3.4 节点信息</h3>\n<p>每个 ZNode 节点在存储数据的同时，都会维护一个叫做&nbsp;<code>Stat</code>&nbsp;的数据结构，里面存储了关于该节点的全部状态信息。如下：<br>\n</p>\n<h3> 3.5 Watcher</h3>\n<p>Zookeeper 中一个常用的功能是 Watcher(事件监听器)，它允许用户在指定节点上针对感兴趣的事件注册监听，当事件发生时，监听器会被触发，并将事件信息推送到客户端。该机制是 Zookeeper 实现分布式协调服务的重要特性。</p>\n<h3> 3.6 ACL</h3>\n<p>Zookeeper 采用 ACL(Access Control Lists) 策略来进行权限控制，类似于 UNIX 文件系统的权限控制。它定义了如下五种权限：</p>\n<ul>\n<li>\n<p><strong>CREATE</strong>：允许创建子节点；</p>\n</li>\n<li>\n<p><strong>READ</strong>：允许从节点获取数据并列出其子节点；</p>\n</li>\n<li>\n<p><strong>WRITE</strong>：允许为节点设置数据；</p>\n</li>\n<li>\n<p><strong>DELETE</strong>：允许删除子节点；</p>\n</li>\n<li>\n<p><strong>ADMIN</strong>：允许为节点设置权限。</p>\n</li>\n</ul>\n<h3> 四、ZAB协议</h3>\n<h3> 4.1 ZAB协议与数据一致性</h3>\n<p>ZAB 协议是 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。通过该协议，Zookeeper 基于主从模式的系统架构来保持集群中各个副本之间数据的一致性。具体如下：</p>\n<p>Zookeeper 使用一个单一的主进程来接收并处理客户端的所有事务请求，并采用原子广播协议将数据状态的变更以事务 Proposal 的形式广播到所有的副本进程上去。如下图：<br>\n</p>\n<p>具体流程如下：</p>\n<p>所有的事务请求必须由唯一的 Leader 服务来处理，Leader 服务将事务请求转换为事务 Proposal，并将该 Proposal 分发给集群中所有的 Follower 服务。如果有半数的 Follower 服务进行了正确的反馈，那么 Leader 就会再次向所有的 Follower 发出 Commit 消息，要求将前一个 Proposal 进行提交。</p>\n<h3> 4.2 ZAB协议的内容</h3>\n<p>ZAB 协议包括两种基本的模式，分别是崩溃恢复和消息广播：</p>\n<h3> 1. 崩溃恢复</h3>\n<p>当整个服务框架在启动过程中，或者当 Leader 服务器出现异常时，ZAB 协议就会进入恢复模式，通过过半选举机制产生新的 Leader，之后其他机器将从新的 Leader 上同步状态，当有过半机器完成状态同步后，就退出恢复模式，进入消息广播模式。</p>\n<h3> 2. 消息广播</h3>\n<p>ZAB 协议的消息广播过程使用的是原子广播协议。在整个消息的广播过程中，Leader 服务器会每个事物请求生成对应的 Proposal，并为其分配一个全局唯一的递增的事务 ID(ZXID)，之后再对其进行广播。具体过程如下：</p>\n<p>Leader 服务会为每一个 Follower 服务器分配一个单独的队列，然后将事务 Proposal 依次放入队列中，并根据 FIFO(先进先出) 的策略进行消息发送。Follower 服务在接收到 Proposal 后，会将其以事务日志的形式写入本地磁盘中，并在写入成功后反馈给 Leader 一个 Ack 响应。当 Leader 接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 以通知其进行事务提交，之后 Leader 自身也会完成对事务的提交。而每一个 Follower 则在接收到 Commit 消息后，完成事务的提交。<br>\n</p>\n<h3> 五、Zookeeper的典型应用场景</h3>\n<p>5.1 数据的发布/订阅</p>\n<p>数据的发布/订阅系统，通常也用作配置中心。在分布式系统中，你可能有成千上万个服务节点，如果想要对所有服务的某项配置进行更改，由于数据节点过多，你不可逐台进行修改，而应该在设计时采用统一的配置中心。之后发布者只需要将新的配置发送到配置中心，所有服务节点即可自动下载并进行更新，从而实现配置的集中管理和动态更新。</p>\n<p>Zookeeper 通过 Watcher 机制可以实现数据的发布和订阅。分布式系统的所有的服务节点可以对某个 ZNode 注册监听，之后只需要将新的配置写入该 ZNode，所有服务节点都会收到该事件。</p>\n<p>5.2 命名服务</p>\n<p>在分布式系统中，通常需要一个全局唯一的名字，如生成全局唯一的订单号等，Zookeeper 可以通过顺序节点的特性来生成全局唯一 ID，从而可以对分布式系统提供命名服务。</p>\n<p>5.3 Master选举</p>\n<p>分布式系统一个重要的模式就是主从模式 (Master/Salves)，Zookeeper 可以用于该模式下的 Matser 选举。可以让所有服务节点去竞争性地创建同一个 ZNode，由于 Zookeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，这样该服务节点就可以成为 Master 节点。</p>\n<p>5.4 分布式锁</p>\n<p>可以通过 Zookeeper 的临时节点和 Watcher 机制来实现分布式锁，这里以排它锁为例进行说明：</p>\n<p>分布式系统的所有服务节点可以竞争性地去创建同一个临时 ZNode，由于 Zookeeper 不能有路径相同的 ZNode，必然只有一个服务节点能够创建成功，此时可以认为该节点获得了锁。其他没有获得锁的服务节点通过在该 ZNode 上注册监听，从而当锁释放时再去竞争获得锁。锁的释放情况有以下两种：</p>\n<p>当正常执行完业务逻辑后，客户端主动将临时 ZNode 删除，此时锁被释放；</p>\n<p>当获得锁的客户端发生宕机时，临时 ZNode 会被自动删除，此时认为锁已经释放。</p>\n<p>当锁被释放后，其他服务节点则再次去竞争性地进行创建，但每次都只有一个服务节点能够获取到锁，这就是排他锁。</p>\n<p>5.5 集群管理</p>\n<p>Zookeeper 还能解决大多数分布式系统中的问题：</p>\n<p>如可以通过创建临时节点来建立心跳检测机制。如果分布式系统的某个服务节点宕机了，则其持有的会话会超时，此时该临时节点会被删除，相应的监听事件就会被触发。</p>\n<p>分布式系统的每个服务节点还可以将自己的节点状态写入临时节点，从而完成状态报告或节点工作进度汇报。</p>\n<p>通过数据的订阅和发布功能，Zookeeper 还能对分布式系统进行模块的解耦和任务的调度。</p>\n<p>通过监听机制，还能对分布式系统的服务节点进行动态上下线，从而实现服务的动态扩容。</p>\n",
      "date_published": "2024-04-16T01:53:26.000Z",
      "date_modified": "2024-04-23T00:41:57.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "MySQL慢查询",
      "url": "https://ujava.cn/synthesis/mysqlslow.html",
      "id": "https://ujava.cn/synthesis/mysqlslow.html",
      "summary": "简介 MySQL服务器处理查询请求的整个过程： 客户端发送SQL强求给服务器 服务器检查是否可以在查询缓存中命中该SQL 服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划 根据执行计划，调用存储引擎API来查询数据 将结果返回给客户端 查询性能低下最基本的原因是访问的数据太多。 一、如何优化慢查询？ 1，首先开启慢查询日志： long_query_time（多长时间视为慢查询） slow_query_log（是否开启了慢查询日志，off表示未开启） slow_query_log_file（慢查询日志存放的位置）",
      "content_html": "<h2> 简介</h2>\n<p>MySQL服务器处理查询请求的整个过程：</p>\n<ul>\n<li>客户端发送SQL强求给服务器</li>\n<li>服务器检查是否可以在查询缓存中命中该SQL</li>\n<li>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划</li>\n<li>根据执行计划，调用存储引擎API来查询数据</li>\n<li>将结果返回给客户端<br>\n查询性能低下最基本的原因是访问的数据太多。</li>\n</ul>\n<h2> 一、如何优化慢查询？</h2>\n<p>1，首先开启慢查询日志：</p>\n<ul>\n<li>long_query_time（多长时间视为慢查询）</li>\n<li>slow_query_log（是否开启了慢查询日志，off表示未开启）</li>\n<li>slow_query_log_file（慢查询日志存放的位置）</li>\n</ul>\n<p>2.慢查询优化思路：<br>\n</p>\n<figure><figcaption>img_140.png</figcaption></figure>\n<figure><figcaption>img_141.png</figcaption></figure>\n<figure><figcaption>img_142.png</figcaption></figure>\n<p>3，分析慢查询语句，来进行相应的优化</p>\n<ul>\n<li>①建立索引</li>\n<li>②减少表之间的关联</li>\n<li>③优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引，把数据量大的表排在前面</li>\n<li>④简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>\n</ul>\n<h2> 二、数据库优化的方法：</h2>\n<p>1，SQL语句优化：</p>\n<ul>\n<li>①应该尽量避免在where子句中使用！=或者&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>\n<li>②应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用而进行全表扫描</li>\n<li>③很多时候，用exits代替in是一个很好的选择</li>\n<li>④用where子句替代having子句，因为having只会在检索出所有记录之后才对结果集进行过滤</li>\n</ul>\n<p>2，索引优化：</p>\n<ul>\n<li>①为经常出现在关键字order by，group by，distinct后面的字段，建立索引</li>\n<li>②为经常用作where查询选择的字段，建立索引</li>\n<li>③在经常用作表连接的属性上建立索引</li>\n<li>④更新非常频繁的字段不适合建立索引</li>\n</ul>\n<p>3，数据库结构优化：</p>\n<ul>\n<li>①范式优化（如消除冗余，节省空间）</li>\n<li>②反范式化优化（适当增加冗余）</li>\n<li>③拆分表（不同分区的数据可以指定保存在处于不同磁盘上的数据文件里）</li>\n<li>④拆分又分为垂直拆分和水平拆分</li>\n</ul>\n<p>4，服务器硬件优化（对花钱）</p>\n<h2> 三、MySQL查询优化（0其实这个概念比较偏小，上一道题的概念比较偏大）：</h2>\n<ul>\n<li>应该尽量避免全表扫描，首先应考虑哎where及order by涉及的列上建索引</li>\n<li>尽量避免在where子句中对字段进行null值判断</li>\n<li>尽量避免在where子句中使用or来连接条件</li>\n<li>尽量避免在where子句中使用！=或&lt;&gt;操作符</li>\n<li>in和not in也要慎用</li>\n<li>%aa%应尽量避免</li>\n<li>尽量避免在where子句中对字段进行表达式操作</li>\n<li>在where子句中使用参数慎用</li>\n<li>尽量避免在where子句中进行函数操作</li>\n<li>不要在where子句中的“=”左边进行函数算术运算或其他表达式运算</li>\n<li>若使用复合索引，则必须使用到该索引中的第一个字段作为条件时才能保证系统使用索引</li>\n<li>不要写无意义的查询，select…from…where 0=1</li>\n<li>用exists代替in是一个很好的选择</li>\n<li>建立索引时要慎重（并不是越多越好）</li>\n<li>应尽量避免更新cluster（索引数据列）</li>\n<li>尽量使用数字型字段（尽量不要设计为字符型）</li>\n<li>尽量使用varchar/nvaechar代替char/nchar，因为变长字段存储空间小</li>\n<li>尽量避免select * from t</li>\n<li>尽量使用表变量来代替临时表</li>\n</ul>\n<h2> 四、为什么Like以%开头索引会失效 ？</h2>\n<p>like失效的原因：</p>\n<ul>\n<li>%在右：由于B+树的索引顺序，是按照首字母的大小进行排序，%号在右的匹配又是匹配首字母，所以可以在B+树上进行有序的查找，查找首字母符合要求的数据。</li>\n<li>%在左：是匹配字符串尾部的数据，我们上面说了排序规则，尾部的字母是没有顺序的，所以不能按照索引顺序查询，就用不到索引。</li>\n<li>两个%号：这个查询任意位置的字母满足条件即可，只有首字母是进行索引排序的，其他位置的字母都是相对无序的，所以查找任意位置的字母是用不上索引的。</li>\n</ul>\n<p>解决%出现在左边索引失效的方法，使用覆盖索引。</p>\n<h2> 五、select * 为什么禁止使用？</h2>\n<p>为了说明这个问题，我们需要建一个表:</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们创建了一个存储引擎为InnoDB的表user_innodb，并设置id为主键，另外为name和phone创建了联合索引，最后向表中随机初始化了500W+条数据。</p>\n<p>InnoDB会自动为主键id创建一棵名为主键索引（又叫做聚簇索引）的B+树，这个B+树的最重要的特点就是叶子节点包含了完整的用户记录，大概长这个样子：</p>\n<figure><figcaption>img_143.png</figcaption></figure>\n<p>如果我们执行这个语句：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用EXPLAIN查看一下语句的执行计划：</p>\n<figure><figcaption>img_144.png</figcaption></figure>\n<p>发现这个SQL语句会使用到IDX_NAME_PHONE索引，这是一个二级索引。二级索引的叶子节点长这个样子：</p>\n<figure><figcaption>img_145.png</figcaption></figure>\n<p>InnoDB存储引擎会根据搜索条件在该二级索引的叶子节点中找到name为蝉沐风的记录，但是二级索引中只记录了name、phone和主键id字段（谁让我们用的是SELECT *呢），因此InnoDB需要拿着主键id去主键索引中查找这一条完整的记录，这个过程叫做回表。</p>\n<p>想一下，如果二级索引的叶子节点上有我们想要的所有数据，是不是就不需要回表了呢？是的，这就是覆盖索引。</p>\n<p>举个例子，我们恰好只想搜索name、phone以及主键字段。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>使用EXPLAIN查看一下语句的执行计划：</p>\n<figure><figcaption>img_146.png</figcaption></figure>\n<p>可以看到Extra一列显示Using index，表示我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是使用了覆盖索引，能够直接摒弃回表操作，大幅度提高查询效率。</p>\n<p>小总结及问题：</p>\n<p>1.select * from 表 where name = “蝉沐风” 与 select id,name,gender,phone from 表 where name = “蝉沐风” 效率一样吗？</p>\n<p>答：一样；因为只是在name和phone建立了联合索引，根据上面的分析，<br>\n可以看到二级索引中的树的情况，叶子节点中只有name、phone、id ;<br>\n但是叶子节点中没有gender这个字段 ，<br>\n想要获得这个gender字段，必须根据二级索引得到id，<br>\n然后根据id去查主键索引得到id，name、gender、phone等所有字段。<br>\nselect * 也是类似的。所以两个的效率是一样的。</p>\n",
      "date_published": "2024-04-15T11:10:22.000Z",
      "date_modified": "2024-04-15T11:10:22.000Z",
      "authors": [],
      "tags": [
        "设计综合"
      ]
    },
    {
      "title": "设计原则",
      "url": "https://ujava.cn/base/theory.html",
      "id": "https://ujava.cn/base/theory.html",
      "summary": "一、单一职责原则 单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。 单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。 单一职责原则的好处： 类的复杂性降低，实现什么职责都有清晰明确的定义； 可读性提高，复杂性降低，那当然可读性提高了； 可维护性提高，可读性提高，那当然更容易维护了； 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。",
      "content_html": "<h2> 一、单一职责原则</h2>\n<p>单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。</p>\n<p>单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。</p>\n<p>单一职责原则的好处：</p>\n<ul>\n<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>\n<li>可读性提高，复杂性降低，那当然可读性提高了；</li>\n<li>可维护性提高，可读性提高，那当然更容易维护了；</li>\n<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>\n</ul>\n<p>注意： 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p>\n<p>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>\n<h2> 二、里氏替换原则</h2>\n<p>里氏替换原则（Liskov Substitution Principle，LSP），有两种定义：</p>\n<ul>\n<li>\n<p>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P<br>\ndefined in terms of T ,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p>\n</li>\n<li>\n<p>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes<br>\nwithout knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>\n</li>\n<li>\n<p>第二个定义是最清晰明确的，通俗点讲，只要父类出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必就能适应。</p>\n</li>\n</ul>\n<p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义：</p>\n<ul>\n<li>子类必须完全实现父类的方法；\n<ul>\n<li>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则；</li>\n<li>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</li>\n</ul>\n</li>\n<li>子类可以有自己的个性；</li>\n<li>覆盖或实现父类的方法时输入参数可以被放大；\n<ul>\n<li>如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴；</li>\n<li>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</li>\n</ul>\n</li>\n<li>覆写或实现父类的方法时输出结果可以被缩小。\n<ul>\n<li>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。</li>\n</ul>\n</li>\n</ul>\n<p>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续执行。</p>\n<h2> 三、依赖倒置原则</h2>\n<p>依赖倒置原则（Dependence Inversion Principle,DIP）,原始定义是：High level modules should not depend upon low level<br>\nmodules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon<br>\nabstractions.</p>\n<p>包含三层含义：</p>\n<ul>\n<li>高层模块不应该依赖底层模块，两者都应该依赖抽象；</li>\n<li>抽象不应该依赖细节；</li>\n<li>细节应该依赖抽象。 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。</li>\n</ul>\n<p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。依赖倒置原则在Java语言中的表现就是：</p>\n<p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p>\n<p>接口或抽象类不依赖于实现类；</p>\n<p>实现类依赖接口或抽象类。 更加精简的定义就是“面向接口编程”--OOD（Object-Oriented Design，面向对象设计）的精髓之一。</p>\n<p>依赖的三种写法：</p>\n<p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D。。。。。。生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p>\n<p>对象的依赖关系有三种方式来传递：</p>\n<ul>\n<li>\n<p>构造函数传递依赖对象 --- 在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。</p>\n</li>\n<li>\n<p>Setter方法传递依赖对象 --- 在抽象中设置Setter方法声明依赖关系，依照注入的说法，这是Setter依赖注入。</p>\n</li>\n<li>\n<p>在接口的方法中声明依赖对象，这种方式也叫做接口注入。<br>\n依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的规则就可以：</p>\n</li>\n<li>\n<p>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备； --- 这是依赖倒置的基本要求，接口或抽象类都是属于抽象的，有了抽象才可能依赖倒置。</p>\n</li>\n<li>\n<p>变量的表面类型尽量是接口或者是抽象类；</p>\n</li>\n<li>\n<p>任何类都不应该从具体类派生；</p>\n</li>\n<li>\n<p>尽量不要覆写基类的方法； --- 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。</p>\n</li>\n<li>\n<p>结合里氏替换原则使用。 --- 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</p>\n</li>\n</ul>\n<h2> 四、接口隔离原则</h2>\n<p>接口分为两种：</p>\n<ul>\n<li>\n<p>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的食物的描述，这是一种接口。</p>\n</li>\n<li>\n<p>类接口（Class Interface），Java中经常使用的interface关键字定义的接口；</p>\n</li>\n<li>\n<p>Clients should not be forced to depend upon interfaces that they don‘t use。（客户端不应该依赖它不需要的接口。）</p>\n</li>\n<li>\n<p>The dependency of one class to another one should depend on the smallest possible interface。（类间的依赖关系应该建立在最小的接口上。）<br>\n接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p>\n</li>\n<li>\n<p>接口要尽量小； --- 这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。</p>\n</li>\n<li>\n<p>接口要高内聚； --- 高内聚就是提高接口、类、模块的处理能力，减少对外的交互。在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也越有利于降低成本。</p>\n</li>\n<li>\n<p>定制服务； ---  一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务。定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。</p>\n</li>\n<li>\n<p>接口设计是有限度的。 --- 接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断？根据经验和常识判断，没有一个固话或可测量的标准。</p>\n</li>\n</ul>\n<p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：</p>\n<ul>\n<li>一个接口只服务于一个模块或业务逻辑；</li>\n<li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</li>\n<li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</li>\n<li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</li>\n</ul>\n<h2> 五、迪米特法则</h2>\n<p>迪米特法则（Law of Demeter ，LoD）也称为最少知识原则（Least Knowledge<br>\nPrinciple，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>\n<p>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义：</p>\n<ul>\n<li>只和朋友交流 --- 迪米特法则还有一个英文解释是：Only talk to your immedate<br>\nfriends（只与直接的朋友通信。）什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。注意：一个类只和朋友交流，不与陌生类交流，不要出现getA()<br>\n.getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点后面返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK<br>\nAPI提供的类除外。</li>\n<li>朋友间也是有距离的 --- 一个类公开的public属性或方法越多，修改时涉及的面积越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected<br>\n等访问权限，是否可以加上final关键字等。<br>\n注意：迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</li>\n<li>是自己的就是自己的 --- 如果一个方法放在本类中，即不增加类间的关系，也对本类不产生负面影响，就放置在本类中。</li>\n<li>谨慎使用Serializable</li>\n</ul>\n<p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。</p>\n<p>迪米特法则要求类间解耦，但解耦是有限度的，除非是计算机的最小单元——二进制的0和1。那才是完全解耦，在实际的项目中，需要适度地考虑这个原则，别为了套用原则而做项目。原则只是供参考，如果违背了这个原则，项目也未必会失败，这就需要大家在采用原则时反复度量，不遵循是不对的，严格执行就是“过犹不及”。</p>\n<h2> 六、开放封闭原则</h2>\n<p>开放封闭原则的定义：Software entities like classes, modules and functions should be open for extension but closed for<br>\nmodifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）其含义是说一个软件实体应该通过扩展来实现变化。软实体包括以下几个部分：</p>\n<ul>\n<li>项目或软件产品中按照一定的逻辑规则划分的模块；</li>\n<li>抽象和类；</li>\n<li>方法。</li>\n</ul>\n<p>一个软件产品只要在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。开放封闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。</p>\n<p>开放封闭原则对扩展开放，对修改封闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。我们可以把变化归纳以下三种类型：</p>\n<ul>\n<li>逻辑变化； -- 只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是 a<em>b+c ，现在需要修改为 a</em>b*c ，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖关系都按照相同的逻辑处理。</li>\n<li>子模块变化； --- 一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层次模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的。</li>\n<li>可见视图变化 --- 可见视图是提供给客户使用的界面，如JSP程序、Swing界面等，该部分的变化一般会引起连锁反应（特别是在国内做项目，做欧美的外包项目一般不会影响太大）。如果仅仅是界面上按钮、文字的重新排列倒是简单，最司空见惯的是业务耦合变化，什么意思？一个展示数据的列表，按照原有的需求是6列，突然有一天要增加1列，而且这一列要跨N张表，处理M个逻辑才能展现出来，这样的变化是比较恐怖的，但还是可以通过扩展来完成变化，这就要看我们原有的设计是否灵活。</li>\n</ul>\n<p><strong>为什么要采用开放封闭原则</strong>：</p>\n<p>每个事物的诞生都有它存在的必要性，存在即合理，那开闭原则的存在也是合理的，为什么这么说呢？</p>\n<p>首先，开闭原则是那么地著名，只要是做面向对象编程的，甭管是什么语言，Java也好，C++也好，或者是Smalltalk，在开发时都会提及开闭原则。</p>\n<p>其次，开闭原则是最基础的一个原则，前面介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。换一个角度理解，依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类，开闭原则在面向对象设计领域中的地位就类似于牛顿第一定律在力学、勾股定律在几何学、质能方程在狭义相对论中的地位，其地位无人能及。</p>\n<p>最后，开闭原则是非常重要的，可通过以下几个方面来理解其重要性。</p>\n<p>1、开闭原则对测试的影响</p>\n<p>所有已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经过“千锤百炼”的测试过程，不仅保证逻辑是正确的，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码（Poisonous<br>\nCode）”，因此有变化提出时，我们就需要考虑一下，原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试，现在虽然在大力提倡自动化测试工具，但是仍然代替不了人工的测试工作。</p>\n<p>2、 开闭原则可以提高复用性</p>\n<p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什么要复用呢？减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码，然后发出对开发人员“极度失望”的感概。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。</p>\n<p>3、开闭原则可以提高可维护性</p>\n<p>一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂代码原有的代码，然后再修改，是一件很痛苦的事情，不要让他在原有的代码海洋里游戈完毕后再修改，那是对维护人员的一种折磨和摧残。</p>\n<p>4、面向对象开发的要求</p>\n<p>万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。</p>\n<p><strong>如何使用开闭原则</strong></p>\n<p>1、抽象约束</p>\n<p>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。</p>\n<p>2、元数据（metadata）控制模块行为</p>\n<p>编程时使用元数据来控制程序的行为，减少重复开发。用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据中库中获得。</p>\n<p>3、制定项目章程</p>\n<p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。相信大家都做过项目，会发现一个项目会产生非常多的配置文件。以SSH项目开发为例，一个项目中Bean配置文件就非常多，管理非常麻烦。如果需要扩展，就需要增加子类，并修改SpringContext文件。然而，如果你在项目中指定这样一个章程：所有的Bean都自动注入，使用Annotation进行装配，进行扩展时，甚至只用写一个类，然后由持久层生成对象，其他的都不需要修改，这就需要项目内约束，每个项目成员都必须遵守，该方法需要一个团队有较高的自觉性，需要一个较长时间的磨合，一旦项目成员都熟悉这样的规则，比通过接口或抽象类进行的约束效率更高，而且扩展性一点也没有减少。</p>\n<p>4、封装变化</p>\n<p>对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protected<br>\nvariations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装，23个设计模式都是从各个不同的角度对变化进行封装的，我们会在各个模式中逐步讲解。</p>\n",
      "date_published": "2024-04-15T07:11:10.000Z",
      "date_modified": "2024-04-15T07:18:48.000Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "UML图",
      "url": "https://ujava.cn/base/uml.html",
      "id": "https://ujava.cn/base/uml.html",
      "summary": "简介 众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。 软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有 7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。 在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。",
      "content_html": "<h2> 简介</h2>\n<p>众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。</p>\n<p>软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有<br>\n7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>\n<p>在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。</p>\n<p>下面我们将探讨如何绘制这 7 种模型图，以及如何在不同阶段使用这些模型来生成相应的设计文档。</p>\n<h2> 类图</h2>\n<p>类图是软件设计中使用最广泛的 UML 图形之一，用来描述类的特性以及类之间的静态关系。在一个类图中，每个类都由三个部分组成：类名、属性列表和方法列表。</p>\n<p>除了描述类的基本特征，类图还用来表示类之间的关系，其中包括六种静态关系：</p>\n<p>关联（Association）：表示一个类对象与另一个类对象之间的关系，比如订单与客户之间的关系。</p>\n<p>依赖（Dependency）：表示一个类对另一个类的使用或调用，比如客户下订单时需要使用订单类。</p>\n<p>组合（Composition）：表示一种包含关系，表示一个类对象包含另一个类对象，比如一个订单包含多个商品。</p>\n<p>聚合（Aggregation）：也表示一种包含关系，但是聚合关系中包含的类对象可以被多个类共享，比如一个学校包含多个班级。</p>\n<p>继承（Inheritance）：表示一个类继承自另一个类，可以从父类中继承属性和方法，并且可以添加新的属性和方法。</p>\n<p>泛化（Generalization）：与继承关系相似，但泛化关系可以用来表示更抽象的关系，比如多个类都实现了一个接口。</p>\n<p>通过绘制类图，我们可以清晰地描述一个软件系统中的类及其之间的关系，帮助开发人员更好地理解软件系统的结构和功能。</p>\n<p>在UML工具中把相关的一组类及其关系用一张图画出来，就是类图。</p>\n<p><br>\n如上图所示，描述的就是一个典型的责任链模式的实现类图。</p>\n<p>类图主要是在 详细设计<br>\n阶段画，一旦类图设计完成，开发工程师可以根据类图来实现代码。只要类方法的逻辑不是太复杂，不同工程师实现的代码几乎是一样的，这有利于保证软件的规范和统一性。在实际应用中，通常不需要画出所有类的类图，只需要画出核心、代表性、技术难度较高的类图即可。</p>\n<p><br>\n除了在详细设计阶段绘制类图外，还可以在需求分析阶段使用类图来表示关键领域模型对象。在这个阶段中，我们不要将注意力集中在属性或行为上，而应该专注于识别领域对象及其之间的关系。因此，可以使用简化的类图来描述，只需要绘制类的名称和它们之间的关系即可。</p>\n<p>如上所示描述的是在需求分析阶段挖掘出SIM卡、运营商、手机、手机厂商等模型对象之间的关系。</p>\n<h2> 序列图</h2>\n<p>类图之外，另一种常用的图形是序列图。</p>\n<p>类图描述类之间的静态关系，而序列图用于描述参与者之间的动态调用关系。每个参与者都有一条垂直向下的生命线，该生命线用虚线表示。参与者之间的消息按照从上到下的顺序表示它们的调用顺序关系，这就是序列图这个词的来源。每个生命线都有一个激活条，它是图中的细长矩形条，只有在参与者活动时才是激活的。</p>\n<figure><figcaption>3.png</figcaption></figure>\n<p>通常使用序列图表示对象之间的交互，这些对象可以是类对象，也可以是更大的参与者，如组件、服务器、子系统等。总之，只要涉及到不同参与者之间的交互，都可以使用序列图，比如下面这张图就是业务分析阶段，系统建设后完成后的业务流程。</p>\n<figure><figcaption>4.png</figcaption></figure>\n<p>记住，在软件设计的不同阶段都可以使用序列图。</p>\n<h2> 组件图</h2>\n<p>组件是比类更大粒度的设计元素，通常一个组件中包含多个类。组件图有时与包图的用途相似，通常用于描述物理组件，如JAR、DLL等。在实践中，我们更多地使用组件图进行模块设计。</p>\n<figure><figcaption>5.png</figcaption></figure>\n<p>组件图描述组件之间的静态关系，主要是依赖关系。如果想要描述组件之间的动态调用关系，可以使用组件序列图，以组件作为参与者，描述组件之间的消息调用关系。</p>\n<p>由于组件的粒度较大，通常用于描述和设计软件的模块及其之间的关系。因此，在设计的早期阶段就需要画出组件图，一般用于架构设计阶段。</p>\n<h2> 部署图</h2>\n<p>部署图描述的是软件系统最终的物理部署情况，包括需要部署的服务器数量、关键组件的部署位置等。它是软件系统最终呈现的物理蓝图，能够让客户、老板和工程师清晰地了解系统的最终运行状态，以及与现有系统和第三方服务器的关系。通过部署图，可以预估服务器和第三方软件的采购成本。</p>\n<p>因此，部署图是整个软件设计模型中相当宏观的一种图，需要在设计早期就绘制。各方可以根据部署图讨论是否认可该方案，只有对部署图达成共识，才能继续后面的细节设计。部署图主要用于架构设计阶段，并且与组件图要彼此呼应。<br>\n</p>\n<h2> 用例图</h2>\n<p>用例图分为业务用例和系统用例，业务用例图主要体现在 业务分析阶段， 描述一个承建系统的组织对外提供的能力，系统用例体现在需求分析阶段描述系统对外提供的能力。</p>\n<figure><figcaption>7.png</figcaption></figure>\n<p>这张图中，左边是业务用例图，右边是系统用例图。虽然它们的画法相似，但它们本质上有很大的区别，具体可以查看我之前写的这篇文章。</p>\n<p>图中的人形元素称为角色，角色可以是人也可以是其他系统。由于系统的功能可能很复杂，用例图可能仅包含其中的一小部分功能，这些功能被画在一个矩形框内，这个矩形框是用例边界。矩形框里面的椭圆表示单个功能，它们可以相互依赖或需要扩展。因为用例图中的功能描述相对简单，所以通常需要配以文字说明以形成需求文档。</p>\n<h2> 状态图</h2>\n<p>状态图用来展现单个对象生命周期中的状态变迁。</p>\n<p>在业务系统中，许多重要的领域对象都有相当复杂的状态变化，比如订单，它们可以有待付款、待审核、待发货、待收货、交易关闭和交易完成等各种状态。</p>\n<p>这些状态变化可以在用例图中用文本形式描述，并随着各个用户的不同操作而改变。但是，使用这种方法描述状态时，状态会分散到不同的地方，这样可能会导致开发错误以及产品经理在设计时的困惑。</p>\n<p>采用UML状态图可以有效地解决这些问题，因为它可以在一张图表中展示对象的整个生命周期以及各个状态和变迁之间的关系。比如下面的图表展示了一个订单从创建到交易完成的状态变化。</p>\n<figure><figcaption>8.png</figcaption></figure>\n<p>状态图要在需求分析阶段画，描述状态变迁的逻辑关系，在详细设计阶段也要画，这个时候，状态要用枚举值表示，以指导具体的开发。</p>\n<h2> 活动图</h2>\n<p>活动图常用于描述系统或业务流程中的动态行为。它可以清晰地展现从一个活动到另一个活动的控制流，描绘出系统或业务流程的逻辑和流程，让开发人员更好地了解整个系统的运作方式。</p>\n<p>在活动图中，实心圆表示流程的开始，空心圆表示流程的结束，圆角矩形表示活动，菱形表示分支判断。这些符号的使用能够使活动图更加规范化和可读性，有助于提高系统开发的效率和质量。</p>\n<figure><figcaption>9.png</figcaption></figure>\n<p>此外，活动图引入了一个重要的概念——泳道。活动图可以根据活动的范围，将活动根据领域、系统和角色等划分到不同的泳道中，使流程边界更加清晰。</p>\n<p>流程图也比较有普适性，可以在需求分析阶段描述业务流程，也可以在架构设计阶段描述子系统和组件的交互，还可以在详细设计阶段描述一个类方法内部的计算流程。</p>\n<p>使用合适的 UML 模型构建一个设计文档<br>\nUML 模型图本身并不难掌握，但如何在正确的场合下用适当的 UML 模型表达设计意图，形成一套清晰且详细的软件模型，并在团队内外达成共识的设计文档则需要注意。</p>\n<p>根据软件设计不同阶段的需要，我们可以使用不同的模型图进行建模。</p>\n<p>在需求分析阶段，我们可以使用用例图、活动图、时序图和简化的类图进行领域模型抽象和关系描述。</p>\n<p>在架构设计阶段，通过组件图、组件时序图和部署图描述系统物理蓝图和模块关系。</p>\n<p>在详细设计阶段，主要侧重于类图和类的时序图，而对于复杂的方法逻辑，可以使用方法的活动图进行描述。</p>\n<h2> 小结</h2>\n<p>掌握类图、时序图、组件图、部署图、用例图、状态图、活动图这七种UML模型图，根据实际场景，在需求分析、架构设计和详细设计阶段选择并巧妙应用对应的模型图，有助于有效地进行软件建模和系统设计，成为一个掌控大局、指导技术团队的优秀架构师。</p>\n<p>要注意模型图的规范和注释，遵循命名规范，对模型元素进行命名，注释模型元素的关系和属性等，简洁明了。此外，UML模型图只是设计文档的一部分，需要与其他文档相结合，如需求文档、设计文档、测试文档等，形成一个完整的设计文档，指导软件开发。</p>\n<p>对于画UML的工具，有收费的专业软件设计工具像EA(Enterprise Architect)、Astah和亿图，<a href=\"http://xn--draw-955fn1koi57ny3ibkg51n9w4beb3a3cyhe2c.io\" target=\"_blank\" rel=\"noopener noreferrer\">以及免费的在线工具比如draw.io</a>，processon等，建议可以根据自身需要选择合适的工具，同时也建议从简单易用的工具入手。</p>\n",
      "date_published": "2024-04-15T07:11:10.000Z",
      "date_modified": "2024-04-15T07:11:10.000Z",
      "authors": [],
      "tags": [
        "设计基础"
      ]
    },
    {
      "title": "组件Netty",
      "url": "https://ujava.cn/assembly/netty.html",
      "id": "https://ujava.cn/assembly/netty.html",
      "summary": "一、Netty 简介 Netty 是基于 Java NIO 的异步事件驱动的网络应用框架，使用 Netty 可以快速开发网络应用，Netty 提供了高层次的抽象来简化 TCP 和 UDP 服务器的编程，但是你仍然可以使用底层的 API。 Netty 的内部实现是很复杂的，但是 Netty 提供了简单易用的API从网络处理代码中解耦业务逻辑。Netty 是完全基于 NIO 实现的，所以整个 Netty 都是异步的。 Netty 是最流行的 NIO 框架，它已经得到成百上千的商业、商用项目验证，许多框架和开源组件的底层 rpc 都是使用的 Netty，如 Dubbo、Elasticsearch 等等。下面是官网给出的一些 Netty 的特性：",
      "content_html": "<h2> 一、Netty 简介</h2>\n<p>Netty 是基于 Java NIO 的异步事件驱动的网络应用框架，使用 Netty 可以快速开发网络应用，Netty 提供了高层次的抽象来简化 TCP 和 UDP 服务器的编程，但是你仍然可以使用底层的 API。</p>\n<p>Netty 的内部实现是很复杂的，但是 Netty 提供了简单易用的API从网络处理代码中解耦业务逻辑。Netty 是完全基于 NIO 实现的，所以整个 Netty 都是异步的。</p>\n<p>Netty 是最流行的 NIO 框架，它已经得到成百上千的商业、商用项目验证，许多框架和开源组件的底层 rpc 都是使用的 Netty，如 Dubbo、Elasticsearch 等等。下面是官网给出的一些 Netty 的特性：</p>\n<p>设计方面</p>\n<ul>\n<li>\n<p>对各种传输协议提供统一的 API（使用阻塞和非阻塞套接字时候使用的是同一个 API，只是需要设置的参数不一样）。</p>\n</li>\n<li>\n<p>基于一个灵活、可扩展的事件模型来实现关注点清晰分离。</p>\n</li>\n<li>\n<p>高度可定制的线程模型——单线程、一个或多个线程池。</p>\n</li>\n<li>\n<p>真正的无数据报套接字（UDP）的支持（since 3.1）。<br>\n易用性</p>\n</li>\n<li>\n<p>完善的 Javadoc 文档和示例代码。</p>\n</li>\n<li>\n<p>不需要额外的依赖，JDK 5 (Netty 3.x) 或者 JDK 6 (Netty 4.x) 已经足够。<br>\n性能</p>\n</li>\n<li>\n<p>更好的吞吐量，更低的等待延迟。</p>\n</li>\n<li>\n<p>更少的资源消耗。</p>\n</li>\n<li>\n<p>最小化不必要的内存拷贝。<br>\n安全性</p>\n</li>\n<li>\n<p>完整的 SSL/TLS 和 StartTLS 支持</p>\n</li>\n<li>\n<p>对于初学者，上面的特性我们在脑中有个简单了解和印象即可， 下面开始我们的实战部分。</p>\n</li>\n</ul>\n<h2> 二、一个简单 Http 服务器</h2>\n<p>开始前说明下我这里使用的开发环境是 IDEA+Gradle+Netty4，当然你使用 Eclipse 和 Maven 都是可以的，然后在 Gradle 的 build 文件中添加依赖 compile 'io.netty:netty-all:4.1.26.Final'，这样就可以编写我们的 Netty 程序了，正如在前面介绍 Netty 特性中提到的，Netty 不需要额外的依赖。</p>\n<p>第一个示例我们使用 Netty 编写一个 Http 服务器的程序，启动服务我们在浏览器输入网址来访问我们的服务，便会得到服务端的响应。功能很简单，下面我们看看具体怎么做？</p>\n<p>首先编写服务启动类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在编写 Netty 程序时，一开始都会生成 NioEventLoopGroup 的两个实例，分别是 bossGroup 和 workerGroup，也可以称为 parentGroup 和 childGroup，为什么创建这两个实例，作用是什么？可以这么理解，bossGroup 和 workerGroup 是两个线程池, 它们默认线程数为 CPU 核心数乘以 2，bossGroup 用于接收客户端传过来的请求，接收到请求后将后续操作交由 workerGroup 处理。</p>\n<p>接下来我们生成了一个服务启动辅助类的实例 bootstrap，boostrap 用来为 Netty 程序的启动组装配置一些必须要组件，例如上面的创建的两个线程组。channel 方法用于指定服务器端监听套接字通道 NioServerSocketChannel，其内部管理了一个 Java NIO 中的ServerSocketChannel实例。</p>\n<p>channelHandler 方法用于设置业务职责链，责任链是我们下面要编写的，责任链具体是什么，它其实就是由一个个的 ChannelHandler 串联而成，形成的链式结构。正是这一个个的 ChannelHandler 帮我们完成了要处理的事情。</p>\n<p>接着我们调用了 bootstrap 的 bind 方法将服务绑定到 8080 端口上，bind 方法内部会执行端口绑定等一系列操，使得前面的配置都各就各位各司其职，sync 方法用于阻塞当前 Thread，一直到端口绑定操作完成。接下来一句是应用程序将会阻塞等待直到服务器的 Channel 关闭。</p>\n<p>启动类的编写大体就是这样了，下面要编写的就是上面提到的责任链了。如何构建一个链，在 Netty 中很简单，不需要我们做太多，代码如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们自定义一个类 HttpServerInitializer 继承 ChannelInitializer 并实现其中的 initChannel方法。</p>\n<p>ChannelInitializer 继承 ChannelInboundHandlerAdapter，用于初始化 Channel 的 ChannelPipeline。通过 initChannel 方法参数 sc 得到 ChannelPipeline 的一个实例。</p>\n<p>当一个新的连接被接受时， 一个新的 Channel 将被创建，同时它会被自动地分配到它专属的 ChannelPipeline。</p>\n<p>ChannelPipeline 提供了 ChannelHandler 链的容器，推荐读者仔细自己看看 ChannelPipeline 的 Javadoc，文章后面也会继续说明 ChannelPipeline 的内容。</p>\n<p>Netty 是一个高性能网络通信框架，同时它也是比较底层的框架，想要 Netty 支持 Http（超文本传输协议），必须要给它提供相应的编解码器。</p>\n<p>所以我们这里使用 Netty 自带的 Http 编解码组件 HttpServerCodec 对通信数据进行编解码，HttpServerCodec 是 HttpRequestDecoder 和 HttpResponseEncoder 的组合，因为在处理 Http 请求时这两个类是经常使用的，所以 Netty 直接将他们合并在一起更加方便使用。所以对于上面的代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>我们替换成如下两行也是可以的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>通过 addLast 方法将一个一个的 ChannelHandler 添加到责任链上并给它们取个名称（不取也可以，Netty 会给它个默认名称），这样就形成了链式结构。在请求进来或者响应出去时都会经过链上这些 ChannelHandler 的处理。</p>\n<p>最后再向链上加入我们自定义的 ChannelHandler 组件，处理自定义的业务逻辑。下面就是我们自定义的 ChannelHandler。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>至此一个简单的 Http 服务器就完成了。首先我们来看看效果怎样，我们运行 HttpServer 中的 main 方法。让后使用 Postman 这个工具来测试下，使用 post 请求方式（也可以 get，但没有请求体），并一个 json 格式数据作为请求体发送给服务端，服务端返回给我们一个hello world字符串。</p>\n<figure><figcaption>img.png</figcaption></figure>\n<p>服务端控制台打印如下：</p>\n<figure><figcaption>img_1.png</figcaption></figure>\n<p>对于自定义的 ChannelHandler， 一般会继承 Netty 提供的SimpleChannelInboundHandler类，并且对于 Http 请求我们可以给它设置泛型参数为 HttpOjbect 类，然后覆写 channelRead0 方法，在 channelRead0 方法中编写我们的业务逻辑代码，此方法会在接收到服务器数据后被系统调用。</p>\n<p>Netty 的设计中把 Http 请求分为了 HttpRequest 和 HttpContent 两个部分，HttpRequest 主要包含请求头、请求方法等信息，HttpContent 主要包含请求体的信息。</p>\n<p>所以上面的代码我们分两块来处理。在 HttpContent 部分，首先输出客户端传过来的字符，然后通过 Unpooled 提供的静态辅助方法来创建未池化的 ByteBuf 实例， Java NIO 提供了 ByteBuffer 作为它的字节容器，Netty 的 ByteBuffer 替代品是 ByteBuf。</p>\n<p>接着构建一个 FullHttpResponse 的实例，并为它设置一些响应参数，最后通过 writeAndFlush 方法将它写回给客户端。</p>\n<p>上面这样获取请求和消息体则相当不方便，Netty 又提供了另一个类 FullHttpRequest，FullHttpRequest 包含请求的所有信息，它是一个接口，直接或者间接继承了 HttpRequest 和 HttpContent，它的实现类是 DefalutFullHttpRequest。</p>\n<p>因此我们可以修改自定义的 ChannelHandler 如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样修改就可以了吗，如果你去启动程序运行看看，是会抛异常的。前面说过 Netty 是一个很底层的框架，对于将请求合并为一个 FullRequest 是需要代码实现的，然而这里我们并不需要我们自己动手去实现，Netty 为我们提供了一个 HttpObjectAggregator 类，这个 ChannelHandler作用就是将请求转换为单一的 FullHttpReques。</p>\n<p>所以在我们的 ChannelPipeline 中添加一个 HttpObjectAggregator 的实例即可。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动程序运行，一切都顺畅了，好了，这个简单 Http 的例子就 OK 了。</p>\n<h2> 三、编写 Netty 客户端</h2>\n<p>上面的两个示例中我们都是以 Netty 做为服务端，接下来看看如何编写 Netty 客户端，以第一个 Http 服务的例子为基础，编写一个访问 Http 服务的客户端。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>客户端启动类编写基本和服务端类似，在客户端我们只用到了一个线程池，服务端使用了两个，因为服务端要处理 n 条连接，而客户端相对来说只处理一条，因此一个线程池足以。</p>\n<p>然后服务端启动辅助类使用的是 ServerBootstrap，而客户端换成了 Bootstrap。通过 Bootstrap 组织一些必要的组件，为了方便，在 handler 方法中我们使用匿名内部类的方式来构建 ChannelPipeline 链容器。最后通过 connect 方法连接服务端。</p>\n<p>接着编写 HttpClientHandler 类。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在 HttpClientHandler 类中，我们覆写了 channelActive 方法，当连接建立时，此方法会被调用，我们在方法中构建了一个 FullHttpRequest 对象，并且通过 writeAndFlush 方法将请求发送出去。</p>\n<p>channelRead0 方法用于处理服务端返回给我们的响应，打印服务端返回给客户端的信息。至此，Netty 客户端的编写就完成了，我们先开启服务端，然后开启客户端就可以看到效果了。</p>\n<p>希望通过前面介绍的几个例子能让大家基本知道如何编写 Netty 客户端和服务端，下面我们来说说 Netty 程序为什么是这样编写的，这也是 Netty 中最为重要的一部分知识，可以让你在编写 netty 程序时做到心中有数。</p>\n<h2> 四、Channel、ChannelPipeline、ChannelHandler、ChannelHandlerContext 之间的关系</h2>\n<p>在编写 Netty 程序时，经常跟我们打交道的是上面这几个对象，这也是 Netty 中几个重要的对象，下面我们来看看它们之间有什么样的关系。</p>\n<p>Netty 中的 Channel 是框架自己定义的一个通道接口，Netty 实现的客户端 NIO 套接字通道是 NioSocketChannel，提供的服务器端 NIO 套接字通道是 NioServerSocketChannel。</p>\n<p>当服务端和客户端建立一个新的连接时， 一个新的 Channel 将被创建，同时它会被自动地分配到它专属的 ChannelPipeline。</p>\n<p>ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 ChannelHandler 实例链，并定义了用于在该链上传播入站和出站事件流的 API。那么就很容易看出这些 ChannelHandler 之间的交互是组成一个应用程序数据和事件处理逻辑的核心。</p>\n<figure><figcaption>img_2.png</figcaption></figure>\n<p>上图描述了 IO 事件如何被一个 ChannelPipeline 的 ChannelHandler 处理的。</p>\n<p>ChannelHandler分为 ChannelInBoundHandler 和 ChannelOutboundHandler 两种，如果一个入站 IO 事件被触发，这个事件会从第一个开始依次通过 ChannelPipeline中的 ChannelInBoundHandler，先添加的先执行。</p>\n<p>若是一个出站 I/O 事件，则会从最后一个开始依次通过 ChannelPipeline 中的 ChannelOutboundHandler，后添加的先执行，然后通过调用在 ChannelHandlerContext 中定义的事件传播方法传递给最近的 ChannelHandler。</p>\n<p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。</p>\n<p>如果某个ChannelHandler不能处理则会跳过，并将事件传递到下一个ChannelHandler，直到它找到和该事件所期望的方向相匹配的为止。</p>\n<p>假设我们创建下面这样一个 pipeline：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在上面示例代码中，inbound 开头的 handler 意味着它是一个ChannelInBoundHandler。outbound 开头的 handler 意味着它是一个 ChannelOutboundHandler。</p>\n<p>当一个事件进入 inbound 时 handler 的顺序是 1，2，3，4，5；当一个事件进入 outbound 时，handler 的顺序是 5，4，3，2，1。在这个最高准则下，ChannelPipeline 跳过特定 ChannelHandler 的处理：</p>\n<ul>\n<li>3，4 没有实现 ChannelInboundHandler，因而一个 inbound 事件的处理顺序是 1，2，5。</li>\n<li>1，2 没有实现 ChannelOutBoundhandler，因而一个 outbound 事件的处理顺序是 5，4，3。</li>\n<li>5 同时实现了 ChannelInboundHandler 和 channelOutBoundHandler，所以它同时可以处理 inbound 和 outbound 事件。<br>\nChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。</li>\n</ul>\n<p>（它也可以将它自己从 ChannelPipeline 中移除。）这是 ChannelHandler 最重要的能力之一。</p>\n<p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。</p>\n<p>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。事件从一个 ChannelHandler 到下一个 ChannelHandler 的移动是由 ChannelHandlerContext 上的调用完成的。</p>\n<figure><figcaption>img_3.png</figcaption></figure>\n<p>但是有些时候不希望总是从 ChannelPipeline 的第一个 ChannelHandler 开始事件，我们希望从一个特定的 ChannelHandler 开始处理。</p>\n<p>你必须引用于此 ChannelHandler 的前一个 ChannelHandler 关联的 ChannelHandlerContext，利用它调用与自身关联的 ChannelHandler 的下一个 ChannelHandler。</p>\n<p>如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果我们想有一些事件流全部通过 ChannelPipeline，有两个不同的方法可以做到：</p>\n<ul>\n<li>\n<p>调用 Channel 的方法</p>\n</li>\n<li>\n<p>调用 ChannelPipeline 的方法</p>\n</li>\n<li>\n<p>这两个方法都可以让事件流全部通过 ChannelPipeline，无论从头部还是尾部开始，因为它主要依赖于事件的性质。如果是一个 “ 入站 ” 事件，它开始于头部；若是一个 “ 出站 ” 事件，则开始于尾部。<br>\n那为什么你可能会需要在 ChannelPipeline 某个特定的位置开始传递事件呢？</p>\n</li>\n<li>\n<p>减少因为让事件穿过那些对它不感兴趣的 ChannelHandler 而带来的开销</p>\n</li>\n<li>\n<p>避免事件被那些可能对它感兴趣的 ChannlHandler 处理</p>\n</li>\n</ul>\n<h2> 五、Netty 线程模型</h2>\n<p>在前面的示例中我们程序一开始都会生成两个 NioEventLoopGroup 的实例，为什么需要这两个实例呢？这两个实例可以说是 Netty 程序的源头，其背后是由 Netty 线程模型决定的。</p>\n<p>Netty 线程模型是典型的 Reactor 模型结构，其中常用的 Reactor 线程模型有三种，分别为：Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型。</p>\n<p>而在 Netty 的线程模型并非固定不变，通过在启动辅助类中创建不同的 EventLoopGroup 实例并通过适当的参数配置，就可以支持上述三种 Reactor 线程模型。</p>\n<p>Reactor 线程模型</p>\n<h3> Reactor 单线程模型</h3>\n<p>Reactor 单线程模型指的是所有的 IO 操作都在同一个 NIO 线程上面完成。作为 NIO 服务端接收客户端的 TCP 连接，作为 NIO 客户端向服务端发起 TCP 连接，读取通信对端的请求或向通信对端发送消息请求或者应答消息。</p>\n<p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。</p>\n<figure><figcaption>img_4.png</figcaption></figure>\n<p>Netty 使用单线程模型的的方式如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在实例化 NioEventLoopGroup 时，构造器参数是 1，表示 NioEventLoopGroup 的线程池大小是 1。然后接着我们调用 b.group(bossGroup) 设置了服务器端的 EventLoopGroup，因此 bossGroup和 workerGroup 就是同一个 NioEventLoopGroup 了。</p>\n<h3> Reactor 多线程模型</h3>\n<p>对于一些小容量应用场景，可以使用单线程模型，但是对于高负载、大并发的应用却不合适，需要对该模型进行改进，演进为 Reactor 多线程模型。</p>\n<p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。</p>\n<p>在该模型中有专门一个 NIO 线程 -Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；而 1 个 NIO 线程可以同时处理N条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。</p>\n<p>网络 IO 操作-读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送。</p>\n<figure><figcaption>img_5.png</figcaption></figure>\n<p>Netty 中实现多线程模型的方式如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>bossGroup 中只有一个线程，而 workerGroup 中的线程是 CPU 核心数乘以 2，那么就对应 Recator 的多线程模型。</p>\n<h3> 主从 Reactor 多线程模型</h3>\n<p>在并发极高的情况单独一个 Acceptor 线程可能会存在性能不足问题，为了解决性能问题，产生主从 Reactor 多线程模型。</p>\n<p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。</p>\n<p>Acceptor 接收到客户端 TCP 连接请求处理完成后，将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。</p>\n<p>Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p>\n<figure><figcaption>img_6.png</figcaption></figure>\n<p>根据前面所讲的两个线程模型，很容想到 Netty 实现多线程的方式如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但是，在 Netty 的服务器端的 acceptor 阶段，没有使用到多线程, 因此上面的主从多线程模型在 Netty 的实现是有误的。</p>\n<p>服务器端的 ServerSocketChannel 只绑定到了 bossGroup 中的一个线程，因此在调用 Java NIO 的 Selector.select 处理客户端的连接请求时，实际上是在一个线程中的，所以对只有一个服务的应用来说，bossGroup 设置多个线程是没有什么作用的，反而还会造成资源浪费。</p>\n<p>至于 Netty 中的 bossGroup 为什么使用线程池，我在 stackoverflow 找到一个对于此问题的讨论 。</p>\n<p>the creator of Netty says multiple boss threads are useful if we share NioEventLoopGroup between different server bootstraps</p>\n<p>EventLoopGroup 和 EventLoop</p>\n<p>当系统在运行过程中，如果频繁的进行线程上下文切换，会带来额外的性能损耗。多线程并发执行某个业务流程，业务开发者还需要时刻对线程安全保持警惕，哪些数据可能会被并发修改，如何保护？这不仅降低了开发效率，也会带来额外的性能损耗。</p>\n<p>为了解决上述问题，Netty采用了串行化设计理念，从消息的读取、编码以及后续 ChannelHandler 的执行，始终都由 IO 线程 EventLoop 负责，这就意外着整个流程不会进行线程上下文的切换，数据也不会面临被并发修改的风险。</p>\n<p>EventLoopGroup 是一组 EventLoop 的抽象，一个 EventLoopGroup 当中会包含一个或多个 EventLoop，EventLoopGroup 提供 next 接口，可以从一组 EventLoop 里面按照一定规则获取其中一个 EventLoop 来处理任务。</p>\n<p>在 Netty 服务器端编程中我们需要 BossEventLoopGroup 和 WorkerEventLoopGroup 两个 EventLoopGroup 来进行工作。</p>\n<p>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了 ServerSocketChannel 的 Selector 实例，EventLoop 的实现涵盖 IO 事件的分离，和分发（Dispatcher），EventLoop 的实现充当 Reactor 模式中的分发（Dispatcher）的角色。</p>\n<p>所以通常可以将 BossEventLoopGroup 的线程数参数为 1。</p>\n<p>BossEventLoop 只负责处理连接，故开销非常小，连接到来，马上按照策略将 SocketChannel 转发给 WorkerEventLoopGroup，WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop 来将这 个SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理。</p>\n<p>ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生严重的负面影响。但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。</p>\n<p>对于这种情况， ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add() 方法。如果一个事件被传递给一个自定义的 EventExecutorGroup， DefaultEventExecutorGroup 的默认实现。</p>\n<p>就是在把 ChannelHanders 添加到 ChannelPipeline 的时候，指定一个 EventExecutorGroup，ChannelHandler 中所有的方法都将会在这个指定的 EventExecutorGroup 中运行。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>NioEventLoopGroup 实际上就是个线程池，一个 EventLoopGroup 包含一个或者多个 EventLoop；</li>\n<li>一个 EventLoop 在它的生命周期内只和一个 Thread 绑定；</li>\n<li>所有有 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</li>\n<li>一个 Channel 在它的生命周期内只注册于一个 EventLoop；</li>\n<li>每一个 EventLoop 负责处理一个或多个 Channel；</li>\n</ul>\n",
      "date_published": "2024-04-15T06:08:01.000Z",
      "date_modified": "2024-04-15T06:08:01.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "算法试题",
      "url": "https://ujava.cn/algorithm/program.html",
      "id": "https://ujava.cn/algorithm/program.html",
      "summary": "算法试题",
      "content_html": "<h2> <a href=\"https://javainterview.cn/categories/?category=algorithm\" target=\"_blank\" rel=\"noopener noreferrer\">算法试题</a></h2>\n",
      "date_published": "2024-04-15T04:22:41.000Z",
      "date_modified": "2024-04-15T04:22:41.000Z",
      "authors": [],
      "tags": [
        "设计算法"
      ]
    },
    {
      "title": "一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构",
      "url": "https://ujava.cn/synthesis/business.html",
      "id": "https://ujava.cn/synthesis/business.html",
      "summary": "简介 在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。 架构的视角 在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。",
      "content_html": "<h2> 简介</h2>\n<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>\n<h2> 架构的视角</h2>\n<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>\n<p>很多时候架构的视角/分类没有明显的边界，通常是交叉的；<br>\n有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</p>\n<h2> 业务架构</h2>\n<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>\n<p><br>\n看看京东业务架构（网上分享图）：<br>\n</p>\n<h2> 应用/技术架构</h2>\n<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>\n<p>不限于如下视角，主要表示应用开发中的软件架构视角...</p>\n<h3> 视角：功能视角</h3>\n<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>\n<h3> 视角：技术视角-总体</h3>\n<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>\n<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。<br>\n</p>\n<h3> 视角：技术视角-数据架构</h3>\n<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>\n<h3> 视角：技术视角-基础架构</h3>\n<p>PAAS，IAAS...</p>\n<figure><figcaption>img_35.png</figcaption></figure>\n<h3> 视角：技术视角-运维架构</h3>\n<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>\n<figure><figcaption>img_36.png</figcaption></figure>\n<h2> 物理架构</h2>\n<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>\n<p>以一个银行系统为例</p>\n<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。<br>\n</p>\n<p>物理部署架构设计说明：</p>\n<ul>\n<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>\n<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>\n<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>\n<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>\n<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>\n<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。<br>\n下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。<br>\n</li>\n</ul>\n<p>物理部署架构设计说明：</p>\n<ul>\n<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>\n<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>\n<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>\n</ul>\n<h2> DDD到各种架构</h2>\n<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>\n<p>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</p>\n<p>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</p>\n<p>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</p>\n<figure><figcaption>img_39.png</figcaption></figure>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计缓存",
      "url": "https://ujava.cn/synthesis/cache.html",
      "id": "https://ujava.cn/synthesis/cache.html",
      "summary": "简介 实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。 数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。 CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。 虚拟主存： 作为磁盘数据的缓存。 磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存 网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。 本文总结互联网技术体系中尤为重要的缓存技术。",
      "content_html": "<h2> 简介</h2>\n<p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p>\n<p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p>\n<ul>\n<li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li>\n<li>虚拟主存： 作为磁盘数据的缓存。</li>\n<li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li>\n<li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br>\n本文总结互联网技术体系中尤为重要的缓存技术。</li>\n</ul>\n<h2> 基本思想</h2>\n<ul>\n<li>缓存是以空间换时间，提升查询性能。缓存遵循“近水楼台先得月”法则：邻近 CPU 优先，邻近用户优先（CDN）。</li>\n<li>缓存依据：访问局部性原理。时间局部性 - 某个存储器位置在短时间内被再次访问；空间局部性 -<br>\n若某个存储器位置被访问，则邻近存储器位置也很可能会被访问。重复引用相同变量的程序具有良好的时间局部性。步长为 1<br>\n的引用模式的程序具有良好的空间局部性。一个典型例子是数组求和。求和变量体现了时间局部性，数组访问体现了空间局部性。可以用缓存命中率来衡量局部性。</li>\n<li>顺序引用模式：顺序地每隔 k 个元素地访问一个连续向量中的每个元素，称为步长为 k 的顺序引用模式 。 k 越大，空间局部性越差。步长为<br>\n1 的顺序引用模式是局部性原理的重要应用之一。高效访问顺序与存储结构设计及存储细节是紧密关联的。数组和列表是连续存储结构，因此顺序引用模式很吃香。</li>\n<li>存储器层次结构：对于每个 k, 位于第 k 层的更快更小的存储设备作为位于第 k+1 层的更慢更大的存储设备的缓存。数据总是以块为传送单元，在第<br>\nk 层和第 k+1 层之间进行复制的。层次结构中，相邻的两层的块大小是一样的；不同层次的块大小可以不同。越靠近慢而大的存储层次，块大小越大。</li>\n</ul>\n<h2> 缓存问题</h2>\n<p>缓存问题主要包括缓存结构设计、缓存一致性分析、缓存策略（热身/替换/清理）、缓存保护（击穿/雪崩/穿透）。<br>\n一致性问题涉及准确性；缓存策略涉及性能（缓存命中率及主存占用）；而缓存保护涉及稳定性（在大并发请求下且缓存未能命中时保护原始数据源不被压倒）。</p>\n<h4> 缓存结构设计</h4>\n<p>缓存数据结构主要包括记录型和哈希型。记录型的缓存，是一个连续存储阵列，可简化为多维数组；哈希型的缓存，是基于哈希表。 CPU<br>\n高速缓存是基于记录型的，因为硬件上不宜做复杂的运算；应用缓存通常是基于哈希型的，比如 Redis 缓存。</p>\n<h4> CPU高速缓存</h4>\n<p>CPU 高速缓存可使用 (S, E, B, m) 来表示组织结构。m 位存储器具有 2^m 个存储器地址，其对应的高速缓存组织划分为 S = 2^s 个组，每组<br>\nE 个缓存行，每个缓存行包括一个有效位、t 个标记位、B = 2^b 个字节，缓存大小 C = S * E * B。 其中 s<br>\n是组索引，标识缓存块在哪个组里；t = m-s-b 标识缓存块在缓存组的哪个缓存行里；b 是字节在缓存行里的偏移量。[s,t,b]<br>\n标识了缓存字节在缓存结构里的位置。发生缓存替换时，替换的是某个组里的某个缓存行。</p>\n<p>E = 1 时，DMC Directed-Map Cache ；1 &lt; E &lt; C/B 时，SAC Set Associative Cache ；E = C/B 时 Full Associative Cache FAC。 DMC<br>\n每组只有一个缓存行，在组中查找缓存行没有开销，但容易发生组的冲突不命中； SAC 在组中查找缓存行有一定开销，但可以减少组的冲突不命中概率；<br>\nFAC 只有一个组，在定位组时无开销，替换缓存行时有更大的选择，但在查找缓存行时开销比较大。在硬件层，搜索和匹配标记位是昂贵的操作，因此<br>\nFAC 一般应用在搜索和匹配操作代价不高的地方，比如虚拟主存或应用缓存。</p>\n<p>高速缓存定位字的步骤是：首先从 m 中拿到 s 位组索引，找到缓存行所在的组；再根据 t 位标记位找到匹配的组内的缓存行；最后，根据 b<br>\n位偏移量找到字在缓存块中的位置。如果有效位未置位，则可能是过期缓存；如果 t 位标记位无法匹配所有的组，则是缓存未命中。</p>\n<figure><figcaption>img.png</figcaption></figure>\n<p>CPU 写主存时可采用两种方式：直写和回写。直写会在更新缓存是直接写入缓存，而回写在更新缓存时只是标记缓存块的缓存状态，只有在替换缓存块时才会写回主存。这就导致了<br>\nCPU 缓存与主存的一致性问题。这个问题是通过 MESI 协议来解决的。</p>\n<h4> MESI协议</h4>\n<p>MESI 协议是 SMP 体系结构的 CPU 缓存一致性协议，涉及读写时多个 CPU 高速缓存如何与主存保持一致<br>\n。主要设计思想包括：缓存条目状态的状态转换自动机、写缓冲器、总线事务定义及缓存控制、操作异步化队列、操作屏障。</p>\n<h4> 一致性概念</h4>\n<p>多处理器存储系统是一致的，如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（将所有进程的读写操作排成一个全序），此序列与执行结果一致，并且在此序列中：</p>\n<ul>\n<li>任何特定进程发出的操作，所表现出的序和该进程向存储系统发出他们的序相同；</li>\n<li>每个读操作返回的值是对相应单元按串行顺序写入的最后一个值。</li>\n</ul>\n<h4> 一致性前提</h4>\n<ul>\n<li>系统总线上的所有事务对所有处理器的高速缓存控制器可见，且以相同顺序可见。</li>\n<li>为响应存储的所有必要事务都出现在总线上，且缓存控制器采取适当的措施。</li>\n<li>当高速缓存监听到与之相关的写操作事务时，要么使缓存块拷贝作废，要么更新它。处理器随后的访问，要么缓存不命中而加载新的值，要么直接看到新的值。</li>\n</ul>\n<h4> CPU宏观结构</h4>\n<p>CPU 宏观结构主要包括：CPU Core, Store Buffer , CPU Cache , System BUS 。 CPU Cache 和 Store Buffer 是 CPU 专有的，System<br>\nBUS 是共享的消息通道。 CPU Cache 是一个缓存条目的阵列（多维数组），每个缓存条目有 tag, data, flag 三个值，tag 表示主存地址，flag<br>\n表示缓存条目的状态。flag 定义了如下值：</p>\n<ul>\n<li>Modified(M)：已修改状态。某个处理器缓存副本拥有已修改的值, 主存里的是过期的；</li>\n<li>Exclusive(E)：干净独占状态。仅有该处理器缓存副本与主存一致且主存状态是最新的，独占控制权，缓存能够写操作并转移到 M<br>\n状态，却不产生总线事务;</li>\n<li>Shared(S)：至少两个处理器缓存副本与主存一致，主存有最新的值，其他处理器可能有最新的或者过期的值;</li>\n<li>Invalid(I)：初始状态，缓存无效状态。</li>\n</ul>\n<p>缓存条目状态简称为 CES。CES 的状态转换图可以定位为一个有限状态自动机。理解 CES 的有限状态转换机是关键。如下图所示，A/B 表示当观察<br>\nA 事件时，将产生一个 B 总线事务。Flush’ 表示清除相应的存储块，前提是使用了缓存到缓存的共享，且清除是由提供数据的缓存。BusRd(<br>\nS) 表示由共享信号 S 生成的总线读事务。缓存控制器通过共享信号 S 在地址阶段确定是否有其它缓存拥有同样的缓存拷贝。如果一个缓存确定自己拥有同样的存储块拷贝，就会发出<br>\nS 信号。</p>\n<p>MESI 协议定义了一些总线事务（总线读事务、总线排它读事务、总线写事务、回写事务）。结合 CES 状态转换图、总线事务及 CPU<br>\n缓存读写控制来实现一致性。</p>\n<h4> 缓存读</h4>\n<p>读是指拿到变量的最新值并读取到 CPU 寄存器。假设处理器 P1 和 P2 均拥有变量 x 的副本。如果 P1 发现 x 的 CES 为 M/E/S，则直接获取副本<br>\nx 的值。若 P1 发现变量 x 的 CES 为 I，则遵循如下步骤：</p>\n<ul>\n<li>STEP1 -- 发送 BUS Read 事务；</li>\n<li>STEP2 -- P2 拥有变量 x 的最新副本（ CES 为 M），嗅探到 x Read 事务，就会将 x 的最新副本写入主存，构造 Read Response 发送到<br>\nBUS 上，并将 CES 更新为 S ；如果有多个处理器缓存都拥有变量 x 的最新副本，则通过某种策略来选择从某个高速缓存来提供新值还是直接由主存来提供新值。</li>\n<li>STEP3 -- P1 嗅探到到 x Read Response ，将 CES 更新为 S，写入相应的缓存块。<br>\n注意：任何一个处理器在嗅探到缓存块的 BUS Read 事务，且相应缓存块为 M 状态时，都会执行 STEP2 操作。</li>\n</ul>\n<h4> 缓存写</h4>\n<p>写是指将变量 x 的最新值写到缓存块。对一个处于 E 或 I 状态的缓存块的写操作，将其置为 M<br>\n状态之前，所有其他处理器缓存拷贝都必须通过一个排它读总线事务将自己的缓存作废。如果缓存状态是 M/E ，则不发送总线事务；遵循如下步骤：</p>\n<ul>\n<li>STEP1：P1 发送总线排它读事务；</li>\n<li>STEP2：其他处理器嗅探到总线排它读事务，更新 CES 为 I，再发送 Invalidate Acknowledge ；后续读会产生一次缓存不命中，从而通过一次总线读事务读取最新值。</li>\n<li>STEP3：P1 收到所有 Invalidate Acknowledge ，将 CES 更新为 E，获得数据控制权。然后写入缓存行，将 CES 更新为 M。CPU<br>\n写需要等待其他处理器都发送 Invalidate Acknowledge 消息，此时会有写等待问题。</li>\n</ul>\n<h4> 缓存替换</h4>\n<p>当一个缓存块被替换时：</p>\n<ul>\n<li>如果缓存块处于 S 或 I, 则逻辑上直接更新为 I; 如果缓存块处于 M 状态，则从 M 到 I 的状态转换会触发一次回写事务，将缓存块的状态写入主存。</li>\n</ul>\n<h4> 写等待问题</h4>\n<p>写缓冲器（Store Buffer）、无效化队列（Invalidate Queue）。CPU 会直接先写 Store Buffer ，再同步缓存。其他处理器则会将消息存入<br>\nInvalidate Queue 就发送 Invalidate Acknowledge ，异步去更新 CES 。 写缓冲器和无效化队列将 CPU<br>\n缓存副本更新变成异步处理。读则采用存储转发，先查询写缓冲器，再查询高速缓存。相当于写缓冲器又加了一层缓存。写缓存异步化又会带来一致性问题。</p>\n<h4> 主存屏障</h4>\n<p>Store Barrier 和 Load Barrier 。Store Barrier 将 Store Buffer 的数据写入缓存； Load Barrier 根据 Invalidate Queue<br>\n的主存地址，将相应的 CES 更新为 I。</p>\n<h2> 缓存读写一致性</h2>\n<p>要正确使用缓存，必然要保证缓存并发读写的一致性。缓存读写一致性需要保证：</p>\n<ul>\n<li>源数据与缓存的同一数据达成一致性（或者达成不一致时延可接受的最终一致性）。</li>\n<li>以源数据的数据为准。<br>\n可以采用 [ xC, xDB, yC, yDB ] 操作序列分析读写一致性问题，x,y 是读、更新、删除，C 表示缓存，DB 表示数据库（源数据）。</li>\n</ul>\n<p>首先框定讨论范围：两个线程 A, B，一个变量 x ，数据源 DB 和 缓存 C ，其中 C 从 DB 中获取，需要与 DB 保持一致， A,B 有读写操作，读为<br>\nRD， 写可以进一步分为更新值 UP 和删除值操作 DE，读写时序不确定。</p>\n<p>缓存读模式是确定的：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读 DB。这点无异议。如果 A, B<br>\n并发读，均直接从 C 中获取当前值即可。如果 C 中没有值，那么 A, B 可能都会从 DB 获取。在大并发的情形下，会有缓存击穿/穿透的问题。缓存击穿和穿透的问题在后面讨论。</p>\n<p>当两个线程处于并发读-并发写，或者并发写-并发写的时候，可以有两种方案：加锁和不加锁。</p>\n<ul>\n<li>对更新 DB 和更新 C 进行加分布式锁，使之原子化。加锁会更简单，但吞吐量会比较低；</li>\n<li>对更新 DB 和 更新 C 不加锁，保证合理的执行顺序，使之达到最终一致性（业务可接受一定的不一致时延）。<br>\n以下主要讨论不加锁的方案。分情形讨论：</li>\n</ul>\n<h4> A写-B读</h4>\n<p>先指明期望结果：</p>\n<ul>\n<li>\n<p>如果 B 在 A 写之前读，那么 B 读到的是写之前的值，直接从 C 中获取即可。没问题。</p>\n</li>\n<li>\n<p>如果 B 在 A 写之后读，那么 B 读到的应该是写之后的值。<br>\n那么 A 该如何写，才能保证 B 读到最新的值？</p>\n</li>\n<li>\n<p>A 先更新 C，再写 DB。会有什么问题 ？ 如果 A 先更新了 C ，然后更新 DB 失败了，那么 C 与 DB 就不一致了。DB 里是旧值。不符合一致性保证。当然，读<br>\nC 会读到新值。可以有一种思路，就是缓存作为读写的前置环节，负责缓存与 DB 的最终一致性。这种方案也是可以接受的。这是 Write<br>\nBehind Caching Pattern 模式。</p>\n</li>\n<li>\n<p>A 先删除 C， 再写 DB。会有什么问题？ 如果操作时序是 [ A 删除 C， B 读 C，A 更新 DB ]， 那么在 A 更新 DB 之前，B 读 C 未命中，从<br>\nDB 读到旧值，而 A 更新 DB， DB 与 C 的值不一致。不符合一致性保证。</p>\n</li>\n<li>\n<p>A 先写 DB ，再更新 C。会有什么问题？ 1. 更新缓存可能是代价昂贵的操作，频繁更新缓存会导致吞吐量降低；在更新 C<br>\n之前读到的是旧值，如果更新操作比较耗时，那么 DB 和 C 的不一致时延会比较大，会影响业务。</p>\n</li>\n<li>\n<p>A 先写 DB ，再删除 C。 会有什么问题？ 避免了更新代价高的问题，在删除 C 之前读到的是旧值，在删除 C<br>\n之后读到新值。由于删除缓存往往代价很小，不一致时延通常可接受。这是 Cache Aside Pattern 模式。</p>\n</li>\n</ul>\n<h4> A写-B写</h4>\n<ul>\n<li>期望结果：无论 A 先写还是 B 先写，最终写入的 DB 和 C 的值应当一致。</li>\n<li>A 先更新 C，再写 DB。 会有什么问题？如果操作时序是 [ A 写 C x， B 写 C y， B 写 DB y， A 写 DB x]，会导致 C 是 y , DB 是 x<br>\n，DB 与 C 中的数据不一致。</li>\n<li>A 先写 DB， 再更新 C。会有什么问题？[ A 写 DB x， B 写 DB y， B 写 C y， A 写 C x]，会导致 C 是 x , DB 是 y ，DB 与 C 中的数据不一致。<br>\n从上述分析可知：1. 更新缓存操作可能是一个代价昂贵的操作，会导致 DB 与 C 达到最终一致性的不一致时延较长，对业务有影响； 2.<br>\n在并发写-写模式下，DB 和 C 的数据会不一致，从而读到不一致的数据。因此，一般不采用更新缓存的方式，而是直接删除缓存。</li>\n</ul>\n<p>常见的缓存读写模式有 Cache Aside Pattern 和 Write Behind Caching Pattern 。</p>\n<ul>\n<li>Cache Aside Pattern：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读<br>\nDB。读更写删。读模式基本是固定的；写入数据时，先更新 DB ，再删除缓存。可以采集 DB binlog 异步删除缓存。如果是主从<br>\nDB，则必须采集最后一个从库 binlog （最终一致性）。</li>\n<li>Write Behind Caching Pattern --- 写入时只更新缓存，异步去更新 DB 。牺牲短暂的一致性来获得高吞吐量。</li>\n</ul>\n<h2> 缓存热身</h2>\n<p>空缓存会直接导致不命中，从而影响第一次读的性能。如果大并发访问空缓存（类似缓存雪崩），很容易导致大量并发请求直接打到 DB 上，使得<br>\nDB 压力陡增。</p>\n<p>缓存热身即是预先把一些数据加载到缓存，提升第一次访问的性能，同时防止第一次访问面临大并发时会将后台打出问题。比如在应用启动后，可以将一些<br>\nTOPN 商品异步加载到缓存（不能影响应用启动）；商家做活动前，把一些活动商品和活动信息数据加载到缓存（可配置化）；把一些极少变动的静态数据加载到缓存。加载缓存可以使用应用通知机制，比如实现<br>\nApplicationListener 的<br>\nonApplicationEvent 方法。</p>\n<h2> 缓存替换策略</h2>\n<p>缓存总有未命中的情况：</p>\n<ul>\n<li>空不命中：总是不会命中，亦称冷缓存。避免冷缓存的方法是进行“缓存热身”。将 k+1 层的缓存块放到第 k<br>\n层的策略称为放置策略。通常采用取模的方式: j = i Mod N ，即：将第 k+1 层的第 i 个块对 N 取模后，放到第 k 层的第 i 个块里。</li>\n<li>冲突不命中：比如按取模的放置策略，有可能在缓存未满的情况下，总是对第 k 层的同一个块进行替换。比如 j mod 4 ，当 j=0,4,8,12<br>\n时，总是会放在到第 0 块上。缓存抖动是一种特殊的冲突不命中，指高速缓存反复加载或驱逐相同的高速缓存块/组/行。</li>\n<li>容量不命中：缓存容量满了。</li>\n</ul>\n<p>缓存替换策略是指当缓存未命中，且缓存容量已满时，判断要替换哪个块的缓存数据。原则上，应该淘汰：1. 只访问过一次的数据； 2.<br>\n相比其他数据更少访问的； 3. 在一段时间内没有再访问的。</p>\n<p>缓存替换策略主要有 FIFO, LRU, LFU。</p>\n<ul>\n<li>FIFO ： 最先进入缓存的首先被淘汰。队列实现。或者使用双向链表，新进入元素添加到链表尾，丢弃链表头的元素。FIFO适合丢弃那些只有一次访问的数据。</li>\n<li>LRU ：最近最少使用淘汰。使用链表实现，若缓存命中，则将节点移至首部，淘汰尾部节点。 LRU 适合热点数据访问。LRU<br>\n无法识别哪些缓存是最多被访问的。偶发性、周期性的批量操作可能导致缓存被大量替换，造成缓存污染，使得 LRU 的效率大幅下降。实际采用<br>\nLRU-K 算法，将缓存分为两级，数据在较短时间被访问 K 次以上，则进入二级缓存。两级都采用 LRU 策略。</li>\n<li>LFU ： 最少次数使用淘汰。引用计数 + 优先级队列（堆）。</li>\n</ul>\n<h2> 缓存清理策略</h2>\n<p>当缓存对应的原始数据更新后，缓存里的数据就与原始数据不一致了，即缓存失效了。这时候需要及时清理缓存，避免读到过期数据以及过期数据占用过大的内存。缓存清理策略是指什么时候清理过期或失效缓存。</p>\n<ul>\n<li>TTL： 设置过期时间。 TTL 一般以数据变化频繁度为依据来设置。不同业务数据的过期时间不一样。</li>\n<li>写时失效： 写失效、写更新。写失效 - 标记缓存数据已过期，读时清理或替换；写更新 - 在更新数据时就替换缓存项。</li>\n<li>读时失效：写时只标注失效信息，读时判断是否失效并加载最新数据。如果有大量缓存对象要更新，可以采用读时失效将写更新成本分摊到每一个读上。缓存对象时，同时存储相应的版本号或时间戳。需要展示数据时，通过对比版本号来判断是否缓存已失效。</li>\n</ul>\n<h2> 缓存击穿/雪崩/穿透</h2>\n<ul>\n<li>缓存击穿【重点】。 热点问题。大并发集中对热点 key 进行访问，当这个 key<br>\n在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。基本方案：多级缓存（不同失效时间）+<br>\n热点散列 + 热点识别、熔断降级、互斥锁、不过期+异步更新。</li>\n<li>缓存雪崩。 大量 key 同时失效，导致大量请求打到 DB，造成巨大 DB 压力和系统不稳定。基本方案：过期时间+随机化。</li>\n<li>缓存穿透。大量不存在的 key 的非法访问请求，同样会使得大量请求打到 DB。使用布隆过滤器过滤大量非法请求。还有一种方法是空值缓存，失效时间设置小一些，应对短时间内无效重复<br>\nkey 的大量查询。</li>\n<li>缓存命中统计、缓存监控。</li>\n<li>注意\n<ul>\n<li>缓存穿透：请求Key是大量数据，不存在于缓存，也不存在于数据库</li>\n<li>缓存击穿：请求Key是热点数据，不存在于缓存（缓存过期），存在于数据库</li>\n<li>缓存雪崩：请求Key是大量数据，缓存大面积失效，打到数据库</li>\n</ul>\n</li>\n</ul>\n<h2> 缓存实现</h2>\n<p>以本地缓存为例，来分析缓存实现。本地缓存通常在单机共享范围内：某个进程内的被多次访问的主存数据；单机范围内的多进程共享的主存数据。要实现缓存功能，通常需要考虑如下因素：</p>\n<ul>\n<li>\n<p>缓存的规格指定，会影响缓存的创建和性能。</p>\n</li>\n<li>\n<p>缓存的值的计算和迟加载。</p>\n</li>\n<li>\n<p>缓存策略的配置。</p>\n</li>\n<li>\n<p>缓存对并发的支持。</p>\n</li>\n<li>\n<p>缓存更新的通知与监听。</p>\n</li>\n<li>\n<p>缓存的监控与统计。<br>\nGuava.Cache 是本地缓存的一个实现。核心类是 CacheBuilderSpec (规格指定)、CacheBuilder (根据缓存规格创建缓存)、LocalCache (<br>\n缓存功能的核心实现类)。 LocalCache 的底层是一个哈希表，支持并发访问，实现了 ConcurrentMap 接口。实现要点如下：</p>\n</li>\n<li>\n<p>缓存数据的读写与 ConcurrentHashMap 类似。</p>\n</li>\n<li>\n<p>有两个用双向链表实现的优先级队列： writeQueue 和 accessQueue ，用来控制缓存何时过期。writeQueue 按写时间排序，accessQueue<br>\n按访问时间排序。在每次写入或更新或清理操作的时候，会执行清理操作，根据这两个队列来判断缓存数据是否过期，如果过期则从缓存数据哈希表中移除。</p>\n</li>\n</ul>\n<h2> 高效应用缓存</h2>\n<h4> 缓存友好的代码</h4>\n<p>针对连续型存储的高速缓存，编写对缓存友好的代码。比如聚焦核心函数的循环；减少循环内部不命中的数量；对局部变量的反复引用；步长为<br>\n1 的顺序引用模式；多重循环中的循环变量的次序。</p>\n<p>换言之，每个循环都会在高速缓存上产生很大的影响，进而影响程序运行性能。对于上层应用可能感知不明显，但是对于底层却很重要。</p>\n<figure><figcaption>img_1.png</figcaption></figure>\n<h4> 服务实例缓存</h4>\n<p>凡是将数据进行变换后存储起来，在将来的计算中重复多次使用，都是缓存的实现形式。最常见的就是服务单例缓存。比如在类<br>\nDefaultSingletonBeanRegistry 中的 singletonObjects 单例缓存，可用来解决循环引用依赖问题 ：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 缓存与动态规划</h4>\n<p>动态规划法通常会复用到子问题的解，因此可以使用缓存来存储子问题的解。一个简单的例子如下，计算阶乘：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> HTTP缓存</h4>\n<ul>\n<li>HTTP 缓存原理：HTTP 缓存服务器上会保存原始服务器上的文档副本。当 HTTP 请求到来时，若缓存命中，则直接返回文档副本，而无需再与原始服务器通信。</li>\n<li>缓存再验证：HTTP<br>\n缓存服务器会发送特殊请求（无需取整个文档对象），与原始服务器的文档比较，检测缓存副本是否过期；如果检测到未过期 ,<br>\n缓存服务器会获取到新的首部和新的过期时间，更新缓存首部，再将文档副本标识为“未过期”的；若检测到缓存副本过期了，则从原始服务器取最新的文档并生成新的文档副本。</li>\n<li>缓存命中统计：缓存请求命中占比；缓存字节命中占比。</li>\n<li>缓存层次结构：可以使用多级缓存。可分为私有缓存和公有缓存，私有缓存通常是用户浏览器缓存，存放在本地磁盘上；公有缓存则是 HTTP<br>\n缓存服务器（可能是代理服务器、CDN服务器）。私有缓存可以作为第一级缓存，公有缓存作为第二级或第 N 级缓存。</li>\n<li>缓存过期标识：可使用 Cache-Control 和 Expires 来标明缓存副本何时过期，是否需要做缓存再验证。缓存服务器从 HTTP<br>\n请求中解析出首部，并与缓存里的 Cache-Control ( max-age 从生成文档到过期的生存时间，秒为单位 ) 和 Expires (<br>\n过期绝对日期 ) 配置进行比较，如果已经超过指定期限，则要做缓存再验证操作。由于时钟不准确，一般不推荐使用 Expires 首部。</li>\n<li>条件再验证：将缓存再验证与获取新的缓存副本合为一个请求。主要有 If-Modified-Since 和 If-None-Match。</li>\n<li>If-Modified-Since 首部：将 If-Modified-Since 首部添加的 GET 请求中，告知原始服务器，仅当其内容已经修改，才返回修改后的文档对象。若原始服务器文档没有修改，则返回<br>\n304 Not Modified ；若文档已修改，返回完整的对象；若文档已删除，则返回 404 Not Found ，缓存服务器会将副本删除。If-Modified-Since<br>\n可以与 Last-Modified 配合使用。</li>\n<li>If-None-Match:Etags: 当日期不足以区分文档的过期时，可以使用 If-None-Match:Etags 。实际上类似一个版本号。</li>\n<li>Cache-Control: no-store （禁止缓存复制响应）, no-cache ( 在进行再验证之前不可提供缓存副本 ), must-revalidation (<br>\n必须进行缓存再验证), max-age ( 在指定秒数之后进行缓存再验证 ), max-stale, min-fresh</li>\n<li>试探性过期算法：如果 If-Modified-Since 和 If-None-Match<br>\n都没有提供，则根据最近修改时间，智能推断需要缓存的时间。若最近修改时间很久，则认为文档稳定，可以缓存更长时间，若最近修改时间很近，则认为文档易变，将缓存时间改下一点。有点自适应缓存的意味。LM-Factor<br>\n是一种常用的试探性过期算法。<code>$time_since_modify = max(0, $server_Date - $server_Last_Modified); $server_freshness_limit = int($time_since_modify * $lm_factor);</code></li>\n<li>设置缓存的工具： Apache web 服务器 ( mod_headers, mod_expires )，META HTTP-EQUIV 标签。</li>\n</ul>\n<h4> 分布式缓存</h4>\n<p>一般采用 Redis 来做多机共享的分布式缓存。一些有效做法：</p>\n<ul>\n<li>命名空间规范和隔离，部署隔离，避免业务相互影响和耦合。</li>\n<li>采用批量获取缓存数据的方法提升查询性能，减少网络传输开销。</li>\n<li>尽量使用 O(1) 的命令，避免使用遍历性命令。</li>\n<li>单个 key 的 value 不超过 10KB, list, set, map 等不超过 1000 个元素。</li>\n<li>设置合理的定期删除/惰性删除/缓存替换策略。</li>\n<li>测量缓存的命中率及性能提升情况；若数据不理想，则要仔细分析原因并优化。</li>\n<li>监控大对象缓存。</li>\n</ul>\n<p>要避免的坑：</p>\n<ul>\n<li>内存占用和缓存同步要特别注意，避免内存占用大、同步慢影响了业务。</li>\n<li>缓存主要用来提升性能，不要当做持久化存储使用，避免数据丢失的风险。</li>\n<li>避免滥用和浪费缓存资源。主存缓存是比较昂贵的资源。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计考量",
      "url": "https://ujava.cn/synthesis/consider.html",
      "id": "https://ujava.cn/synthesis/consider.html",
      "summary": "简介 1、系统拆分 有句古话 “牵一发而动全身”。 面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。 万物相通，回到我们的软件架构。 早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。 “鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。 因此，系统拆分 成了更多人的选择。 慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。",
      "content_html": "<h2> 简介</h2>\n<h2> 1、系统拆分</h2>\n<p>有句古话 “牵一发而动全身”。</p>\n<p>面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。</p>\n<p>万物相通，回到我们的软件架构。</p>\n<p>早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。</p>\n<p>“鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。</p>\n<p>因此，系统拆分 成了更多人的选择。</p>\n<p>慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。</p>\n<h2> 2、解耦</h2>\n<p>软件开发有个重要原则“高内聚、低耦合”。</p>\n<p>小到接口抽象、MVC 分层，大到 SOLID 原则、23种设计模式。核心都是降低不同模块间的耦合度，避免一处错误改动影响到整个系统。</p>\n<p>就以开闭原则为例，对扩展是开放的，对修改是关闭的。随着业务功能迭代，如何做到每次改动不对原来的旧代码产生影响。</p>\n<p>高内聚，低耦合方案（解耦方案）：</p>\n<p>动态代理技术，通过对字节码进行增强，在方法调用的时候进行拦截，以便于在方法调用前后，增加我们需要的额外处理逻辑。</p>\n<p>事件机制，通过发布订阅模式，新增的需求，只需要订阅对应的事件通知，针对性消费即可。不会对原来的代码侵入性修改，是不是会好很多。</p>\n<p>队列，将消息丢往队列，消费者消费消息，提高可扩展性，性能</p>\n<h2> 3、异步</h2>\n<p>同步指一个进程在执行请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</p>\n<p>效率会大大降低，聪明的人想到了 异步 方式。</p>\n<p>如果是非实时响应的动作可以采用异步来完成，线程不需要一直等待，而是继续执行后面的逻辑。</p>\n<p>如：线程池（ThreadPoolExecutor）、规则推送、消息队列 等都是这个原理</p>\n<p>比如一个用户在淘宝下了一笔购物订单，关心的是订单是否创建成功，能否进行后续的付款流程</p>\n<p>至于其他业务动作，如短信通知、邮件通知、生成订单快照、创建超时任务记录，这些非核心动作用户并不是特别关心。</p>\n<p>我们可以采用消息队列的发布/订阅 机制，数据库插入订单记录后，发布一条消息到 MQ，然后就可以告知用户下单成功。</p>\n<p>其他事情，由不同的 Task 任务订阅消息异步处理，彼此间互不干扰。</p>\n<h2> 4、重试</h2>\n<p>重试主要是体现在远程的RPC调用，受 网络抖动、线程资源阻塞 等因素影响，请求无法及时响应。</p>\n<p>为了提升用户体验，调用方可以通过 重试 方式再次发送请求，尝试获取结果。比过：浏览器的 F5 刷新机制就是类似道理。</p>\n<p>接口重试是一把双刃剑，虽然客户端收到了响应超时结果，但是我们无法确定，服务端是否已经执行完成。如果盲目地重试，可能会带来严重后果。比如：银行转账。</p>\n<p>重试通常跟幂等组合使用，如果一个接口支持了 幂等，那你就可以随便重试</p>\n<p>1、幂等性概念</p>\n<p>顾名思义，所谓幂等就是对于数据的操作不论多少次，但始终操作的结果是一致的。也就是说，无论相同的查询操作多少次，得到结果始终只是一次的结果和影响。</p>\n<p><strong>保证幂等方案</strong></p>\n<h4> 1、查询操作：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作；</h4>\n<h4> 2、删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；</h4>\n<h4> 3、唯一索引：防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；</h4>\n<h4> 4、token机制（防止重复提交）</h4>\n<p>方式一：</p>\n<p>原理上通过session token来实现的(也可以通过redis来实现)<br>\n。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。</p>\n<p>服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p>\n<p>方式二：</p>\n<p>调用方在调用接口时候先向后端请求一个全局ID（Token），请求的时候携带全局ID一起请求，后端需要用这个Token作为Key，用户信息作为Value到Redis中进行键值内容校验，如果Key存在且Value匹配就执行删除命令，然后执行后面的业务逻辑。如果不存在对应的Key或者Value不匹配就返回执行错误的信息。</p>\n<p><br>\n方式三：</p>\n<p>请求每次访问时候，会记录当前请求相同参数，url的信息，访问时间，到期时间等放入redis，定义一个一定时间内防止重复处理的时间间隔，如果下次请求来的时候，通过url，参数等信息获取redis中的请求信息，如果redis中记录的访问时间小于上次请求时间+固定的时间间隔，就不允许访问。</p>\n<h4> 5、乐观锁</h4>\n<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：<br>\n</p>\n<h4> 6、分布式锁</h4>\n<p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(<br>\nredis或zookeeper)<br>\n，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(<br>\n用户ID+后缀等)<br>\n获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(<br>\n分布式锁要第三方系统提供)；</p>\n<h4> 7、select + insert</h4>\n<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；</p>\n<h4> 8、状态机幂等</h4>\n<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)<br>\n，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>\n<h4> 9、对外提供接口的api如何保证幂等</h4>\n<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(<br>\n并发时，只能处理一个请求) 。</p>\n<p>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>\n<h2> 5、补偿</h2>\n<p>我们知道不是所有的请求都能收到成功响应。除了上面的 重试 机制外，我们还可以采用补偿玩法，实现数据最终一致性。</p>\n<p>业务补偿根据处理的方向分为两部分：</p>\n<ul>\n<li>正向。多个操作构成一个分布式事务，如果部分成功、部分失败，我们会通过最大努力机制将失败的任务推进到成功状态</li>\n<li>逆向。同上道理，我们也可以采用反向操作，将部分成功任务恢复到初始状态</li>\n</ul>\n<p>注意：补偿操作有个重要前提，业务能接受短时间内的数据不一致。</p>\n<p>补偿有很多的实现方式：</p>\n<p>1、本地建表方式，存储相关数据，然后通过定时任务扫描提取，并借助反射机制触发执行</p>\n<p>2、也可以采用简单的消息中间件，构建业务消息体，由下游的的消费任务执行。如果失败，可以借助MQ的重试机制，多次重试</p>\n<h2> 6、备份</h2>\n<p>任何服务器都有宕机的可能性，一旦存储了数据，带上状态，如果发生故障，数据丢失，后果是我们无法承受的。</p>\n<p>所以，容灾备份也就变成了互联网的基本能力。</p>\n<p>那如何备份，不同的框架有不用的玩法。我们以 Redis 为例：</p>\n<p>Redis 借助 RDB 和 AOF 来实现两台服务器间的数据同步</p>\n<ul>\n<li>RDB，全量数据同步</li>\n<li>AOF，增量数据同步，回放日志</li>\n</ul>\n<p>一旦主节点挂了怎么办？</p>\n<p>这里引入哨兵机制。哨兵机制可以实现主从库的自动切换，有效解决了故障转移。整个过程分为三个阶段：监控、选主、通知。</p>\n<p>除了 Redis 中间件外，其他常见的 MySQL、Kafka 消息中间件、HBase 、ES 等 ，凡是涉及到数据存储的介质，都有备份机制，一旦主节点挂了，会启用备份节点，保证数据不会丢失。</p>\n<h2> 7、多活策略</h2>\n<p>虽然有了上面的备份策略，那是不是就万事大吉呢？</p>\n<p>在一些极端情况，如：机房断电、机房火灾、地震、山洪等不可抗力因素，所有的服务器都可能出现故障，无法对外提供服务，导致整体业务瘫痪。</p>\n<p>为了降低风险，保证服务的24小时可用性，我们会采用 多活策略。</p>\n<p>常见的多活方案有，同城双活、两地三中心、三地五中心、异地双活、异地多活</p>\n<p>不同的方案技术要求、建设成本、运维成本也都不一样。</p>\n<p>多活的技术方案复杂，需要考虑的问题点也非常多，这里只是抛砖引玉就不过多展开</p>\n<h2> 8、隔离</h2>\n<p>隔离属于物理层面的分割，将若干的系统低耦合设计，独立部署，从物理上隔开。</p>\n<p>每个子系统有自己独立的代码库，独立开发，独立发布。一旦出现故障，也不会相互干扰。当然如果不同子系统间有相互依赖，这种情况比较特殊，需要有默认值或者异常特殊处理，这属于业务层面解决方案。</p>\n<p>隔离属于分布式技术的衍生产物，我们最常见的微服务解决方案。</p>\n<p>将一个大型的复杂系统拆分成若干个微服务系统，这些微服务子系统通常由不同的团队开发、维护，独立部署，服务之间通过 RPC 远程调用。</p>\n<p>隔离使得系统间边界更加清晰，故障可以更加隔离开来，问题的发现与解决也更加快速，系统的可用性也更高。</p>\n<h2> 9、限流</h2>\n<p>高并发系统，如果遇到流量洪峰，超过了当前系统的承载能力。我们要怎么办？</p>\n<p>一种方案，照单全收，CPU、内存、Load负载飚的很高，最后处理不过来，所有请求都超时无法正常响应。</p>\n<p>另一种解决方案，“舍得，有舍有得”，多余的流量我们直接丢弃。</p>\n<p>限流定义：</p>\n<p>限制到达系统的并发请求数量，保证系统能够正常响应部分用户请求，而对于超过限制的流量，则通过拒绝服务的方式保证整体系统的可用性。</p>\n<p>根据作用范围：限流分为单机版限流、分布式限流</p>\n<p>1、单机版限流</p>\n<p>主要借助于本机内存来实现计数器，比如通过AtomicLong#incrementAndGet()，但是要注意之前不用的key定期做清理，释放内存。</p>\n<p>纯内存实现，无需和其他节点统计汇总，性能最高。但是优点也是缺点，无法做到全局统一化的限流。</p>\n<p>2、分布式限流</p>\n<p>单机版限流仅能保护自身节点，但无法保护应用依赖的各种服务，并且在进行节点扩容、缩容时也无法准确控制整个服务的请求限制。而分布式限流，以集群为维度，可以方便的控制这个集群的请求限制，从而保护下游依赖的各种服务资源。</p>\n<p>限流支持多个维度：</p>\n<ul>\n<li>整个系统一定时间内（比如每分钟）处理多少请求</li>\n<li>单个接口一定时间内处理多少流量</li>\n<li>单个IP、城市、渠道、设备id、用户id等在一定时间内发送的请求数</li>\n<li>如果是开放平台，则为每个appkey设置独立的访问速率规则</li>\n</ul>\n<p>常见的限流算法：</p>\n<ul>\n<li>计数器限流(固定窗口限流)</li>\n<li>滑动窗口限流</li>\n<li>漏桶限流</li>\n<li>令牌桶限流</li>\n</ul>\n<h2> 10、熔断</h2>\n<p>熔断，其实是对调用链路中某个资源出现不稳定状态时（如：调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p>\n<p>熔断的主要方式是使用断路器阻断对故障服务器的调用</p>\n<p>断路器有三种状态，关闭、打开、半打开。</p>\n<ul>\n<li>1、关闭（Closed）状态：在这个状态下，请求都会被转发给后端服务。同时会记录请求失败的次数，当请求失败次数在一段时间超过一定次数就会进入打开状态。</li>\n<li>2、打开（Open）状态：在这个状态下，熔断器会直接拒绝请求，返回错误，而不去调用后端服务。同时，会有一个定时器，时间到的时候会变成半打开状态。目的是假设服务会在一段时间内恢复正常。</li>\n<li>3、半打开（Half Open）状态：在这个状态下，熔断器会尝试把部分请求转发给后端服务，目的是为了探测后端服务是否恢复。如果请求失败会进入打开状态，成功情况下会进入关闭状态，同时重置计数。</li>\n</ul>\n<h2> 11、降级</h2>\n<p>降级是系统保护的一种重要手段。</p>\n<p>正如 “好钢用在刀刃上”，为了使有限资源发挥最大价值，我们会临时关闭一些非核心功能，减轻系统压力，并将有限资源留给核心业务。</p>\n<p>比如电商大促，业务在峰值时刻，系统抵挡不住全部的流量时，系统的负载、CPU<br>\n的使用率都超过了预警水位，可以对一些非核心的功能进行降级，降低系统压力，比如把商品评价、成交记录等功能临时关掉。弃车保帅，保证<br>\n创建订单、订单支付 等核心功能的正常使用。</p>\n<p>当然，不同业务、不同公司，处理方式也各不相同，需要结合实际场景，和业务方同学一块讨论，最后达成一个统一认可的降级方案。</p>\n<p>总结下来：降级是通过暂时关闭某些非核心服务或者组件从而保护核心系统的可用性。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计数据库索引",
      "url": "https://ujava.cn/synthesis/databaseindex.html",
      "id": "https://ujava.cn/synthesis/databaseindex.html",
      "summary": "简介 建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。 基本知识 InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。 索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。",
      "content_html": "<h2> 简介</h2>\n<p>建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。</p>\n<h2> 基本知识</h2>\n<p>InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。</p>\n<p>索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。</p>\n<h4> 顺序索引</h4>\n<p>InnoDB 的顺序索引是将主键列表构建成一棵 B+ 树。内节点存放的是均是主键值，叶子节点存放的是整张表的行数据。这样，可以让节点尽可能存放更多的主键值，从而降低树的高度。B+ 树是有序查找平衡树，高度通常在 2-4 之间，因为要尽可能减少磁盘读写次数。B+ 树的插入操作在节点关键数满的情况下，会分裂成两个子节点。理解 B+ 树对于理解顺序索引非常关键。</p>\n<p>顺序索引可以分为聚簇索引和非聚簇索引。</p>\n<p>聚簇索引：在叶子节点中保存了 B-Tree 索引和数据行。将索引列放在内节点上，而将行数据放在叶子节点上。聚簇索引可以极大提升 IO 密集型的性能。一个表只能有一个聚簇索引，通常用主键列。聚簇索引的最优插入顺序是按照主键值顺序插入。如果是随机插入，更新聚簇索引的代价较高：更多的查找操作、频繁的“页分裂”、移动大量数据、产生碎片。<br>\n非聚簇索引：非聚簇索引的内节点存放的是非聚簇索引列的值，叶子节点存储的是对应数据行的主键值。因此，根据非聚簇索引需要两次索引查找。先从叶子节点找到主键值，再根据主键值在聚簇索引里找到数据行。非聚簇索引因为不存储数据行的信息，因此占用空间会比聚簇索引更小。</p>\n<h4> 哈希索引</h4>\n<p>使用哈希原理实现，性能很高，只能等值匹配，按索引整列匹配、不支持范围查找、不能用于排序。哈希函数可以选择 crc32 或者 md5 的一部分。哈希索引要避免大量冲突同时不占用过多空间。哈希索引的选择性取决于该列哈希列值的冲突度。Memory 引擎支持哈希索引，也支持 B+Tree 索引。可以为较长的字符串（比如 URL）创建哈希索引，在条件中必须同时带上哈希值条件和列值条件。where url = xxx and hashed_url = yyy 。</p>\n<p>InnoDB 为某些非常频繁的索引值在 B+ 上在内存中再创建一个哈希索引，称为自适应哈希索引。</p>\n<h2> 开发事项</h2>\n<h4> 适合做索引的列</h4>\n<p>选择性高原则。如果所有行在该列上的“不重复值数量/所有值数量”的比率越高，则选择性越高，越适合做索引。列的选择性：count(distinct(col)) / count(col) 。唯一索引的选择性是 1。使用 show index from tablename ，Cardinality 的值展示了索引列的不重复值的预估值。可以用来判断这个索引是否合适。如果 Cardinality 的值接近于表的记录总数，则是选择性高的。</p>\n<p>注意，在单列索引的时候，这个值对应指定索引列的 Cardinality 值，而在联合索引中，这个值对应联合列的 Cardinality 值。如下所示: sid_index 的值为 41659 , tid_index 的值是 101 , sid_index 的选择性高于 tid_index ； stc_id_index.t_id 的值是 3443139 ，是指 (s_id, t_id) 联合索引的值，高于 sid_index 单列索引的选择性。</p>\n<p>如何找到高选择性的列呢？</p>\n<ul>\n<li>定性分析：值比较倾向于唯一的，是高选择性的；而值域在某个有限集合的，是低选择性的。比如 ID 值通常是高选择性的，而 age 值则是低选择性的。</li>\n<li>测量分析：使用 count(distinct(col)) / count(col) 来计算，值越接近于 1 的是高选择性的。测量分析通常用于验证或否定。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 构建索引</h4>\n<p>先列出所有可能的搜索语句，找到出现的列，将选择性高的列放在最左边，有范围查找的列尽可能放最右边。从左开始逐个将列添加到联合索引里，尽可能覆盖所有搜索语句。可能需要建立多个联合索引来覆盖。最后，要考虑选择语句和排序语句的列，尽可能使用索引覆盖获取列数据，使用索引扫描来排序。</p>\n<h4> 联合索引</h4>\n<p>联合索引也是一棵 B+ 树，关键字是一个元组。类似索引的多级搜索，逐步大幅减少需要扫描和匹配的行。联合索引搜索遵循最左匹配原则。联合索引需要建立最优索引列顺序。注意，在每个需要搜索的列上建立单列索引，不是联合索引（搜索的时候只能单列搜索后，再用到索引合并来合并结果）。</p>\n<p>联合索引匹配遵循最左匹配原则。匹配终止条件：将搜索条件按照联合索引顺序重排列，遇到等值查询（包括 IN 查询）继续，遇到范围查询、BETWEEN、LIKE 查询则终止。无法使用索引的情况：在 where 条件中，索引列在表达式中或对索引列使用函数。</p>\n<p>实践中，需要用相同的列但顺序不同的联合索引来满足不同的查询需求。</p>\n<h4> 前缀索引</h4>\n<p>为长字符串建立索引。使用指定长度的字符串的前缀来建立索引。对于 BLOB, TEXT, 很长的 VARCHAR 列，必须使用前缀索引。前缀索引要选择一个合适的长度：选择性与整列的选择性接近，同时不占用过多空间。前缀索引无法使用 GROUP BY 和 ORDER BY，无法做覆盖扫描。如果字符串后缀或某个部分的选择性更高，也可以做一些预处理转化为前缀索引。思想是相同的。</p>\n<p>寻找前缀索引最佳长度的步骤：</p>\n<ul>\n<li>STEP1 - 先找到该列所有值的 TOPN，可以使用 count as c, col from table group by col order by c desc limit N 语句；</li>\n<li>STEP2 - 从一个比较合适的值（比如 3）开始，测试选择性，直到 TOPN 绝大部分列的 c 的数量与 TOPN 的 c 比较接近。</li>\n</ul>\n<h4> 覆盖索引</h4>\n<p>覆盖索引的列包含了所有需要查询的列，可以减少大量的磁盘读，大幅提升性能。如果某个列在 select cols 字句中频繁出现，也可以考虑放在联合索引里，利用覆盖索引来优化性能。延迟关联技术可以使用覆盖索引能力。</p>\n<h4> 索引扫描排序</h4>\n<p>只有当索引的列顺序与 ORDER BY 字句的顺序完全一致，并且所有列的排序方向都一样时，才能使用索引对结果做排序。有一个例外，就是前导列条件指定为常数。比如 (date, fans_id) 对于 where date = 'xxx' order by fans_id desc 也可以使用索引扫描排序。</p>\n<h4> 索引提示</h4>\n<p>可以使用 FORCE INDEX(a) 强制指定 SQL 语句要使用的索引。</p>\n<h4> MRR</h4>\n<p>Multi-Range Read。针对范围查询的优化。MRR 会将查询到的辅助索引键放到缓存里，然后按照主键排序（将随机 IO 转换为顺序 IO，可以减少页替换），再根据排序后主键来顺序来访问实际数据。适用于 range, ref, eq_ref 的查询。</p>\n<p>MRR 默认开启。使用 optimizer_switch 的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。<br>\nSET @@optimizer_switch='mrr=on,mrr_cost_based=on';</p>\n<h4> “系统账号”问题</h4>\n<p>索引列的某个值出现次数非常多。应避免使用系统账号值出现在查询语句里。</p>\n<h2> 索引实验</h2>\n<h4> 准备工作</h4>\n<h4> 准备表</h4>\n<p>假设有个学生选课表。如下所示：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 准备数据</h4>\n<p>写个 groovy 脚本生成 800w 条选课数据。批量插入的效率更高。单个插入，每刷新一次，几千的插入；批量插入，每刷新一次，20w 的插入。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>生成的样例数据如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以查看表空间大小：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 开始试验</h2>\n<h4> 给裸表添加索引</h4>\n<p>假设什么索引都不建，裸表一个，通过 s_id 搜索需要 2.94s; 添加 sid_index 索引后，同样的搜索不到 0.01s 。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用 explain 解释下：</p>\n<ul>\n<li>select_type：查询类型， SIMPLE 表示这是一个简单的 SELECT 查询；</li>\n<li>type: 表的连接类型。 const 表示匹配最多一行，通常是根据主键查询；ref 表示使用非主键/唯一索引匹配少量行； range 表示范围查询，&lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, IN, BETWEEN, LIKE ； index 扫描索引树，但数量太大，相当于全表扫描；ALL 全表扫描。</li>\n<li>possible_keys 和 key : 可能使用的索引以及实际使用的索引。</li>\n<li>ref: 对于 key 给出的列，哪些列或哪些常量被用来比较了。</li>\n<li>rows: 为了找到满足条件的行要扫描的预计行数。</li>\n<li>filtered: 被过滤行数的比例。</li>\n<li>Extra: 索引使用的额外信息。 Using Where 需要使用 where 字句条件来过滤记录; Using Index 要获取的列信息可以从索引树上拿到; Using filesort 文件排序; Using MRR 是否使用了 MRR 优化范围查询.</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对索引列使用了函数不会使用索引：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>假设有如下语句，可以看到使用了索引 sid_index ，从 194 条过滤到最终 3 条。因为 sid_index 已经过滤了绝大多数记录，因此添加 t_id 索引看上去没有必要。不过，这里只是某个 s_id 值的查询结果，不代表其它的 s_id 查询结果。不能仅仅据此就断定不需要加 (s_id, t_id) 联合索引。可以 count group by s_id 看看 s_id 的重复数量，进一步判断。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>现在删除 sid_index 索引，添加 tid_index 索引。看看情况如何。由于 t_id 选择性较低，添加 tid_index 过滤后仍然有 8w+ 条记录，两条搜索语句耗时 0.4s 左右。计算一下 s_id 和 t_id 的不重复行数量， s_id 更大，选择性更高。这说明：添加选择性高的索引，性能提升更优。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 联合索引</h4>\n<p>考虑如下语句。仍然使用 tid_index ，耗时 0.4s 。如果使用联合索引 (tid_index, cid_index) , 则耗时 0.03s 。相当于做了两次索引查找，当然比一次要快。代价是，索引占用空间更高。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>结合情形一，通常会将多个业务 ID 建成联合索引 (s_id, t_id, c_id) ，这样，(s_id), (s_id, t_id), (s_id, t_id, c_id) 的联合等值查询都可以应用到这个索引。由于 s_id 选择性非常大，可以单独建一个索引（节省索引占用空间）；而 (t_id, c_id) 需要建一个联合索引，因为 (s_id, t_id, c_id) 无法匹配 t_id 和 c_id 联合查询的情况。根据最左匹配原则，s_id 必须出现。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>联合索引是应对多条件查询的性能提升的关键。最左匹配原则是应用联合索引的最重要的原则之一。将查询条件按照联合索引定义的顺序 (a,b,c,d,e) 重新排列，逐个比较：</p>\n<ul>\n<li>如果查询条件均是等值查询，则出现顺序没有关系，按照联合索引定义顺序重新排列即可。比如 a=1 and b=2 与 b=2 and a=1 是等同的。顺序可以不同，但必须出现。如果 b=2 and c=3 就无法应用联合索引 (a,b,c,d,e) 了，因为 a 没出现。</li>\n<li>如果联合索引里没有出现该列，则匹配到此终止。比如 b=2 and a=1 and d = 4 只能应用 (a,b)，因为 c 没出现。</li>\n<li>如果联合索引里出现了范围匹配的列，则匹配到该列终止，后面的条件无法应用索引。比如 b=2 and a=1 and d=4 and c in (2,3) 只能应用 (a,b,c) ，因为 c 出现了范围匹配。<br>\n在 explain 命令中，可以看 ref , filter 来判断应用了哪些索引。如果没有应用到某个列的索引，也可以删除相应的查询条件，用 explain 命令的 ref 和 rows 来对比是否有变化。如果只应用到了某个索引，则 Extra = Using index condition 。 假设现在只建立了 (s_id, t_id, c_id) 联合索引。可以用 show index from student_courses; 查看建立了哪些索引。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>下面是各语句以及应用联合索引的情况：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 索引覆盖</h4>\n<p>索引覆盖是指 select 中的列均出现在联合索引列中。如下两个语句，后面那个语句应用了索引覆盖，Extra = Using index ，取列数据时可以直接从索引中获取，而不需要去读磁盘。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 索引扫描排序</h4>\n<p>索引可以用来排序，从而减少随机 IO，提升排序性能。如下三种情况可以应用索引排序：</p>\n<ul>\n<li>索引列顺序与 ORDER BY 子句的顺序完全一致时，并且所有列的排序方向都相同；如果要关联多张表，则 ORDER BY 引用的排序字段都为第一张表的字段时；</li>\n<li>如果前导列为等值查询，后续的 ORDER BY 子句的字段顺序与索引列顺序一致。<br>\n如果使用了索引排序，则 type = index ； 如果未能引用索引排序，那么 Extra 会提示 Using filesort 。</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> MRR</h4>\n<p>如果使用 MRR 导致的开销过高，也不会开启 MRR。此时，可以使用强制索引，或者设置无论如何都开启 MRR。如下所示，t_id &lt; 'T24' 会开启 MRR，但 t_id &lt; 'T32' 则不会开启。此时，可以强制使用索引 tc_index， 这样，就会使用 MRR。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 小结</h2>\n<p>数据库是开发人员最常打交道的软件，而索引是高效访问数据库的重中之重。深入理解索引的原理，合理设计适配查询的索引，是有必要下功夫的。</p>\n<p>索引基本功：</p>\n<ul>\n<li>根据查询条件创建高效的索引；</li>\n<li>理解最左匹配原则并定义最优的联合索引；</li>\n<li>尽可能用好覆盖索引和索引扫描。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "系统设计原则",
      "url": "https://ujava.cn/synthesis/design.html",
      "id": "https://ujava.cn/synthesis/design.html",
      "summary": "简介 好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。 业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。 在设计系统时，应该多思考墨菲定律: 任何事情都没有表面看起来那么简单 所有的事情都会比你预计的时间长 可能会出错的事一定会出错 如果你担心某种情况发生，那么它就更有可能发生",
      "content_html": "<h2> 简介</h2>\n<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>\n<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>\n<p>在设计系统时，应该多思考墨菲定律:</p>\n<ul>\n<li>任何事情都没有表面看起来那么简单</li>\n<li>所有的事情都会比你预计的时间长</li>\n<li>可能会出错的事一定会出错</li>\n<li>如果你担心某种情况发生，那么它就更有可能发生</li>\n</ul>\n<p>在系统划分时，也要思考康威定律:</p>\n<ul>\n<li>系统架构是公司组织架构的反映</li>\n<li>应该按照业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚/低耦合，减少沟通成本</li>\n<li>如果沟通出现问题，那么就应该考虑进行系统和组织架构的调整</li>\n<li>在合适时机进行系统拆分，不要一开始就把系统/服务拆得非常细，虽然闭环，但是每个人维护的系统多，维护成本高该处使用的url网络请求的数据。</li>\n</ul>\n<h2> 一、系统的技术设计原则</h2>\n<h3> 1.1.高并发原则</h3>\n<h4> 1.1.1.无状态</h4>\n<p>如果设计的是无状态的，那么应用比较容易进行水平扩展。</p>\n<p>实际生产环境可能是这样的：应用无状态，配置文件有状态。比如，不同的机房需要读取不同的数据源，此时，就需要通过配置文件或配置中心指定。比如后台系统使用session共享机制保证分布式部署。</p>\n<h4> 1.1.2.拆分</h4>\n<p>在系统设计时，要考虑到系统是否做拆分。如果资源有限，并且用户并没有那么多，可以做一个大而全的系统。</p>\n<p>而高并发的应用，通常是要做拆分的。拆分可以依据多个维度：</p>\n<ul>\n<li>系统维度 ：如订单、库存、商品系统等</li>\n<li>功能维度 ：如，对登录系统再拆分，划分为 ：验证码登录、微信登录、密码登录等功能。</li>\n<li>读写维度 ：针对读写再做分离，读服务可以使用缓存、写服务使用分库分表。</li>\n</ul>\n<h4> 1.1.3.服务化</h4>\n<p>首先判断单点服务是否可以满足。如果不能满足，集群可以吗？使用Nginx做负载均衡是否可以解决？</p>\n<p>服务越来越多，是否要使用服务自动注册与发现？某些服务访问量太大，导致整个系统不可用，要不要上服务降级和限流？哪些是主要服务？</p>\n<h4> 1.1.4.消息队列</h4>\n<p>消息队列的作用有三个 ：削峰、解耦、异步。</p>\n<p>使用消息队列可以实现服务解耦（一对多消费）、异步处理、流量削峰/缓冲等。但是订阅者太多，那么订阅单个消息队列就会成为瓶颈，此时需要考虑对消息队列进行多个镜像复制。</p>\n<p>使用消息队列时，需要注意消息丢失、重复接收的场景。这对于不能容忍生产失败的业务场景来说，一定要做好后续的数据处理工作，比如持久化数据同时要增加日志、报警等，或者在生产失败后发送http请求来保证成功。还有消息重复问题，特别是一些分布式消息队列，出于对性能和开销的考虑，在一些场景下会发送消息重复接收，需要在代码层面进行防重处理。</p>\n<h4> 1.1.5.缓存</h4>\n<p>缓存对读服务来说，是扛流量的必选技术。不同的场景缓存不同的信息，以解决不同的问题：</p>\n<ul>\n<li>浏览器端缓存</li>\n<li>客户端缓存</li>\n<li>CDN缓存</li>\n<li>接入层缓存: 使用Nginx做一层缓存</li>\n<li>应用层缓存</li>\n<li>分布式缓存</li>\n<li>异步与并发:某些资源实时性没那么高，可以考虑使用异步加载，如用户评价、商品打分这种。获取多个资源时，采用并发的方式获取，可以大大的加快访问速度。</li>\n</ul>\n<h4> 1.1.6.数据异构</h4>\n<p>所谓数据异构，是把数据按需（数据结构、存取方式、存取形式）异地构建存储。比如将mysql里面的数据缓存到redis里面去，就是一种数据异构的方式。</p>\n<p>分库分表中有一个最为常见的场景，为了提升数据库的查询能力，我们都会对数据库做分库分表操作。比如订单库，开始的时候是按照订单ID维度去分库分表，那么后来的业务需求按照商家维度去查询。相同的数据需要做多种异构可以使用MQ机制接收数据的变更，然后存储到合适的存储引擎，如订单id纬度的分库分表、商家纬度的分库分表、用户纬度的分库分表、redis、Elasticsearch等。</p>\n<p>另外，还需要考虑对历史订单数据进行归档处理，以提升服务的性能和稳定性。而有些数据异构的意义不大，如库存架构，可以考虑异步加载，或者合并并发请求。</p>\n<p>总结起来大概有以下几种场景：</p>\n<ul>\n<li>\n<p>数据库镜像</p>\n</li>\n<li>\n<p>数据库实时备份</p>\n</li>\n<li>\n<p>多级索引</p>\n</li>\n<li>\n<p>search build（比如分库分表后的多维度数据查询）</p>\n</li>\n<li>\n<p>业务cache刷新</p>\n</li>\n<li>\n<p>价格、库存变化等重要业务消息<br>\n常见的异构方式：</p>\n</li>\n<li>\n<p>完全克隆。做数据备份。将数据库A，全部拷贝一份到数据库B，这样的使用场景是离线统计跑任务脚本的时候可以。缺点也很突出，不适用于持续增长的数据。</p>\n</li>\n<li>\n<p>binlog方式。比如使用比较广泛的canal是基于mysql数据库binlog的增量订阅和消费组件。订阅mysql的binlog日志，消费这些日志做主从同步、缓存更新。</p>\n</li>\n<li>\n<p>MQ方式。业务数据写入DB的同时，也发送MQ一份，也就是业务里面实现双写，消费MQ的数据做各种异构处理。这种方式比较简单，但也很难保证数据一致性，对简单的业务场景可以采用这种方式。</p>\n</li>\n</ul>\n<h3> 1.2.高可用原则</h3>\n<h4> 1.2.1.降级</h4>\n<p>对于一个高可用服务，很重要的一个设计就是降级开关，提前写好降级逻辑。</p>\n<p>可以手动降级，也可以自动降级。自动降级触发的条件可以使用：超时的请求数超过阈值、异常的请求数超过阈值时。阈值具体设置为多少，通过压测初步确认，上线观察后，再次调整。</p>\n<p>降级的手段：停止读数据库、准确结果转为近似结果、使用静态结果、同步转异步、功能裁剪、禁止写（高峰期减少不必要的写）、分用户降级、工作量证明POW(<br>\n验证码、数学题、拼图、滑块)。</p>\n<p>主要依据如下思路：</p>\n<ul>\n<li>开关集中化管理：通过推送机制把开关推送到各个应用。</li>\n<li>可降级的多级读服务：可以指定服务调用降级为只读本地缓存、只读分布式缓存、只读默认数据。</li>\n<li>开关前置化: 如架构是Nginx—&gt;Apache，可以将开关前置到Nginx接入层，在Nginx层做开关，请求流量汇源后端应用或者只是一小部分流量回源</li>\n<li>业务降级：当高并发流量来袭，保证核心业务是正常的，并保障数据最终一致性即可。这样就把一些同步调用改成异步调用，优先处理高优先级数据或特殊特征的数据，合理分配进入系统的流量，以保障系统可用。</li>\n</ul>\n<h4> 1.2.2.限流</h4>\n<p>当监控发现外部流量超过阈值或内部资源使用达到阈值（通过压测、上线观察、调整）时，告知各系统限流打开。</p>\n<p>限流的目的是防止恶意请求流量，或者防止流量超出系统峰值。思路如下：</p>\n<ul>\n<li>\n<p>基于请求的限流：</p>\n<ul>\n<li>限制请求总量。如腾讯会议最多500人。</li>\n<li>限制时间量。如一个时间窗口内最多接受100个请求。</li>\n</ul>\n</li>\n<li>\n<p>基于关键资源的限流：</p>\n<ul>\n<li>统计连接数、线程数、cup等硬件参数。难点是如何确定哪些是关键资源、阈值是多少。</li>\n<li>使用池化技术：线程池、连接池；使用队列排队；</li>\n</ul>\n</li>\n</ul>\n<p>相关限流的算法：</p>\n<ul>\n<li>滑动时间窗口：有突刺</li>\n<li>漏桶: 请求进入队列的速度不受限制，但是超过队列的大小就拒绝，请求出队列的速度固定。请求会匀速出队列。</li>\n<li>令牌桶：系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。有突刺。<br>\n有些大流量是正常的用户，这种是要临时的水平扩容。</li>\n</ul>\n<p>原则是限制流量穿透到后端薄弱的应用层</p>\n<h4> 1.2.3.熔断</h4>\n<p>熔断发生的三个必要条件，缺一不可，必须全部满足才能开启 hystrix 的熔断功能：</p>\n<ul>\n<li>\n<p>有一个统计的时间周期，滚动窗口；如1000毫秒</p>\n</li>\n<li>\n<p>请求次数必须达到一定数量；如20次</p>\n</li>\n<li>\n<p>失败率达到阈值；如50%<br>\n熔断器的三个状态：</p>\n</li>\n<li>\n<p>关闭状态。关闭状态时用户请求是可以到达服务提供方的。</p>\n</li>\n<li>\n<p>开启状态。开启状态时用户请求是不能到达服务提供方的，直接会走降级方法。</p>\n</li>\n<li></li>\n</ul>\n<p>半开状态。当熔断器开启时，过一段时间后，熔断器就会由开启状态变成半开状态。半开状态的熔断器是可以接受用户请求并把请求传递给服务提供方的，这时候如果远程调用返回成功，那么熔断器就会有半开状态变成关闭状态，反之，如果调用失败，熔断器就会有半开状态变成开启状态。<br>\nHystrix功能建议在并发比较高的方法上使用，并不是所有方法都得使用的。</p>\n<p>Sentinel的熔断策略是根据响应时间，响应时间超过阈值，熔断开关打开。</p>\n<h4> 1.2.4.恢复</h4>\n<p>撤出限流、消除降级、关闭熔断</p>\n<p>熔断使用半开状态，完成吞吐量爬升、缓存预热。</p>\n<p>灰度发布，限流阈值逐步提升。</p>\n<h4> 1.2.5.隔离</h4>\n<ul>\n<li>数据隔离：数据按照重要性排序、分库</li>\n<li>机器隔离：给重要的用户单独配置服务器，用用户标识去路由</li>\n<li>线程池隔离：线程池分配。hystrix</li>\n<li>信号量隔离：计数器。hystrix</li>\n<li>集群隔离：服务分组（注册中心）、秒杀</li>\n<li>机房隔离：3个服务。局域网IP、路由。</li>\n<li>读写隔离：主从</li>\n<li>动静隔离：识别静态资源。nginx CDN</li>\n<li>爬虫隔离：对IP的访问频率</li>\n<li>冷热隔离：秒杀、抢购。读：缓存；写：缓存+队列</li>\n</ul>\n<h4> 1.2.6.异地多活</h4>\n<p>异地机房部署相同的服务，同时对外提供服务（不是备份）。防止因为停电、火灾、水灾、地震、战争等问题导致服务不可用。</p>\n<p>异地多活通常考虑RTT(round trip time):网络请求一个来回消耗的传输时间。光纤光速计算 300000 KM/s，两个机房如果一个在上海，一个在新疆，隔5000KM，<br>\nrtt = 300000 / 5000 * 2 = 120毫秒的往返时延。</p>\n<p>多活要求：</p>\n<ul>\n<li>\n<p>请求任何一个节点，都能正常响应</p>\n</li>\n<li>\n<p>某些系统故障，用户访问其他系统也能访问<br>\n分类：</p>\n</li>\n<li>\n<p>同城异区：距离较近，可以防止停电、机房起火</p>\n</li>\n<li>\n<p>跨域异地：距离较近，可以防止停电、机房起火、火灾、水灾、地震。</p>\n</li>\n<li>\n<p>跨国异地（隔离）：延迟，已经无法让系统提供服务了。通常在异国开展业务，数据和服务就放在异国，和国内数据是隔离的。<br>\n异地多活容易出现数据不一致问题，要保证核心业务的多活。如用户系统有注册、登陆、修改用户信息等功能，保证正常注册、登陆多活，修改用户信息可以根据时间合并数据。</p>\n</li>\n</ul>\n<h4> 1.2.7.可回滚</h4>\n<p>灰度发布。版本化机制，当程序出错时，回滚到上一个版本。</p>\n<h2> 二、业务设计原则</h2>\n<h3> 2.1.防重、幂等</h3>\n<p>重复提交业务，消息中间件重复消费消息。使用分布式锁、数据库唯一键等保证。</p>\n<h3> 2.2.模块复用</h3>\n<p>相同的功能只开发一次，模块化。不要到处拷贝相同的代码。</p>\n<h3> 2.3.可追溯</h3>\n<p>可以快速追踪到问题涉及的这个数据链路，快速定位问题。traceId</p>\n<h3> 2.4.反馈原则</h3>\n<p>给出精确友好的结果反馈。如http接口调用异常时尽量给出精确的异常原因，降低内外部沟通成本。</p>\n<h3> 2.5.流程可定义</h3>\n<p>相关工作有明确的流程规范</p>\n<h3> 2.6.系统审批化</h3>\n<p>系统变更需要审批</p>\n<h3> 2.7.文档和注释</h3>\n<p>完善文档和注释</p>\n<h3> 2.8.备份</h3>\n<ul>\n<li>代码备份：git、分支</li>\n<li>数据备份：运维备份，操作记录备份。</li>\n<li>人员备份：不因个人离职导致项目停滞。</li>\n</ul>\n<h3> 2.9.规范</h3>\n<p>制定规范，定期review。</p>\n<h2> 三、系统性能常见指标</h2>\n<h3> 3.1.响应时间（Response time）</h3>\n<p>响应时间就是用户感受软件系统为其服务所耗费的时间，对于网站系统来说，响应时间就是从点击了一个页面计时开始，到这个页面完全在浏览器里展现计时结束的这一段时间间隔，看起来很简单，但其实在这段响应时间内，软件系统在幕后经过了一系列的处理工作，贯穿了整个系统节点。</p>\n<p>根据“管辖区域”不同，响应时间可以细分为：</p>\n<ul>\n<li>服务器端响应时间这个时间指的是服务器完成交易请求执行的时间，不包括客户端到服务器端的反应（请求和耗费在网络上的通信时间），这个服务器端响应时间可以度量服务器的处理能力。</li>\n<li>网络响应时间，这是网络硬件传输交易请求和交易结果所耗费的时间。</li>\n<li>客户端响应时间，这是客户端在构建请求和展现交易结果时所耗费的时间，对于普通的瘦客户端Web应用来说，这个时间很短，通常可以忽略不计；但是对于胖客户端Web应用来说，比如Java<br>\napplet、AJAX，由于客户端内嵌了大量的逻辑处理，耗费的时间有可能很长，从而成为系统的瓶颈，这是要注意的一个地方。<br>\n那么客户感受的响应时间其实是等于客户端响应时间+服务器端响应时间+网络响应时间。细分的目的是为了方便定位性能瓶颈出现在哪个节点上。</li>\n</ul>\n<h3> 3.2.吞吐量（Throughput）</h3>\n<p>吞吐量是我们常见的一个软件性能指标，对于软件系统来说，“吞”进去的是请求，“吐”出来的是结果，而吞吐量反映的就是软件系统的“饭量”，也就是系统的处理能力，具体说来，就是指软件系统在每单位时间内能处理多少个事务/请求/单位数据等。但它的定义比较灵活，在不同的场景下有不同的诠释，比如数据库的吞吐量指的是单位时间内，不同SQL语句的执行数量；而网络的吞吐量指的是单位时间内在网络上传输的数据流量。吞吐量的大小由负载（如用户的数量）或行为方式来决定。举个例子，下载文件比浏览网页需要更高的网络吞吐量。</p>\n<h3> 3.3.资源使用率（Resource utilization）</h3>\n<p>常见的资源有：CPU占用率、内存使用率、磁盘I/O、网络I/O。</p>\n<h3> 3.4.点击数（Hits per second）</h3>\n<p>点击数是衡量Web Server处理能力的一个很有用的指标。需要明确的是：点击数不是我们通常理解的用户鼠标点击次数，而是按照客户端向Web<br>\nServer发起了多少次http请求计算的，一次鼠标可能触发多个http请求，这需要结合具体的Web系统实现来计算。</p>\n<h3> 3.3.并发用户数（Concurrent users）</h3>\n<p>并发用户数用来度量服务器并发容量和同步协调能力。在客户端指一批用户同时执行一个操作。并发数反映了软件系统的并发处理能力，和吞吐量不同的是，它大多是占用套接字、句柄等操作系统资源。</p>\n<p>另外，度量软件系统的性能指标还有系统恢复时间等，其实凡是用户有关资源和时间的要求都可以被视作性能指标，都可以作为软件系统的度量，而性能测试就是为了验证这些性能指标是否被满足。</p>\n<h2> 四、总结</h2>\n<p>一个系统的设计，不仅需要考虑实现业务功能，还要保证系统高并发、高可用等。在系统容量规划（流量、容量等）、SLA制定（吞吐量、响应时间、可用性、降级方案等）、压测方案（线上、test等）、监控报警（机器负载、响应时间、可用率等）、应急预案（容灾、降级、限流、隔离、切流量、可回滚）等方面，也要有一些原则来进行设计。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "影响项目的要素及经验总结",
      "url": "https://ujava.cn/synthesis/effect.html",
      "id": "https://ujava.cn/synthesis/effect.html",
      "summary": "简介 项目失败的因素主要分为以下几类 技术原因 1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足； 2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善； 3、为非技术问题提供了技术解决方案，没有认真思考问题的本质； 4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性； 5、在开发生命周期过程中没有充分利用工具； 6、以技术为导向进行开发，而不是需求导向； 人为因素 1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；",
      "content_html": "<h2> 简介</h2>\n<p>项目失败的因素主要分为以下几类</p>\n<h2> 技术原因</h2>\n<p>1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足；</p>\n<p>2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善；</p>\n<p>3、为非技术问题提供了技术解决方案，没有认真思考问题的本质；</p>\n<p>4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性；</p>\n<p>5、在开发生命周期过程中没有充分利用工具；</p>\n<p>6、以技术为导向进行开发，而不是需求导向；</p>\n<h2> 人为因素</h2>\n<p>1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；</p>\n<p>2、缺少领导，团队内部多头领导；</p>\n<p>3、没有敬业精神的项目团队；</p>\n<p>4、功能不全的项目团队，人员配比缺失；</p>\n<p>5、管理第三方的因素，如技术外包的项目；</p>\n<p>6、缺少一个项目精英，如专职的项目经理；</p>\n<p>7、缺少项目所有权；</p>\n<p>8、相关人员冲突，指人员配比失衡；</p>\n<p>9、拒绝变更，无法面对需求的变化；</p>\n<p>10、不友好的组织文化；</p>\n<p>11、经验不足的项目经理；</p>\n<p>12、缺少商业理由，项目的价值较低；</p>\n<p>13、不清晰或模棱两可的优先级；</p>\n<p>14、缺少培训，项目执行过程中状况百出；</p>\n<p>15、相关人员动机不一致，缺乏向心力；</p>\n<h2> 过程管理因素</h2>\n<p>1、 缺少项目管理方法体系；</p>\n<p>2、 缺少系统开发方法体系；</p>\n<p>3、缺少收益管理方法体系；</p>\n<p>4、缺少质量管理方法体系；</p>\n<p>5、未能确定和转移项目风险；</p>\n<p>6、未能管理好需求；</p>\n<p>7、过长的项目时间表；</p>\n<p>8、测试覆盖不足；</p>\n<p>9、计算机化的”爆炸“方法</p>\n<p>从失败中吸取教训是不断改进过程的重要组成部分，下面罗列一些主要的经验教训。</p>\n<h2> 管理用户预期</h2>\n<p>即项目人员要从一开始就明白需要交付什么以及不要交付什么，要在项目中确定用户的需求和建立尽可能清晰的所有权。即使在最好的情况下，用户以前收到的信息也是有限的。通常情况下，我们很难确定能够提供反馈信息的合适用户。在项目一开始就需要确定主要的用户需求，并且为主要用户提供时间，以便他们确定所有的需求，同时他们也有责任提供和验证信息并投入相应的资源。</p>\n<h2> 项目规格说明书中必须考虑价值和用户需求</h2>\n<p>第一，项目是因为可确定且可测量的用户需求而产生并发展的。在项目初期确定的清晰目标将随着项目的进展而逐渐变得模糊，这是交付期限过长的项目所共有的特点。因此在项目开始之前，需要确定最终用户，以便在项目的设计和开发过程中充分考虑到他们的需求，同时用户也有责任而且需要采取相应的行动来帮助项目获得成功，这一点非常重要。用户需求构成了项目分析和设计阶段中一个至关重要的环节。需求确定后，就要为这些需求确定基线，并将它们引入到项目管理系统中，同时使用变更控制对其进行管理。如果这些需求出现了变更或添加了新需求，则需要对项目进行影响分析，并对项目计划进行相应的修正。</p>\n<p>第二，项目规格说明书必须关注项目价值而不是技术解决方案。因此，即使从技术上讲已经存在明确的解决方案，但在进行项目评审时仍需将重点放在与项目价值相关的方面。</p>\n<h2> 在确定资源前测量和评估项目的规模和复杂度（重视实现性）</h2>\n<p>技术力量的发展带来了一个不好的后果，就是让我们相信，许多以前不可能实现的目标如今不但可以实现了，而且可以轻而易举地实现。有时候这种想法在项目的早期阶段通常表现为对项目的潜在收益过分夸大、过于庞大的项目范围定义以及过分乐观却相当危险且不够详细的项目规划。项目的规模和复杂度是项目成功与否的一个决定性因素，因此我们需要明确确定的是</p>\n<p>a、提议的项目进度表是否现实可行；</p>\n<p>b、项目的需求案例是否可行；</p>\n<p>c、解决方案在技术上是否可行；</p>\n<h2> 新技术的引入必须安排相应的培训</h2>\n<p>新技术或者一些开源工具会给项目带来的不少影响，容易导致有关程序员角色和责任的不明确。因此在项目计划中纳入培训成本和时间进度以确保员工知道如何使用和维护系统是至关重要的。没有合理的培训就是永远不可能实现软件投资的全部潜在收益。更重要的是，缺少培训可能会为项目带来实现风险和运作风险，这些风险可能会最终威胁项目的长期可用性。</p>\n<h2> 清晰可见的项目管理结构</h2>\n<p>在管理结构中必须存在定义清楚的角色、责任和义务，明确各个项目成员自身所处的角色及相应的职责。在项目的开始阶段就应该确定正式的组织结构以及与高级管理层交流的途径，同时在项目的整个过程中予以保持。</p>\n<h2> 处理好人员问题</h2>\n<p>人才永远是项目成功的最重要因素。人员开发计划必须与组织中的项目管理框架同步进行，从而提供培训、业绩评估、分派工作和职位晋升相关的机制。谁都希望项目团队里都是高度主动性和熟练技能的员工，但现实往往很残酷，如果应届生较多的话，还是早点安排老员工带一下，这样能尽快的上手。</p>\n<h2> 接受风险，但要严格管理风险</h2>\n<p>项目的成功实现需要有有效的风险管理所支持的创造性思维。要及时对一些影响项目进度的功能模块进行调查并重新进行风险分析工作以及后续的风险管理工作，从而对需求进行重新评估并相应的调整计划。</p>\n<p>项目管理是一门学问，需要一定时间的工作经验积累，并不是去考个PMP回来就能当项目经理的，真正注重的还是实践，照搬理论那一套的话，很多公司内部的现状都不足以支撑PMP所要求的完善体系，大型公司可以试下。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计实践经验",
      "url": "https://ujava.cn/synthesis/experience.html",
      "id": "https://ujava.cn/synthesis/experience.html",
      "summary": "简介 记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。 涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。 使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。 使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。 将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用 OAuth2.0 协议来实现多渠道认证。 账号系统在设计维度上一般主要有 登录方式、渠道。 合并登录方式 登录方式以手机号为中心 合并。 渠道分组，按渠道分组分区分服。 事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。 go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。 业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。 使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。 一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。 如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。 业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。 mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。( 例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择",
      "content_html": "<h2> 简介</h2>\n<ul>\n<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>\n<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>\n<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>\n<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>\n<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>\nOAuth2.0 协议来实现多渠道认证。\n<ul>\n<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>\n<li>合并登录方式 登录方式以手机号为中心 合并。</li>\n<li>渠道分组，按渠道分组分区分服。</li>\n</ul>\n</li>\n<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>\n<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>\n<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>\n<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>\n<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>\n<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>\n<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>\n<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>\n例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>这个操作相对比较耗费性能，要谨慎操作。在数据量超千万的表中进行释放，一定要保证cpu核数至少大于等于2。因为这时候会占用1core的资源全部用来处理。时长可能超过5min。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计容错",
      "url": "https://ujava.cn/synthesis/faulttolerant.html",
      "id": "https://ujava.cn/synthesis/faulttolerant.html",
      "summary": "简介 在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。 错误源 要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。 要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。 机器节点 磁盘故障、内存耗尽、CPU 100% 占用、掉电；",
      "content_html": "<h2> 简介</h2>\n<p>在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。</p>\n<h2> 错误源</h2>\n<p>要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。</p>\n<p>要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。</p>\n<h4> 机器节点</h4>\n<ul>\n<li>磁盘故障、内存耗尽、CPU 100% 占用、掉电；</li>\n</ul>\n<h4> 网络</h4>\n<ul>\n<li>DNS 故障、机架故障、路由器故障、设备故障、电缆故障；</li>\n<li>连接中断、请求排队（延迟）、网络丢包、网络重传、网络拥塞、网络分区。</li>\n</ul>\n<h4> 时间</h4>\n<ul>\n<li>很多监控统计依赖于时钟；</li>\n<li>数据最终一致性的操作依赖于到达先后顺序；</li>\n<li>同一台机器的时钟晶振可能受温度影响而波动；</li>\n<li>不同机器上的时钟是不一致的，通过 NTP 协议同步；</li>\n<li>NTP 协议是经过网络的，这意味着网络的不稳定会影响时钟的同步；</li>\n<li>“跳秒”现象：1 分钟有 59s 或 61s ；</li>\n<li>任务耗时过长，对外部来说就是无响应。</li>\n</ul>\n<h4> 资源</h4>\n<ul>\n<li>资源不存在，比如文件不存在；</li>\n<li>资源暂时不可用，比如端口已占用；</li>\n<li>没有可用资源，比如连接池满；</li>\n<li>资源路径已经被移动；</li>\n<li>资源访问时的同步死锁。</li>\n</ul>\n<h4> 数据</h4>\n<ul>\n<li>不符合预期格式的数据；</li>\n<li>脏数据引起解析错误；</li>\n<li>不一致的数据引起后继行为错误；</li>\n<li>大对象数据引起 FullGC 导致响应不稳定；</li>\n<li>错误配置；</li>\n<li>非法请求获得正常资源；</li>\n<li>恶意代码。</li>\n</ul>\n<h4> 计算</h4>\n<ul>\n<li>溢出，不符合运算法则；</li>\n<li>除零，无值可表示；</li>\n<li>有限精度，浮点计算错误；</li>\n<li>逻辑错误，比如越界、不正确的算法。</li>\n</ul>\n<h4> 设计</h4>\n<ul>\n<li>设计不足或不合理，容易令人疏忽而导致误操作；</li>\n<li>危险操作无确认、无提示，容易造成损失；</li>\n<li>少数服从多数原则，达不到多数；</li>\n<li>Leader 的消息无法被其它节点接收，被其它节点判定为下线。</li>\n</ul>\n<h4> 流程</h4>\n<ul>\n<li>中途取消操作；</li>\n<li>逆向操作。</li>\n</ul>\n<h4> 负荷</h4>\n<ul>\n<li>大流量超出应用承受负荷。</li>\n</ul>\n<h4> 安全</h4>\n<ul>\n<li>非授权访问；</li>\n<li>数据泄露；</li>\n<li>数据被篡改；</li>\n<li>访问拒绝。</li>\n</ul>\n<h4> 并发</h4>\n<ul>\n<li>数据覆写：访问一个共享资源时，进程 A 获取锁，然后进入了 stop-the-world GC pause ； 进程 B 发现锁已过期，然后申请获得锁，进行数据写操作，接着释放锁；进程 A 结束 GC，进行数据写操作。 进程 A 将 进程 B 的写数据覆盖了。</li>\n</ul>\n<h4> 拜占庭错误</h4>\n<ul>\n<li>当分布式系统里的节点要达成共识时，少数节点故意发送错误消息迷惑其它节点，以造成整体错误决策。比如航天领域防电子辐射干扰、多参与者协作和决策。</li>\n</ul>\n<h2> 健壮性</h2>\n<p>健壮性是极为重要的程序质量属性。分为代码健壮性和业务健壮性。健壮性体现在代码和业务上的错误和异常处理上，避免整体失败、数据泄露、不一致、资损等故障。要做出健壮性好的设计和程序，就要预先思考清楚：流程中有哪些可能的错误和异常，每一种对应的处理措施是什么 ？ 这样，才能让逻辑思维更加缜密，也是锻炼逻辑思维的一种有效之法。</p>\n<ul>\n<li>代码健壮性体现在避免局部失败导致整体失败。常见考虑：参数校验以拦截不合法请求、越界异常捕获、JSON 脏数据异常捕获、类型转换异常捕获、底层异常捕获（连接异常、DB 异常、网络超时异常等）。</li>\n<li>业务健壮性体现在业务的闭合环。在整个业务过程中会发生什么异常，导致什么问题（体验或资损问题），如何处理。比如同城异常检测要考虑商家同城呼叫失败后又快递发货的情形。</li>\n</ul>\n<h2> 容错机制</h2>\n<h4> 思路与方法</h4>\n<ul>\n<li>设定系统假定，检测系统假定是否成立，然后在系统假定上构建系统；</li>\n<li>聚焦高频错误：磁盘故障 &gt; 服务器单机故障 &gt; DNS 故障 &gt; 机架故障 &gt; 路由器重启；</li>\n<li>错误提示规范：定义规范一致的错误码和错误消息；</li>\n<li>快速失败并记录日志：适用于“请求检测，请求中含有错误或非法数据”的场景；</li>\n<li>忽略失败并记录日志：适用于“不影响整体输出且不造成负面影响的极次要地方有点小问题”的场景；</li>\n<li>确认机制：设计一种确认机制，确保交互的多方参与者满足某种契约或约束；</li>\n<li>预防策略：避免容易导致错误的做法；</li>\n<li>冗余策略：冗余、替换、路由，见高可用部分；</li>\n<li>降级策略：当核心服务出现问题时，提供有损服务来维持稍低质量的服务，保证服务的可用性；</li>\n<li>重试策略：幂等；完全重试；补偿重试；</li>\n<li>回滚策略：中途取消，重续执行很容易导致脏数据，考虑回滚操作；</li>\n<li>故障恢复：监控、检测错误和故障、自动恢复；</li>\n<li>乐观锁：递增的 fencing token ，防止过期写操作覆盖已经完成的写操作；</li>\n</ul>\n<h4> 系统假定</h4>\n<ul>\n<li>同步模型假定：任何网络延迟、进程暂停、时钟错误都不可能超出某个上限值。即：有限的网络延迟；有限的进程暂停；有限的时钟错误。</li>\n<li>部分同步模型假定：在同步模型假定的基础上，允许极少数的无法预测的超上限的网络延迟、进程暂停、时钟错误。</li>\n<li>异步模型假定：对时序不做假定，难以预料事件何时发生和动作何时执行。</li>\n<li>节点崩溃假定：节点突然失去响应，再也无法正常运行；</li>\n<li>节点崩溃-恢复假定：节点可能在任何时候失去响应，在一段时间之后自动恢复并正常运行；易失性存储（比如内存）中的数据丢失，而持久性存储（比如磁盘）中的数据完好；</li>\n<li>拜占庭假定：部分节点通过虚假消息欺骗其它节点，从而诱导作出错误的整体决策。</li>\n</ul>\n<p>最常见的系统假定：部分同步模型假定 + 节点崩溃-恢复假定。</p>\n<h4> 算法的正确性</h4>\n<ul>\n<li>正确性假定：算法满足某些指定性质。</li>\n<li>达成预期结果、安全、活性。</li>\n</ul>\n<h4> 重试</h4>\n<ul>\n<li>使操作满足幂等性质；</li>\n<li>可以使用失败队列来记录失败的操作及失败信息、失败现场；</li>\n<li>完全重试策略：整个操作从头开始执行，适合多读少写的长事务；</li>\n<li>补偿重试策略：从失败现场的地方重续执行，适合多写且回滚代价昂贵的长事务；‘</li>\n<li>完全重试策略，可指定重试次数；</li>\n<li>可采用定时任务重试。</li>\n<li>幂等：唯一索引、Token 机制（防页面重复提交）、分布式锁、select+insert、状态机幂等、查询/删除天然幂等。</li>\n</ul>\n<h4> 故障检测与恢复</h4>\n<ul>\n<li>故障检测主要靠监控。服务器监控（CPU、内存利用率、Load、IO RW、Net RW）、服务监控（RT、QPS、消费速率</li>\n<li>、延迟、网络连接；来源、TOPN）、Java 监控（ThreadPool、Heap、GC 等）、异常监控（失败次数、失败比例；超时，消费堆积或不均）、业务监控（瞬时峰值、瞬时下跌、同比上涨或下跌、大数据对象）、对账监控（数据一致性检测，尤其资金相关）。</li>\n<li>心跳机制：心跳机制用于故障检测。每台工作机每隔指定时间将自己的CPU、内存、磁盘、网络、IO读写、负载等情况上报给 Master， Master 会判断服务器是否正常，以决定是否分发流量给该服务器。每台服务器与 Master 有个超时设置，如果达到超时没有收到该服务器的心跳信息，则会判断服务器出现问题。心跳机制需要 KeepAlive （连接最大空闲时间） 属性，使用 MQTT 协议。</li>\n<li>租约机制：每台工作机向 Master 申请具有一定租约期限的服务时间。当服务时间快到时，再向 Master 继续申请延长租约的有效期。如果因为网络或工作机故障导致租约无法响应，则会将该工作机隔离，不再提供服务。</li>\n<li>WAL（Write Ahead Log）： 预写日志，恢复日志。基本机理是复制状态机、备忘录、备份。关系数据库系统中用于提供原子性和持久性。in-place 和 shadow paging 。提升磁盘写性能：随机读写改顺序读写、缓冲单条读写改批量读写、单线程读写改并发读写。同步 WAL 文件和数据库文件的行为被称为 checkpoint（检查点）。实现方法：DB - undo, redo 机制；ES - fsync 机制；ZK - 先写 WAL，再更新内存，最后通知客户端；定期将内存中的目录树进行 Snapshot，落磁盘； ETCD - wal 和 snap 目录； HBase - 更新数据前写 WAL， 且写 WAL 与数据更新在同一事务。</li>\n<li>检查点（CheckPoint）：系统定期将内存状态以检查点文件的形式dump到磁盘中，并记录检查点时刻对应的操作日志回放点。 检查点可以快速提升故障恢复的速度。</li>\n<li>备份。备份是应对数据故障（丢失、不一致）的重要保障。备份只是实现数据的恢复，并不能完全实现故障恢复。故障恢复是指服务或服务器回到正常可用状态。</li>\n</ul>\n<h4> MySQL备份</h4>\n<ul>\n<li>逻辑备份和物理备份。逻辑备份是可读文件、恢复简单灵活（恢复工具及选项）、在不同机器上运行、与存储引擎无关、避免物理环境导致的数据损坏，但恢复时间较长，需要<br>\nMySQL 来完成、需要测试恢复；物理备份通常是不可读的二进制文件，恢复更简单（只要拷贝文件到目的路径）、恢复时间很短，但 InnoDB<br>\n的原始文件通常比逻辑备份的文件更大。两种方式可混合。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "一致性Hash算法",
      "url": "https://ujava.cn/synthesis/hash.html",
      "id": "https://ujava.cn/synthesis/hash.html",
      "summary": "简介 在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。 本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。 产生背景 考虑这么一种场景： 我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？",
      "content_html": "<h2> 简介</h2>\n<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>\n<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>\n<h2> 产生背景</h2>\n<p>考虑这么一种场景：</p>\n<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>\n<p>我们可能首先想到的方案是：取模算法hash（key）% N，即：对 key 进行 hash 运算后取模，N 是机器的数量；</p>\n<p>这样，对 key 进行 hash 后的结果对 3 取模，得到的结果一定是 0、1 或者 2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题；</p>\n<figure><figcaption>img_7.png</figcaption></figure>\n<p>取模算法虽然使用简单，但对机器数量取模，在集群扩容和收缩时却有一定的局限性：因为在生产环境中根据业务量的大小，调整服务器数量是常有的事；</p>\n<p>而服务器数量 N 发生变化后hash（key）% N计算的结果也会随之变化！</p>\n<figure><figcaption>img_8.png</figcaption></figure>\n<p>比如：一个服务器节点挂了，计算公式从hash（key）% 3变成了hash（key）% 2，结果会发生变化，此时想要访问一个 key，这个 key 的缓存位置大概率会发生改变，那么之前缓存 key 的数据也会失去作用与意义；</p>\n<p>大量缓存在同一时间失效，造成缓存的雪崩，进而导致整个缓存系统的不可用，这基本上是不能接受的；</p>\n<p>为了解决优化上述情况，一致性 hash 算法应运而生~</p>\n<h2> 什么是一致性哈希算法</h2>\n<p>一致性哈希算法是一种用于分布式系统中的数据分片和负载均衡的算法。它将整个哈希空间划分为一个环，并且每个节点在这个环上都有一个对应的位置。当需要读写某个数据时，先将其进行哈希运算得到一个哈希值，然后根据这个哈希值在环上找到对应的节点，从而实现数据的定位。</p>\n<p>一致性哈希算法的优点在于：当新增或删除节点时，只会影响到环上的一小部分节点，因此不会像传统的哈希算法那样造成大量的数据迁移和重新分片。同时，由于节点数较多，请求可以被更好地平均分配，从而实现了负载均衡的效果。</p>\n<p>另外，一致性哈希算法还可以通过增加虚拟节点来解决节点不均衡的问题，从而进一步提高负载均衡的效果。</p>\n<h2> 一致性哈希算法原理</h2>\n<p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系；</p>\n<p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题；</p>\n<p>一致性 hash 算法本质上也是一种取模算法；</p>\n<p>不过，不同于上边按服务器数量取模，一致性 hash 是对固定值 2^32 取模；</p>\n<p>IPv4 的地址是 4 组 8 位 2 进制数组成，所以用 2^32 可以保证每个 IP 地址会有唯一的映射；</p>\n<ol>\n<li>hash 环<br>\n我们可以将这2^32个值抽象成一个圆环 ⭕️，圆环的正上方的点代表 0，顺时针排列，以此类推：1、2、3…直到2^32-1，而这个由 2 的 32 次方个点组成的圆环统称为hash环；</li>\n</ol>\n<figure><figcaption>img_9.png</figcaption></figure>\n<ol start=\"2\">\n<li>服务器映射到 hash 环<br>\n在对服务器进行映射时，使用hash（服务器ip）% 2^32，即：</li>\n</ol>\n<p>使用服务器 IP 地址进行 hash 计算，用哈希后的结果对2^32取模，结果一定是一个 0 到2^32-1之间的整数；</p>\n<p>而这个整数映射在 hash 环上的位置代表了一个服务器，依次将node0、node1、node2三个缓存服务器映射到 hash 环上；</p>\n<figure><figcaption>img_10.png</figcaption></figure>\n<ol start=\"3\">\n<li>对象 key 映射到服务器<br>\n在对对应的 Key 映射到具体的服务器时，需要首先计算 Key 的 Hash 值：hash（key）% 2^32；</li>\n</ol>\n<p>注：此处的 Hash 函数可以和之前计算服务器映射至 Hash 环的函数不同，只要保证取值范围和 Hash 环的范围相同即可（即：2^32）；</p>\n<p>将 Key 映射至服务器遵循下面的逻辑：</p>\n<p>从缓存对象 key 的位置开始，沿顺时针方向遇到的第一个服务器，便是当前对象将要缓存到的服务器；</p>\n<p>假设我们有 “semlinker”、“kakuqo”、“lolo”、“fer” 四个对象，分别简写为 o1、o2、o3 和 o4；</p>\n<p>首先，使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p>\n<figure><figcaption>img_11.png</figcaption></figure>\n<p>图中对象的映射关系如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>同时 3 台缓存服务器，分别为 CS1、CS2 和 CS3：</p>\n<figure><figcaption>img_12.png</figcaption></figure>\n<p>则可知，各对象和服务器的映射关系如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>即：</p>\n<figure><figcaption>img_13.png</figcaption></figure>\n<p>以上便是一致性 Hash 的工作原理；</p>\n<blockquote>\n<p>可以看到，一致性 Hash 就是：将原本单个点的 Hash 映射，转变为了在一个环上的某个片段上的映射！</p>\n</blockquote>\n<h2> 服务器扩缩容场景</h2>\n<ol>\n<li>服务器减少</li>\n</ol>\n<p>假设 CS3 服务器出现故障导致服务下线，这时原本存储于 CS3 服务器的对象 o4，需要被重新分配至 CS2 服务器，其它对象仍存储在原有的机器上：</p>\n<figure><figcaption>img_14.png</figcaption></figure>\n<p>此时受影响的数据只有 CS2 和 CS3 服务器之间的部分数据！</p>\n<ol start=\"2\">\n<li>服务器增加</li>\n</ol>\n<p>假如业务量激增，我们需要增加一台服务器 CS4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p>\n<figure><figcaption>img_15.png</figcaption></figure>\n<p>此时，只有 t1 和 t2 服务器之间的部分对象需要重新分配；</p>\n<p>在以上示例中只有 o3 对象需要重新分配，即它被重新到 CS4 服务器；</p>\n<p>在前面我们已经说过：如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配！</p>\n<h2> 数据偏斜&amp;服务器性能平衡问题</h2>\n<ol>\n<li>引出问题</li>\n</ol>\n<p>在上面给出的例子中，各个服务器几乎是平均被均摊到 Hash 环上；</p>\n<p>但是在实际场景中很难选取到一个 Hash 函数这么完美的将各个服务器散列到 Hash 环上；</p>\n<p>此时，在服务器节点数量太少的情况下，很容易因为节点分布不均匀而造成数据倾斜问题；</p>\n<p>如下图被缓存的对象大部分缓存在node-4服务器上，导致其他节点资源浪费，系统压力大部分集中在node-4节点上，这样的集群是非常不健康的：</p>\n<figure><figcaption>img_16.png</figcaption></figure>\n<p>同时，还有另一个问题：</p>\n<p>在上面新增服务器 CS4 时，CS4 只分担了 CS1 服务器的负载，服务器 CS2 和 CS3 并没有因为 CS4 服务器的加入而减少负载压力；如果 CS4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的；</p>\n<ol start=\"2\">\n<li>虚拟节点</li>\n</ol>\n<p>针对上面的问题，我们可以通过：引入虚拟节点来解决负载不均衡的问题：</p>\n<p>即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器；</p>\n<p>如下图所示：</p>\n<figure><figcaption>img_17.png</figcaption></figure>\n<p>在图中：o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示实际的物理服务器；</p>\n<ol start=\"3\">\n<li>虚拟节点的计算</li>\n</ol>\n<p>虚拟节点的 hash 计算通常可以采用：对应节点的 IP 地址加数字编号后缀 hash（10.24.23.227#1) 的方式；</p>\n<p>举个例子，node-1 节点 IP 为 10.24.23.227，正常计算node-1的 hash 值：</p>\n<ul>\n<li>\n<p>hash（10.24.23.227#1）% 2^32<br>\n假设我们给 node-1 设置三个虚拟节点，node-1#1、node-1#2、node-1#3，对它们进行 hash 后取模：</p>\n</li>\n<li>\n<p>hash（10.24.23.227#1）% 2^32</p>\n</li>\n<li>\n<p>hash（10.24.23.227#2）% 2^32</p>\n</li>\n<li>\n<p>hash（10.24.23.227#3）% 2^32</p>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>分配的虚拟节点个数越多，映射在 hash 环上才会越趋于均匀，节点太少的话很难看出效果；</li>\n<li>引入虚拟节点的同时也增加了新的问题，要做虚拟节点和真实节点间的映射，对象key-&gt;虚拟节点-&gt;实际节点之间的转换；</li>\n</ul>\n<h2> 使用场景</h2>\n<p>一致性 hash 在分布式系统中应该是实现负载均衡的首选算法，它的实现比较灵活，既可以在客户端实现，也可以在中间件上实现，比如日常使用较多的缓存中间件memcached和redis集群都有用到它；</p>\n<p>memcached 的集群比较特殊，严格来说它只能算是伪集群，因为它的服务器之间不能通信，请求的分发路由完全靠客户端来的计算出缓存对象应该落在哪个服务器上，而它的路由算法用的就是一致性 hash；</p>\n<p>还有 redis 集群中 hash 槽的概念，虽然实现不尽相同，但思想万变不离其宗，看完本篇的一致性 hash，你再去理解 redis 槽位就轻松多了；</p>\n<p>其它的应用场景还有很多：</p>\n<ul>\n<li>RPC框架Dubbo用来选择服务提供者</li>\n<li>分布式关系数据库分库分表：数据与节点的映射关系</li>\n<li>LVS负载均衡调度器</li>\n<li>……</li>\n</ul>\n<h2> 小结</h2>\n<p>一致性哈希是一种用于分布式系统中数据负载均衡的算法。在分布式系统中，多个服务器节点需要负责处理不同的请求，但由于每个请求的负载大小不同，因此会导致服务器节点的负载不平衡，一些节点可能会过度负载，而另一些节点则占用较少的资源。这就需要一种算法来平衡各个节点之间的负载。</p>\n<p>一致性哈希算法通过将服务器节点和请求都映射到一个固定的哈希环上，使得每个请求可以被映射到一个特定的服务器节点上。同时，在哈希环上沿顺时针方向查找离该请求最近的服务器节点，并将该请求路由到该节点上，从而实现了负载均衡。一致性哈希算法还支持添加或删除服务器节点，同时保持大部分请求仍然能够映射到原来的节点上，以避免数据迁移带来的复杂性和成本。</p>\n<p>总之，一致性哈希算法可以提高分布式系统的可扩展性和可靠性，减少系统崩溃等问题的风险，从而更好地满足大规模应用所需的高吞吐量和低延迟要求。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "微服务架构和分布式架构的区别",
      "url": "https://ujava.cn/synthesis/microservice.html",
      "id": "https://ujava.cn/synthesis/microservice.html",
      "summary": "微服务架构和分布式架构的区别有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。 1、含义不同 微服务架构：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。",
      "content_html": "<blockquote>\n<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>\n</blockquote>\n<h2> 1、含义不同</h2>\n<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>\n<p><strong>分布式架构</strong>：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。</p>\n<h2> 2、概念层面不同</h2>\n<p><strong>微服务架构</strong>：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。</p>\n<p><strong>分布式架构</strong>：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。</p>\n<h2> 3、解决问题不同</h2>\n<p><strong>微服务架构</strong>：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。</p>\n<p><strong>分布式架构</strong>：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。</p>\n<h2> 4、部署方式不同</h2>\n<p><strong>微服务架构</strong>：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。</p>\n<p><strong>分布式架构</strong>：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。</p>\n<h2> 5、耦合度不同</h2>\n<p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势，不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>\n<h3> 拓展阅读</h3>\n<h2> 分布式是否属于微服务？</h2>\n<p>答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业级架构带来的模式改变",
      "url": "https://ujava.cn/synthesis/modelchange.html",
      "id": "https://ujava.cn/synthesis/modelchange.html",
      "summary": "数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。 一、价值评估有章可循 近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。",
      "content_html": "<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>\n<h2> 一、价值评估有章可循</h2>\n<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>\n<p>企业级架构建设循着企业价值创造的链条，可面向业务领域逐步开展需求识别和定义。对于业务领域而言，其主要职责是创造业务价值，承接战略分析成果，进行产品研发。实践中，业务领域需要清晰定义本领域应具备的能力，提出能力建设方案，并在领域范畴内，按照计划—执行—监督的完整价值流，识别出业务活动。业务活动是指创造端对端业务价值的具体工作，其价值交付主要以产品为载体，包括产品服务的客户、产品提供的渠道、产品所需的合作伙伴等，在流程模型中需要进行全面辨识。基于企业级架构方法论形成的业务需求和业务模型，有助于业务价值的体现和评估：</p>\n<p>一是基于企业级架构的全局视角，可以减少个别部门的短期促销行为，同时避免不规范需求引发的产品定价、业务流程不一致等问题。二是企业级架构承接业务战略，始终围绕着价值创造建设，而需求在经过“战略解析—能力主题—产品设计—流程设计—能力实现”的工作模型检验后，将能够更好地满足战略需要，有利于提高核心竞争力。三是需求的业务价值更容易量化，基于企业级架构，可建立产品、客户、渠道、合作方贡献度评价体系，对需求带来的效益进行数字化评估。四是业务需求价值评估能力提高，可以使科技产能更好地倾向于重点需求开发，快速形成竞争力。</p>\n<h2> 二、数据治理追本溯源</h2>\n<p>如果说价值交付是建设企业级架构的核心，那么业务信息则是构成企业级架构的基础，内容涉及业务架构的业务对象以及业务模型的实体模型等。对此，IT架构的数据架构进一步从数据定义、数据管理、数据服务等方向，规定了数据生命周期中各种形态的管理原则。数据架构组成示意如图1所示。例如，针对实体建模，该架构详细描述定义了业务实体和实体属性；针对数据定义，要求开发数据结构准确继承实体模型；针对元数据管理，要求建立企业级数据字典，保证数据能被正确描述和使用。此外，在数据质量管控方面，则是要求在组织、办法和流程等维度进行全面统筹。</p>\n<figure><figcaption>数据架构组成示意</figcaption></figure>\n<p>实践证明，如果不能全面梳理数据脉络，数据治理的结果往往是事倍功半。对此，企业级架构有助于为全面实施数据治理打开局面：一是在需求的业务建模阶段，业务流程的数据需求和实体模型需要进行相互验证，并通过企业级数据字典进行定义，在源头保证数据准确性。二是从架构设计到实施工艺，从实体建模到数据结构设计，借助企业级架构可形成全面的数据管理办法，保证数据在产生、传输、存储、服务各个环节的一致性。三是基于企业级架构，可将内部能力按业务组件归集，并依照业务组件开发应用组件，同时加强数据副本管理，进而避免因同类业务被不同应用系统承接导致的管理复杂化问题。综上，数据治理是数字化转型的一项基础性工作，而企业级架构恰好提供了一枚“金钥匙”。</p>\n<h2> 三、业务与技术更好衔接</h2>\n<p>在瀑布式开发模式下，标准化需求确认需要经历多个不同阶段的准入门禁，需求响应缓慢。与之相比，敏捷开发模式强调客户参与，更有助于加速需求交付进程，例如将开发过程前移到需求提出阶段，或是请业务人员加入开发团队等。除此之外，企业级架构也为业务与技术融合提供了一种新的途径：</p>\n<ul>\n<li>一是在提交业务需求前，通过对活动进行流程建模，以及对业务对象进行实体建模，并采用结构化、标准化语言(如流程建模的BPMN图和实体建模的ER图等)消弭理解歧义，可基于业务模型团队构建衔接业务和技术的桥梁。</li>\n<li>二是企业级架构结合内部视角，可从业务流程、职责划分等维度映射业务组件与应用组件的对应关系，进而实现业务和技术的完美对应。</li>\n<li>三是企业级架构的流程建模需要勾连相关实体，而建模产出物结合面向对象的设计方法，将能方便地识别出符合客观世界的对象，对象拥有实体属性，并具备流程模型描述的处理能力。</li>\n<li>四是企业级架构在进行实体建模时，可对实体进行归类，定义出主实体，并与周边的多个实体组成业务对象(子主题域)。在开发阶段，通过将业务建模的业务对象(子主题域)设计成相应的数据聚合，可有效保证技术和业务理解一致，使用“共同语言”。</li>\n</ul>\n<p>总体而言，业务模型通过以业务视角来描述战术层和运营层的业务架构，可为IT架构提供高效输入，而善于使用业务架构和业务模型，也将使业务与技术衔接得更好，加快需求响应速度。业务架构基础模型如图2所示。</p>\n<figure><figcaption>业务架构基础模型</figcaption></figure>\n<h2> 四、方法实践潜移默化</h2>\n<p>从实践角度发出，企业级架构不仅是对业务架构和IT架构进行全局设计，还提供了精确描述企业的统一方法论，如可灵活应用在日常工作中，将产生潜移默化的积极影响：</p>\n<ul>\n<li>一是价值链分析。企业级架构进行企业层面的流程模型设计，遵循价值创造的链条识别业务领域，并在业务领域通过各类活动实现业务价值，接着就是将活动下的任务按能力类别聚合成业务组件。在IT实施阶段，可沿用同样的分析方法，按价值维度将业务组件进一步细分为子域，最后将能力进行聚合，开发出高内聚的微服务。</li>\n<li>二是架构视图绘制。企业级架构的IT架构通常包含了四个维度，即安全架构、技术架构、数据架构和应用架构。其中，应用架构可进一步划分为三个阶段，即分层架构、逻辑架构、物理架构，并从功能视图、接口视图、剖面视图等多个维度进行描述。实践中，上述建模方法不仅可用于搭建企业级总体架构，在描述应用系统的内部架构时也同样适用。</li>\n<li>三是名词术语。基于企业级架构建设，有助于统一名词术语，改善概念混淆的状况，进而减少沟通成本。例如，在旧文档中信息系统有时被称作“系统”，也有称作“产品”或“应用”的情况。而结合企业级架构建设，可将业务领域下各类活动的系统统一称为“应用”，负责承接业务组件的系统称为“应用组件”，名称更加准确、明白。</li>\n<li>四是建模方法。业界常用的建模方法一般指业务建模采用的BPMN图和实体建模采用的ER图，两者作为通用的建模语言，在开发阶段也常被使用。而企业级架构借助建模过程可将上述方法进一步推广到整个组织，进而可大幅提高描述能力和沟通效率。</li>\n<li>五是职责定义。企业级架构对工作职责的定义往往是从目标(WHY)、定义(WHAT)、范围(WHERE)等三个维度进行描述，不仅言简意赅，且广泛适用于各种场景。</li>\n</ul>\n<p>综上，数字化转型是银行机构践行高质量发展的必由之路。自2018年提出数字化转型总体框架以来，中国银行于2019年全面启动数据治理，并在2020年启动了企业级架构建设，通过自上而下对业务架构、技术架构、工艺方法等进行全面整合，数据治理各环节工作变得更加顺畅，需求开发变得更加敏捷，数字化转型目标也愈发清晰可见!</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业级架构建模之浅谈三大模型关系",
      "url": "https://ujava.cn/synthesis/modelrelation.html",
      "id": "https://ujava.cn/synthesis/modelrelation.html",
      "summary": "通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。 企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。 产品模型是企业定制化产品的集合，阐述企业提供的服务是什么 流程模型展现可复用的业务环节，表达企业提供的服务怎么做 数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。 从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。",
      "content_html": "<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>\n<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>\n产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>\n<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>\n<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>\n从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>\n<h2> 01、三大模型概述</h2>\n<p><br>\n1.企架三大模型之——产品模型</p>\n<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。顶层的产品线可以理解为银行业务条线，可包含多个产品组，每一个产品组是对其唯一归属的产品线下具有相似业务性质基础产品的聚合。基础产品包含了聚类可售产品所有可能的特征，为对基础产品进一步划分，可创建不同的产品组件。产品组件的存在不仅能对基础产品做出细分，同时也是最底层产品特征相同或相似的产品条件的归类。产品条件表达产品对金额、利率、期限、数量等业务特征的限制规则，可用于对属性和逻辑的控制参数。</p>\n<p>2.企架三大模型之——流程模型</p>\n<p>流程模型用标准化的方式表达业务流程结构，可分为五层，逐层把企业业务能力分解为业务领域、价值流、活动、任务和步骤，并通过与产品模型和数据模型协同关系，精准刻画业务需求。顶层的业务领域是紧密相关业务的集合。价值流是一组互不相同、界限分明，但相互关联的生产经营活动，是构成价值创造的动态过程，如存款和贷款的界限分明但共同存在为银行创造价值。这里的活动由不同的事件触发，比如外部事件、时间或条件触发的内部事件，活动的存在是为了达成具体的业务目的，企业执行端到端的行为序列集合；活动也是从用户角度看到的执行业务流程。具体来讲，我们可用任务来表达从银行内部执行的操作。活动和任务具备明确目的性，要求产生可观测、有价值的结果。流程模型中最底层的步骤则涵盖所有最细化的业务规则和业务信息。</p>\n<p>3.企架三大模型之——数据模型</p>\n<p>数据模型是企业范围内统一的数据视图，通过一系列规范和相关图表反映数据需求和设计。根据规则从企业的视角对业务概念进行逻辑化、一致性的表述，用数据语言表达业务需求并展现业务规则，是联接业务和技术的桥梁，也是业务模型的主要组成部分。具体来看，顶层的业务对象是一组关联实体的集合，要求高内聚松耦合；关联的实体不允许重复或缺失。业务实体可视为以业务视角抽象表示一种客观存在于现实世界并且可以跟其他物体区分开，用一系列业务属性来描述的事物。</p>\n<p>因此业务实体所具有的某一业务特性，我们称之为实体属性。若干个属性可共同刻画同一实体。向下延申，属性域值对属性取值范围进行规范，每个属性都有需要遵循的值的范围，通过域明确属性的取值规则。属性域实例只与代码类的域关联，用于进一步明确每一个取值下的规范。一个实例组会有多个取值，每个取值称为实例组的一个实例。业务组件是独立的业务模块，指具有相似资源、人和专业技能的任务组合，通过将标准化的任务按照业务对象聚类形成业务组件。</p>\n<h2> 02、模型间协同关系</h2>\n<p>第一部分概述中已经对每个模型划分层级，比如产品模型自上而下分别是产品线、产品组、基础产品、产品组件和产品条件。三大模型间的协同关系主要也是讨论模型层级与层级间的联动，下面将分类剖析：</p>\n<p>1.产品模型对接流程模型</p>\n<p><br>\n基础产品与活动（多对多） 基础产品仅关联与产品有关的活动。活动可以看作是某个基础产品在提供服务有哪些环节划分，比如任何与贷款相关的基础产品需要有申请贷款额度、审核客户背景等环节共同搭建贷款服务体系。这些环节我们就可以说是这个基础产品对应的活动。在填写流程模型活动表单时，会体现活动编号、名称、详情等信息，也会专门有一列“产品信息”来体现活动对应到哪些具体的基础产品。基础产品与任务（多对多） 刚才提到活动是环节划分，而任务则是某环节衍生出来要做的事，因此任务与其上层活动所关联的基础产品范围上是一致的。延续”申请贷款额度“这个活动案例，银行方面需要完成的任务就是“受理额度申请”等一系列为了完成客户申请贷款额度而做的工作。我们也可以理解为活动是客户角度看到的环节，而任务是从我们服务提供方内部角度对活动拆解出来需要完成的事项。当活动关联了基础产品，才会建立该活动下层任务与基础产品的关系。产品条件与步骤（多对多） 步骤则是呈现任务中的事项具体如何去操作，是环节最细致的拆分。因此当活动和任务关联了基础产品，步骤作为最底层的拆分理应映射产品模型最下层的参数-产品条件。通常一个步骤需要关联至少一个产品条件，同时每个产品条件需要被至少一个步骤使用。对“受理额度申请”这个任务来说，其中一个“检查账户信息”的具体步骤，在流程模型步骤表单“与产品模型映射”列就可以映射“开户银行类型”这一产品条件，表示对某账户开户银行具体类型的选择。</p>\n<p>2.数据模型对接流程模型</p>\n<p><br>\n任务与业务实体（多对多） 数据模型中的实体由流程模型的任务创建而来。流程模型任务表单有专门一列“业务实体”来呈现关系。比如终止某产品协议就可以关联到“产品协议”这个实体。终止某产品协议是要做的事，要把这件事说清楚便需要创建一个产品协议实体去承接，且实体名称需与数据模型的实体精确匹配。步骤与业务实体（多对多） 步骤是任务的细化，和任务一样可以去操作实体。在实际工作中，会遇到步骤牵扯到多个实体的情况，比如“调查客户背景”这个任务，其中有一个步骤是“核实客户基本信息”，涉及操作“账户”实体和“客户信息”实体，这时可根据业务含义判断是否可拆分步骤，拆至最小颗粒度便于业务和技术人员清晰理解流程。步骤与实体属性（多对多） 实体属性用于描述业务实体。流程模型中的“业务规则”列需要体现涉及业务实体下的属性。主要体现对业务规则有影响的关键属性及对应的取值描述和使用规则。还是举“核实客户基本信息”这个步骤，在创建“客户信息”实体的同时会在业务规则中体现是对公客户还是对私客户，因此属性“客户公私类型”便会建立在数据模型与其做映射，属性的取值也直接影响到该步骤最终的结果。</p>\n<p>3.业务组件对接业务对象和任务</p>\n<figure><figcaption>img_43.png</figcaption></figure>\n<p>业务组件与任务（一对多）</p>\n<p>业务组件可视为业务分类器，作为独立的业务模块归集具有相似业务目的的任务。这里的相似主要是领域和数据使用的相似。比如“调查客户背景”和“识别客户风险”两项任务都是为了更好了解和识别客户信息和行为，涉及的数据都可以有账户实体下的所有属性字段。因此我们可以将它们归集在“客户管理”业务组件。一个任务只归属一个业务组件，一个业务组件下可包含多个紧密相关的任务。</p>\n<p>业务组件与业务对象（一对一/多）</p>\n<figure><figcaption>img_44.png</figcaption></figure>\n<p>业务组件归集具有相似业务目的的任务，业务对象归集互相关联的实体，而实体由任务来创建。因此业务组件与业务对象的关联具体体现在业务组件下任务对业务对象下实体的操作。以最基本的存款业务举例，“存款”是业务组件，具体任务有“记录存款信息”和“更换存单”，这两项任务便可操作“存款账户”这个业务对象下的“存款合约”和“存单”两个实体。</p>\n<p>3.业务事件承接业务领域和活动</p>\n<p><br>\n业务领域对业务划分主题类型，其具体发生的行为操作称之为业务事件。围绕业务事件所产生的两条关系可总结为业务领域包含业务事件，而事件会触发一系列活动。比如贷款这个业务领域，我们能想到发生的业务事件包括申请住房贷款、购车贷款、助学贷款等贷款额度，这些事件便可触发申请个人贷款额度的活动，这个活动下面的任务和步骤则是对其需要做的事更细致的划分。一个领域涵盖多个事件，每个活动必由一个或多个业务事件触发。在实际建模工作中，三大模型分别建立再做关联映射大大提升建模难度，为了映射而映射，导致模型质量降低。因此，从建模初期保持三大建模的“实时”匹配尤其重要。无论是顶层领域划分规则还是底层参数设定，三个建模组通过完善的沟通机制共同协商而定，是企业级建模结果能够有效应用于全领域业务的基石。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "系统总体结构设计",
      "url": "https://ujava.cn/synthesis/overall.html",
      "id": "https://ujava.cn/synthesis/overall.html",
      "summary": "简介 系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。 一、系统设计的任务 系统设计的概念 系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。",
      "content_html": "<h2> 简介</h2>\n<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>\n<h2> 一、系统设计的任务</h2>\n<ol>\n<li>系统设计的概念</li>\n</ol>\n<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>\n<p>系统设计是开发人员进行的工作，他们将系统设计阶段得到的目标系统的逻辑模型转换为目标系统的物理模型，该阶段得到工作成果――系统设计说明书是下一个阶段系统实施的工作依据。</p>\n<ol start=\"2\">\n<li>系统设计的主要内容</li>\n</ol>\n<p>系统设计的主要任务是进行总体设计和详细设计。下面分别说明它们的具体内容。</p>\n<p>(1) 总体设计</p>\n<p>总体设计包括系统模块结构设计和计算机物理系统的配置方案设计。</p>\n<ol>\n<li>系统模块结构设计</li>\n</ol>\n<p>系统模块结构设计的任务是划分子系统，然后确定子系统的模块结构，并画出模块结构图。在这个过程中必须考虑以下几个问题：</p>\n<p>如何将一个系统划分成多个子系统；</p>\n<p>每个子系统如何划分成多个模块；</p>\n<p>如何确定子系统之间、模块之间传送的数据及其调用关系；</p>\n<p>如何评价并改进模块结构的质量。</p>\n<ol start=\"2\">\n<li>计算机物理系统配置方案设计</li>\n</ol>\n<p>在进行总体设计时，还要进行计算机物理系统具体配置方案的设计，要解决计算机软硬件系统的配置、通信网络系统的配置、机房设备的配置等问题。计算机物理系统具体配置方案要经过用户单位和领导部门的同意才可进行实施。</p>\n<p>开发管理信息系统的大量经验教训说明，选择计算机软硬件设备不能光看广告或资料介绍，必须进行充分的调查研究，最好应向使用过该软硬件设备的单位了解运行情况及优缺点，并征求有关专家的意见，然后进行论证，最后写出计算机物理系统配置方案报告。</p>\n<p>从我国的实际情况看，不少单位是先买计算机然后决定开发。这种不科学的、盲目的做法是不可取的，它会造成极大浪费。因为，计算机更新换代是非常快的，就是在开发初期和在开发的中后期系统实施阶段购买计算机设备，价格差别就会很大。因此，在开发管理信息系统过程中应在系统设计的总体设计阶段才具体设计计算机物理系统的配置方案。</p>\n<p>(2) 详细设计</p>\n<p>在总体设计基础上，第二步进行的是详细设计，主要有处理过程设计以确定每个模块内部的详细执行过程，包括局部数据组织、控制流、每一步的具体加工要求等，一般来说，处理过程模块详细设计的难度已不太大，关键是用一种合适的方式来描述每个模块的执行过程，常用的有流程图、问题分析图、IPO图和过程设计语言等；除了处理过程设计，还有代码设计、界面设计、数据库设计、输入输出设计等。</p>\n<p>(3) 编写系统设计说明书</p>\n<p>系统设计阶段的结果是系统设计说明书，它主要由模块结构图、模块说明书和其它详细设计的内容组成。</p>\n<h2> 系统设计的方法与工具</h2>\n<p>系统设计的工作复杂又细致，总体设计阶段需要进行系统模块结构设计，要将一个大系统分解成不同层次、多个模块组成的系统，在详细设计阶段要在模块结构设计的基础上，给出每个模块实现方法的细节，并对模块的输入、输出和处理过程作详细描述，以便在系统实施阶段进行程序设计时可以把这个描述直接“翻译”成用某种程序设计语言书写的程序。系统设计在技术上有相当的难度，为此需要有一定的设计方法和设计工具来指导。70年代以来，出现了多种设计方法，其中结构化设计方法是较为典型的方法，本章将对该设计方法进行论述并介绍几个常用的设计工具。</p>\n<h2> 一、结构化设计的方法</h2>\n<p>结构化设计（STRUCTURED DESIGN, 简称SD)<br>\n方法是使用最广的一种设计方法，由美国IBM公司的W·STEVENS、G·MYERS和·CONSTANTINE等人提出。该方法适合于软件系统的总体设计和详细设计，特别是将一个复杂的系统转换成模块化结构系统，该方法具有它的优势。在使用过程中可将结构化设计方法与结构化分析（SA)<br>\n方法及编程阶段的结构化程序设计方法(SP)前后衔接起来，SD方法具有以下特点：</p>\n<p>1．相对独立、功能单一的模块结构</p>\n<p>结构化设计的基本思想是将系统设计成由多个相对独立、功能单一的模块组成的结构。由于模块之间相对独立，每一模块就可以单独地被理解、编写、测试、排错和修改,从而有效地防止错误在模块之间扩散蔓延，提高了系统的质量(<br>\n可维护性、可靠性等)。因此，大大简化了系统研制开发的工作。</p>\n<p>2．“块内联系大、块间联系小”的模块性能标准</p>\n<p>“模块内部联系要大，模块之间联系要小”，这是结构化设计中衡量模块“相对独立”性能的标准。事实上，块内联系和块间联系是同一件事的两个方面。系统中各组成成分之间是有联系的，若把联系密切的成分组织在同一模块中，块内联系高了，块间联系自然就少了。反之，若把密切相关的一些组成成分分散在各个模块中，势必造成很高的块间联系，这将影响系统的可维护性。所以，在系统设计过程中一定要以结构化设计的模块性能标准为指导。</p>\n<p>3．采用模块结构图的描述方式</p>\n<p>结构化设计方法使用的描述方式是模块结构图。</p>\n<h2> 系统模块结构设计</h2>\n<p>总体设计的另外一个主要内容是合理地进行系统模块结构的分析和定义，将一个复杂的系统设计转为若干个子系统和一系列基本模块的设计，并通过模块结构图把分解的子系统和一个个模块按层次结构联系起来。下面来介绍如何进行模块的分解、如何从数据流图导出模块结构图以及模块结构图的改进。</p>\n<h4> 一、模块分解的原则和依据</h4>\n<p>系统逻辑模型中数据流图中的模块是逻辑处理模块，模型中没有说明模块的物理构成和实现途径，同时也看不出模块的层次分解关系，为此在系统结构设计中要将数据流图上的各个逻辑处理模块进一步分解，用模块结构图确定系统的层次结构关系，并将系统的逻辑模型转变为物理模型。</p>\n<ol>\n<li>“耦合小，内聚大”的基本原则</li>\n</ol>\n<p>在结构化设计中，采用自顶向下，逐步细化的方法将系统分解成为一些相对独立、功能单一的模块。如何度量模块之间的独立性呢？</p>\n<p>在一个管理信息系统中，系统的各组成部分之间总是存在着各种联系的，将系统或子系统划分成若干模块，则一个模块内部的联系就是块内联系，而穿越模块边界的联系就是块间联系。由于模块之间的互相联系越多，模块的独立性就越少，因此，引入模块耦合和内聚的概念。</p>\n<p>耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。</p>\n<p>内聚表示模块内部各成分之间的联系程度。</p>\n<p>一般说来，在系统中各模块的内聚越大，则模块间的耦合越小。但这种关系并不是绝对的。耦合小使得模块间尽可能相对独立，从而各模块可以单独开发和维护。内聚大使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚。</p>\n<ol start=\"2\">\n<li>对子系统或模块进行划分的依据</li>\n</ol>\n<p>一个合理的子系统或模块划分，应该是内部联系强，子系统或模块间尽可能独立，接口明确、简单，尽量适应用户的组织体系，有适当的共用性。也就是上面所说的“耦合小，内聚大”。按照结构化设计的思想，对模块或子系统进行划分的依据通常有以下几种：</p>\n<p>(1)按逻辑划分，把相类似的处理逻辑功能放在一个子系统或模块里。例如，把“对所有业务输入数据进行编辑”的功能放在一个子系统或模块里。那么不管是库存、还是财务，只要有业务输入数据都由这个子系统或模块来校错、编辑。</p>\n<p>(2)按时间划分，把要在同一时间段执行的各种处理结合成一个子系统或模块。</p>\n<p>(3)按过程划分，即按工作流程划分。从控制流程的角度看，同一子系统或模块的许多功能都应该是相关的。</p>\n<p>(4)按通信划分，把相互需要较多通讯的处理结合成一个子系统或模块。这样可减少子系统间或模块间的通讯，使接口简单。</p>\n<p>(5)按职能划分，即按管理的功能。例如，财务、物资、销售子系统，或输入记帐凭证、计算机优解子系统或模块等等。</p>\n<p>一般来说，按职能划分子系统，按逻辑划分模块的方式是比较合理和方便的</p>\n<h2> 详细设计</h2>\n<p>进行了系统的总体设计后即可在此基础上进行系统的详细设计了，即各种输入、输出、处理和数据存储等的详细设计。下面分别介绍详细设计的内容。</p>\n<h4> 一、代码设计</h4>\n<p>代码是用来表示事物名称、属性和状态等的符号。在管理信息系统中，代码是人和机器的共同语言，是系统进行信息分类、校对、统计和检索的依据。代码设计就是要设计出一套能为系统各部门公用的、优化的代码系统，这是实现计算机管理的一个前提条件。</p>\n<ol>\n<li>代码设计的原则</li>\n</ol>\n<p>代码设计是一项重要的工作，合理的编码结构是使管理信息系统具有生命力的重要因素。设计代码的基本原则是：</p>\n<p>(1) 具备唯一确定性。每一个代码都仅代表唯一的实体或属性。</p>\n<p>(2) 标准化与通用性。凡国家和主管部门对某些信息分类和代码有统一规定和要求的，则应采用标准形式的代码，以使其通用化。</p>\n<p>(3) 可扩充且易修改。要考虑今后的发展，为增加新代码留有余地。当某个代码在条件或代表的实体改变时，容易进行变更。</p>\n<p>(4) 短小精悍即选择最小值代码。代码的长度会影响所占据的内存空间、处理速度以及输入时的出错概率，因此要尽量短小。</p>\n<p>(5) 具有规律性、便于编码和识别。代码应具有逻辑性强，直观性好的特点，便于用户识别和记忆。</p>\n<ol start=\"2\">\n<li>分类方法</li>\n</ol>\n<p>目前最常用的分类方案有两种，一种是线分类方法，一种是面分类方法。在实际应用中根据具体情况各有其不同的用途。</p>\n<p>线分类方法：首先给定母项，然后下分若干子项，由对象的母项分大集合，由大集合确定小集合，最后落实到具体对象</p>\n<p>特点：结构清晰，容易识别和记忆，易查找；适应于手工系统；</p>\n<p>缺点：结构不灵活，柔性差。</p>\n<p>线分类时要掌握两个原则：唯一性和不交叉性。</p>\n<p>例：公司生产组织结构。</p>\n<p>面分类方法：它主要从面的角度来考虑分类</p>\n<p>面分类的特点：</p>\n<p>柔性好，面上的增、删、改很容易；</p>\n<p>可实现按任意组配面的信息检索，对机器处理有良好的适应性；</p>\n<p>缺点是不易直观识别，不便于记忆。</p>\n<p>系统设计报告</p>\n<p>系统设计阶段的成果是系统设计报告， 其主要是各种设计方案和设计图表，它是下一步系统实现的基础。</p>\n<h4> 一、系统设计的成果</h4>\n<p>系统设计阶段的成果归纳起来一般有 (点击这里观看“各开发环节之间的关系”动画演示)：</p>\n<p>1.系统总体结构图（包括总体结构图，子系统结构图，计算机流程图等）。</p>\n<p>2.系统设备配置图（系统设备配置图： 主要是计算机系统图，设备在各生产岗位的分布图，主机、网络、终端联系图等）。</p>\n<p>3.系统分布编码方案（分类方案、编码系统）。</p>\n<p>4.数据库结构图（DB的结构，主要指表与表之间的结构，表内部结构（字段、域、数据字典等）。</p>\n<p>5.HIPO图（层次化模块控制图、IPO图等等）。</p>\n<p>6.系统详细设计方案说明书。</p>\n<h2> 二、系统设计说明书的组成</h2>\n<ol>\n<li>引言</li>\n</ol>\n<p>(1) 摘要 系统的目标名称和功能等的说明</p>\n<p>(2) 背景</p>\n<ul>\n<li>项目开发者</li>\n<li>用户</li>\n<li>本项目和其它系统或机构的关系和联系</li>\n</ul>\n<p>(3) 系统环境与限制</p>\n<ul>\n<li>硬件、软件和运行环境方面的限制</li>\n<li>保密和安全的限制</li>\n<li>有关系统软件文本</li>\n<li>有关网络协议标准文本</li>\n</ul>\n<p>(4) 参考资料和专门术语说明</p>\n<h2> 2.系统设计方案</h2>\n<p>(1) 模块设计</p>\n<ul>\n<li>系统的模块结构图</li>\n<li>各个模块的IPO图(包括各模块的名称、功能、调用关系、局部数据项和详细的算法说明等)</li>\n</ul>\n<p>(2) 代码设计</p>\n<p>各类代码的类型、名称、功能、使用范围和使用要求等的设计说明书</p>\n<p>(3) 输入设计</p>\n<p>输入项目</p>\n<p>输入人员(指出所要求的输入操作人员的水平与技术专长，说明与输入数据有关的接口软件及其来源)</p>\n<p>主要功能要求(从满足正确、迅速、简单、经济、方便使用者等方面达到要求的说明)</p>\n<p>输入校验(关于各类输入数据的校验方法的说明)</p>\n<p>(4) 输出设计</p>\n<p>输出项目</p>\n<p>输出接受者</p>\n<p>输出要求(所用设备介质、输出格式、数值范围和精度要求等)</p>\n<p>(5) 文件(数据库)设计说明</p>\n<p>概述(目标、主要功能)</p>\n<p>需求规定(精度、有效性、时间要求及其它专门要求)</p>\n<p>运行环境要求(设备支撑软件，安全保密等要求)</p>\n<p>逻辑结构设计(有关文件及其记录、数据项的标识、定义、长度和它们之间的关系)</p>\n<p>物理结构设计(有关文件的存贮要求、访问方法、存贮单位、设计考虑和保密处理等)</p>\n<p>(6) 模型库和方法库设计(本系统所选用的数学模型和方法以及简要说明)</p>\n<p>(7) 安全保密设计</p>\n<p>(8) 物理系统配置方案报告</p>\n<p>硬件配置设计</p>\n<p>通信与网络配置设计</p>\n<p>软件配置设计</p>\n<p>机房配置设计</p>\n<p>(9) 系统实施方案及说明</p>\n<p>实施方案</p>\n<p>实施计划(包括工作任务的分解、进度安排和经费预算)</p>\n<p>实施方案的审批(说明经过审批的实施方案概况和审批人员的姓名)</p>\n<p>3.案例</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>模块名称</th>\n<th>主要用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>无线寻呼管理信息系统-系统设计说明书</td>\n<td>研究开发5-10万用户寻呼机管理信息系统，它可以进行普通寻呼服务；漫游寻呼服务；群呼服务；试机服务；定时服务；系统管理；运行管理。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>库存管理系统-系统设计说明书</td>\n<td>研发库存控制系统的主要目的:1）为顾客订货提供更好的服务；2）控制库存水平；3）决定向厂家订货的时间和批量。</td>\n</tr>\n<tr>\n<td>3</td>\n<td>百货商店业务管理信息系统-系统设计</td>\n<td>实现登记、整理数据，处理核对顾客订货单；向经理提供各种业务统计报表；提供各级查询；销售、采购、会计各部门的业务数据处理实现自动化。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>铁道财务会计管理信息系统-系统设计</td>\n<td>运用系统的方法以计算机和现代通信技术为基本信息处理手段和工具的，能为全国铁道财务会计核算、管理、决策提供信息服务的人—机系统。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>高校选课辅助决策</td>\n<td>本选课系统能够使学生在INTERNET上自主、便捷、准确地进行全校性课程选择的一种软件。学生在选择选修课前，可以上网进行查询，当学生输入其学号与密码后，系统便调出其所有相关信息，包括已修课程、已修课程的成绩、专业培养计划、全校性可选课程，系统进行综合分析后，得到一些可行的方案，供选课学生参考，并提出合理建议。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>条形材料选材优化</td>\n<td>要制造器件,必须先制造一定的零件,而这些零件又由某种原材料截取而得到。例如：用某一种条形材料锯成数种需要的零件，求最少的用料数量。使用运筹学线性规划的思想和解决方法。</td>\n</tr>\n</tbody>\n</table>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "高并发场景下如何优化微服务的性能",
      "url": "https://ujava.cn/synthesis/performance.html",
      "id": "https://ujava.cn/synthesis/performance.html",
      "summary": "1.背景介绍 随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。 在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。 2.核心概念与联系",
      "content_html": "<h2> 1.背景介绍</h2>\n<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>\n<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>\n<h2> 2.核心概念与联系</h2>\n<p>在微服务架构中，计算性能的重构主要包括以下几个方面：</p>\n<p>分布式计算：将计算任务分散到多个节点上，通过网络间通信实现数据交换和任务协同。<br>\n并发处理：利用多核处理器和多线程技术，实现并发处理，提高计算效率。<br>\n数据分区：将数据划分为多个部分，每个服务只处理自己的数据，减少通信开销。<br>\n负载均衡：将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>\n这些概念和技术在微服务架构中相互联系，共同实现高性能计算。</p>\n<h2> 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解</h2>\n<p>在微服务架构中，重构计算的核心算法原理包括以下几个方面：</p>\n<h1> 分布式计算：使用MapReduce算法实现分布式计算，将大型数据集划分为多个子任务，每个子任务在多个节点上并行执行，最后通过reduce阶段将结果聚合到一个最终结果中。<br>\nMapReduce=(Map,Shuffle,Reduce)<br>\nMapReduce</h1>\n<h1> (<br>\nMap<br>\n,<br>\nShuffle<br>\n,<br>\nReduce<br>\n)<br>\n并发处理：使用线程池技术实现并发处理，将任务分配到多个线程中执行，提高计算效率。<br>\n线程池=(核心线程数,最大线程数,工作队列)<br>\n线程池</h1>\n<h1> (<br>\n核心线程数<br>\n,<br>\n最大线程数<br>\n,<br>\n工作队列<br>\n)<br>\n数据分区：使用哈希分区算法实现数据分区，将数据按照某个关键字划分为多个部分，每个服务只处理自己的数据。<br>\n哈希分区=(关键字,哈希函数,分区数)<br>\n哈希分区</h1>\n<h1> (<br>\n关键字<br>\n,<br>\n哈希函数<br>\n,<br>\n分区数<br>\n)<br>\n负载均衡：使用Consistent Hashing算法实现负载均衡，将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>\n一致性哈希=(虚拟节点,哈希函数,节点集)<br>\n一致性哈希</h1>\n<p>(<br>\n虚拟节点<br>\n,<br>\n哈希函数<br>\n,<br>\n节点集<br>\n)</p>\n<h2> 4.具体代码实例和详细解释说明</h2>\n<p>在这里，我们以一个简单的Word Count示例来展示如何在微服务架构中实现高性能计算。</p>\n<p>使用MapReduce算法实现分布式计算：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用线程池技术实现并发处理：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用哈希分区算法实现数据分区：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用一致性哈希算法实现负载均衡：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 5.未来发展趋势与挑战</h2>\n<p>随着大数据和人工智能的发展，微服务架构在计算性能方面面临着越来越大的挑战。未来的发展趋势包括：</p>\n<ul>\n<li>\n<p>更高性能的分布式计算：通过优化算法和数据结构，提高分布式计算的性能。</p>\n</li>\n<li>\n<p>更智能的负载均衡：通过学习算法和自适应机制，实现更智能的负载均衡。</p>\n</li>\n<li>\n<p>更高效的数据存储和处理：通过新的存储技术和处理方法，提高数据存储和处理的效率。<br>\n挑战包括：</p>\n</li>\n<li>\n<p>系统复杂性：微服务架构的系统复杂性增加，导致开发、测试和维护的难度增加。</p>\n</li>\n<li>\n<p>数据一致性：在分布式计算中，保证数据的一致性变得越来越难以实现。</p>\n</li>\n<li>\n<p>安全性和隐私：在大数据时代，数据安全性和隐私保护成为关键问题。</p>\n</li>\n</ul>\n<h2> 6.附录常见问题与解答</h2>\n<p>Q: 微服务架构与传统架构有什么区别？</p>\n<p>A: 微服务架构将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。而传统架构通常是基于大型应用程序和单个进程结构的。</p>\n<p>Q: 如何选择合适的算法和数据结构？</p>\n<p>A: 在选择算法和数据结构时，需要考虑问题的特点，如问题规模、时间复杂度、空间复杂度等。同时，也需要考虑算法和数据结构的实现难度和性能。</p>\n<p>Q: 如何保证微服务架构的高性能？</p>\n<p>A: 要保证微服务架构的高性能，需要关注分布式计算、并发处理、数据分区和负载均衡等方面。同时，还需要关注系统的设计和优化，如选择合适的算法和数据结构、减少通信开销、提高系统可扩展性等。</p>\n<p>Q: 如何处理微服务架构中的数据一致性问题？</p>\n<p>A: 在微服务架构中，数据一致性问题可以通过使用分布式事务、版本控制和幂等性等方法来解决。同时，还可以通过设计合理的系统架构和算法来减少数据一致性问题的影响。</p>\n<p>Q: 如何保证微服务架构的安全性和隐私？</p>\n<p>A: 保证微服务架构的安全性和隐私需要关注多方面，如身份验证、授权、加密、审计等。同时，还需要关注数据存储和处理的安全性，如使用安全的存储技术和处理方法。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "微服务拆分原则",
      "url": "https://ujava.cn/synthesis/split.html",
      "id": "https://ujava.cn/synthesis/split.html",
      "summary": "简介 微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。 一、微服务拆分的原则 微服务拆分原则有以下几个： 单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。 服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。 服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。 服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。 服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。 服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。 服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。 使用有界上下文。 确定核心域并保持竞争优势。 对通用域进行成本优化。 考虑支持领域。 引入反腐层。 识别数据通信模式。 引入事件驱动架构。 使API简洁明了。 将相关的微服务合并为更大的服务。 引入无缝开发支持工具。",
      "content_html": "<h2> 简介</h2>\n<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>\n<h2> 一、微服务拆分的原则</h2>\n<p>微服务拆分原则有以下几个：</p>\n<ul>\n<li>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</li>\n<li>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</li>\n<li>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</li>\n<li>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</li>\n<li>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</li>\n<li>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</li>\n<li>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</li>\n<li>使用有界上下文。</li>\n<li>确定核心域并保持竞争优势。</li>\n<li>对通用域进行成本优化。</li>\n<li>考虑支持领域。</li>\n<li>引入反腐层。</li>\n<li>识别数据通信模式。</li>\n<li>引入事件驱动架构。</li>\n<li>使API简洁明了。</li>\n<li>将相关的微服务合并为更大的服务。</li>\n<li>引入无缝开发支持工具。</li>\n</ul>\n<p><strong>不管是哪种拆分原则，目标都是需要将相同或相似的服务聚合在一起，形成一个独立的自治服务。</strong></p>\n<h2> 二、微服务拆分的时机</h2>\n<p>并非所有公司都适合采用微服务架构，尤其是规模较小且业务相对固定的公司。对于这些公司来说，从服务层面，他们不会有更多变化，通过优化现有服务即可满足需求。从成本方面，构建微服务架构，需要很多资源和配套的中间件。因此，对于那些规模较大，业务服务复杂度高，同时业务也在不断更新或新增的项目，微服务架构则是非常适合的选择。</p>\n<p>在确定使用微服务架构后，服务的拆分是一项重要任务。根据拆分原则，我们可以在恰当的时机进行服务拆分。然而，根据行业经验来看，并<strong>不建议在项目构建初期进行服务拆分</strong>。主要原因有以下几点：</p>\n<ul>\n<li>项目构建初期，服务单一，数据量较少，及时是单体系统都可以支撑业务。</li>\n<li>项目构建初期，服务没有形成体系，更没有规模服务，很难做到微服务的单一职责和服务自治。</li>\n<li>业务架构不够成熟，目前提供的服务，很有可能会优化，甚至更改技术栈重构。</li>\n</ul>\n<p>因此，项目构建初期无需将其拆分，因为强行拆分此时可能会产生适得其反的效果。而遇到下面这些情况就可以进行服务拆分了。</p>\n<ul>\n<li>项目足够成熟并且业务稳定，团队成员不断扩大并且目前的服务想要扩展很难。只有在项目成熟的情况下，业务专家才可以从精确的划分出业务领域，进而将各个服务分解到业务领域内，最终形成各自独立的微服务。</li>\n<li></li>\n</ul>\n<p>项目要求CI/CD（持续集成/持续交付）。尤其是很多新兴的互联网公司，要求系统在尽可能不停机的情况下，还需要持续上线新的功能。使用敏捷开发，可以更好地让开发者在完成周期形的业务交付，而DevOps则可以将这些代码，进行自动化测试、构建和集成，不断的完成新的需求提交，并保证代码的质量和稳定性。</p>\n<ul>\n<li>正式运行的项目，部分服务需要停机。当上线一些有问题的服务时，将该部分服务停机，这个情况对单体应用是非常有困难的。而微服务架构中，可以对存在问题的微服务进行下线处理，从而达到快速解决问题的目的。</li>\n</ul>\n<h2> 三、微服务拆分的方法</h2>\n<p>在掌握了准确的微服务拆分时机和有了强有力的拆分原则后，拆分方法将成为下一个关键环节。现在微服务拆分的方法有很多种，常见的包括：</p>\n<ul>\n<li>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。</li>\n<li>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。</li>\n<li>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。</li>\n<li>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。</li>\n<li>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。</li>\n</ul>\n<p>从行业经验来看，可以确定领域驱动设计（Domain Driven Design，简称DDD）在微服务拆分方面具有显著优势。</p>\n<ul>\n<li>DDD是一种软件开发方法论，它强调将软件划分为不同的领域，每个领域都由一个核心模型驱动。</li>\n<li>微服务架构的核心概念是将单一的应用程序拆分为一组小型、自治的服务。而DDD则提供了一种方法来设计这些微服务的边界和交互。</li>\n<li>领域驱动设计引入了领域模型的概念，该模型描述了业务领域的核心概念和实体，而不关注技术实现细节。这使得团队可以专注于业务逻辑，而不被底层技术细节所干扰。</li>\n<li>通过将领域模型作为微服务拆分的基础，可以确保每个微服务都是高内聚的，并且只关注自己领域内的业务逻辑。这种拆分方式使得每个微服务都能够独立开发、部署和维护，从而提高了系统的可伸缩性和可靠性。</li>\n<li>此外，DDD还强调了领域驱动设计的语言在业务团队和开发团队之间的沟通和理解的重要性。通过共享统一的语言和概念，可以确保业务需求能够准确地传达给开发团队，并且开发团队能够将其转化为可行的技术解决方案。<br>\n因此，DDD是一种非常适合成为微服务拆分的方法论。它能够帮助开发人员更好地理解业务需求，找到合适的服务边界，构建高质量的领域模型和微服务。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-27T13:05:13.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "概要设计和详细设计",
      "url": "https://ujava.cn/synthesis/summary.html",
      "id": "https://ujava.cn/synthesis/summary.html",
      "summary": "概要设计和详细设计 在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？ 一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。 结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。 这样一来，设计可以明显地划分成两个阶段： 概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。 详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。",
      "content_html": "<h2> 概要设计和详细设计</h2>\n<p>在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？</p>\n<p>一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。<br>\n结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。</p>\n<p>这样一来，设计可以明显地划分成两个阶段：</p>\n<ul>\n<li>概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。</li>\n<li>详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。</li>\n</ul>\n<h2> 一、概要设计阶段</h2>\n<p>在这个阶段，设计者会大致考虑并照顾模块的内部实现，但不过多纠缠于此。</p>\n<ul>\n<li>主要集中于划分模块、分配任务、定义调用关系。</li>\n<li>模块间的接口与传参在这个阶段要定得十分细致明确，应编写严谨的数据字典，避免后续设计产生不解或误解。</li>\n<li>概要设计一般不是一次就能做到位，而是反复地进行结构调整。</li>\n<li>典型的调整是合并功能重复的模块，或者进一步分解出可以复用的模块。</li>\n<li>在概要设计阶段，应最大限度地提取可以重用的模块，建立合理的结构体系，节省后续环节的工作量。</li>\n</ul>\n<p>概要设计文档最重要的部分是<strong>分层数据流图、结构图、数据字典以及相应的文字说明</strong>等。以概要设计文档为依据，各个模块的详细设计就可以并行展开了。</p>\n<h2> 二、详细设计阶段</h2>\n<ul>\n<li>在这个阶段，各个模块可以分给不同的人去并行设计。</li>\n<li></li>\n</ul>\n<p>在详细设计阶段，设计者的工作对象是一个模块，根据概要设计赋予的局部任务和对外接口，设计并表达出模块的算法、流程、状态转换等内容。这里要注意，如果发现有结构调整（如分解出子模块等）的必要，必须返回到概要设计阶段，将调整反应到概要设计文档中，而不能就地解决，不打招呼。</p>\n<ul>\n<li>详细设计文档最重要的部分是模块的流程图、状态图、局部变量及相应的文字说明等。一个模块一篇详细设计文档。</li>\n<li>概要设计文档相当于机械设计中的装配图，而详细设计文档相当于机械设计中的零件图。文档的编排、装订方式也可以参考机械图纸的方法。</li>\n<li>概要设计中较顶层的部分便是所谓的方案。方案文档的作用是在宏观的角度上保持设计的合理性。</li>\n</ul>\n<p>有的项目采用面向对象的分析、设计方法。可能在概要设计、详细设计的分工上疑问更多。其实，面向对象的分析、设计方法并没有强调结构化方法那样的阶段性，因此一般不引入概要、详细设计的概念。如果按照公司的文档体系，非要有这种分工的话，可以将包的划分、类及对象间的关系、类的对外属性、方法及协作设计看做</p>\n<ul>\n<li>概要设计；类属性、方法的内部实现看做详细设计。</li>\n<li>需求分析--产生软件功能规格说明书,需要确定用户对软件的需求,要作到明确、无歧义。不涉及具体实现方法。用户能看得明白，开发人员也可据此进行下面的工作（概要设计）。</li>\n<li>概要设计--产生软件概要设计说明书，说明系统模块划分、选择的技术路线等，整体说明软件的实现思路。并且需要指出关键技术难点等。</li>\n<li>详细设计--产生软件详细设计说明书，对概要设计的进一步细化，一般由各部分的担当人员依据概要设计分别完成，然后在集成，是具体的实现细节。理论上要求可以照此编码。</li>\n</ul>\n<h2> 三、概要设计和详细设计的区别与联系</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>概要设计</th>\n<th>详细设计</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>定义</td>\n<td>设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。</td>\n<td>为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。</td>\n</tr>\n<tr>\n<td>描述方式</td>\n<td>通常得到软件结构图</td>\n<td>流程图、N-S图、PAD图、伪代码等</td>\n</tr>\n<tr>\n<td>采用方法</td>\n<td>实现软件的总体设计、模块划分、用户界面设计、数据库设计等等</td>\n<td>根据概要设计所做的模块划分，实现各模块的算法设计，实现用户界面设计、数据结构设计的细化等等</td>\n</tr>\n<tr>\n<td>数据库设计</td>\n<td>里面的数据库设计应该重点在描述数据关系上，说明数据的来龙去脉，在这里应该结合我们的一下结果数据，说明这些结果数据的源点，我们这样设计的目的和原因</td>\n<td>应该是一份完善的数据结构文档，就是一个包括类型、命名、精度、字段说明、表说明等内容的数据字典。</td>\n</tr>\n<tr>\n<td>功能</td>\n<td>重点在功能描述，对需求的解释和整合，整体划分功能模块，并对各功能模块进行详细的图文描述，应该让读者大致了解系统作完后大体的结构和操作模式</td>\n<td>说明实现功能所需的类及具体的方法函数，包括涉及到的sql语句等</td>\n</tr>\n<tr>\n<td>关系</td>\n<td>是详细设计的基础，必须在详细设计之前完成，概要设计经复查确认后才可以开始详细设计。概要设计，必须完成概要设计文档，包括系统的总体设计文档、以及各个模块的概要设计文档。每个模块的设计文档都应该独立成册。</td>\n<td>必须遵循概要设计来进行。详细设计方案的更改，不得影响到概要设计方案；如果需要更改概要设计，必须经过项目经理的同意。详细设计，应该完成详细设计文档，主要是模块的详细设计方案说明。和概要设计一样，每个模块的详细设计文档都应该独立成册。</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>软件设计采用自顶向下、逐次功能展开的设计方法，首先完成总体设计，然后完成各有机组成部分的设计。根据工作性质和内容的不同，软件设计分为概要设计和详细设计。</li>\n</ul>\n<h2> 四、软件设计的过程</h2>\n<p>1、制定规范</p>\n<p>在软件开发组设计标准，规定编码的信息格式，命名规则</p>\n<p>2、软件系统结构的总体设计</p>\n<p>基于功能层次，划分模块，采用抽象、分层、模块分解</p>\n<p>3、处理方式设计</p>\n<p>确定为实现功能的需求所必须的算法，评估算法的性能。</p>\n<p>4、数据结构设计</p>\n<p>确定数据的模式，子模式，安全性，整体性，输入输出文件的结构和模式</p>\n<p>5、可靠性设计（质量设计）</p>\n<p>运行期间为了使用要求，保证可靠的运行</p>\n<p>6、编写概要设计阶段的文档</p>\n<p>概要设计说明书，数据库的说明书，进一步完善用户手册，制定初步的测试计划</p>\n<p>7、概要设计评审</p>\n<p>概要设计说明书，评审的要点：可追溯性、接口、</p>\n<p>模块的内部，高内聚、低耦合</p>\n<p>模块的作用于是否在控制范围内，实用性，技术清晰性</p>\n<p>其他的选择方案，</p>\n<p>8、详细设计阶段</p>\n<p>确定软件各个组成部分的算法，</p>\n<p>选定某种过程的表达形式，</p>\n<p>进行详细设计的评审，</p>\n<h2> 五、软件设计的基础</h2>\n<p>自顶向下，逐步细化</p>\n<p>将软件的体系结构按自顶向下方式，对各个层次的过程细节和数据细节逐层细化</p>\n<p>软件结构</p>\n<p>软件的结构包括两部分。程序的模块结构和数据的结构。</p>\n<p>程序结构</p>\n<p>树状结构、网状结构、</p>\n<p>结构图</p>\n<p>反应程序中模块中模块之间的层次调用关系和联系</p>\n<p>模块</p>\n<p>模块的调用关系和接口</p>\n<p>模块之间的信息传递</p>\n<p>表示模块A有条件地调用另一个模块</p>\n<p>模块化</p>\n<p>能够把一个大而复杂的软件系统划分成易于理解的比较单纯的模块结构。</p>\n<p>抽象化</p>\n<p>软件系统进行模块设计时，可以有不同的抽象层次。</p>\n<p>功能抽象：</p>\n<p>抽象层次1（高层次的抽象）：用问题所处环境的术语来描述这个软件。</p>\n<p>抽象层次2：任务需求的描述。</p>\n<p>抽象层次3：程序过程表示。</p>\n<p>数据抽象：在不同层次上描述数据对象的细节，定义与该数据对象相关的操作。</p>\n<p>模块独立性：</p>\n<p>模块：一般具有如下三个基本属性：功能、逻辑、状态、模块的独立性、采用耦合和内聚</p>\n<h2> 六、概要设计说明书：</h2>\n<p>1、引言</p>\n<p>1.1编写目的</p>\n<p>1.2项目背景</p>\n<p>1.3定义</p>\n<p>1.4参考资料</p>\n<p>2、任务概述</p>\n<p>2.1目标</p>\n<p>2.2运行环境</p>\n<p>2.3需求概述</p>\n<p>2.4条件与限制</p>\n<p>3、总体设计</p>\n<p>3.1处理流程</p>\n<p>3.2总体结构和模块外部设计</p>\n<p>3.3功能分配</p>\n<p>4、接口设计</p>\n<p>4.1外部接口</p>\n<p>4.2内部接口</p>\n<p>5、数据结构设计</p>\n<p>5.1逻辑结构设计</p>\n<p>5.2物理结构设计</p>\n<p>5.3数据结构与程序的关系</p>\n<p>6、运行设计</p>\n<p>6.1运行模块的组合</p>\n<p>6.2运行控制</p>\n<p>6.3运行时间</p>\n<p>7、出错处理设计</p>\n<p>7.1出错输出信息</p>\n<p>7.2出错处理对策</p>\n<p>8、安全保密设计</p>\n<p>9、维护设计</p>\n<h2> 详细设计说明书</h2>\n<p>1、引言</p>\n<p>1.1编写目的</p>\n<p>1.2项目背景</p>\n<p>1.3定义</p>\n<p>1.4参考资料</p>\n<p>2、总体设计</p>\n<p>2.1需求概述</p>\n<p>2.2软件结构</p>\n<p>3、程序描述</p>\n<p>3.1功能</p>\n<p>3.2性能</p>\n<p>3.3输入项目</p>\n<p>3.4输出项目</p>\n<p>3.5算法</p>\n<p>3.6程序逻辑</p>\n<p>3.7接口</p>\n<p>3.8存储分配</p>\n<p>3.9限制条件</p>\n<p>3.10测试要点</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-27T03:24:08.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "4种MySQL同步ES方案",
      "url": "https://ujava.cn/synthesis/synchronousdata.html",
      "id": "https://ujava.cn/synthesis/synchronousdata.html",
      "summary": "简介 本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具 img_129.png 1.前言 在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。 这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。 我们先看看下面 4 种常用的数据同步方案。",
      "content_html": "<h2> 简介</h2>\n<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>\n<figure><figcaption>img_129.png</figcaption></figure>\n<h1> <strong>1.前言</strong></h1>\n<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>\n这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>\n我们先看看下面 4 种常用的数据同步方案。</p>\n<h1> <strong>2.数据同步方案</strong></h1>\n<h2> <strong>2.1同步双写</strong></h2>\n<p>这是一种最为简单的方式，在将数据写到 MySQL 时，同时将数据写到 ES。</p>\n<figure><figcaption>img_130.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>业务逻辑简单；</li>\n<li>实时性高。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>硬编码，有需要写入 MySQL 的地方都需要添加写入 ES 的代码；</li>\n<li>业务强耦合；</li>\n<li>存在双写失败丢数据风险；</li>\n<li>性能较差，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。</li>\n</ul>\n<h2> <strong>2.2异写同步</strong></h2>\n<p>针对多数据源写入的场景，可以借助 MQ 实现异步的多源写入。</p>\n<figure><figcaption>img_131.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>性能高；</li>\n<li>不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息；</li>\n<li>多源写入之间相互隔离，便于扩展更多的数据源写入。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>硬编码问题，接入新的数据源需要实现新的消费者代码；</li>\n<li>系统复杂度增加，引入了消息中间件；</li>\n<li>MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时。</li>\n</ul>\n<h2> <strong>2.3基于SQL抽取</strong></h2>\n<p>上面两种方案中都存在硬编码问题，代码的侵入性太强，如果对实时性要求不高的情况下，可以考虑用定时器来处理：</p>\n<ol>\n<li>数据库的相关表中增加一个字段为 timestamp 的字段，任何 CURD 操作都会导致该字段的时间发生变化；</li>\n<li>原来程序中的 CURD 操作不做任何变化；</li>\n<li>增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；</li>\n<li>逐条写入到 ES 中。</li>\n</ol>\n<figure><figcaption>img_132.png</figcaption></figure>\n<p>优点：</p>\n<ul>\n<li>不改变原来代码，没有侵入性、没有硬编码；</li>\n<li>没有业务强耦合，不改变原来程序的性能；</li>\n<li>Worker 代码编写简单不需要考虑增删改查。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>时效性较差，由于是采用定时器根据固定频率查询表来同步数据，尽管将同步周期设置到秒级，也还是会存在一定时间的延迟；</li>\n<li>对数据库有一定的轮询压力，一种改进方法是将轮询放到压力不大的从库上。</li>\n</ul>\n<p><strong>经典方案：借助 Logstash 实现数据同步，其底层实现原理就是根据配置定期使用 SQL 查询新增的数据写入 ES 中，实现数据的增量同步。</strong></p>\n<h2> <strong>2.4基于Binlog实现同步</strong></h2>\n<p>上面三种方案要么有代码侵入，要么有硬编码，要么有延迟，那么有没有一种方案既能保证数据同步的实时性又没有代入侵入呢？</p>\n<p>当然有，可以利用 MySQL 的 Binlog 来进行同步。</p>\n<figure><figcaption>img_133.png</figcaption></figure>\n<p>具体步骤如下：</p>\n<ul>\n<li>读取 MySQL 的 Binlog 日志，获取指定表的日志信息；</li>\n<li>将读取的信息转为 MQ；</li>\n<li>编写一个 MQ 消费程序；</li>\n<li>不断消费 MQ，每消费完一条消息，将消息写入到 ES 中。</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>没有代码侵入、没有硬编码；</li>\n<li>原有系统不需要任何变化，没有感知；</li>\n<li>性能高；</li>\n<li>业务解耦，不需要关注原来系统的业务逻辑。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>构建 Binlog 系统复杂；</li>\n<li>如果采用 MQ 消费解析的 Binlog 信息，也会像方案二一样存在 MQ 延时的风险。</li>\n</ul>\n<h1> <strong>3.数据迁移工具</strong></h1>\n<p>对于上面 4 种数据同步方案，“基于 Binlog 实时同步”方案是目前最常用的，也诞生了很多优秀的数据迁移工具，这里主要对这些迁移工具进行介绍。</p>\n<p>这些数据迁移工具，很多都是基于 Binlog 订阅的方式实现，<strong>模拟一个 MySQL Slave 订阅 Binlog 日志，从而实现 CDC</strong>（Change Data Capture），将已提交的更改发送到下游，包括 INSERT、DELETE、UPDATE。</p>\n<p>至于如何伪装？大家需要先了解 MySQL 的主从复制原理，需要学习这块知识的同学，可以看我之前写的高并发教程，里面有详细讲解。</p>\n<h2> <strong>3.1Canal</strong></h2>\n<p>基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持 MySQL。</p>\n<p>Canal 原理就是伪装成 MySQL 的从节点，从而订阅 master 节点的 Binlog 日志，主要流程为：</p>\n<ol>\n<li>Canal 服务端向 MySQL 的 master 节点传输 dump 协议；</li>\n<li>MySQL 的 master 节点接收到 dump 请求后推送 Binlog 日志给 Canal 服务端，解析 Binlog 对象（原始为 byte 流）转成 Json 格式；</li>\n<li>Canal 客户端通过 TCP 协议或 MQ 形式监听 Canal 服务端，同步数据到 ES。</li>\n</ol>\n<figure><figcaption>img_134.png</figcaption></figure>\n<h2> <strong>3.2阿里DTS</strong></h2>\n<p>数据传输服务 DTS（Data Transmission Service）支持 RDBMS、NoSQL、OLAP 等多种数据源之间的数据传输。</p>\n<p>它提供了数据迁移、实时数据订阅及数据实时同步等多种数据传输方式。相对于第三方数据流工具，DTS 提供丰富多样、高性能、高安全可靠的传输链路，同时它提供了诸多便利功能，极大方便了传输链路的创建及管理。</p>\n<p>特点：</p>\n<ul>\n<li>多数据源：支持 RDBMS、NoSQL、OLAP 等多种数据源间的数据传输；</li>\n<li>多传输方式：支持多种传输方式，包括数据迁移、实时数据订阅及数据实时同步；</li>\n<li>高性能：底层采用了多种性能优化措施，全量数据迁移高峰期时性能可以达到70MB/s，20万的TPS，使用高规格服务器来保证每条迁移或同步链路都能拥有良好的传输性能；</li>\n<li>高可用：底层为服务集群，如果集群内任何一个节点宕机或发生故障，控制中心都能够将这个节点上的所有任务快速切换到其他节点上，链路稳定性高；</li>\n<li>简单易用：提供可视化管理界面，提供向导式的链路创建流程，用户可以在其控制台简单轻松地创建传输链路；</li>\n<li>需要付费。</li>\n</ul>\n<h2> <strong>3.3Databus</strong></h2>\n<p>Databus 是一个低延迟、可靠的、支持事务的、保持一致性的数据变更抓取系统。由 LinkedIn 于 2013 年开源。</p>\n<p>Databus 通过挖掘数据库日志的方式，将数据库变更实时、可靠的从数据库拉取出来，业务可以通过定制化 client 实时获取变更并进行其他业务逻辑。</p>\n<p>特点：</p>\n<ul>\n<li>多数据源：Databus 支持多种数据来源的变更抓取，包括 Oracle 和 MySQL。</li>\n<li>可扩展、高度可用：Databus 能扩展到支持数千消费者和事务数据来源，同时保持高度可用性。</li>\n<li>事务按序提交：Databus 能保持来源数据库中的事务完整性，并按照事务分组和来源的提交顺寻交付变更事件。</li>\n<li>低延迟、支持多种订阅机制：数据源变更完成后，Databus 能在毫秒级内将事务提交给消费者。同时，消费者使用D atabus 中的服务器端过滤功能，可以只获取自己需要的特定数据。</li>\n<li>无限回溯：对消费者支持无限回溯能力，例如当消费者需要产生数据的完整拷贝时，它不会对数据库产生任何额外负担。当消费者的数据大大落后于来源数据库时，也可以使用该功能。</li>\n</ul>\n<h2> <strong>3.4其他</strong></h2>\n<p><strong>Flink</strong></p>\n<ul>\n<li>有界数据流和无界数据流上进行有状态计算分布式处理引擎和框架。</li>\n<li>官网地址：<a href=\"https://flink.apache.org\" target=\"_blank\" rel=\"noopener noreferrer\">https://flink.apache.org</a></li>\n</ul>\n<p><strong>CloudCanal</strong></p>\n<ul>\n<li>数据同步迁移系统，商业产品。</li>\n<li>官网地址：<a href=\"https://www.clougence.com/?utm_source=wwek\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.clougence.com/?utm_source=wwek</a></li>\n</ul>\n<p><strong>Maxwell</strong></p>\n<ul>\n<li>使用简单，直接将数据变更输出为json字符串，不需要再编写客户端。</li>\n<li>官网地址：<a href=\"http://maxwells-daemon.io\" target=\"_blank\" rel=\"noopener noreferrer\">http://maxwells-daemon.io</a></li>\n</ul>\n<p><strong>DRD</strong></p>\n<ul>\n<li>阿里巴巴集团自主研发的分布式数据库中间件产品，专注于解决单机关系型数据库扩展性问题，具备轻量(无状态)、灵活、稳定、高效等特性。</li>\n<li>官方地址：<a href=\"https://www.aliyun.com/product/drds\" target=\"_blank\" rel=\"noopener noreferrer\">https://www.aliyun.com/product/drds</a></li>\n</ul>\n<p><strong>yugong</strong></p>\n<ul>\n<li>帮助用户完成从 Oracle 数据迁移到 MySQL。</li>\n<li>访问地址：<a href=\"https://github.com/alibaba/yugong\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/alibaba/yugong</a></li>\n</ul>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "服务器高并发之提高TCP连接数",
      "url": "https://ujava.cn/synthesis/tcpcount.html",
      "id": "https://ujava.cn/synthesis/tcpcount.html",
      "summary": "前言 测试服务器系统：ubuntu server 20.04.3 nginx负载均衡服务器：centos 7 服务器上我放了一个web系统用来测试连接数：开源的支持高并发的服务器 发出请求的是我的电脑，电脑系统：win7 发出请求用的是python的压测工具：locust TCP连接能连接多少",
      "content_html": "<h2> 前言</h2>\n<ul>\n<li>测试服务器系统：ubuntu server 20.04.3</li>\n<li>nginx负载均衡服务器：centos 7</li>\n<li>服务器上我放了一个web系统用来测试连接数：<a href=\"https://github.com/yedf/handy\" target=\"_blank\" rel=\"noopener noreferrer\">开源的支持高并发的服务器</a></li>\n<li>发出请求的是我的电脑，电脑系统：win7</li>\n<li>发出请求用的是python的压测工具：locust</li>\n</ul>\n<h2> TCP连接能连接多少</h2>\n<p>要想弄清楚一个服务器能接受多少连接数，就需要根据socket五元组来看，即源IP+源端口+目标IP+目标端口+类型（TCP/UDP）。只要五元组不重复，就可以新增tcp连接。不过由于测试的时候一般类型都是相同的，所有大多数都是称为四元组。<br>\n由于服务器的IP和web系统的端口一般是固定的，每个客户端的IP又不相同，那么照这样看连接数应该基本上相当于没限制才对。其实不然，实际上每个连接还要占用一定的内存和一个文件描述符。</p>\n<p><strong>那么一个TCP socket占用多少内存呢？</strong><br>\n大约是3K多，当然如果有发送或者接收的缓存区文件存在则另算，在响应较快、缓存文件不大的情况下内存应该不会成为瓶颈。</p>\n<p><strong>服务器又能打开多少文件描述符呢？</strong><br>\n可以通过以下命令查看<br>\n系统级：当前系统可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/file-max</code>&nbsp;查看<br>\n用户级：指定用户可打开的最大数量，通过&nbsp;<code>cat /etc/security/limits.conf</code>&nbsp;查看<br>\n进程级：单个进程可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/nr_open</code>&nbsp;查看</p>\n<p>修改方式<br>\n修改单个进程可打开的最大文件描述符为10000，即可打开10000个连接：<code>echo 10000 &gt; /proc/sys/fs/nr_open</code><br>\n用户级修改：</p>\n<div class=\"language-bash line-numbers-mode\" data-ext=\"sh\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>当然，每创建一个tcp连接，还需要消耗一个线程来处理（也可以采用IO多路复用的方式，一个线程管理多个TCP连接），所以和CPU也有关系，不能通过单纯的提高内存的方式来增加连接数。<br>\n常用查看连接数命令：<br>\n<code>netstat -nat | grep -i \"8085\" | wc -l # 查询指定端口的连接数</code><br>\n<code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # 查看TCP连接数及状态命令</code></p>\n<h2> 实际测试</h2>\n<p>此时是使用我的电脑向nginx负载均衡服务器发送请求，然后转发给web服务器。</p>\n<h3> 测试1 未调整的情况下测试</h3>\n<p><strong>客户端情况：</strong><br>\n初始：可用端口55000个，性能够用<br>\n结果：本地性能未达瓶颈，但是设置的1000并发人数，请求数平均只有437.3。<br>\n</p>\n<p><strong>nginx服务器情况：</strong><br>\n初始：可用端口60000个，用户级65535，性能够用<br>\n结果：本地性能未达瓶颈，但是出现很多TIME_WAIT数，最高时8000多。<br>\n</p>\n<p><strong>服务器情况：</strong><br>\n初始：用户级65535。<br>\n结果：最高连接数23，平均2.<br>\n</p>\n<h3> 测试1分析</h3>\n<p>先分析一下TIME_WAIT、CLOSE_WAIT出现的原因及解决方法<br>\n分析这里，就必须要简短回顾一下四次挥手（当client发起结束请求时）<br>\n<br>\n简短来说：<br>\n1、一端没有close，那么另一端将有大量的close_wait状态；<br>\n2、主动close的一端，在量特别大的情况下将造成大量的time_wait状态（由于Linux中一般默认的2msl为60s，那么正常情况下每秒1000的请求会造成60*1000=60000个time_wait记录，几百几千问题不大）</p>\n<p>既然主动close的一方才会有time_wait记录，那么这里就说明nginx服务器是主动关闭的一方，那nginx服务器关闭的对象又是谁呢？<br>\n在仅修改了nginx的代理地址，未改变其他配置情况下，通过wireshark抓包得知：</p>\n<ul>\n<li>客户端与nginx端相互通信都是http/1.1的链接，这里是nginx端先发起的fin请求；</li>\n<li>nginx端到服务器端的请求是http/1.0，服务器端返回的请求是http/1.1，这里是nginx端先发起的fin请求。</li>\n</ul>\n<h3> 测试1优化</h3>\n<p>依上面的场景分析，如果要减少time_wait数，提高连接数，则需要从以下方面来解决</p>\n<ol>\n<li>调整负载均衡服务器和web服务器/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，修改成&nbsp;<code>net.ipv4.ip_local_port_range=1024 65535</code>，保证至少可以使用6万个随机端口，就算保留1分钟，也能支持每秒1000的并发；</li>\n<li>加多负载均衡服务器的ip，直接翻番；</li>\n<li>负载均衡与服务器端也建立长连接，不关闭就不会有等待；</li>\n<li>扩大nginx的keep-alive超时时间，最大请求数，使得长连接不会这么早关闭；</li>\n<li>在nginx服务器上调整time_wait参数net.ipv4.tcp_tw_reuse=1，尽可能去复用连接（另外net.ipv4.tcp_tw_recycle参数在4.10以上内核中被移除了）。</li>\n</ol>\n<p>另外还有一些参数可以调整，不过一般默认是够用的</p>\n<div class=\"language-yaml line-numbers-mode\" data-ext=\"yml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>待优化测试验证</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计限流",
      "url": "https://ujava.cn/synthesis/throttling.html",
      "id": "https://ujava.cn/synthesis/throttling.html",
      "summary": "简介 漏桶和令牌桶的区别 漏桶 漏桶 令牌桶 令牌桶",
      "content_html": "<h2> 简介</h2>\n<p>漏桶和令牌桶的区别</p>\n<h2> 漏桶</h2>\n<figure><figcaption>漏桶</figcaption></figure>\n<h2> 令牌桶</h2>\n<figure><figcaption>令牌桶</figcaption></figure>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "企业架构TOGAF内容框架",
      "url": "https://ujava.cn/synthesis/togaf.html",
      "id": "https://ujava.cn/synthesis/togaf.html",
      "summary": "img_24.png 一、内容框架概述 TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。 企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。",
      "content_html": "<figure><figcaption>img_24.png</figcaption></figure>\n<h2> 一、内容框架概述</h2>\n<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>\n<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>\n<p>内容框架对企业架构开发方法中各阶段的输入和输出信息进行了分类总结，并通过内容元模型（Content MetaModel）对构成企业架构内容的各个元素（即企业架构中的各个构建块的类型）以及他们之间的关系进行了定义。内容框架中针对其内容的描述采用了一种与架构开发方法的各阶段相映射的方式进行组织，即对架构开发方法的各个阶段所产出的企业架构内容具体是什么进行描述。</p>\n<p>虽然针对企业架构内容的定义非常重要，但是同样重要的还有如何对企业架构的内容进行利用。企业架构的核心目标是为具有不同视角的干系人根据其关注点提供准确的视图，从而使得不同的干系人虽然采用了不同的观察角度和描述方式，但的确是在为共同的目标而进行着无障碍沟通和协作。为了达到这一目标，内容框架对于各种视角（ViewPoint）从表现形式和内容方面都进行了归纳总结，并对一些视图的开发也提供了建议和指南。TOGAF是一个通用性的标准，它的内容不可能涵盖企业中所有的视角，因而在具体实践中，各个企业完全可以根据自身需要对这些视角进行引用、修改和组合，从而总结出适合的视角，并借此开发出相应的视图，从而满足企业中具体干系人的需要。</p>\n<p>下图展示了内容框架中各方面内容与企业中客观存在的各种资源之间关系，以及企业架构的内容是如何在内容框架的组织下为各个干系人提供帮助的：</p>\n<figure><figcaption>img_25.png</figcaption></figure>\n<h2> 二、企业架构工作产品分类</h2>\n<p>在内容框架中，企业架构开发方法过程中所涉及到的各种工作产品被归纳为如下几种：</p>\n<p>1、架构交付物（Architecture Deliverables）：架构交付物是由合同指定并被相关干系人轮流进行正式的审查和签字认可的工作产品。这些交付物代表着架构项目的输出，以及那些在一个项目完结时以文档形式进行交付的，或者作为参考模型、标准或在某一时点的架构情景快照（snapshot of the Architecture Landscape）被过渡到架构资源库中的工作产品。</p>\n<p>2、架构制品（Architectural Artifacts）：与架构交付物相比，架构制品是一个从某个特定视角进行架构描述并具备更细粒度的工作产品。例如，网络图、服务器说明、用例说明、架构需求列表以及业务交互矩阵等。就表现形式来讲，架构制品的内容可以通过目录、矩阵和图形这三种方式来表述。通常情况下，一个架构交付物可以包含多个架构制品，而架构制品也可能会出现在多个架构交付物之中，并且架构制品也将会形成架构资源库的内容。</p>\n<p>3、构建块（Building Blocks）：构建块代表着业务、IT或者架构能力的一个组件，并且可以与其他构建块组合在一起来对各种架构和解决方案进行交付。根据所处的架构开发阶段的不同，构建块能够在多个详细度层次上进行定义。例如，在架构开发的早期阶段，一个构建块可能仅仅包含一个名字或一个概要描述，而随着架构开发过程的演进，此构建块可能会被进一步分解为若干具有详尽描述的支持性构建块。从内容和所面对的问题上看，构建块可以被进一步分为如下两种：</p>\n<p>架构构建块（ABBs：Architecture Building Blocks）：此种类型的构建块一般用于描述各种需要的能力，并对其后的解决方案构建块的轮廓进行了勾勒。例如，企业中的一个客户服务定义了实现这项能力的各种需求，而对于它的真正落实就需要若干解决方案构建块在各方面（流程、数据以及应用软件等）将这些需求映射到具体的实现技术之上。<br>\n解决方案构建块（SBBs：Solution Building Blocks）：此种类型的构建块代表了用于实现各种需求（由架构构建块定义）的具体组件。<br>\n<br>\n以上三种工作产物虽然在内容和产生背景上有着很大的不同，但是他们之间却有着非常紧密的联系。构建块可以说是企业架构资源库的核心内容，并且也是企业架构过程的终极目标产物，因而把其称为企业的模型也并不为过，而架构制品则可以看成此模型在某个角度的各种视图，属于架构描述的范畴。架构交付物比较特殊，它与架构开发方法各阶段紧密相连，并作为各个阶段的输入与输出载体而存在。</p>\n<h2> 三、架构交付物（Architecture Deliverables）</h2>\n<p>架构交付物是在整个架构开发方法循环过程中所产生或被使用的契约性、正规化的企业架构内容。它与企业架构开发方法有着紧密的联系。本节将针对这些架构交付物以及它们与架构开发方法各阶段之间的关系进行阐述。需要注意的是，本节的内容只提供了一个关于架构交付物的内容概括。由于企业中可能存在着符合其自身需要的项目和过程管理方法，所以企业也可以根据自己的实际情况对这些交付物进行改造和定制。</p>\n<p>架构交付物与企业架构开发方法各阶段之间的对应关系（注意，下表采用了简称来标示各企业架构开发方法阶段）：<br>\n</p>\n<figure><figcaption>img_28.png</figcaption></figure>\n<h3> 1、架构构建块</h3>\n<p>构建块是企业架构过程的最终目标之一，它是企业对于各个层面上（业务、应用、数据以及技术等）的可重用部件的抽象。架构构建块的内容侧重于对构建块的需求进行描述，就像软件开发中的接口一样，架构构建块并不涉及具体的实现方式，而只是描述了构建块所需要达成的功能。用于描述架构构建块的文档和模型存储在企业架构资源库之中，企业架构开发过程正是对企业中各种客观存在的或计划中的可重用模块进行抽象建模，并最终将这些内容存储到企业架构资源库之中（或对其内容进行更新）。</p>\n<h3> 2、架构合同</h3>\n<p>目标</p>\n<p>架构合同是企业架构开发团队与赞助团队之间关于架构的交付、质量和适用性的联合协定。为了成功实现这一协定则需要企业进行有效的架构治理。通过实现一个用于合同管理的治理方法，企业将会确保：</p>\n<ul>\n<li>对组织中所有架构相关活动的完整性检查、变更、决策和审计进行持续监督。</li>\n<li>现存或正在开发的架构得以贯彻组织的原则、标准和需求。</li>\n<li>明确架构在开发和实现的各个方面中的风险，这些方面涵盖了关于可接受的标准、策略、技术和产品的内部开发，以及架构的运营层面，从而使得组织可以在一个具有弹性的环境中继续其业务。</li>\n<li>一系列流程和实践，用于确定关于所有架构制品的开发和使用的责任和规则。</li>\n<li>对于为合同负责的治理组织，他们的权限级别及其治理之下的架构范围有一个正式的理解。</li>\n</ul>\n<p>内容</p>\n<p>架构设计和开发合同的内容一般包括：</p>\n<ul>\n<li>介绍和背景</li>\n<li>协议性质</li>\n<li>架构范围</li>\n<li>架构以及战略原则和需求</li>\n<li>一致性需求</li>\n<li>架构开发和管理流程，以及相关角色</li>\n<li>目标架构评测标准</li>\n<li>定义的交付阶段</li>\n<li>按照优先级排序的联合工作计划</li>\n<li>时间窗口（Time windows）</li>\n<li>架构交付和业务指标</li>\n</ul>\n<p>业务用户的架构合同一般包括：</p>\n<ul>\n<li>介绍和背景</li>\n<li>协议性质</li>\n<li>范围</li>\n<li>战略需求</li>\n<li>一致性需求</li>\n<li>架构采用者</li>\n<li>时间窗口</li>\n<li>架构业务指标</li>\n<li>服务架构（包括服务水平协议（SLA：Service Level Agreement））</li>\n</ul>\n<h3> 3、架构定义文档</h3>\n<p>目标</p>\n<p>架构定义文档是一个包含在整个项目中所产生的各种制品的可交付容器。它跨越所有的架构领域（业务、数据、应用和技术），并可用于检阅架构的所有相关状态（当前态、中间态和目标态）。架构定义文档对架构需求文档在如下方面进行互补：</p>\n<ul>\n<li>架构定义文档提供了一个解决方案的定性视图，用于沟通架构师的意图。</li>\n<li>架构需求说明提供了一个解决方案的定量视图，用于声明在架构实现过程中必须遵守的可测量的标准。<br>\n内容</li>\n</ul>\n<p>架构定义文档内容一般包括：</p>\n<ul>\n<li>范围</li>\n<li>目标、阶段目标和约束</li>\n<li>架构原则</li>\n<li>基线架构</li>\n<li>架构模型（针对每个被建模的状态）：业务架构模型、数据架构模型、应用架构模型、技术架构模型</li>\n<li>架构方法的基本原理和理由</li>\n<li>架构资源库内容映射：架构情景映射、参考模型映射、标准映射、重用评估</li>\n<li>差距分析结果</li>\n<li>影响评估</li>\n</ul>\n<h3> 4、架构原则</h3>\n<p>目标</p>\n<p>通用的规则和指南，一般是不会进行更改的。这些原则知会并支持一个组织用以实现其任务的方法。它是用于定义和指导组织从价值到行为和结果的一系列结构化思路中的一员。</p>\n<p>内容</p>\n<p>架构原则一般包括如下几个层面的内容（其具体内容请参看TOGAF标准相关内容）：</p>\n<ul>\n<li>业务原则</li>\n<li>数据原则</li>\n<li>应用原则</li>\n<li>技术原则</li>\n</ul>\n<h3> 5、架构资源库</h3>\n<p>目标</p>\n<p>架构资源库在企业中充当了对于所有架构相关项目进行存储的区域。它允许各个项目管理它们的交付物，定位可重用资产，并对干系人以及其他有兴趣者进行信息发布。</p>\n<p>内容</p>\n<p>架构资源库的内容包括如下几个方面（其具体内容请参看TOGAF标准相关内容）：</p>\n<ul>\n<li>架构框架</li>\n<li>标准信息库</li>\n<li>架构情景</li>\n<li>参考架构</li>\n<li>治理日志</li>\n</ul>\n<h3> 6、架构需求说明</h3>\n<p>目标</p>\n<p>架构需求说明提供了一组量化的描述，用于概括一个项目的实现与架构相符合所必须做的事情。架构需求说明一般会形成一个实施契约，或是更详细的架构定义契约中的主要组件。</p>\n<p>内容</p>\n<p>架构需求说明的内容通常包括：</p>\n<ul>\n<li>成功评测标准</li>\n<li>架构需求描述</li>\n<li>业务服务契约</li>\n<li>应用服务契约</li>\n<li>实施导则</li>\n<li>实施说明</li>\n<li>实施标准</li>\n<li>互操作需求</li>\n<li>约束</li>\n<li>假设</li>\n</ul>\n<h3> 7、架构路线图</h3>\n<p>目标</p>\n<p>架构路线图列举出各个变化增量，并把他们放到时间轴之上，从而展示了从当前架构到目标架构的演进过程。架构路线图是迁移架构的重要组件，并在架构开发方法的B、C、D、E、F阶段中以增量的方式开发出来。</p>\n<p>内容</p>\n<p>架构路线图的内容包括：</p>\n<ul>\n<li>项目列表：每个涉及到的项目的名称、描述和目标，用于实现所建议的架构的项目列表，并按照优先级进行了排序。</li>\n<li>基于时间的迁移规划：迁移的效益、针对各种迁移选择的成本估算。</li>\n<li>实施建议：用于衡量项目有效性的评估准则、风险和问题、解决方案构建块的描述和模型。</li>\n</ul>\n<h3> 8、架构愿景</h3>\n<p>目标</p>\n<p>架构愿景是在项目生命周期早期创建的，它提供了一个高阶的对于最终架构产品的期望视图。目的是为了在一开始就对架构应该达到的期望结果形成一致意见，从而使得在之后的过程中架构师能够关注于切实可行的关键领域。通过提供一份关于整体架构定义的内容摘要，架构愿景对于干系人之间按沟通也提供了一定的支持。</p>\n<p>内容</p>\n<p>架构愿景的内容通常包括：</p>\n<ul>\n<li>问题描述：干系人以及他们的关注点，需要解决的问题/场景列表。</li>\n<li>详细目标描述</li>\n<li>环境和流程模型：流程描述、涉及到环境的流程步骤、涉及到人员的流程步骤、信息流</li>\n<li>执行者以及他们担当的角色和责任：人员方面的执行者和角色、计算机方面的执行者和角色、需求</li>\n<li>所产生的架构模型：约束、IT原则、支持流程的架构、映射到架构之上的需求。</li>\n</ul>\n<h3> 9、业务原则、目标和驱动力</h3>\n<p>目标</p>\n<p>业务原则、目标和驱动力通过描述企业的需要和工作方式为架构工作提供了背景。此外，许多处于架构原则考虑之外的因素对架构的开发也有着重要的影响。</p>\n<p>内容</p>\n<p>于不同的组织有着不同的特性，因而关于架构业务背景的内容将会各不相同，企业应该根据各自的情况定义这部分内容。</p>\n<h3> 10、能力评估</h3>\n<p>目标</p>\n<p>在做一份详细的架构定义之前，对企业的当前和目标的能力水平有一个清晰的认识是非常有价值的。对于能力评估，我们可以在如下几个层面进行考虑：</p>\n<ul>\n<li>企业整体的能力水平是什么？企业希望在何处增强或优化其能力？用于支持企业期望发展的架构关注领域是什么？</li>\n<li>企业中的IT功能的能力或成熟度水平是什么？就设计管理、操作管理、技术和组织架构而言，进行架构项目最可能的影响都有哪些？为了与企业文化和IT部门的能力相适应，架构项目所需的正规化和详细度的最适宜水平是什么？</li>\n<li>企业架构功能的能力和成熟度是什么？当前存在的架构资产有哪些？这些资产是否被一直维护，并且是否还准确？什么样的标准和参考模型需要被考虑进去？是否在这些在架构项目中有可能创建可重用资产？</li>\n<li>能力欠缺存在于何处？为了达成目标能力而需要进行转型的业务范围是什么？在对基本能力欠缺考虑之上的转换风险、文化壁垒以及其他方面考虑都有哪些？<br>\n内容</li>\n</ul>\n<p>能力评估的内容通常包括：</p>\n<ul>\n<li>业务能力评估：业务能力、针对每项能力性能水平的基线状态评估、针对每项能力性能水平的未来状态期望、针对每项能力如何实现的基线状态评估、针对每项能力将会被如何实现的期望</li>\n<li>IT能力评估：变更流程的基线和目标成熟度水平、运营流程的基线和目标成熟度水平、基线能力以及容量评估、针对由于架构项目的执行而对IT组织所可能产生的影响的评估</li>\n<li>架构成熟度评估：架构治理流程/组织/角色和责任、架构技能评估、架构资源库中的情景定义的深度/广度/质量、架构资源库中的标准定义的深度/广度/质量、架构资源库中的参考模型的深度/广度/质量、针对可重用潜力的评估。</li>\n<li>业务转型准备度评估：准备度因素、对于每个准备度因素的愿景、针对当前和目标准备度的评级、与准备度相关的风险。</li>\n</ul>\n<h3> 11、变更请求</h3>\n<p>目标</p>\n<p>在架构的实现过程中，在一切清晰之前，原来的架构定义和需求很可能不适合或不足以达成解决方案的实现。在这种情况下，对实施项目进行调整使之与建议的架构方法发生偏离，或请求架构范围扩展是必需的行为。另外，很多外部因素（例如，市场因素、业务策略变化以及新技术机会）也会为扩展及优化架构提供新的机会。在以上这些环境下，一个变更请求可以被提出，用以开始一个新的架构工作周期。</p>\n<p>内容</p>\n<p>变更请求的内容通常包括：</p>\n<ul>\n<li>对于所建议的变更的描述</li>\n<li>对于所建议的变更的理由</li>\n<li>对于所建议的变更的影响评估：针对相关特定需求的引用、迄今需求所涉及的干系人的优先级、重新审视这些需求的各阶段描述、对需求优先级进行排序的阶段、调查和修正需求的优先级阶段的结果、对于需求管理的建议。</li>\n<li>资源库引用编号</li>\n</ul>\n<h3> 12、 沟通计划</h3>\n<p>目标</p>\n<p>企业架构包含大量的复杂且相互关联的信息。有效地与适当的人在适当的时间针对目标信息进行交流是成功建设企业架构的重要因素。开发沟通计划可以使这些交流通过一种可计划、可管理的方式进行。</p>\n<p>内容</p>\n<p>沟通计划的内容通常包括：</p>\n<ul>\n<li>针对干系人的识别，并根据沟通需求进行分组</li>\n<li>明确沟通需求、与架构愿景相关的关键消息、沟通风险和关键成功因素（CSFs：Critical Success Factors）</li>\n<li>明确用来与干系人进行沟通的机制，并允许其对架构信息的访问</li>\n<li>制定沟通时间表。该时间表展示了沟通将在何时何地进行，以及在何种干系人组之间进行</li>\n</ul>\n<h3> 13、 合规评估</h3>\n<p>目标</p>\n<p>一旦一个架构被定义了出来，就必须在整个实施过程中对其进行治理，从而保证原先的架构愿景可以被适当的实现，并且实现中的经验教训也可以反馈到架构过程中。针对实施项目进行周期性的合规检查为重新审核项目过程，并保证设计和实施符合企业策略和架构目标，提供了一种有益的机制。</p>\n<p>内容</p>\n<p>合规评估的内容通常包括：</p>\n<ul>\n<li>项目进程和状态的概览</li>\n<li>项目架构/设计概览</li>\n<li>完整的架构清单：硬件和操作系统清单、软件服务和中间件清单、应用清单、信息管理清单、安全清单、系统管理清单、系统工程清单、方法和工具清单。</li>\n</ul>\n<h3> 14、实施和迁移计划</h3>\n<p>目标</p>\n<p>通过过渡框架的描述为解决方案的实施提供一个日程表，包括实施的时间、成本、资源、收益和里程碑。</p>\n<p>内容</p>\n<p>实施和迁移计划的内容通常包括：</p>\n<ul>\n<li>实施和迁移战略：战略实施方向、实施排序方法</li>\n<li>与其他管理框架的交互：架构与业务规划相协调的方法、整合架构的方法、架构与项目管理相协调的方法、架构与运营管理相协调的方法。</li>\n<li>项目章程：项目所能交付的能力、所包含的工作包、业务价值、风险、问题、假设和依赖关系</li>\n<li>实施规划：由实施分解出来的各个阶段和工作流、为各阶段和工作流进行工作包分配、里程碑和时间要求、工作分解结构、资源需求和成本</li>\n</ul>\n<h3> 15、实施治理模型</h3>\n<p>目标</p>\n<p>一旦一个架构被定义，在整个实施过程中就需要对用于实现架构的过渡框架进行治理。在已经建立了架构功能的组织中可能已经存在了一个治理框架，但是对于特定的过程、组织、角色、责任和度量来说，需要根据项目进行具体的定义。</p>\n<p>内容</p>\n<p>实施治理模型的内容通常包括：</p>\n<ul>\n<li>治理流程</li>\n<li>治理组织结构</li>\n<li>治理角色和相应职责</li>\n<li>治理检查点和成功与失败标准</li>\n</ul>\n<h3> 16、 企业组织架构模型</h3>\n<p>目标</p>\n<p>为了一个架构框架能够被成功地使用，它必须在企业中获得正确的组织、角色和责任的支持。特别重要的是，对不同企业架构参与者之间边界的定义，以及针对跨边界关系的治理。</p>\n<p>内容</p>\n<p>企业组织架构模型的内容通常包括：</p>\n<ul>\n<li>受影响的组织的范围</li>\n<li>成熟度评估、差距和决议方法</li>\n<li>架构团队的角色和责任</li>\n<li>针对架构工作的约束</li>\n<li>资金预算需求</li>\n<li>治理和支持策略</li>\n</ul>\n<h3> 17、架构工作要求书</h3>\n<p>目标</p>\n<p>由赞助组织交付给架构组织的用于启动架构开发工作的文档。架构工作要求书可以产生于预备阶段，可以是经过批准的架构变化请求的结果，或者是源于迁移计划对架构工作的参考。</p>\n<p>内容</p>\n<p>架构工作要求书的内容通常包括：</p>\n<ul>\n<li>组织赞助者</li>\n<li>组织的任务说明</li>\n<li>业务目标（以及变更）</li>\n<li>业务的战略规划</li>\n<li>时间限制</li>\n<li>业务环境的变化</li>\n<li>组织方面的约束</li>\n<li>预算信息以及财务约束</li>\n<li>外部约束以及业务约束</li>\n<li>当前业务系统描述</li>\n<li>当前架构/IT系统描述</li>\n<li>开发组织的描述</li>\n<li>开发组织可用资源的描述</li>\n</ul>\n<h3> 18、需求影响评估</h3>\n<p>目标</p>\n<p>在整个架构开发方法过程中，总会有新的与架构相关的信息被收集起来。当这些信息被收集后，对架构在当前某方面有影响的新因素也经常会显现出来。需求影响评估就是用来对当前架构需求进行评估，阐明需要进行的变更以及这些变更所带来的影响。</p>\n<p>内容</p>\n<p>需求影响评估的内容通常包括：</p>\n<ul>\n<li>对于具体需求的引用</li>\n<li>迄今需求的相关干系人优先级</li>\n<li>进行重审的各个阶段</li>\n<li>进行需求优先级排序的阶段</li>\n<li>调查和修正需求的优先级阶段的结果</li>\n<li>关于需求管理的建议</li>\n<li>资源库引用编号</li>\n</ul>\n<h3> 19、解决方案构建块</h3>\n<p>与架构构建块相类似，解决方案构建块也是存储于架构资源库中的构建块的一种，不过它的内容更倾向于在实现层面对企业中的可重用构建块进行描述。可以说，架构构建块定义了构建块的需求，而解决方案构建块则是此需求在具体实现技术层面的映射。关于解决方案构建块的具体内容请参阅后面的内容。</p>\n<h3> 20、架构工作说明书</h3>\n<p>目标</p>\n<p>架构工作说明书定义了用于完成一个架构项目的方法和范围，它也是用于评测架构项目是否被成功执行的典型文档，并且它也形成了架构服务提供者和使用者之间的合同协议的基础。</p>\n<p>内容</p>\n<p>架构工作说明书的内容通常包括：</p>\n<ul>\n<li>架构工作标题说明</li>\n<li>项目申请和背景</li>\n<li>项目描述和范围</li>\n<li>架构愿景的概括</li>\n<li>管理办法</li>\n<li>范围变更程序</li>\n<li>角色、责任和交付物</li>\n<li>验收标准和程序</li>\n<li>项目计划和日程安排</li>\n<li>针对架构连续体的支持</li>\n<li>签字批准</li>\n</ul>\n<h3> 21、定制的架构框架</h3>\n<p>目标</p>\n<p>TOGAF提供了一个行业的标准架构框架，但是要在一个架构项目中对其进行有效地使用，则必须在两个层面上进行定制。首先，需要对TOGAF模型进行定制，使得它可以融入到企业之中。此种定制包括将TOGAF模型整合入企业的项目和过程管理框架、术语定制、展示方式开发、架构工具的选择、配置和部署等方面之中。任何被采用的框架的形式和详细程度应该与企业的其他背景元素相适应，例如文化、干系人、企业架构的商业模型以及当前架构能力的水平。一旦针对框架完成了上面的定制，企业就需要为具体的架构项目做进一步的框架定制，而在这一层面的定制中，企业需要选择适当的架构交付物和架构制品来满足项目和干系人的需要。</p>\n<p>内容</p>\n<p>定制的架构框架的内容通常包括：</p>\n<ul>\n<li>定制架构的方法</li>\n<li>定制架构的内容（架构交付物和架构制品）</li>\n<li>配置和部署工具</li>\n<li>治理模型和其他框架的接口：企业架构管理框架、能力管理框架、项目组合管理框架、项目管理框架、运营管理框架。</li>\n</ul>\n<h3> 22、过渡架构</h3>\n<p>目标</p>\n<p>过渡架构展示了企业的增量状态，并反映从当前架构到目标架构的过渡过程。过渡架构被用来将单独的工作包和项目组合为可管理的项目组合和程序，用于描述每个阶段的业务价值。</p>\n<p>内容</p>\n<p>过渡架构的内容通常包括：</p>\n<ul>\n<li>机会组合描述：综合的差距、解决方案和依赖关系评估、机会描述、收益评估、能力和能力增量、互操作性和共存的需求</li>\n<li>工作包组合描述：工作包描述（名称、描述、目标和交付物）、功能性需求、依赖关系、与机会之间的关系、与架构定义文档和架构需求说明之间的关系。</li>\n<li>里程碑和里程碑过渡架构：过渡状态描述、每个过渡状态的业务架构、每个过渡状态的数据架构、每个过渡状态的应用架构、每个过渡状态的技术架构。</li>\n<li>实施因素评估和推导矩阵（ImplementationFactor Assessment and Deduction Matrix：用于记录将会影响架构实施和迁移计划的各个因素。此矩阵包括在制定迁移计划时需要考虑的各个因素、它们的描述，以及由此而推断出的在制定计划时需要考虑的行动或约束）：风险、问题、假设、依赖、行动。</li>\n<li>综合差距、解决方案和依赖矩阵（Consolidated Gaps，Solutions，and Dependencies matrix：此矩阵使架构师可以对在各领域架构差距分析结果中明确的差距进行分组，并评估潜在的解决方案，以及这些方案与差距之间的依赖关系）：架构领域、差距、潜在解决方案、依赖关系。</li>\n</ul>\n<h2> 四、架构制品（Architectural Artifacts）</h2>\n<p>架构制品是针对某个系统或解决方案的模型描述，与架构交付物和构建块相比，架构制品既不是架构开发方法过程各阶段的合约性产物，亦不是企业中客观存在的各种可重用解决方案，而是针对包括这些构建块在内的企业客观现实的描述，并以解答不同干系人的关注点为其最终目标。可以说，架构交付物面向于企业架构的产生，架构构建块倾向于企业架构的结果，而架构制品则注重于针对企业架构的应用（虽然架构交付物可以包含若干架构制品，但是架构制品在本质上还是被用来为不同的干系人按照其视角提供相应的企业客观视图，况且架构交付物对架构制品的包含本身也是架构制品的应用之一，其目的也是为了在架构开发过程中所涉及的不同干系人之间达成共识）。</p>\n<p>企业架构并不是一个静态的过程，不能将建设一个包含企业架构内容的信息资源库当作唯一目标。对于任何企业来说，企业架构的意义都应该在于将其自身的战略决策、业务和信息技术资源联系为一个有机整体，并且不同的干系人从企业架构中获得其所需的关于企业的自上而下（自业务至用于支持各项业务实现的解决方案）的视图，而这方面的内容属于针对企业架构内容的使用范畴。在这一范畴之中，所有的企业架构框架理论，哪怕是几乎不涉及企业架构内容的框架，都会关注于两个概念：视角与视图。其中视角是针对不同干系人企业架构内容的需求描述，而视图是基于某一视角的具体架构内容描述，因而也可以说视角是视图的元类型定义。在这两个概念中，视图比较好理解，亦即根据视角的定义而对企业客观现状的某一侧面描述，相比之下，用于对视图进行定义的视角概念则更为关键。视角是不同干系人对于企业架构内容需求的体现，亦即其采用何种角度对企业客观存在或计划存在的自顶层战略、业务至底层解决方案而进行观察。这些角度的定义基本上应该包括如下几个方面：</p>\n<p>1、目标需求：不同的干系人担当着不同的角色及责任，其看问题的角度与担当的任务也因此有着非常紧密的联系。一般来讲，目标需求大体可以分为：</p>\n<ul>\n<li>设计层面：包括了用于指导和支持与设计决策相关的各种制品。例如架构师、开发人员以及业务流程建模人员等干系人经常会用到的UML图、流程建模图（例如BPMN图）、以及用于描述数据的关系-实体图等制品都属于这一范畴。</li>\n<li>决策层面：包括了用于支持高层决策的制品（例如，交叉引用表、情景图、以及各种报告等制品），适用于企业中处于管理高层的各种决策人，例如CEO、CIO等。</li>\n<li>告知层面：包括了用于为相关干系人进行解释、说服以及获得其承诺方面的制品（流程概述、图表、宣讲动画等）。这些干系人可能会是一般职工、客户，或者其他在企业中从业务到解决方案这条线上虽不占关键位置却需要对企业架构进行了解的干系人。<br>\n2、抽象级别需求：上面描述了不同干系人由于其担负任务的不同，因而对于企业的观察也具有着不同的角度，从而对不同的制品产生兴趣。然而，即使不同的干系人针对企业的相同侧面有着共同的兴趣，但是他们对于描述的抽象级别或详细程度也可能有着不同的要求。例如，对于相同的业务流程来说，可能对于高层管理人员来说需要关注的仅是此流程的输入、输出，而对于其实现细节并不一定关心，而对于流程建模人员来说此业务流程恐怕就需要被细化为粒度更加细小的业务功能组合，而对于软件开发人员来讲，可能还要为某个具体业务行为而考虑其相关的数据结构和实现方案。</li>\n</ul>\n<p>3、展示需求：上述两点可以说是依据干系人所持的角度在内容方面所进行的分类，而除此之外，由于不同的干系人由于各自的偏好不同，他们可能会对视图的展示也有着非常不同的要求。虽然在TOGAF中，架构制品的描述方式被定义为目录、矩阵和图形三种方式，但就其具体展示方式来说，不同的干系人还可能具有不同的要求和偏好。例如，对于组织结构的展示，有的干系人可能偏好于采用简单的树形结构的展示，而其他干系人则可能更加倾向于图形化的结构图。这种展示需求在图形展示方面尤其突出，某些干系人（特别是来自于内部的干系人，例如领域专家等）可能习惯于采用某种标准的标注体系来对架构内容进行展示，而对于其他干系人来讲（例如客户或非专业的干系人）采用如此方式可能并不能取得很好的效果，而采用更加贴近现实的图标来代替标准图标（通常是若干简单的形状、连线和颜色的组合）则更加友好。虽然展示需求也是视角定义所需靠虑的元素之一，但是在大多数情况下这一层面的定义往往可以采用松耦合的方式来进行描述，即将视角的定义分为内容和展示两个层面，并在两者之间建立关联（通常一个内容定义可以包含若干展示定义）。</p>\n<p>上述关于视角分类的定义很容易让人产生非此即彼的感觉，即视角是为干系人服务的，因而应该仅从属于某种干系人。这样的思想除了源于思想的惯性，最主要的还是由于忽视了企业架构的核心精神—在组织中创建无障碍的沟通信息流。作为企业架构的核心概念，如果只把视角看作为企业架构描述用的约束和定义，而忽视了沟通这一本质则是违反企业架构最终目标的。每种干系人对于视角的采用都要着自己的要求，但反过来讲，视角却不一定从属于某种干系人，不同的干系人之间可以共享同样的视角，也只有这样才能保证不同干系人之间的顺畅沟通。正像TOGAF中所举的例子一样，飞机的飞行员和航空管制员对于飞行的视角各具特点，并采用不同的语言和元素来对“飞行”进行描述，但是他们同时也采用一种通用的语言（高度、速度等）来进行沟通。在这个例子中，飞行员和航空管制员在自己的领域内分别采用了自己的视角来对“飞行”进行理解和描述，不过作为沟通用的通用语言却形成了第三个，并且是他们所共享的视角。</p>\n<p>企业架构开发过程的结果可以说是在架构资源库中按照架构元模型定义而填充的各种实体元素，这也方便了在对企业架构的使用中按照各个干系人的视角为其提供相应的视图。针对架构的使用需要自动化工具的支持，该工具需要支持视角的定义和管理，并能够从企业架构资源库中根据选定的视角生成相应的视图。</p>\n<figure><figcaption>img_29.png</figcaption></figure>\n<p>不同的企业架构开发框架对于架构制品、视角和视图的定义，有着不同的描述。例如在Zachman框架中，每一个单元格所代表的是某一种干系人视角针对系统某个方面的描述，而在TOGAF中，The Open Group则采用了一种独特的方式对视角进行了组织和定义。与其他框架理论不同，TOGAF定义了一系列原子架构制品，并倡议在企业架构过程中根据不同干系人的需要对这些原子架构制品进行组合，从而生成对于视角的定义。这些原子架构制品业可被看为原子级的视角定义，实际上在TOGAF中也正是用视角（ViewPoint）这个词来称呼各个架构开发阶段相关的原子架构制品。TOGAF并不强制其用户遵循这些原子架构制品，用户可以根据自己的需要增加新的原子架构制品，或对已经定义的原子架构制品进行修订。根据架构制品的描述形式，TOGAF将这些原子架构制品分为以下三类：</p>\n<ul>\n<li>目录（Catalogs）：此类型的原子架构制品（视角）以列表的形式对各种构建块进行列举。</li>\n<li>矩阵（Matrices）：此类型的原子架构制品（视角）用于展示特定构建块之间的关系。</li>\n<li>图形（Diagrams）：此类型的原子架构制品（视角）采用了一种具有丰富表现力的方式对构建块以及他们之间的关系进行了展示。此种方式特别适合用于在干系人之间进行沟通的场合。</li>\n</ul>\n<h3> 1、架构开发过程与架构制品</h3>\n<p>表面上架构制品并不像架构交付物那样与架构开发方法的各个阶段有着很强的契约性关联，但是做为架构交付物的重要组成部分，架构制品与架构开发方法之间也有着非常紧密的联系。在TOGAF中，针对架构制品的组织和描述也是以架构开发方法各阶段为基础的，它详尽展示了在每个架构开发方法阶段中所产生的各个原子架构制品，以及这些架构制品与架构内容元模型各扩展之间的关系。</p>\n<figure><figcaption>img_30.png</figcaption></figure>\n<h3> 2、架构制品定义</h3>\n<p>原则目录（Principles catalog）</p>\n<p>原则目录对各项业务原则及架构原则进行列举，用以表明一个好的解决方案或架构看起来应该是什么样子。原则用于对各架构决策点的输出进行评估和认可。原则也可在针对变更举措的架构治理中充当辅助工具。</p>\n<p>干系人映射矩阵（Stakeholder Map Matrix）</p>\n<p>干系人映射矩阵用于明确参与架构活动的各个干系人、他们的影响、他们的主要问题，以及架构框架所必须解答的关注点。通过对于干系人的识别，并对他们的需求进行理解，架构师可以将注意力集中在能够满足干系人需求的各个领域之中。</p>\n<p>价值链图（Value Chain Diagram）</p>\n<p>价值链表提供了一张面向高层的企业视图，用于表示企业如何与外界环境交互。与在业务架构阶段中开发出来的更加正式的功能解构图相比较，价值链表更着重于表象上的影响。价值链表的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使得所有参与者能够对架构所涉及到的高层次功能性和组织性环境进行理解。</p>\n<p>解决方案概念图（Solution Concept Diagram）</p>\n<p>解决方案概念图提供了一个解决方案的高层次方向，用于达成架构所涉及的各个目标。与后续架构开发方法阶段开发出来的、更正式且更详细的架构图相比较，解决方案概念图更像是在一开始阶段关于期望解决方案的一张草图。这张图体现了关键的目标、需求和约束，并对将采用正式架构模型来进行更详细描述的各个工作区域进行了标明。解决方案概念图的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使所有的参与者能够理解架构所需要的究竟是什么，以及一个特定的解决方案被期望以何种方式来满足企业的需求。</p>\n<p>组织/执行者目录（Organization/Actor Catalog）</p>\n<p>该目录的目标是得到一份明确的包括用户和IT系统所有者在内的所有与IT有互动的参与者列表。该列表可以在开发需求时作为完备性检测的参考。例如，针对于一个对客户进行服务支持的应用的需求，我们可以通过如下几个方面对其进行完备性检测：</p>\n<ul>\n<li>\n<p>需要对何种类型的客户进行支持。</p>\n</li>\n<li>\n<p>是否某种类型的用户存在特定需求或约束。</p>\n</li>\n<li>\n<p>此目录所涉及到的内容元模型实体包括：</p>\n</li>\n<li>\n<p>组织单位</p>\n</li>\n<li>\n<p>执行者</p>\n</li>\n<li>\n<p>位置（如果一个单独的位置目录并不存在，则关于位置的信息就需要在这个目录中加以维护）</p>\n</li>\n</ul>\n<p>驱动力/目标/阶段目标目录（Driver/Goal/Objective Catalog）</p>\n<p>该目录的目标是描述组织如何通过目标、工作目标和评测（可选内容）来满足其驱动力的需要，并为此提供一份跨越组织的参考。通过针对驱动力、目标和阶段目标的层层分解，各个变更举措可以采用一种跨越组织边界的方式进行协同，并在随后的活动中使得各个干系人得以被明确，此外，相关的变更举措也能够被整合或协调起来。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织单元</li>\n<li>驱动力</li>\n<li>目标</li>\n<li>阶段目标</li>\n<li>评测（可选内容）</li>\n</ul>\n<p>角色目录（Role Catalog）</p>\n<p>角色目录的目标是为企业中所有的授权级别或区域提供一份列表。一般情况下，应用的安全或行为应该按照其对授权概念的理解而分别进行定义，但在与用户的计算机相绑定时却造成了复杂且不被期望的后果。如果角色在整个组织和所有应用中都得到了定义、理解和共识，那么更加安全并能够提供更加无缝的用户体验的应用将会出现，因为管理员无需通过迂回的解决方法来使用户执行他们的工作。除了对企业的安全定义进行支持，角色目录还可以是明确组织变更管理影响、定义工作职能，以及执行最终用户培训这些方面的关键输入。</p>\n<p>由于每个角色都暗含着关于一系列业务功能的访问，如果这些功能被影响到，那么变更管理将必不可少，组织的职责也需要被重新定义，同时新的培训可能也是需要的。</p>\n<p>业务服务/功能目录（Business Service/Function Catalog）</p>\n<p>业务服务功能目录的目标是提供一份功能性的解构，使得各种功能可以被过滤、汇报和查询，并能够作为功能结构图的一个有力补充。服务功能目录可以被用来对组织中的各项能力进行明确，并对组织中施加到各种功能上的治理水平加以理解。通过功能解构，用于支持业务变化所需要的各种新能力能够被识别出来，或者对变更措施、应用以及技术组件的范围进行确定。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织单位</li>\n<li>业务功能</li>\n<li>业务服务</li>\n<li>信息系统服务（可选内容）</li>\n</ul>\n<p>位置目录（Location Catalog）</p>\n<p>位置目录为企业的业务运营或房屋建筑相关的资产（例如数据中心或终端用户计算设备）所处位置提供了一份列表。针对此位置列表的维护，各个变更举措的位置范围得以被快速地定义出来，并且针对当前情况和建议的目标解决方案进行评估时，完备性测试也得以被执行。例如，一个用于更新台式计算机操作系统的项目需要识别出这些系统所部署的位置。与此相似，当实施一个新的系统时，一张关于位置的图形描述对于开发适当的部署策略是非常关键的，该部署策略被用于对用户和应用的位置进行了解，并且各个与位置相关的问题（例如，国际化、本地化、针对可用性的时区影响、延时距离影响、网络带宽影响和访问）也得以被明确。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>位置</li>\n</ul>\n<p>流程/事件/控制/产品目录（Process/Event/Control/Product Catalog）</p>\n<p>流程/事件/控制/产品目录为流程、触发流程的事件、流程的输出和施加到流程执行之上的控制提供了一份层次结构，并可被用来作为流程图（Process Flow diagram）的一个有力的补充，这些流程图使得企业可以进行跨越组织和流程的过滤、汇报和查询操作，从而对其范围、通用性或影响进行明确。例如，流程/事件/控制/产品目录使得企业可以查看流程与各子流程之间的关系，从而明确源自于一个高层流程的变更所能带来的影响链。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>流程</li>\n<li>事件</li>\n<li>控制</li>\n<li>产品</li>\n</ul>\n<p>合同/评测目录（Contract/Measure Catalog）</p>\n<p>此目录提供了一份关于所有经过批准的服务合同以及与此相关的评测的列表，从而形成了在整个企业内获得批准的服务水平的主列表。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>业务服务</li>\n<li>信息系统服务（可选内容）</li>\n<li>合同</li>\n<li>评测</li>\n</ul>\n<p>业务交互矩阵（Business Interaction Matrix）</p>\n<p>此矩阵用于描述企业中各组织与业务功能之间的交互关系。理解企业中的业务交互是很重要的，因为它有助于突出整个组织中的价值链以及相互依赖关系。此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>组织</li>\n<li>业务功能</li>\n<li>业务服务</li>\n<li>业务服务之间的通信关系</li>\n<li>业务服务之间的依赖关系</li>\n</ul>\n<p>执行者/角色矩阵（Actor/Role Matrix）</p>\n<p>此矩阵用于展示哪些执行者扮演何种角色，并支持对安全性和技能需求的定义。理解执行者与角色之间的关系对定义培训需求、用户安全设置和组织变更管理具有关键性作用。此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>执行者</li>\n<li>角色</li>\n<li>执行者与角色之间的担当关系</li>\n</ul>\n<p>务足迹图（Business Footprint Diagram）</p>\n<p>业务足迹图描述了业务目标、组织单元、业务功能和服务之间的关联，并将这些功能映射到各个提供了所需能力的技术组件之上。它在从技术组件到业务目标的映射中提供了清晰的可追溯性，同时还对已经明确的服务的所有权进行了阐述。业务功能图仅对联系组织单元功能与交付服务的关键因素进行描述，并且还可被用来作为与高层次干系人（CIO、CEO等）进行沟通的平台。</p>\n<p>业务服务/信息图（Business Service/Information Diagram）</p>\n<p>业务服务/信息图展示了用于对一个或多个业务服务进行支持的信息，包括了由业务服务使用或者产生的数据及其信息源。服务/信息图对信息在架构中的最初表现形式进行了展现，因此为数据架构阶段的进一步描述打下了基础。</p>\n<p>功能分解图（Functional Decomposition Diagram）</p>\n<p>功能分解图的目标是将组织中与架构相关的各项能力展现在一张图纸之上。通过从功能的视角检视组织的各项能力，企业可以快速针对组织所做的事情进行建模，而不用陷入针对组织如何做所进行的额外讨论之中。</p>\n<p>产品生命周期图（Product Lifecycle Diagram）</p>\n<p>产品生命周期图的目标是对企业中关键实体的理解进行辅助。就关于产品从生产到撤销过程中所必须遵守的环境的关注、立法和规章来说，理解产品生命周期变得越来越重要。与此相同，在为了保证在控制、流程和程序的设计严谨而进行的业务架构开发过程中，创建涉及个人或敏感信息产品的组织必须对产品生命周期具有一个详尽的理解，例如信用卡、借记卡、智能卡以及用户身份认证等信息。</p>\n<p>目标/阶段目标/服务图（Goal/Objective/Ser viceDiagram）</p>\n<p>此图的目标是为服务对业务愿景或策略的达成而定义方法。通过将服务与驱动力、目标、阶段目标和相关的评测进行关联，企业可以了解到哪些服务贡献于相似的业务效能方面。此外，该图还为针对某一特定服务所形成的高效能的认定提供了定性的输入。</p>\n<p>业务用例图（Business Use-Case Diagram）</p>\n<p>业务用例图展示了业务服务的提供者和使用者之间的关系。业务服务被各个执行者或其他的业务服务所使用，而业务用例图则通过针对业务能力在何时以及如何被使用的描述，为业务能力的描述方面提供了额外的价值。此图形的目标是对各执行者和他们在各流程和功能中所担当的角色之间的交互关系进行描述和验证。随着架构过程的演进，这些用例图也将从业务级别发展至包括数据、应用和技术在内的更加详尽的级别。除此之外，业务用例图也可在系统设计工作中得到复用。</p>\n<p>组织分解图（Organization Decomposition Diagram）</p>\n<p>组织分解图描述了执行者、角色以及他们在组织树中所处位置之间的关系。一份组织分解图应提供了一条组织中决策者和业务拥有者的命令链。虽然组织分解图并不打算将组织与其目标联系在一起，但是在这张图中为最终目标与干系人之间建立直观的联系也是可以的。</p>\n<p>流程图（Process Flow Diagram）</p>\n<p>流程图的目标是对流程元模型实体相关的所有模型和映射进行描述，它展示了位于各个活动之间的顺序化控制流，并可借助于泳道技术来表达各个流程步骤的归属和实现。例如，用于支持一个流程步骤的应用就可以作为一条泳道来展示。除此之外，流程图也可以被用来细化赋予在流程之上的控制、触发某流程或产生于流程结束时的事件，以及由于流程执行所产生的各种输出产物。流程图在为主题专家描述架构时非常有用，它可以为这些专家描述一个特定功能的工作是如何被完成的。通过这样一个过程，每个流程步骤可以被细化为更小粒度的功能块，而且这些功能块在以后亦可以被当作一个流程来进行进一步的阐述。</p>\n<p>事件图（Event Diagram）</p>\n<p>事件图的目标是描述事件与流程之间的关系。诸如某些特定信息的到来，或者是某个特定的时间点这样的特定事件会致使业务中特定的工作和行为得以进行，同时也经常会有被称为业务事件（或简称事件）的信息被当作某个流程的触发者。</p>\n<p>数据实体/数据组件目录（Data Entity/Data Component Catalog）</p>\n<p>数据实体/数据组件目录的目标是明确和维护企业中使用的所有数据的列表，包括数据实体，以及用于存储数据实体的数据组件。一个经过批准的数据实体/数据组件目录支持对信息管理和数据治理策略的定义和应用，并且鼓励对数据进行有效地共享和重用。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>数据实体</li>\n<li>逻辑数据组件</li>\n<li>物理数据组件</li>\n</ul>\n<p>数据实体/业务功能矩阵（Data Entity/Business Function Matrix）</p>\n<p>此矩阵用来描述企业中数据实体和业务功能之间的关系。业务功能被具有明显边界的业务服务所支持，并通过业务流程加以实现。通过数据实体与业务功能之间的映射，企业可以得到：</p>\n<ul>\n<li>将数据实体的所有权分配给各个组织。</li>\n<li>理解业务服务的数据和信息交换需求。</li>\n<li>支持差距分析，并决定是否有需要被创建的数据实体被遗漏。</li>\n<li>为数据实体定义源系统、记录系统和引用系统。</li>\n<li>启动企业的数据治理程序的开发（建立数据管家、开发与业务功能相关的数据标准等）。</li>\n</ul>\n<p>此矩阵所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>数据实体</li>\n<li>业务功能</li>\n<li>数据实体与其所属组织单位的“从属”关系</li>\n</ul>\n<p>系统/数据矩阵（System/Data Matrix）</p>\n<p>此矩阵用于描述系统与系统所访问和更新的数据实体之间的关系（一张两维表，其中一个纬度对应逻辑应用组件，而另外一个则对应数据实体）。系统用于创建、读取、更新和删除与他们相关联的特定数据实体。例如，一个客户关系系统将创建、读取、更新和删除客户实体信息。处在一个被封包好的服务环境中的数据实体可以被分为主数据、引用数据、事务数据、内容数据和历史数据，而用于操作这些数据实体的应用则包括事务应用、信息管理应用和业务仓库应用。针对应用组件和数据实体之间映射是一个非常重要的步骤，因为它可以使得：</p>\n<ul>\n<li>针对数据的访问能力被分配给组织中的具体应用。</li>\n<li>了解在不同应用中数据重复的程度，以及数据生命周期的规模。</li>\n<li>了解在何处相同的数据会被不同的应用所更新。</li>\n<li>支持差距分析，并确定是否本应存在的应用被遗漏了。</li>\n</ul>\n<p>类图（Class Diagram）</p>\n<p>类图的主要目标是描述企业中重要数据实体（或类）之间的关系。此图用于清晰地展示数据之间的关系，并帮助干系人理解企业下层数据模型。</p>\n<p>数据传播图（Data Dissemination Diagram）</p>\n<p>数据传播图的目标是展示数据实体、业务服务和应用组件之间关系。此图展示了各个逻辑实体如何被应用组件所实现。它使得针对数据大小的调整得以被有效地执行，同时IT足迹也会得以改善。而且，通过为数据设置业务价值，应用组件的业务重要性的指标也能够在同时被获得。另外，此图还可以展示针对数据复制和主引用的所有权，即它可以展示数据的两个备份以及数据之间的主-备份关系。此图还能够包含服务，比如，封装数据并且驻留在应用之内的服务，或者驻留在应用之上并能够访问封装在应用中的数据的服务。</p>\n<p>上面所说的IT footprint中，footprint，即足迹，的本意是由动物遗留下的包含了遗留者本身标识和信息的事物。在信息技术领域，根据哈佛商学院Andrew McAfee所述，技术足迹表示了其在地理、逻辑分区和/或功能方面所能延展到范围，是针对一个信息技术所期望的覆盖范围的描述（A technology's footprint is its geographic, divisional, and/or functional reach. It's a description of how much territory a piece of IT is intended to cover）。在TOGAF中并没有说明数据大小的调整与IT足迹改善之间的关系，也没有说明所谓的IT足迹改善的具体含义。不过通过互联网上的一个关于IT足迹改善的实例，即将原本有着十几台计算机的教室用一台中心计算机和若干终端来代替，笔者有感而发，粗浅的认为这里IT足迹改善意思是说由于数据尺寸得到了很好的调整，那么不必需的冗余信息被削减，因而数据和应用的“足迹”，即其涉及到的范围，将比冗余剔除前更加清晰有效</p>\n<p>数据安全图（Data Security Diagram）</p>\n<p>数据可以看作是企业的一项资产，简单的讲，数据安全可被认为是确保企业数据不被损害，并且针对数据的访问也要在适当的控制之下。数据安全图的目标是描述何执行者可以访问企业中的哪些数据。此外，此图也可以被用来阐述与数据隐私法规以及其他应用性法规的符合度。此图还需要考虑发生在企业合作伙伴或其他团体对企业系统进行访问之处的信任含义，例如在外包的情形下，信息可能会被企业之外的其他人员（甚至身处国门之外）所管理。</p>\n<p>类层次结构图（Class HierarchyDiagram）</p>\n<p>类层次结构图的目标是为技术方面的干系人展示一个有关类层次的视图。此图的优点是干系人可以得到一份关于数据实体在技术层面上如何被使用的图形描述，它使得干系人可以了解何人正在针对数据进行使用，以及他是在何时、如何以及为何进行这项活动。</p>\n<p>数据迁移图（Data Migration Diagram）</p>\n<p>在实现一个以封包服务为基础的解决方案时，数据迁移是非常重要的，特别是将现存的遗留系统替换为一个服务封包时，或者当企业将要迁移到一个更大的封包服务时。每个服务包都倾向于具有属于他们自己的数据模型，并且在数据迁移过程中，遗留的应用数据可能需要在载入到服务封包之前需要进行某种转化。数据迁移活动通常包含如下的步骤：</p>\n<ul>\n<li>从原有应用中抽取出数据。</li>\n<li>配置源数据</li>\n<li>执行数据转换，其中包括数据质量相关的各个过程：\n<ul>\n<li>对数据进行标准化、归一化，并消除数据的重复性（数据清洗）。</li>\n<li>针对不同来源的数据进行比对、合并和整合。</li>\n<li>进行自源头至目标的映射</li>\n</ul>\n</li>\n<li>将数据加载到目标应用之中。</li>\n</ul>\n<p>数据迁移图的目标是展示数据如何从源头应用流入到目标应用之中。此图为数据从源头到目标过程的进行提供了一个可视化表达，并可在数据审计和追溯中作为辅助工具。此外，此图所展示的细节程度可以按照需要进行调整。例如，数据迁移图可以仅仅包含一个关于迁移情况的整体布置，也可以为单独的应用提供元数据元素级别的详细信息。</p>\n<p>数据生命周期图（Data Lifecycle Diagram）</p>\n<p>数据生命周期图是在业务流程的约束之下对业务数据在其整个生命周期（从概念阶段到最终退出）中对其进行管理的核心部分。数据从本质上讲是一个实体，并独立于业务流程和活动。数据状态的每个变化都被表现在这张图中，这也可以包括引起此状态变化事件或规则。数据与流程的分离使得通用数据需求可以被识别出来，从而使得资源共享得以有效达成。</p>\n<p>应用组合目录（Application Por tfolio Catalog）</p>\n<p>此目录的目标是明确和维护企业中所有应用的列表。一个经过批准的应用组合目录使得一系列应用得以被定义和治理。此目录为后面的矩阵和图形提供了基础，是应用架构开发阶段的起点。现有的应用注册表和资源库（比如SAP的解决方案管理和系统情况目录产品）也从基线和目标两个角度为这个目录的制定提供了输入。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>信息系统服务</li>\n<li>逻辑应用组件</li>\n<li>物理应用组件</li>\n</ul>\n<p>接口目录（Interface Catalog）</p>\n<p>接口目录用来界定应用之间接口的范围，并对这些接口进行文档化记录，从而使得应用间的所有依赖关系得以被尽可地界定。系统可以用来创建、读取、更新和删除其他系统内的数据。无论是通过循环载入的批处理文件、对其他系统数据库的直接连接，还是通过某种形式的应用程序接口或Web服务，这些行为都是通过接口来实现。针对应用组件之间关系的映射是一个非常重要的步骤，它使得如下情形得以实现：</p>\n<ul>\n<li>了解应用间交互程度的，从而可以站在应用与其他系统之间依赖性的角度识别出各个关键的交互。</li>\n<li>了解应用之间接口的数量和类型。</li>\n<li>了解应用之间接口的重复程度。</li>\n<li>在考虑目标应用组合时明确各接口的简化潜力。</li>\n<li>支持差距分析，并确定是存在本应建立的应用被遗漏了。</li>\n</ul>\n<p>此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>逻辑应用组件</li>\n<li>物理应用组件</li>\n<li>应用之间的通信关系</li>\n</ul>\n<p>系统/组织矩阵（System/Organization Matrix）</p>\n<p>此矩阵用于描述企业中系统与组织单元之间的关系。业务功能由组织单元来执行，而一些由组织单元执行的功能和服务也将会被IT系统所支持。应用组件与组织单元之间的映射非常重要，它会使得：</p>\n<ul>\n<li>为执行业务功能的组织单元分配针对应用的使用。</li>\n<li>理解由组织单元所执行的业务服务和流程对应用支持需求。</li>\n<li>支持差距分析，并确定是否有需要被建立的应用被遗漏。</li>\n<li>定义特定组织单元所使用的应用集合</li>\n</ul>\n<p>。<br>\n此矩阵是一张两维表，其中逻辑/物理应用组件在一条坐标轴上，而组织单元在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n<ul>\n<li>组织单位与服务之间的从属关系。</li>\n<li>执行者与组织单位之间的从属关系，以及其与服务之间的使用关系。</li>\n<li>服务与逻辑/物理应用组件之间的实现关系。</li>\n</ul>\n<p>角色/系统矩阵（Role/System Matrix）</p>\n<p>此矩阵用来描述企业中系统与业务角色之间的关系。一个组织中的人们会与各种系统发生交互。在交互过程中，这些用户被假定成为执行一项任务的特定角色，例如，产品购买者。应用组件与角色之间的关系映射非常重要，它使得：</p>\n<ul>\n<li>\n<p>在组织内为特定的角色分配针对应用的使用。</p>\n</li>\n<li>\n<p>理解支持功能的业务服务和流程的应用安全需求，并检查是否与现有策略相符合。</p>\n</li>\n<li>\n<p>支持差距分析，并确定是否有应该被创建的应用被遗漏。</p>\n</li>\n<li>\n<p>定义被特定业务角色所使用的应用集合。<br>\n此矩阵是一个两维表，其中逻辑应用组件在一条坐标轴上，而角色在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n</li>\n<li>\n<p>角色与功能之间的访问关系。</p>\n</li>\n<li>\n<p>功能与服务之间的绑定关系。</p>\n</li>\n<li>\n<p>服务与逻辑/物理应用组件的实现关系。</p>\n</li>\n</ul>\n<p>系统/功能矩阵（System/Function Matrix）</p>\n<p>此矩阵用于阐述企业中系统与业务功能之间的关系。业务功能由组织单元所执行。一些业务功能和服务将会被IT系统所支持。应用组件与功能之间的关系映射是非常重要的，它使得如下方面成为可能：</p>\n<ul>\n<li>\n<p>为业务功能分配针对应用的使用</p>\n</li>\n<li>\n<p>理解业务服务和流程的应用支持需求</p>\n</li>\n<li>\n<p>支持差距分析，并确定是否有需要被创建的应用被遗漏</p>\n</li>\n<li>\n<p>定义被特定业务功能所使用的应用集合<br>\n此矩阵是一张两维表，其中逻辑应用组件位于一条坐标轴上，而功能处在另一条坐标轴之上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>\n</li>\n<li>\n<p>功能与服务之间的绑定关系。</p>\n</li>\n<li>\n<p>服务与逻辑/物理应用组件的实现关系。</p>\n</li>\n</ul>\n<p>应用交互矩阵（Application Interaction Matrix）</p>\n<p>应用交互矩阵的目标是阐述系统之间的沟通关系。在矩阵中展示的应用交互映射与接口目录或者应用通信图示相类似的，只不过以矩阵的形式来展示。此矩阵是一张两维表，其中的每一个维度都包含了应用服务、逻辑应用组件和物理应用组件这些概念。在此矩阵中所描述的关系包括：</p>\n<ul>\n<li>应用服务之间的使用关系。</li>\n<li>逻辑应用组件之间的通信关系。</li>\n<li>物理应用组件的通信关系。</li>\n</ul>\n<p>应用通信图（Application Communication Diagram）</p>\n<p>此图的目标是描述所有与应用之间的沟通相关的模型和映射。应用通信图展示了应用的应用组件和接口，并且接口可以关联数据实体，而应用则可以关联业务服务。此图所表述的“通信”应该是符合逻辑的，并且仅用来展示与架构相关的中介技术。</p>\n<p>应用和用户位置图（Application and User Location Diagram）</p>\n<p>应用和用户位置图展示了应用的地理分布情况。它可以被用来展示：</p>\n<ul>\n<li>被最终用户所使用的各个应用的地点分布</li>\n<li>被执行和/或交付（在客户端情形下）的各个主机应用程序的地点分布情况</li>\n<li>被开发、测试和发布的应用所处位置的分布情况</li>\n</ul>\n<p>此图的目标在于清晰地描述与应用发生交互的业务用户所处的业务位置，而且还包括了应用基础设施的位置。通过此图，我们可以：</p>\n<ul>\n<li>\n<p>识别出足以支持分散在各地的用户群的产品包的数量</p>\n</li>\n<li>\n<p>估算产品或软件的用户许可的类型和数量</p>\n</li>\n<li>\n<p>估算用户的支持等级和支持中心的位置</p>\n</li>\n<li>\n<p>选择系统管理工具、结构，以及用于支持本地或远程的企业用户/客户/合作伙伴的管理系统</p>\n</li>\n<li>\n<p>适当规划业务的技术组件，即服务规模、网络带宽等</p>\n</li>\n<li>\n<p>在实施应用和技术架构解决方案时进行性能方面的考虑<br>\n用户通常会采用多种方式与应用进行交互，例如：</p>\n</li>\n<li>\n<p>支持日常业务的运营。</p>\n</li>\n<li>\n<p>参与业务流程的执行过程。</p>\n</li>\n<li>\n<p>访问信息（查询、读取等）。</p>\n</li>\n<li>\n<p>开发应用。</p>\n</li>\n<li>\n<p>管理、维护应用。</p>\n</li>\n</ul>\n<p>系统用例图（System Use-Case Diagram）</p>\n<p>系统用例图展示了客户与应用服务提供者之间的关系。应用服务被角色或其他应用服务所使用，并且通过描述功能是在何时被如何使用，应用用例图对应用功能的描述提供了更多意义。此图的目标是帮助描述和验证各个参与者与他们对应用所担当的角色之间的交互。随着架构的进展，这些用例能够从功能性信息演进到包含技术实现细节。架构系统用例还可以在更细节的系统设计工作中被复用。</p>\n<p>企业管理能力图（Enterprise Manageability Diagram）</p>\n<p>企业管理能力图展示了一个或多个应用是如何与用以支持一个解决方案的运营管理的应用和技术组件进行交互的。此图实际上是针对应用通信图的一个过滤，特别是针对企业管理类软件方面。基于此图的分析可以揭示组织的IT服务管理操作方面重复、差距和机遇。</p>\n<p>流程/系统实现图（Process/System Realization Diagram）</p>\n<p>流程/系统实现图的目标是清晰地阐述在业务流程执行过程中涉及到多个应用时所产生的事件的顺序。此图可以识别出能够被简化的复杂顺序，以及架构中各种可能的合理化点，从而为业务用户提供更加及时的信息。此外，此图还可被用来明确流程中能够通过减少应用之间的交互流量而进行效率改善的地方。</p>\n<p>软件工程图（Software Engineering Diagram）</p>\n<p>系统工程图从开发的角度将应用分解为包、模块、服务和操作，它使得在各规划迁移阶段和分析机会与解决方案时进行更加详细的影响分析成为可能。在管理复杂开发环境时，系统工程图对应用开发团队和应用管理团队是非常有用的。</p>\n<p>应用迁移图（Application Migration Diagram）</p>\n<p>应用迁移图表明了应用从基线到目标应用组件的迁移过程，它通过精确地展示哪些应用和接口在迁移各阶段中需要被映射，使得针对迁移成本的估算更加准确。应用迁移图确定了临时的应用、集结区域以及用于支持迁移的各项基础设施。</p>\n<p>软件分布图（Software Distribution Diagram）</p>\n<p>软件分布图展示了应用软件在整个组织内的结构和布局，它在系统升级或应用整合项目中是非常有用的。此外，软件分布图还展示了物理应用在整个物理技术领域中是如何分布的，以及这些物理技术的位置。软件分布图对软件是如何被托管的这一问题提供了一份清晰的视图，而且还使得管理操作人员能够了解应用软件在安装成功后是如何被维护的。</p>\n<p>技术标准目录（Technology Standards Catalog）</p>\n<p>技术标准目标记录了企业中被批准的各项技术标准，涵盖了技术、版本、技术生命周期，以及技术的更新周期。根据组织需要，也可能包括地点或者业务的特定领域的标准信息。此目录提供了一个当前或能够被部署的企业标准技术的快照，并有助于在整个企业内搜寻差异。如果当前已经存在了各种技术标准，那么把它们放入到技术组合目录中将会得到一张关于各技术标准符合性的基线视图。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>平台服务</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>技术组合目录（Technology Por tfolio Catalog）</p>\n<p>此目录的目标是识别和维护整个企业中在用技术的列表，包括硬件、技术设施软件，以及应用软件。一个经过批准的技术组合支持技术产品和版本的生命周期管理，而且还形成了技术标准定义的基础。技术组合目录为后续的矩阵和图形描述提供了基础，是技术架构开发阶段的起点。技术注册表和资源库从基线和目标的视角为此目录提供了输入。在此目录中的技术应该按照TOGAF技术参考模型（可以按照需要来对模型进行扩展，从而符合针对正在使用的技术产品的分类）进行分类。此目录所涉及到的内容元模型实体包括：</p>\n<ul>\n<li>平台服务</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>系统/技术矩阵（System/Technology Matrix）</p>\n<p>系统/技术矩阵记录了业务系统与技术平台之间的映射关系。此矩阵应该是一张或多张平台分解图的补充，并应与这些图保持一致。此矩阵展示了：</p>\n<ul>\n<li>逻辑/物理应用组件。</li>\n<li>服务、逻辑技术组件以及物理技术组件。</li>\n<li>物理技术组件与物理应用组件之间的实现关系。</li>\n</ul>\n<p>环境和位置图（Environments and Locations Diagram）</p>\n<p>环境和位置图描述了哪些应用处于哪些位置，并标识出什么技术和/或应用被用在了哪些地方，以及表示出业务用户一般在何处与应用进行交互。此图还展示了不同部署环境的存在和位置，包括非生产环境，例如开发和预生产。</p>\n<p>平台分解图（Platform Decomposition Diagram）</p>\n<p>平台分解图描述了用于支持信息系统架构运行的技术平台。此图涵盖了技术设施平台的所有方面，并提供了一个关于企业技术平台的概览。此图可以通过扩展来将技术平台映射到适当的处于特定功能或流程区域内的应用组件。此图还可以被用来展示规范说明的细节，例如产品版本、CPU数量等，或者只是用来提供技术环境概览的非正式的“过眼图”。</p>\n<p>此图应该清楚的展示企业应用和针对每个应用区域的技术平台，它可以被进一步分解为：</p>\n<ul>\n<li>硬件：</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n<li>软件：</li>\n<li>逻辑技术组件</li>\n<li>物理技术组件</li>\n</ul>\n<p>处理图（Processing Diagram）</p>\n<p>处理图关注于代码/配置的部署单元（针对业务功能、服务或应用组件的分组），以及这些单元是如何被部署到技术平台之上的。处理图表明了：</p>\n<ul>\n<li>\n<p>哪些应用组件需要被组织起来，并形成部署单元。</p>\n</li>\n<li>\n<p>部署单元之间是如何连接和交互的。</p>\n</li>\n<li>\n<p>应用配置和使用模式是如何针对不同的技术组件而产生负载或容量方面需求。<br>\n针对部署单元的组织和分组依赖于对组件的展示、业务逻辑以及数据存储层和服务水平需求这些方面关注点的分离。例如，展示层部署单元是基于如下方面进行分组的：</p>\n</li>\n<li>\n<p>用于提供用户界面或用户访问功能的应用组件。</p>\n</li>\n<li>\n<p>根据位置和用户角色来进行区分的应用组件。<br>\n每个部署单元是由若干子单元所组成的，例如：</p>\n</li>\n<li>\n<p>安装单元：包含可执行的代码或封包配置的部分。</p>\n</li>\n<li>\n<p>执行单元：应用组件以及与其相关的运行时状态。</p>\n</li>\n<li>\n<p>持久化单元：代表应用组件的持久化状态的数据。<br>\n部署单元可以被部署到专用或共享的技术组件之上（工作站、Web服务器、应用服务器或数据库服务器等）。需要注意的是，技术处理对于服务的定义和粒度具有着较大的影响。</p>\n</li>\n</ul>\n<p>网络计算/硬件图（Networked Computing/Hardware Diagram）</p>\n<p>从大型机到客户端-服务器系统的改造开始，以及随后的电子商务和J2EE的出现，大型企业逐步进入到了一个高度网络化的分布式网络计算环境之中。当前，大多数应用都具有一个Web前端，并且就这些应用的部署架构来说，具备三个独立层次的情况还是非常常见的，亦即Web表现层、业务逻辑或应用层，以及一个后台数据存储层。将应用部署到一个共享的通用技术设施环境之中也是一种常见的做法。</p>\n<p>由此可见，将逻辑应用与在开发和生产过程中对应用进行支持的技术组件之间的映射关系记录起来是非常重要的。网络计算/硬件图的目标是展示逻辑应用组件在一个分布式网络计算环境中部署的逻辑视图。此图之所以有用，是因为通过此图我们可以：</p>\n<ul>\n<li>了解应用部署在分布式网络计算环境中的什么地方。</li>\n<li>建立针对这些技术组件的授权、安全和访问。</li>\n<li>了解在问题解决和故障排除中用以支持应用的技术架构。</li>\n<li>对应用所遇到的性能问题进行隔离，确定应用是代码相关的，还是技术平台相关的，并对具体的物理技术组件进行必要的升级。</li>\n<li>当新的技术出现并能够因此带来成本缩减时，确定可通过此技术进行优化的区域。</li>\n<li>使得应用/技术审计成为可能，并证明企业技术标准的符合性程度。</li>\n<li>作为将变更引入到技术架构的用力工具，从而支持有效地变更管理。</li>\n<li>当应用从一个共享环境迁移到一个专门的环境时，建立可追溯性和正在进行变化的应用的终端地址，反之亦然。</li>\n</ul>\n<p>通过适当的定义，网络计算/硬件图的范围可以涵盖某一个特定的应用、业务功能或者是整个企业，而如果选择在企业级别进行开发，那么组织就可以通过一种与应用无关的方式来对网络计算情况进行描述。</p>\n<p>通信工程图（Communications Engineering Diagram）</p>\n<p>通信工程图描述了处在技术架构中的各资产之间的通信方法（收发信息的方法）。此图展示了客户端和服务器组件之间的逻辑连接，并明确了用于对这些逻辑连接进行实现的网络边界和网络基础设施。需要注意的是，此图并不描述参与通信的信息格式或内容，但它可以对通信协议以及容量方面的问题进行阐述。</p>\n<p>项目背景图（Project Context Diagram）</p>\n<p>项目背景图展示了作为过渡路线图一部分而实现的工作包的范围。此图会将工作包与在项目中被增加、删除或影响的组织、功能、服务、流程、应用、数据以及技术连接在一起。此图对于项目组合管理和项目动员来说也是一个有价值的工具。</p>\n<p>效益图（Benefits Diagram）</p>\n<p>效益图展示了在架构定义中识别出来的各种机会，并通过他们的相对规模、效益和复杂度进行分类。此图可被干系人用来对这些识别出来的机会进行选择、对其优先级进行定义，并对他们的顺序进行确定。</p>\n<p>需求目录（Requirements Catalog）</p>\n<p>需求目录包含企业需要用来满足目标要求的种种事物。在架构行为中所产生的需求一般会通过变更措施来实现，并在机会和解决方案阶段中界定其范围。需求还可以被用来作为质量保证的工具，从而保证针对特定架构的使用始终处在其使用范围之内。</p>\n<h3> 3、针对视图的开发</h3>\n<p>如前所述，TOGAF中定义了一系列基本的架构制品来担当原子性视角，不同的组织可以根据自身的需要创建、改造或利用这些原子视角，并根据不同干系人的关注点将这些架构制品组合为适合于他们的视角定义，因而针对视图的开发需要明确其目标干系人、他们的关注点，以及所采用的各种基本架构制品和建模方法。TOGAF中针对多种视图的开发方法进行了建议，包括：</p>\n<ul>\n<li>业务架构视图：此视图是为用户而进行开发的，它从系统用户的角度对系统的功能性方面进行关注。</li>\n<li>企业安全视图：此视图是为系统安全工程师而进行开发的，它从安全的角度对系统如何实现，以及安全如何影响系统特性这些方面进行关注，这其中最重要的是，相关干系人能够了解如何确保系统仅能被具有权限的人员或系统来进行访问，以及如何保护系统不受到非授权地侵扰。</li>\n<li>软件工程视图：创建一个软件密集型系统是非常耗费资源和时间的，因而建立一个能够帮助最小化劳力付出和风险的导则是非常必要的，而这正是软件工程视图的目标。此视图应该是为开发系统的软件工程师而进行开发的。</li>\n<li>系统工程视图：此视图应该是为系统的系统工程人员而进行开发的，并从硬件/软件和网络连接的角度对系统如何被实现进行关注。</li>\n<li>通信工程视图：此视图应该是为系统的通信工程人员而进行开发的，并在通信工程师的角度关注于系统是如何被实现的。</li>\n<li>数据流视图：此视图应该是为系统的数据库工程师而进行开发的。此视图的主要关注点在于了解如何为正确的人员和应用通过适当的接口并在合适的时间提供正确的数据。</li>\n<li>企业管理能力视图：此视图应该是为系统的运营、行政和管理人员而进行开发的。此视图的主要关注点在于了解系统是如何做为一个整体而被管理的，以及系统的所有组件是如何被管理的，这其中关键之处在于管理系统变更，并对预防性维护措施进行预测。</li>\n<li>采购视图：此视图应该是为在架构组件的采购过程中所牵涉的人员而进行开发的。此视图的主要关注点在于了解哪些架构的构建块是需要被采购的，以及与采购行为相关的各种约束。</li>\n</ul>\n<h3> 5、构建块（Building Blocks）</h3>\n<p>架构构建块可以说是企业架构内容的核心，也是企业架构开发方法的最终产物。与此相比，架构交付物所面向的是企业架构开发过程，架构制品则可以看作是企业架构内容的表现形式和使用方式，而唯有构建块则是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些企业各个领域中的可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>\n<p>构建块特性</p>\n<p>在TOGAF中，构建块所共有的特性被定义如下：</p>\n<ul>\n<li>构建块是为了达成整个组织的需要而定义的功能包。</li>\n<li>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</li>\n<li>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</li>\n<li>构建块通常会与其他相互依存的构建块进行互操作。</li>\n</ul>\n<p>除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>\n<ul>\n<li>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</li>\n<li>一个好的构建块可以由其他构建块组合而成。</li>\n<li>一个好的构建块可以是其他构建块的一个组件。</li>\n<li>在理想的情况下，一个构建块应是可重用和可替换的，并具备详尽的描述。</li>\n</ul>\n<p>构建块分类</p>\n<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的，也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者则在实现的层面对能够实现构建块的解决方案进行描述。需要注意的是，由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合，因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>\n<p>①架构构建块（ABBs：Architecture Building Blocks）</p>\n<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>\n</li>\n<li>\n<p>用以指导解决方案架构块的开发。<br>\n架构构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>\n</li>\n<li>\n<p>接口：提供的选择集合。</p>\n</li>\n<li>\n<p>与其他构建块之间的互操作和关系。</p>\n</li>\n<li>\n<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>\n</li>\n<li>\n<p>业务和组织实体之间的映射和策略。</p>\n</li>\n</ul>\n<p>②解决方案构建块（SBBs：SolutionBuilding Blocks）</p>\n<p>解决方案与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>对用于进行功能实现的产品和组件进行定义。</p>\n</li>\n<li>\n<p>对实施进行了定义。</p>\n</li>\n<li>\n<p>满足业务需求。</p>\n</li>\n<li>\n<p>产品或厂商是明确的。<br>\n解决方案构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>具体的功能和属性。</p>\n</li>\n<li>\n<p>接口：具体实现集合。</p>\n</li>\n<li>\n<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>\n</li>\n<li>\n<p>解决方案构建块与IT技术和运用策略之间的映射。</p>\n</li>\n<li>\n<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>\n</li>\n<li>\n<p>性能以及可配置能力。</p>\n</li>\n<li>\n<p>设计驱动力和约束，包括物理架构。</p>\n</li>\n<li>\n<p>解决方案构建块与架构构建块之间的关系。</p>\n</li>\n</ul>\n<p>构建块的使用原则</p>\n<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同，并且组织也应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用，因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>\n<ul>\n<li>\n<p>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</p>\n</li>\n<li>\n<p>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</p>\n</li>\n<li>\n<p>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>\n通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并在之后将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</p>\n</li>\n<li>\n<p>从如下角度对企业中的能力或资产进行分类：</p>\n<ul>\n<li>可重用的构建块，例如遗留项。</li>\n<li>需要被开发的构建块，例如新的应用。</li>\n<li>需要被采购的构建块，例如从市场中可购得的应用。</li>\n</ul>\n</li>\n<li>\n<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>\n</li>\n</ul>\n<p>构建块与架构开发方法</p>\n<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>\n<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，而包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>\n<h2> 五、机构构建块（Building Blocks）</h2>\n<p>架构构建块是企业架构内容的核心，也是企业架构开发方法的最终产物。架构交付物面向的是企业架构开发过程，架构制品则是企业架构内容的表现形式和使用方式，而唯有构建块是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>\n<h3> 1、构建块特性</h3>\n<p>在TOGAF中，构建块所共有的特性被定义如下：</p>\n<ul>\n<li>\n<p>构建块是为了达成整个组织的需要而定义的功能包。</p>\n</li>\n<li>\n<p>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</p>\n</li>\n<li>\n<p>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</p>\n</li>\n<li>\n<p>构建块通常会与其他相互依存的构建块进行互操作。<br>\n除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>\n</li>\n<li>\n<p>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</p>\n</li>\n<li>\n<p>一个好的构建块可以由其他构建块组合而成。</p>\n</li>\n<li>\n<p>一个好的构建块可以是其他构建块的一个组件。</p>\n</li>\n<li>\n<p>一个构建块应是可重用和可替换的，并具备详尽的描述。</p>\n</li>\n</ul>\n<h3> 2、构建块分类</h3>\n<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的。也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者在实现层面对能够实现构建块的解决方案进行描述。由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合。因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>\n<p>架构构建块（ABBs：Architecture Building Blocks）</p>\n<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>\n</li>\n<li>\n<p>用以指导解决方案架构块的开发。<br>\n架构构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>\n</li>\n<li>\n<p>接口：提供的选择集合。</p>\n</li>\n<li>\n<p>与其他构建块之间的互操作和关系。</p>\n</li>\n<li>\n<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>\n</li>\n<li>\n<p>业务和组织实体之间的映射和策略。</p>\n</li>\n</ul>\n<p>解决方案构建块（SBBs：SolutionBuilding Blocks）</p>\n<p>与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>\n<ul>\n<li>\n<p>对用于进行功能实现的产品和组件进行定义。</p>\n</li>\n<li>\n<p>对实施进行了定义。</p>\n</li>\n<li>\n<p>满足业务需求。</p>\n</li>\n<li>\n<p>产品或厂商是明确的。<br>\n解决方案构建块的内容至少应包括：</p>\n</li>\n<li>\n<p>具体的功能和属性。</p>\n</li>\n<li>\n<p>接口：具体实现集合。</p>\n</li>\n<li>\n<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>\n</li>\n<li>\n<p>解决方案构建块与IT技术和运用策略之间的映射。</p>\n</li>\n<li>\n<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>\n</li>\n<li>\n<p>性能以及可配置能力。</p>\n</li>\n<li>\n<p>设计驱动力和约束，包括物理架构。</p>\n</li>\n<li>\n<p>解决方案构建块与架构构建块之间的关系。</p>\n</li>\n</ul>\n<h3> 3、构建块的使用原则</h3>\n<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同。组织应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用。因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>\n<ul>\n<li>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</li>\n<li>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</li>\n<li>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>\n通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</li>\n</ul>\n<p>从如下角度对企业中的能力或资产进行分类：</p>\n<ul>\n<li>可重用的构建块，例如遗留项。</li>\n<li>需要被开发的构建块，例如新的应用。</li>\n<li>需要被采购的构建块，例如从市场中可购得的应用。</li>\n</ul>\n<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>\n<h3> 4、构建块与架构开发方法</h3>\n<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>\n<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>\n<figure><figcaption>img_31.png</figcaption></figure>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "设计时可使用的工具",
      "url": "https://ujava.cn/synthesis/tool.html",
      "id": "https://ujava.cn/synthesis/tool.html",
      "summary": "简介 JUnit test JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。 EclEmma EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。 Checkstyle",
      "content_html": "<h2> 简介</h2>\n<h2> JUnit test</h2>\n<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>\n<h2> EclEmma</h2>\n<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>\n<h2> Checkstyle</h2>\n<p>Checkstyle是一个静态代码分析工具，用于帮助开发团队遵循一致的编码规范。它可以检查代码中的格式错误、命名约定、代码风格和其他潜在的问题，并生成相应的报告。通过使用Checkstyle，团队可以提高代码质量、可读性和可维护性。</p>\n<h2> SpotBugs</h2>\n<p>SpotBugs是一个静态代码分析工具，用于检测Java程序中的潜在缺陷和错误。它可以发现常见的编程错误、空指针引用、资源泄漏、线程安全问题等。SpotBugs提供了详细的报告和建议，帮助开发人员改进代码质量和可靠性。</p>\n<h2> VisualVM</h2>\n<p>VisualVM是一个功能强大的Java虚拟机（JVM）监视和性能分析工具。它可以显示应用程序的内存使用情况、线程活动、垃圾收集行为等，并提供实时的性能监控和分析。VisualVM还支持插件和扩展，可以与其他工具集成以提供更丰富的功能。</p>\n<h2> Git</h2>\n<p>版本控制系统，用于管理和跟踪源代码的变更。可以查看历史提交记录、分支、合并代码等。</p>\n<h2> Eclipse Memory Analyzer</h2>\n<p>Eclipse Memory Analyzer (MAT) 是一个用于分析 Java<br>\n应用程序的内存使用情况的工具。它可以通过分析堆转储文件（例如通过jmap生成的文件）来查找内存泄漏、大对象、过多的对象等问题，而无需执行正在开发的软件代码。MAT提供了强大的内存分析功能，可以帮助开发人员定位和解决内存相关的问题。</p>\n<h2> JMap</h2>\n<p>jmap是Java虚拟机（JVM）的一个诊断工具，它可以生成Java堆转储文件，其中包含了Java应用程序在运行时的内存使用情况。通过使用jmap生成堆转储文件，可以将其提供给Eclipse<br>\nMemory Analyzer（MAT）等工具进行进一步的分析，而无需执行正在开发的软件代码。</p>\n<h2> Jenkins</h2>\n<p>jenkins：一个开源的持续集成和交付工具，可自动构建、测试和部署软件项目。它可以设置为监控代码库的变更，并在发生变更时触发自动构建和测试过程。</p>\n<h2> 自动化测试架构</h2>\n<h4> TestNG + Mocktio</h4>\n<p>JUnit是Java单元测试的一站式解决方案，它把测试驱动的开发思想介绍给了Java开发人员，并教会他们如何有效地编写单元测试。但是在过去的几年中，JUnit的改进并不大，所以为当前复杂的环境编写测试任务已经变得越来越困难，即JUnit必须与其他一些补充性测试框架集成起来。TestNG是一个测试Java应用程序的新框架，功能十分强大。</p>\n<p>EasyMock和Mockito可以极大地简化单元测试的编写过程，因而被许多程序员应用在日常工作中。这两个工具无法实现对静态函数、构造函数、私有函数、Final函数和系统函数的模拟，而这些函数在大型系统中必不可少。</p>\n<h4> JUnit + JMock</h4>\n<p>单元测试一般只测试某一个功能，但是由于类之间的耦合，往往难以把功能隔离开来。例如，想要测试某个业务逻辑处理数据的功能，但是数据是从Database取回的，这就涉及DAO层的类调用。但是很多时候，你不想让单元测试函数去访问数据库（，而是希望有一个假的DAO类刚好可以返回你需要的测试数据。此时即可使用Mock，它的作用是在单元测试里模拟类的行为和状态。</p>\n<p>JMock与Mocktio都是提供Mock功能的框架。</p>\n<h2> 自动化持续集成部署架构</h2>\n<h4> Git/SVN + Jenkins</h4>\n<p>Git和SVN都是版本控制器。Git是分布式管理的版本控制器，通常被用于分布式模式，也就是说，每个开发人员从中心版本库或服务器上检出代码后都会在自己的机器上克隆一个与中心版本库一模一样的本地版本库。而SVN是集中式管理的版本控制器。</p>\n<p>Jenkins是一个开源的、提供友好操作界面的持续集成工具，主要用于持续、自动地构建或测试软件项目、监控外部任务的运行。Jenkins是用Java语言编写的，既可以在Tomcat等流行的Servlet容器中运行，也可以独立运行。Jenkins通常与版本管理工具（SCM）和构建工具结合使用。</p>\n<p>常用的版本控制工具有SVN和Git等，常用的构建工具有Maven、Ant和Gradle等。</p>\n<p>Jenkins涉及持续集成（Continuous Integration，CI）和持续交付（Continuous Delivery，CD）。持续集成强调开发人员在提交新代码之后，立刻进行构建和（单元）测试。根据测试结果，确定新代码和原有代码能否正确地集成在一起。持续交付是在持续集成的基础上，将集成后的代码部署到类生产环境中。</p>\n<p>Jenkins可以把FTP、SVN或Git中存储的Java程序持续构建到生产与测试环境中。也就是说，在微服务分布式环境下，不需要每次更新都在各个服务器上上传代码。一个项目的服务器越多，Jenkins的优势越明显。与Jenkins类似的软件有Travis CI等，不再赘述。</p>\n<h4> Puppet</h4>\n<p>Puppet是Linux、UNIX和Windows操作系统的自动管理引擎，它根据集中式规范执行管理任务（例如，添加用户、安装软件包和更新服务器配置等）。Puppet的简单陈述规范语言的能力提供了强大的代理服务，制定了主机之间的相似之处，同时使它们能够提供尽可能具体的、必要的管理内容，它依赖的先决条件和对象之间的关系清楚且明确。</p>\n<p>Puppet主要解决的是环境部署的难点，例如，需要给50台服务器安装JDK，或者给10台服务器的MongoDB升级版本。如果在升级过程中出现意外的Bug和错误，此时就可以通过Puppet编写相关配置文件，一键安装到所有服务器上。与Puppet类似的软件有Homebrew等。</p>\n<h2> 高并发架构</h2>\n<h4> FreeMaker/Thymeleaf + FastDFS</h4>\n<p>页面静态化指将部分前端需要经常请求的内容，通过页面静态化引擎转换成独立的HTML页面进行缓存。也就是说，不再需要请求后端代码，即可直接返回独立的HTML页面，减轻后端的压力。例如，在某小说网站中如果对某本热门小说的每一章内容都去请求后端，则服务器和数据库的压力会过大，通过页面静态化技术，可以把该热门小说的每一章内容都制作成独立的HTML页面，当返回该页面时，服务器承受的压力几乎可以忽略不计。除小说网站外，门户网站、新闻网站、博客网站和视频网站都可以通过这样的技术进行架构。</p>\n<p>FreeMaker/Thymeleaf + FastDFS是一种页面静态化+文件管理系统的高并发架构，多用于视频、电商、小说等网站。这里的FastDFS也可以换成其他软件，其目的是减少对数据库的读取，将静态化页面存储在某存储引擎或文件管理系统中。</p>\n<p>传统SSM项目架构在上传静态文件时通常上传至SSM项目服务器的本地，无法针对存储进行加卷之类的扩展性操作，因而FastDFS应运而生。FastDFS是专门为了管理静态文件制作的独立运行的应用程序，静态文件可能包含图片、GIF、TXT等。</p>\n<p>在Spring Boot + FastDFS + Thymeleaf架构中，FastDFS主要负责保存Thymeleaf生成的静态文件，并提供给Spring Boot进行读写操作。这是一种很常见的以空间换时间的架构模式。当文件管理系统中的数据量过大时，可以进行定时删除操作，极大地减少对MySQL的访问量。</p>\n<p>当然，电商网站用Elasticsearch引擎或MongoDB缓存的也非常多，方便在读取页面时返回不同的数据，减少对MySQL数据库的访问量。页面静态化+文件管理系统的架构更加细致，返回速度更快，压力更小。</p>\n<p>下面用一个简单的例子介绍Spring Boot + FastDFS + Thymeleaf架构的业务流程。假设前端需要请求一页新闻，首先，请求Redis查看缓存中是否包含Thymeleaf生成的静态页面标识。若没有，则通过MySQL请求静态页面标识。其次，在拿到静态页面标识后，即可通过FastDFS请求到HTML静态页面，并直接将其返回给前端进行处理。另外，管理员或定时任务可以定时修改FastDFS中的新闻（相当于更新FastDFS中的缓存）。</p>\n<p>如果不使用该架构，仍假设前端需要请求一页一万字的新闻，则先在Redis中查询是否包含这一万字的新闻。若没有，再在MySQL中查询一万字的String字符串，转化速度极慢。这种架构相当于将大量的字符都缓存了起来 ， 减 少 了 后 端 的 压 力 。 但 是 将 N 篇 一 万 字 的 新 闻 都 缓 存 在 Redis 或Elasticsearch中并不是好的选择。</p>\n<h4> Spring Boot +Netty+ gRpc + Protobuf</h4>\n<p>Spring Boot + Netty + gRPC +Protobuf是一种多语言多协议的集成架构，多用于金融、医疗等网站。</p>\n<p>Protobuf是一个与平台和语言无关，可扩展且轻便高效的序列化数据结构协议，可用于网络通信和数据存储。Protobuf像XML和JSON一样，可以让由不同语言编写并在不同平台上运行的应用程序交换数据。例如，用Go语言编写的发送程序可以在Protobuf中对用Go语言编写的销售订单数据进行编码，然后用Java语言编写的接收方对它进行解码，以获取所接收订单数据的Java表示方式。Protobuf传输的是二进制数据。Protobuf和其他编码系统对结构化数据进行序列化和反序列化。</p>\n<p>远程过程调用（Remote Procedure Call，RPC）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，而且遵从C/S模型。在使用时，客户端调用服务器端提供的接口就像调用本地的函数一样。</p>\n<p>gRPC是Google公司针对远程过程调用提供的一种实现框架，通过gRPC框架配合ProtoBuf序列化传输协议，可以使数据如同本地调用一样轻松跨语言传输。例如，对于一些特定内容，若C++性能比Java性能更加优秀，则可以使用C++代码编写，之后再通过gRPC+ Protobuf架构让Java代码直接调用。</p>\n<h4> Spring Batch + Quartz + Kettle</h4>\n<p>Spring Batch是Spring全家桶的一个组件，是一个批处理应用框架。它不是调度框架，但需要和调度框架合作来构建并完成批处理任务。它只关注批处理任务相关的问题，如事务、并发、监控、执行等，并不提供相应的调度功能。如果需要使用调度框架，则可以使用Quartz、Tivoli、Control-M、Cron等企业级调度框架。Spring Batch擅长数据迁移、数据同步、数据批处理等工作。</p>\n<p>Quartz是OpenSymphony开源组织在Job Scheduling领域的又一个开源项目，它既可以与J2EE和J2SE应用程序相结合，也可以单独使用。Quartz可以用来创建简单的或者可以运行上万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p>\n<p>Spring Batch + Quartz通常与Kettle、MySQL一起使用。Kettle是一款国外开源的ETL（Extract-Transform-Load）数据仓库技术工具，可以在Window、Linux、UNIX操作系统上运行，数据抽取高效稳定。Spring Batch +Quartz可将多个数据源的数据统一置入数据仓库中，由数据仓库导出各种所需要的数据。例如，原本的数据为用户表、购物车表和商品表，经数据仓库处理之后，可直接返回所需要的数据格式，而非多个表或多个值。除此之外，Kettle包含界面化导出Excel的功能，可以由非技术类人员导出相关数据。</p>\n<h2> 响应式编程架构</h2>\n<p>响应式编程（Reactive Programming）是一种面向数据流和变化传播的范式，可以在编程语言中很方便地表达静态或动态的数据流，相关的计算模型会自动将变化的值通过数据流进行传播。例如，c=a+b表示将a+b表达式的结果赋给c。在传统编程中，改变a或b的值不会影响c；但在响应式编程中，c的值会随着a或b值的变化而变化。</p>\n<p>Reactor是一个基于JVM之上的异步应用框架。为Java、Groovy和其他JVM语言提供构建基于事件和数据驱动应用的抽象库。Reactor的性能相当高，在最新的硬件平台上，使用无堵塞分发器每秒可以处理1500万个事件。</p>\n<p>Reactor框架是Spring之前的项目，实现了Reactive Programming思想，符合Reactive Streams规范。。Spring WebFlux是在Ractor框架基础上实现的响应式Web框架，完全无阻塞，支持Reactive Streams背压，并且可以在Netty、Undertow和Servlet 3.1+等服务器上运行。</p>\n<p>Spring WebFlux的功能较多，下面通过代码展示部分功能：<br>\n<br>\n</p>\n<p>此时分别调用controller1接口与controller2接口，后台日志输出如下所示：<br>\n</p>\n<h2> 负载均衡架构</h2>\n<p>负载均衡的含义是通过多台服务器共同承载压力。例如，一个HTTP请求通过Nginx中间件转发给多台Tomcat的架构形式即为负载均衡架构。</p>\n<p>负载均衡架构有多种表现形式，如下所示：</p>\n<ul>\n<li>服务器端静态反向代理负载均衡架构：Keepalived + Nginx + Java。该架构被负载的实际地址是在配置文件中直接编写的IP地址与端口。该架构形式无法在正在运行的过程中进行修改。</li>\n<li>服务器端动态反向代理负载均衡架构：Nginx + UpSync + Consul +Java。该架构被负载的实际地址是通过Consul注册中心记录的。Nginx会通过UpSync插件获得到实际地址并进行负载均衡。该架构形式可以在系统正常运行时更新Java程序的节点。</li>\n<li>客 户 端 负 载 均 衡 架 构 Spring Cloud + Consul + Spring BootRibbon。在该架构中，当Java1程序请求Java2程序时，Java1程序会通过Consul获取Java2程序的节点信息，若Java2程序在Consul中注册了N个节点，则Java1程序在获得所有Java2程序的节点信息之后，会通过算法请求Java2程序的其中一个节点，即以客户端请求直接进行分发的方式达到负载均衡的目的</li>\n<li>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，以便将客户端的访问引导到不同的服务器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。这种负载均衡技术通常由云服务商提供。与DNS负载均衡类似的是CDN负载均衡，不再赘述。</li>\n<li>硬件负载均衡技术：通常由硬件直接进行数据与请求分发，达到负载均衡的结果。市场上常见的硬件有NetScaler和Radware等。</li>\n<li>协议性负载均衡架构。例如，通过HTTP协议的重定向功能进行负载均衡，或通过自研协议进行负载均衡。</li>\n<li>混合型负载均衡架构。使用多种负载均衡架构的混合架构，不同的应用程序可以采用不同的负载均衡架构。</li>\n</ul>\n<h2> 监控工具与监控架构</h2>\n<h4> 性能监控设计</h4>\n<p>性能监控通常指监控Linux服务器的CPU、内存、I/O、硬盘、应用程序接口耗时等，常见的性能监控架构如下所示：</p>\n<ul>\n<li>Telegraf + InfluxDB + Chronograf + Kapacitor架构。</li>\n<li>Prometheus + Grafana架构。</li>\n<li>Elasticsearch + Logstash + Kibana + Filebeat架构。</li>\n<li>Zabbix + Grafana架构。<br>\n在Telegraf + InfluxDB + Chronograf + Kapacitor架构（简称TICK架构）中，InfluxDB为时序数据库，负责数据存储；Telegraf为独立运行的采集软件，负责数据采集；Chronograf负责数据可视化；Kapacitor负责告警、预警。Telegraf从Linux系统或相关文件中获取数据，通过HTTP接口传到InfluxDB数据库中，Chronograf会定时从InfluxDB数据库中获取相关数据并进行展示。</li>\n</ul>\n<p>TICK架构可转换成Telegraf + InfluxDB + Grafana架构（简称TIG架构），其中，Grafana提供数据可视化与报警、预警功能。TICK架构也可转换成Prometheus + Grafana架构（简称PG架构），即由Prometheus负责数据的采集与存储。</p>\n<p>在 Elasticsearch + Logstash + Kibana 架 构 （ 简 称 ELK 架 构 ） 中 ，Logstash负责数据的采集，Elasticsearch负责数据的存储，Kibana负责数据的展示。当Logstash在大型项目中采集能力不足时，偶尔会增加Filebeat来采集数据，之后通过Logstash管道传输给Elasticsearch。</p>\n<p>ELK架构与TICK架构、TIG架构和PG架构的相似之处在于各个角色的划分几乎相同，并且都可以采集CPU、内存等信息，与TICK架构、TIG架构和PG架构相比，ELK架构更着重于采集不同类型的数据，具有更丰富的生态，不过在构建一些监控图表时，较为费时费力。TICK架构、TIG架构和PG架构的监控图表更加美观，搭建与报警也更加简便，所以业内通常采用TICK架构和TIG架构作为性能监控设计，采集CPU、内存、硬盘等相关信息；采用ELK架构作为业务监控设计，采集程序日志、Nginx日志、接口请求等相关信息。采用TICK架构、TIG架构作为性能监控设计主要。采用PG架构采集MySQL相关的信息。</p>\n<p>Zabbix与上面的软件都不同，它是一套自我完善的监控软件，也就是说，只使用Zabbix，也可以完成对CPU、内存等相关信息的监控。Zabbix是一个基于Web界面的提供分布式系统监视和网络监视功能的企业级的开源解决方案。Zabbix能控各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制，以便让系统管理员快速定位并解决存在的问题。</p>\n<p>Zabbix由两部分组成，zabbix server与可选组件zabbix agent。zabbixserver可以通过SNMP、zabbix agent、ping、端口监视等实现对远程服务器或网络状态的监控、数据收集等功能，它可以运行在Linux、Solaris、OS X等平台上。</p>\n<p>Zabbix自带图表功能，但图表并不美观，所以通常结合Grafana使用。</p>\n<h2> 全链路监控</h2>\n<p>Pinpoint是一款全链路分析工具，提供了无侵入式的调用链监控和方法执行详情查看、应用状态信息监控等功能，与另一款开源的全链路分析工具Zipkin类似。与Zipkin相比，Pinpoint提供了无侵入式等特性，支持的功能较为丰富，可以帮助分析系统的总体结构，以及分布式应用程序组件之间是如何进行数据互联的。</p>\n<p>服务拓扑图：对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的详细信息，比如当前节点状态、请求数量等</p>\n<p>实时活跃线程图：监控应用内活跃线程的执行情况，可以直观地了解应用的线程执行性能。请求响应散点图：以时间维度进行请求计数和响应时间的展示，通过拖动图表可以选择对应的请求，查看执行的详细情况。</p>\n<p>请求调用栈查看：对分布式环境中的每个请求都提供了代码维度的可见性，可以在页面中查看请求针对代码维度的执行详情，帮助查找请求的瓶颈和故障原因。</p>\n<p>应用状态、机器状态检查：查看相关应用程序的其他详细信息，比如CPU的使用情况、内存状态、垃圾收集状态、TPS和JVM信息等参数。</p>\n<p>与Pinpoint类似的还有Zorka和Scouter等。</p>\n",
      "date_published": "2024-04-15T03:42:50.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "组件Web",
      "url": "https://ujava.cn/assembly/container.html",
      "id": "https://ujava.cn/assembly/container.html",
      "summary": "简介 应用服务器：tomcat 常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。 在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。 glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5 平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations 1.0、StAX 1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。",
      "content_html": "<h2> 简介</h2>\n<p>应用服务器：tomcat</p>\n<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>\n<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>\n<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>\n<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5 平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations 1.0、StAX 1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>\n<h2> webSphere</h2>\n<p>WebSphere是 IBM 的集成软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web<br>\n应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的集成软件。</p>\n<h2> JBoss</h2>\n<p>JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3.0的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。2006年,Jboss公司被Redhat公司收购。</p>\n<h2> Tomcat</h2>\n<p>Tomcat是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5 支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>\n<p>JBoss与Tomcat的是完全开源的WebLogic与WebSphere都是对业内多种标准的全面支持，包括EJB、JSB、JMS、JDBC、XML和WML，使Web应用系统的实施更为简单，并且保护了投资，同时也使基于标准的解决方案的开发更加简便。</p>\n<h4> 扩展性的不同：</h4>\n<p>WebLogic和WebSphere都是以其高扩展的架构体系闻名于业内，包括客户机连接的共享、资源 pooling以及动态网页和EJB组件群集。</p>\n<h4> 应用范围的区别：</h4>\n<p>Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>\n<p>WebLogic和WebSphere是商业软件，功能齐全强大，主要应用于大型企业的大型项目。</p>\n<p>JBOSS 主要应用于EJB服务的中小型公司。</p>\n<h4> JBoss还具有如下六大优点：</h4>\n<p>1、JBoss是免费的，开放源代码J2EE的实现，它通过LGPL许可证进行发布。</p>\n<p>2、JBoss需要的内存和硬盘空间比较小。</p>\n<p>3、安装非常简单。先解压缩JBoss打包文件再配置一些环境变量就可以了。</p>\n<p>4、JBoss能够\"热部署\"，部署BEAN只是简单拷贝BEAN的JAR文件到部署路径下就可以了。如果没有加载就加载它；如果已经加载了就卸载掉，然后LOAD这个新的。</p>\n<p>5、JBoss与Web服务器在同一个Java虚拟机中运行，Servlet调用EJB不经过网络，从而大大提高运行效率，提升安全性能。</p>\n<p>6、用户可以直接实施J2EE-EAR，而不是以前分别实施EJB-JAR和Web-WAR，非常方便。</p>\n<p>JBoss的安装和配置可以直接拷贝使用，但是要改动 %JBoss-HOME%\\bin\\run.bat里JAVA-HOME的设置，改成本机JDK的目录。运行run.bat来启动JBoss</p>\n<h2> Weblogic</h2>\n<p>WebLogic是美国bea公司出品的一个application server确切的说是一个基于j2ee架构的中间件，webserver是用来构建网站的必要软件用来解析发布网页等功能，它是用纯java开发的。weblogic本来不是由bea发明的，是它从别人手中买过来，然后再加工扩展。目前weblogic在世界application server市场上占有最大的份额，其他还有象IBM的websphere，免费的tomcat、resin等中间件。</p>\n<p>BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>\n<p>BEA WebLogic Server拥有处理关键Web应用系统问题所需的性能 、可扩展性和高可用性。与BEA WebLogic Commerce ServerTM配合使用， BEA WebLogic Server可为部署适应性个性化电子商务应用系统提供完善的解决方案。</p>\n<p>BEA WebLogic Server具有开发和部署关键任务电子商务Web应用系统 所需的多种特色和优势</p>\n<p>WebLogic: WebLogic是一套基于JAVA功能强大的电子商务套件，提供了许多功能强大的中间件以方便编程人员编写的JSP、SERVLET等电子商务应用，可以为企业提供一个完整的商务应用解决方案。不适合开发阶段，太慢了，适合于运行环境（收费）。</p>\n",
      "date_published": "2024-04-15T03:37:02.000Z",
      "date_modified": "2024-04-27T14:03:48.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "组件Serverless",
      "url": "https://ujava.cn/assembly/serverless.html",
      "id": "https://ujava.cn/assembly/serverless.html",
      "summary": "1 什么是severless ? Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。 img_58.png 纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。 那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。 简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。 进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。 就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。",
      "content_html": "<h2> 1 什么是severless ?</h2>\n<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>\n<figure><figcaption>img_58.png</figcaption></figure>\n<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>\n<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>\n<ul>\n<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>\n<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>\n就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>\n</ul>\n<h2> 2 有服务到无服务构架有哪些变化？</h2>\n<ul>\n<li>弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>\n<li>代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>\n<li>按使用量计费。Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。<br>\n云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</li>\n</ul>\n<h2> 3 serverless发展历史</h2>\n<p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>\n<ul>\n<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。</li>\n<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>\n<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a href=\"http://iron.io\" target=\"_blank\" rel=\"noopener noreferrer\">iron.io</a>。</li>\n<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>\n</ul>\n<h2> 4 severless 分类</h2>\n<p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。</p>\n<ul>\n<li>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</li>\n<li>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</li>\n</ul>\n<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>\n<h2> 5 severles优缺点</h2>\n<h3> 优点</h3>\n<ul>\n<li>降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</li>\n<li>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</li>\n<li>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</li>\n<li>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</li>\n<li>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</li>\n<li>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是多快好省。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</li>\n<li>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</li>\n<li>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</li>\n<li>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</li>\n<li>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</li>\n<li>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</li>\n</ul>\n<h3> 缺点</h3>\n<ul>\n<li>状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>\n<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>\n<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>\n</ul>\n<h2> 6 serverless使用场景</h2>\n<p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。</p>\n<ul>\n<li>\n<p>异步的并发，组件可独立部署和扩展</p>\n</li>\n<li>\n<p>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</p>\n</li>\n<li>\n<p>短暂、无状态的应用，对冷启动时间不敏感</p>\n</li>\n<li>\n<p>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）<br>\nServerless 的使用场景示例如：</p>\n</li>\n<li>\n<p>ETL</p>\n</li>\n<li>\n<p>机器学习及 AI 模型处理</p>\n</li>\n<li>\n<p>图片处理</p>\n</li>\n<li>\n<p>IoT 传感器数据分析</p>\n</li>\n<li>\n<p>流处理</p>\n</li>\n<li>\n<p>聊天机器人<br>\n示例：</p>\n</li>\n</ul>\n<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>\n<p>一款移动端游戏至少包含如下几个特性：</p>\n<ul>\n<li>移动端友好的用户体验</li>\n<li>用户管理和权限认证</li>\n<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息<br>\n传统的应用程序架构可能是这样的：</li>\n</ul>\n<figure><figcaption>img_59.png</figcaption></figure>\n<ul>\n<li>一个 app 前端，iOS 或者安卓</li>\n<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>\n<li>使用关系型数据库存储用户数据，如 MySQL<br>\n这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</li>\n</ul>\n<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>\n<figure><figcaption>img_60.png</figcaption></figure>\n<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>\n<h2> 7 serverless核心技术</h2>\n<p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>\n<ul>\n<li>函数的规范定义</li>\n<li>函数部署流水线</li>\n<li>Workflow 设置</li>\n<li>0-m-n 扩缩容</li>\n<li>快速冷启动</li>\n</ul>\n<h2> 总结</h2>\n<p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>\n",
      "date_published": "2024-04-15T03:37:02.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计高频"
      ]
    },
    {
      "title": "架构分类",
      "url": "https://ujava.cn/attention/attention1.html",
      "id": "https://ujava.cn/attention/attention1.html",
      "summary": "架构的本质 其实总结下来就一句话：架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。 分为三部分： 整体：部分的组成，强调合力。 规则：强调部分之前有关联关系，有规则，有约束。 通信：强调部分之间有往来，有交互。 img_18.png 架构的分类 实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。",
      "content_html": "<h2> 架构的本质</h2>\n<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>\n<p>分为三部分：</p>\n<ul>\n<li>整体：部分的组成，强调合力。</li>\n<li>规则：强调部分之前有关联关系，有规则，有约束。</li>\n<li>通信：强调部分之间有往来，有交互。</li>\n</ul>\n<figure><figcaption>img_18.png</figcaption></figure>\n<h2> 架构的分类</h2>\n<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>\n<h2> 业务架构</h2>\n<p>业务架构是指企业或机构的业务逻辑、流程、组织结构等方面的设计。它着重于企业业务运营的需求和目标，将业务需求转化为技术解决方案。业务架构的设计需要考虑企业的战略规划、组织结构、业务流程、客户需求等多个方面。</p>\n<p>例如：一个银行的业务架构设计需要考虑银行的基本业务逻辑、流程和组织结构，如存款、贷款、投资、支付等，以及银行的安全性、可靠性和效率等方面的需求。</p>\n<h2> 应用架构</h2>\n<p>应用架构是指企业或机构的信息系统中的应用程序、系统、服务等方面的设计。它着重于解决企业业务运营中的具体问题，将业务需求转化为具体的应用程序。应用架构的设计需要考虑企业的业务需求、用户体验、系统性能、安全风险等多个方面。</p>\n<p>例如：一个电商网站的应用架构设计需要考虑用户购物、订单管理、库存管理、支付等多个应用程序的设计，以及这些应用程序之间的交互和集成。</p>\n<h2> 技术架构</h2>\n<p>技术架构是指企业或机构的信息系统中的技术实现、系统架构、软件设计等方面的设计。它着重于解决企业业务运营中的技术问题，如系统的稳定性、可扩展性、可维护性等。</p>\n<p>例如：一个电商网站的技术架构设计需要考虑系统的负载均衡、容错容灾、CDN缓存、自动化部署等多个方面的技术实现。</p>\n<h2> 数据架构</h2>\n<p>数据架构是指企业或机构的信息系统中的数据存储、数据处理、数据安全等方面的设计。它着重于解决企业业务运营中的数据问题，如数据的一致性、完整性、安全性等。</p>\n<p>例如：一个电商网站的数据架构设计需要考虑数据的分层存储、数据备份和恢复、数据加密和权限管理等多个方面的设计，以确保数据的安全和可靠性。</p>\n<h2> 架构设计要考虑的因素</h2>\n<p>架构设计过程中我们要考虑的因素，整体可以分为两大类，一类是功能性因素，一类是非功能性因素。</p>\n<h2> 功能性因素</h2>\n<p>无论什么架构设计，我们首先是要考虑必须满足我们的业务需求，否则我们的设计都是空中楼阁。功能需求会直接决定我们的业务架构设计。所以我们的架构必须完整性地，正确地对业务实现支撑。</p>\n<h2> 非功能性因素</h2>\n<p>满足了功能性因素以后，我们就得要考虑怎么能够稳定地，可靠地，可持续性地支持我们的业务功能，比如性能，可靠性，扩展性，兼容性等等。</p>\n<ul>\n<li>可靠性\n<ul>\n<li>为了更好的服务于功能，我们需要确保架构能够稳定、高效的运行。不会时不时的出现服务崩溃或者不可用的情况。</li>\n</ul>\n</li>\n<li>可用性\n<ul>\n<li>同样的，服务对外要始终处于可用的状态，即使单个服务实例出现问题，我们依然可以正常的对外提供服务。</li>\n</ul>\n</li>\n<li>扩展性\n<ul>\n<li>功能性需求不是一层不变的，尤其在当今盛行敏捷的时代，需求不是一次性提出的。我们需要对系统、服务的整体能力有全面的定位和把控。这就需要我们的架构在新的需求出现的时候，可以方便的进行扩展支持。</li>\n</ul>\n</li>\n<li>治理能力\n<ul>\n<li>好的架构一定是方便运营、管理和监控的。甚至微观到工程管理，代码一定是易于维护、扩展、协同的。</li>\n</ul>\n</li>\n<li>响应性能\n<ul>\n<li>一般的，功能性需求都会对性能有一定的预期。这个业务要我们在架构上做很多工作，比如读写分离、缓存、异步等等的介入，以满足整体架构的响应能力。</li>\n</ul>\n</li>\n</ul>\n<figure><figcaption>img_19.png</figcaption></figure>\n<h2> 设计原则</h2>\n<ul>\n<li>价值为王：系统架构设计应该以实现业务价值为目标，始终关注用户需求和业务场景，确保设计出的系统能够满足用户需求和业务场景，为企业创造价值。</li>\n<li>以终为始：在进行系统架构设计时，需要明确系统的目标和愿景，并以此为起点，进行设计和实现。以确保系统的设计和实现都是为了实现业务价值，满足用户需求。</li>\n<li>分治原则：将系统划分为多个子系统或模块，每个子系统或模块都可以独立地进行开发、测试、部署和维护。这样可以降低系统的复杂度，提高系统的可维护性和可扩展性。</li>\n<li>服务自治：每个服务都应该具备独立的能力，能够独立地进行开发、测试、部署和维护。这样可以提高服务的可用性和可靠性，降低系统的耦合度。</li>\n<li>拥抱变化：系统架构设计应该能够适应业务需求的变化和市场的变化，具备快速响应和灵活应变的能力。</li>\n<li>系统安全性：系统架构设计应该充分考虑系统的安全性，包括数据安全、应用安全、系统安全等方面，确保系统的安全性和稳定性。</li>\n<li>不作不死：系统架构设计应该遵循“最小化变更范围”原则，避免过度设计和复杂度的出现，从而提高系统的可维护性和可扩展性。</li>\n</ul>\n<h2> 常见的架构设计方案</h2>\n<p>之前比较流行的是MVC，MVC有很多的优点，但是缺点也不少：</p>\n<ul>\n<li>视图与控制器的连接过紧，视图如果不依赖控制器，那么它的应用就会十分有限，这妨碍了他们的独立。</li>\n<li>模型对视图数据的访问效率较低，工作量大，并且有一些高级的界面工具或构造器不支持MVC框架。</li>\n<li>MVC架构使得我们面向视图开发，但是视图的变化是不可控的，容易受到用户主观的影响。同时复杂系统必然存在纷繁复杂的依赖，依赖不可能存在于视图，最终表现为接口依赖。</li>\n</ul>\n<p>所以现在比较流行如下几种方案：</p>\n<figure><figcaption>img_20.png</figcaption></figure>\n<h2> 领域驱动架构</h2>\n<p>领域驱动设计是通过将软件实现与核心业务概念的演进紧密相连，从而实现复杂需求的软件开发方法。</p>\n<p>领域驱动设计包括三要素：</p>\n<ul>\n<li>专业知识：就是前期在与客户沟通需求过程中，学习到的关于业务方面的知识。 这类知识并不仅仅只是对需求的理解，更多的要思考业务需求实际要解决的是什么问题。</li>\n<li>抽象能力：一般指发现核心业务对象，简化问题空间的能力。</li>\n<li>细分问题：把业务问题细化为更小更容易处理的子问题。<br>\n领域驱动设计，使得我们不再用数据进行驱动，而是使用领域进行驱动。遇到问题，我们先进行领域上的划分和拆解。这个问题属于哪个问题域，或者需要拆解到哪些问题域里面去，然后再通过领域的组合以及依赖，完成最终问题的解决。</li>\n</ul>\n<h2> 微服务架构</h2>\n<p>微服务架构是一种软件开发架构，它将应用程序拆分成小型、独立的微服务，每个微服务都有自己的功能集，并运行在其独立的进程中。</p>\n<p>微服务架构有以下优点：</p>\n<ul>\n<li>开发人员可以只关注整个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化。</li>\n<li>有利于各层逻辑的复用，如PetShop可经过简单的配置实现Sqlserver和Oracle之间的转换。</li>\n<li>扩展性强，不同层负责不同的层面，有利于系统的扩展和维护。</li>\n<li>安全性高，用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。</li>\n<li>项目结构更清楚，分工更明确，有利于后期的维护和升级。</li>\n</ul>\n<h2> 云原生架构</h2>\n<figure><figcaption>img_21.png</figcaption></figure>\n<p>云原生架构是一种创新的软件开发方法，专为充分利用云计算模型而设计。</p>\n<p>云原生架构通过结合使用云计算和各种云服务来创建具有更大可扩展性的可定制模块化基础架构，从而提高了团队的效率，生产力和协作能力。</p>\n<p>云原生架构的核心原则：</p>\n<ul>\n<li>云原生架构是一种设计方法，利用AWS等EC2，S3，Lambda等云服务来支持动态，敏捷的应用程序开发技术，这些技术采用模块化方法通过一套基于云的套件来构建，运行和更新软件微服务与整体应用程序基础架构。</li>\n<li>微服务和容器化通过简化云提供商之间的转移或独立地以不同的语言或框架部署服务而没有冲突或停机的情况，从而支持云本机应用程序的敏捷性和动态性。</li>\n<li>将微服务架构集成到应用程序开发中可支持协作，效率和生产力，因为DevOps团队能够同时独立处理应用程序的不同组件或实现新功能而又不牺牲稳定性。</li>\n</ul>\n<h2> DevOps架构</h2>\n<figure><figcaption>img_22.png</figcaption></figure>\n<p>DevOps架构，它旨在加强软件产品开发与交付过程中的协作、自动化、持续性和监控等方面，以实现更高效、更迅速和更可靠的软件交付。</p>\n<p>DevOps通常包括以下核心组成部分：</p>\n<ul>\n<li>持续集成：将代码频繁地集成到一个共享的代码库中，并对代码进行自动化测试，以确保代码质量和稳定性，并及时发现和解决错误。</li>\n<li>持续交付：通过自动化测试、构建、部署和运行环节，实现快速、可靠和可重复的软件发布，从而减少手动操作和人工干预带来的错误和风险。</li>\n<li>自动化运维：将基础设施的管理、配置和维护工作自动化，并将其作为代码、脚本或配置文件存储在版本控制系统中，以便快速搭建、复制和修改环境。</li>\n<li>容器化技术：使用容器化技术（如Docker）将应用程序和其依赖项打包成独立的、可移植的容器，在不同的环境中快速部署和运行。</li>\n<li>监控和日志分析：通过对软件运行时数据进行采集、储存、分析和可视化，监控系统状态、性能和安全等方面的指标，并及时发现和修复问题。</li>\n</ul>\n<h2> 大数据架构</h2>\n<figure><figcaption>img_23.png</figcaption></figure>\n<p>大数据架构是一种面向海量数据、高并发、高可靠、高性能的计算和存储系统架构，用于管理和处理大规模的结构化、半结构化和非结构化数据。它具有以下几个特点：</p>\n<ul>\n<li>高可扩展性：大数据架构应该能够轻松地扩展到海量数据和高并发请求下。</li>\n<li>高容错性：大数据架构应该在硬件、网络和软件故障等异常情况下保证系统稳定性。</li>\n<li>实时计算：大数据架构需要支持实时计算和流式处理，以满足复杂的业务场景。</li>\n<li>数据安全：大数据架构需要保证数据的机密性、完整性和可用性，避免数据泄露和损坏。</li>\n<li>成本效益：大数据架构应该充分考虑成本问题，尽可能利用开源技术和云平台来降低系统运维和资源开销。<br>\n比如常见的大数据架构包括<code>Hadoop、Spark、Storm、Kafka</code><br>\n等开源软件，它们可以被组合在一起形成一个完整的数据处理流水线。例如，Hadoop可以提供分布式文件系统HDFS和MapReduce计算模型，Spark可以提供内存计算和机器学习功能，Storm可以提供实时数据处理功能，Kafka可以提供高可靠的消息队列服务。使用这些开源软件和云平台，企业可以构建出适合自己场景的大数据处理系统，提升自身的业务竞争力。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:50:17.000Z",
      "authors": [],
      "tags": [
        "设计注意"
      ]
    },
    {
      "title": "架构原则",
      "url": "https://ujava.cn/attention/attention2.html",
      "id": "https://ujava.cn/attention/attention2.html",
      "summary": "架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。 示例： 是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？ 是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？ 淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？",
      "content_html": "<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>\n<p>示例：</p>\n<ul>\n<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>\n<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>\n<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>\n</ul>\n<h4> 1.合适原则</h4>\n<blockquote>\n<p>合适优于业界领先。</p>\n</blockquote>\n<p>在进行架构设计的同时，需要考虑自身业务，而不是一味的去参照业界顶尖的规模，如：QQ、微信、淘宝架构。真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>\n<h4> 2.简单原则</h4>\n<blockquote>\n<p>简单优于复杂。</p>\n</blockquote>\n<p>软件架构设计是一门技术活，当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>\n<p>软件复杂度的体现，主要有以下两个方面：</p>\n<p>结构的复杂性<br>\n– 组成复杂系统的组件数量更多；<br>\n– 组件之间的关系也更加复杂。</p>\n<p>其问题主要有：</p>\n<ul>\n<li>（1）组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li>\n<li>（2）某个组件改动，会影响关联的所有组件。</li>\n<li>（3）定位一个复杂系统中的问题总是比简单系统更加困难。</li>\n</ul>\n<h4> 逻辑的复杂性</h4>\n<p>逻辑的复杂性来源于一个组件集中了太多的功能，修改协作困难；并且，其中某些业务还可能使用了一些复杂的算法，导致难以理解、修改困难。</p>\n<p>一个组件集中了太多功能，就会表现出一些逻辑复杂性的特征，为了解决这个问题，一般的手段是进行组件的拆分，但随着组件的细化，又会引入结构复杂性的一些特征，所以，在做结构设计的时候，需要权衡这两者。</p>\n<h4> 3.演化原则</h4>\n<blockquote>\n<p>演化优于一步到位。</p>\n</blockquote>\n<p>维基百科对“软件架构”的定义如下：</p>\n<blockquote>\n<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>\n</blockquote>\n<p>这个定义中，将建筑和软件架构做了一个比较，但是，两者之间是有一个本质区别的：对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。<br>\n也就是说，软件架构的本质是：软件架构需要根据业务发展不断变化，所以，我们在做软件架构设计的时候，不要试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>\n<p>架构设计的过程基本上可以总结为下面三个历程：</p>\n<ul>\n<li>首先，设计出来的架构要满足当时的业务需要。</li>\n<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。--<br>\n小重构</li>\n<li>最后，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。--<br>\n大重构</li>\n</ul>\n<p>我们在做架构设计的时候，切勿贪大求全，或者盲目的照搬大公司的做法，而是要牢记软件架构的本质（软件架构需要根据业务发展不断变化）。认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T07:11:10.000Z",
      "authors": [],
      "tags": [
        "设计注意"
      ]
    },
    {
      "title": "组件DevOps",
      "url": "https://ujava.cn/assembly/devops.html",
      "id": "https://ujava.cn/assembly/devops.html",
      "summary": "1. DevOps 维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。 为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？ 项目管理模式的演变是受项目的规模大小影响的。 最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。 后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。",
      "content_html": "<h2> 1. DevOps</h2>\n<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>\n<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>\n<p>项目管理模式的演变是受项目的规模大小影响的。</p>\n<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>\n<br>\n后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>\n<p><br>\n再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>\n<br>\n再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>\n<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>\n<p><br>\nDevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>\n<ul>\n<li>DevOps = 人 + 流程 + 平台</li>\n<li>人 + 流程 = 文化</li>\n<li>流程 + 平台 = 工具</li>\n<li>平台 + 人 = 赋能</li>\n</ul>\n<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>\n<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>\n<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>\n<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>\n<h2> 2. CI/CD</h2>\n<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>\n<p><br>\nCI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>\n<p><strong>持续集成</strong>：</p>\n<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>\n</p>\n<p><strong>持续交付</strong>：</p>\n<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>\n</p>\n<p><strong>持续部署</strong>：</p>\n<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>\n</p>\n<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>\n<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>\n<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>\n<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>\n<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件ElasticSearch",
      "url": "https://ujava.cn/assembly/elasticsearch.html",
      "id": "https://ujava.cn/assembly/elasticsearch.html",
      "summary": "一、 简介 Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作: 一个分布式的实时文档存储，每个字段可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 1.ES优点 1.支持全文搜索，并基于倒排索引，检索速度特别快 2.高可用性，支持集群部署，任何节点失效系统自动调整。",
      "content_html": "<h2> 一、 简介</h2>\n<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>\n<ul>\n<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>\n<li>一个分布式实时分析搜索引擎</li>\n<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>\n</ul>\n<h3> 1.ES优点</h3>\n<ul>\n<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>\n<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>\n</ul>\n<h3> 2.ES缺点</h3>\n<ul>\n<li>1.对硬件要求较高，es比较吃内存，需要存储资源来支持大量数据的处理。</li>\n<li>2.不支持事务等ACID属性。</li>\n</ul>\n<h3> 3.ES使用场景</h3>\n<p>1.聊天消息</p>\n<ul>\n<li>数据量大，业务关系简单，会通过关键字搜索聊天信息</li>\n<li>非核心业务，不会频繁crud</li>\n<li>没有事务的场景，可以不用支持事务</li>\n</ul>\n<p>2.日志纪录</p>\n<p>Elasticsearch 一个典型应用就是 ELK 日志分析系统。如nginx接入请求的访问日志纪录。</p>\n<p>3.热点数据搜索</p>\n<p>如电商业务的商品搜索等。</p>\n<h3> 4.DSL语言高级查询</h3>\n<h4> 1.Query DSL概述</h4>\n<p>Domain Specific Language 领域专用语言</p>\n<ul>\n<li>Elasticsearch provides a ful1 Query DSL based on JSON to define queries</li>\n<li>Elasticsearch提供了基于JSON的DSL来定义查询。</li>\n</ul>\n<p>DSL由叶子查询子句和复合查询子句两种子句组成。</p>\n<figure><figcaption>img_111.png</figcaption></figure>\n<h4> 2.模糊匹配</h4>\n<p>模糊匹配主要是针对文本类型的字段，文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据，模糊匹配主要通过match等参数来实现</p>\n<ul>\n<li>match : 通过match关键词模糊匹配条件内容</li>\n<li>prefix : 前缀匹配</li>\n<li>regexp : 通过正则表达式来匹配数据</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 3.精确匹配</h4>\n<ul>\n<li>term : 单个条件相等</li>\n<li>terms : 单个字段属于某个值数组内的值</li>\n<li>range : 字段属于某个范围内的值</li>\n<li>exists : 某个字段的值是否存在</li>\n<li>ids : 通过ID批量查询</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h4> 4.聚合搜索</h4>\n<p><strong>1.bucket和metric</strong></p>\n<p>bucket就是一个聚合搜索时的数据分组。</p>\n<p>如：销售部门有员工张三和李四，开发部门有员工王五和赵六。那么根据部门分组聚合得到结果就是两个bucket。销售部门bucket中有张三和李四，开发部门 bucket中有王五和赵六。</p>\n<p>metric就是对一个bucket数据执行的统计分析。如上述案例中，开发部门有2个员工，销售部门有2个员工，这就是metric。</p>\n<p>metric有多种统计，如：求和，最大值，最小值，平均值等。</p>\n<p>用一个大家容易理解的SQL语法来解释，如：select count() from table group by column。那么group by column分组后的每组数据就是bucket。对每个分组执行的count()就是metric。</p>\n<p>es最重要的核心功能是数据检索，统计分析我认为不是es最核心的功能，想这种离线统计应该由其他的替代方案去做，所以如果想了解更多es聚合搜索相关知识可以参考官网或者其他博客</p>\n<h3> 5.文档映射</h3>\n<p>ES中映射可以分为动态映射和静态映射</p>\n<h4> 1.动态映射</h4>\n<p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。<br>\n动态映射规则如下：</p>\n<figure><figcaption>img_112.png</figcaption></figure>\n<h4> 2.静态映射</h4>\n<p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。</p>\n<h4> 3.核心类型（Core datatype）</h4>\n<ul>\n<li>字符串：string，string类型包含 text 和 keyword。</li>\n<li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li>\n<li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li>\n<li>数值型：long、integer、short、byte、double、float</li>\n<li>日期型：date</li>\n<li>布尔型：boolean</li>\n</ul>\n<h4> 4.数据建模</h4>\n<p>就是针对于关系型数据库的一对多数据模型，而我自己认为es的主要应用场景是全文搜索引擎，这种复杂的业务关系就应该由关系型数据库如mysql去完成数据建模和存储，而不是交给es去建模存储，当然es也是提供了Parent / Child相关机制继续数据建模，如果有场景使用到，自己去参考对应的官方文档了解即可，但我自己不建议这样做。</p>\n<h4> 5.分页查询</h4>\n<p>1.语法</p>\n<p>在存在大量数据时，一般我们进行查询都需要进行分页查询。例如：我们指定页码、并指定每页显示多少条数据，然后Elasticsearch返回对应页码的数据。</p>\n<p>在执行查询时，可以指定from（从第几条数据开始查起）和size（每页返回多少条）数据，就可以轻松完成分页。</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>2.scroll解决深分页问题</p>\n<p>前面使用from和size方式，查询在1W条数据以内都是OK的，但如果数据比较多的时候，会出现性能问题。Elasticsearch做了一个限制，不允许查询的是10000条以后的数据。如果要查询1W条以后的数据，需要使用Elasticsearch中提供的scroll游标来查询。</p>\n<p>在进行大量分页时，每次分页都需要将要查询的数据进行重新排序，这样非常浪费性能。</p>\n<p>使用scroll是将要用的数据一次性排序好，然后分批取出,性能要比from + size好得多。</p>\n<p>使用scroll查询后，排序后的数据会保持一定的时间，后续的分页查询都从该快照取数据即可。</p>\n<p>第一次使用scroll分页查询</p>\n<p>此处，我们让排序的数据保持1分钟，所以设置scroll为1m</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>执行后，我们注意到，在响应结果中有一项：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>后续，我们需要根据这个_scroll_id来进行查询</p>\n<p>第二次直接使用scroll id进行查询</p>\n<h3> 6.suggest search</h3>\n<p>suggest search（completion suggest）：就是建议搜索或称为搜索建议，也可以叫做自动完成-auto completion。类似百度中的搜索联想提示功能。</p>\n<p>ES实现suggest的时候，性能非常高，其构建的不是倒排索引，也不是正排索引，就是纯的用于进行前缀搜索的一种特殊的数据结构，而且会全部放在内存中，所以suggest search进行的前缀搜索提示，性能是非常高。</p>\n<p>需要使用suggest的时候，必须在定义index时，为其mapping指定开启suggest。</p>\n<p>具体如下:</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>suggest 搜索：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 二、ES核心原理</h2>\n<p>ES存储模型</p>\n<p>Elasticsearch与关系数据库结构对应</p>\n<figure><figcaption>img_113.png</figcaption></figure>\n<p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p>\n<h3> 1.索引（Index）</h3>\n<p>相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</p>\n<p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引<br>\n一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</p>\n<h3> 2.文档类型（Type）</h3>\n<p>相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</p>\n<p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p>\n<h3> 3.文档（Document）</h3>\n<p>相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；</p>\n<p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示；</p>\n<h3> 4.字段（Field）</h3>\n<p>文档的一个Key/Value对；</p>\n<ul>\n<li>词（Term）：表示文本中的一个单词；</li>\n<li>标记（Token）：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li>\n</ul>\n<p>相当于是数据表的字段|列</p>\n<h3> 5.倒排索引</h3>\n<p>全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。</p>\n<p>之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。</p>\n<p>假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。</p>\n<p>正排索引示例：</p>\n<figure><figcaption>img_114.png</figcaption></figure>\n<p>（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）</p>\n<p>正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了“面向对象葵花宝典是什么”，网站根据文章标题查询文章的内容展示给用户。</p>\n<p>倒排索引示例：</p>\n<figure><figcaption>img_115.png</figcaption></figure>\n<p>（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）</p>\n<p>倒排索引适用于根据关键词来查询文档内容，它是根据文章内容中的关键字建立索引，而值对应于文档ID，而搜索出来的结果就是文档ID所在行的所有内容。</p>\n<p>例如，用户只是想看“设计”相关的文章，网站需要将文章内容中包含“设计”一词的文章都搜索出来展示给用户。</p>\n<p>要注意倒排索引的两个重要细节：</p>\n<ul>\n<li>倒排索引中的所有词项对应一个或多个文档；</li>\n<li>倒排索引中的词项根据字典顺序升序排列<br>\nElasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。</li>\n</ul>\n<h3> 6.分词器</h3>\n<p>对于英文来说，分词比较简单，只需要按照单词的空格来进行分词。<br>\n如下所示<br>\n</p>\n<p>如果要搜索hello这个关键词，则匹配的结果将是下面两个内容</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果。</p>\n<p>这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。</p>\n<p>ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。</p>\n<p>修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>分词器工作流程<br>\n<br>\n分词器由三部分组成：</p>\n<ul>\n<li>Character Filter：将文本中html标签剔除掉。</li>\n<li>Tokenizer：按照规则进行分词，在英文中按照空格分词</li>\n<li>Token Filter：将切分的单词进行加工，小写，删除 stopwords(停顿词，a、an、the、is等),增加同义词</li>\n</ul>\n<p>每个组件的作用，可参考下面的例子</p>\n<p>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签</p>\n<p>tokenizer：分词，hello you and me --&gt; hello, you, and, me</p>\n<p>token filter：lowercase，stop word，synonymom，liked --&gt; like，Tom --&gt; tom，a/the/an --&gt; 干掉，small --&gt; little</p>\n<p>ES内置分词器</p>\n<ul>\n<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>\n<li>Simple Analyzer - 按照非字母切分(符号被过滤), 小写处理</li>\n<li>Stop Analyzer - 小写处理，停用词过滤(the,a,is)</li>\n<li>Whitespace Analyzer - 按照空格切分，不转小写</li>\n<li>Keyword Analyzer - 不分词，直接将输入当作输出</li>\n<li>Patter Analyzer - 正则表达式，默认\\W+(非字符分割)</li>\n<li>Language - 提供了30多种常见语言的分词器</li>\n<li>Customer Analyzer 自定义分词器</li>\n</ul>\n<p>每个内置分词器的作用，可参考下面的例子</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定制分词器</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定制化自己的分词器</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>IK热更新</p>\n<p>每次都是在es的扩展词典中，手动添加新词语，很坑</p>\n<p>（1）每次添加完，都要重启es才能生效，非常麻烦</p>\n<p>（2）es是分布式的，可能有数百个节点，你不能每次都一个一个节点上面去修改</p>\n<p>es不停机，直接我们在外部某个地方添加新的词语，es中立即热加载到这些新词语<br>\nIKAnalyzer.cfg.xml</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 7.es评分机制</h3>\n<p>当你通过关键字搜索相关文档时，可能会出现多个文档，这些文档的顺序是通过一个max_score属性的大小从高到低顺序展现出来的，max_score属性就是我们所说的评分。</p>\n<p>打分算法</p>\n<p>relevance score算法，简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度</p>\n<p>Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法</p>\n<p>总公式</p>\n<p>max_score = boost * idf * tf</p>\n<figure><figcaption>img_118.png</figcaption></figure>\n<p>对于查询权重我们可以自己定义</p>\n<p>如下面所示：</p>\n<figure><figcaption>img_119.png</figcaption></figure>\n<p>TF算法</p>\n<p>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关</p>\n<ul>\n<li>搜索请求：hello world</li>\n<li>doc1：hello you, and world is very good</li>\n<li>doc2：hello, how are you</li>\n</ul>\n<p>doc1这个文档匹配了2个单词，所以doc1的得分要高一些。</p>\n<p>2.IDF算法<br>\nInverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关</p>\n<ul>\n<li>搜索请求：hello world</li>\n<li>doc1：hello, tuling is very good</li>\n<li>doc2：hi world, how are you</li>\n</ul>\n<p>比如说，在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次；world这个单词在所有的document中，一共出现了100次，所以world这个单词得分就更高。</p>\n<p>那么匹配world的doc得分就越高,越有可能排在搜索结果前面。</p>\n<p>Field-length norm：field长度，field越长，相关度越弱<br>\n搜索请求：hello world</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>hello world在整个index中出现的次数是一样多的，那么doc1更相关，title field更短</p>\n<p><strong>2.空间向量模型（vector space model）</strong></p>\n<p>每个doc vector计算出对query vector的弧度，最后基于这个弧度给出一个doc相对于query中多个term的总分数</p>\n<p>弧度越大，分数月底; 弧度越小，分数越高</p>\n<p>如果是多个term，那么就是线性代数来计算，无法用图表示</p>\n<figure><figcaption>img_120.png</figcaption></figure>\n<p>了解即可，掌握对应的打分算法我自己认为就足够了，不用砖牛角尖</p>\n<h2> 三、ElasticSearch架构设计</h2>\n<p>es集群架构</p>\n<p>如下图 ，就是一个三个节点组成的es集群，p0、p1、p2表示一个节点中的分片，R0、R1、R2表示分片对应的副本<br>\n<br>\n在Elasticsearch主要分成两类节点，一类是Master，一类是DataNode。</p>\n<h3> 1.Master节点</h3>\n<p>在Elasticsearch启动时，会选举出来一个Master节点。</p>\n<p>当某个节点启动后，然后使用Zen Discovery机制找到集群中的其他节点，并建立连接。</p>\n<p>discovery.seed_hosts: [“192.168.21.130”, “192.168.21.131”, “192.168.21.132”]</p>\n<p>并从候选主节点中选举出一个主节点。</p>\n<p>cluster.initial_master_nodes: [“node1”, “node2”,“node3”]</p>\n<p>Master节点主要负责</p>\n<ul>\n<li>管理索引（创建索引、删除索引）、分配分片</li>\n<li>维护元数据</li>\n<li>管理集群节点状态</li>\n<li>不负责数据写入和查询，比较轻量级</li>\n</ul>\n<p>一个Elasticsearch集群中，只有一个Master节点。在生产环境中，内存可以相对小一点，但机器要稳定。</p>\n<h3> 2.DataNode节点</h3>\n<p>在Elasticsearch集群中，会有N个DataNode节点。</p>\n<p>DataNode节点主要负责：</p>\n<p>数据写入、数据检索，</p>\n<p>大部分Elasticsearch的压力都在DataNode节点上在生产环境中，内存最好配置大一些</p>\n<h3> 3.分片</h3>\n<p>Elasticsearch是一个分布式的搜索引擎，索引的数据也是分成若干部分，分布在不同的服务器节点中，分布在不同服务器节点中的索引数据，就是分片（Shard）。</p>\n<p>Elasticsearch会自动管理分片，如果发现分片分布不均衡，就会自动迁移一个索引（index）由多个shard（分片）组成，而分片是分布在不同的服务器上的.</p>\n<h3> 4.副本</h3>\n<p>为了对Elasticsearch的分片进行容错，假设某个节点不可用，会导致整个索引库都将不可用。所以，需要对分片进行副本容错，每一个分片都会有对应的副本。</p>\n<p>在Elasticsearch中，默认创建的索引为1个分片、每个分片有1个主分片和1个副本分片。</p>\n<p>每个分片都会有一个Primary Shard（主分片），也会有若干个Replica Shard（副本分片）</p>\n<p>Primary Shard和Replica Shard不在同一个节点上</p>\n<h3> 5.es集群读写流程</h3>\n<p>es 写数据流程</p>\n<figure><figcaption>img_122.png</figcaption></figure>\n<p>1.选择任意一个DataNode发送请求，例如：node2。此时，node2就成为一个coordinating node（协调节点）</p>\n<p>2.计算得到文档要写入的分片</p>\n<p><code>shard = hash(routing) % number_of_primary_shards</code><br>\nrouting 是一个可变值，默认是文档的 _id</p>\n<p>3.coordinating node会进行路由，将请求转发给对应的primary shard所在的DataNode（假设primary shard在node1、replica shard在node2）</p>\n<p>4.node1节点上的Primary Shard处理请求，写入数据到索引库中，并将数据同步到Replica shard</p>\n<p>5.Primary Shard和Replica Shard都保存好了文档，返回client</p>\n<p>es 读数据流程</p>\n<figure><figcaption>img_123.png</figcaption></figure>\n<p>1.client发起查询请求，某个DataNode接收到请求，该DataNode就会成为协调节点（Coordinating Node）</p>\n<p>2.协调节点（Coordinating Node）将查询请求广播到每一个数据节点，这些数据节点的分片会处理该查询请求</p>\n<p>3.每个分片进行数据查询，将符合条件的数据放在一个优先队列中，并将这些数据的文档ID、节点信息、分片信息返回给协调节点</p>\n<p>4.协调节点将所有的结果进行汇总，并进行全局排序</p>\n<p>5.协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据返回给客户端</p>\n<p>注意：写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>\n<p>自己总结：es的检索流程和mysql数据表查询非主键索引的思路有些相似，先从索引表查询出对应的主键索引值，在进行回表查询具体的行数据。</p>\n<p>es删除/更新数据底层原理</p>\n<p>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</p>\n<p>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p>\n<p>es 底层写数据原理</p>\n<figure><figcaption>img_124.png</figcaption></figure>\n<p>简述：先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；然后刷新到os cache中（同时将数据备份到translog日志文件），最后刷新到 segment file磁盘文件中</p>\n<p>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件作备份（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。最后存入到commit point磁盘文件中。</p>\n<p>refresh到文件系统缓存</p>\n<p>当数据写入到ES分片时，会首先写入到内存中，然后通过内存的buffer生成一个segment，并刷到文件系统缓存中。</p>\n<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。</p>\n<p>这个过程就是 refresh 。</p>\n<p>只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。</p>\n<p>定时 refresh到文件系统缓存机制</p>\n<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file ，每秒钟会产生一个新的磁盘文件 segment file ，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。<br>\n但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>\n<p>segment file合并</p>\n<p>buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，此时会定期执行 merge，减少索引查询时IO开销。<br>\n每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉（之前执行过的delete的数据），然后将新的 segment file 写入到一个 commit point磁盘 。</p>\n<p>知识扩展</p>\n<p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache ，先进入操作系统级别的一个内存缓存中去。</p>\n<p>备份到translog磁盘</p>\n<p>刷新到translog文件以保障数据不丢失，translog的设计思想和mysql的redo log是相似的。</p>\n<p>每隔5s,从os cache 中同步到translog磁盘里面去做备份。</p>\n<p>那么translog 日志文件的作用是什么？</p>\n<p>你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>\n<p>flush到磁盘文件</p>\n<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file文件系统缓存中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p>\n<p>数据最终被flush到磁盘文件就完成了数据的最终归宿。</p>\n<figure><figcaption>img_125.png</figcaption></figure>\n<p>commit操作流程</p>\n<p>commit 操作首先就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。<br>\n然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。<br>\n最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>\n<p>这个 commit 操作叫做 flush 。</p>\n<p>默认 30 分钟自动执行一次 flush ，将文件系统缓存的数据刷入到磁盘。<br>\n但如果 translog 过大，也会触发 flush 。</p>\n<p>flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>\n<p>es准实时机制</p>\n<p>为什么叫 es 是准实时的？</p>\n<p>NRT ，全称 near real-time 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</p>\n<p>可以通过 es 的 restful api 或者 java api ，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>\n<p>es会数据丢失吗？</p>\n<p>可能会丢失有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果备份到translog过程中宕机，会导致 5 秒的数据丢失。</p>\n<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。<br>\n也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>\n<p>es集群脑裂</p>\n<p>关于集群脑裂的定义请参考我的另一篇博文</p>\n<p><a href=\"https://blog.csdn.net/sinat_34814635/article/details/129914369\" target=\"_blank\" rel=\"noopener noreferrer\">https://blog.csdn.net/sinat_34814635/article/details/129914369</a></p>\n<p>那么es是如何解决脑裂问题的？</p>\n<p>es是直到有足够的master候选节点时，才可以选举出一个master，否则就不要选举出一个master。</p>\n<p>这个参数必须被设置为集群中master候选节点的quorum数量，也就是大多数，至于quorum的算法，就是：master候选节点数量 / 2 + 1。</p>\n<p>综上所述，一个生产环境的es集群，至少要有3个节点，同时将这个参数设置为quorum，也就是2。discovery.zen.minimum_master_nodes设置为2</p>\n<p>那么这个是参数是如何避免脑裂问题的产生的呢？比如我们有3个节点，quorum是2.现在网络故障，1个节点在一个网络区域，另外2个节点在另外一个网络区域，不同的网络区域内无法通信。</p>\n<p>这个时候有两种情况情况：</p>\n<p>（1）如果master是单独的那个节点，另外2个节点是master候选节点，那么此时那个单独的master节点因为没有指定数量的候选master node在自己当前所在的集群内，因此就会取消当前master的角色，尝试重新选举，但是无法选举成功。然后另外一个网络区域内的node因为无法连接到master，就会发起重新选举，因为有两个master候选节点，满足了quorum，因此可以成功选举出一个master。此时集群中就会还是只有一个master。</p>\n<p>（2）如果master和另外一个node在一个网络区域内，然后一个node单独在一个网络区域内。那么此时那个单独的node因为连接不上master，会尝试发起选举，但是因为master候选节点数量不到quorum，因此无法选举出master。而另外一个网络区域内，原先的那个master还会继续工作。这也可以保证集群内只有一个master节点。</p>\n<p>综上所述，集群中master节点的数量至少3台，三台主节点通过在elasticsearch.yml中配置discovery.zen.minimum_master_nodes: 2，就可以避免脑裂问题的产生。</p>\n<h2> 四、ElasticSearch应用</h2>\n<h3> 1.Elasticsearch SQL</h3>\n<figure><figcaption>img_126.png</figcaption></figure>\n<p>Elasticsearch SQL允许执行类SQL的查询，可以使用REST接口、命令行或者是JDBC，都可以使用SQL来进行数据的检索和数据的聚合。</p>\n<p>Elasticsearch SQL特点：</p>\n<p>本地集成</p>\n<p>Elasticsearch SQL是专门为Elasticsearch构建的。每个SQL查询都根据底层存储对相关节点有效执行。</p>\n<p>没有额外的要求</p>\n<p>不依赖其他的硬件、进程、运行时库，Elasticsearch SQL可以直接运行在Elasticsearch集群上</p>\n<p>轻量且高效</p>\n<p>像SQL那样简洁、高效地完成查询</p>\n<p>Elasticsearch SQL提供了sql转换的功能，但是只能满足一些简单的查询，例如：不支持JOIN、不支持较复杂的子查询。官方还是推荐使用DSL语句来实现</p>\n<h3> 2.Java客户端</h3>\n<p>这个就自己看官网吧</p>\n<h3> 3.es和mysql的双写</h3>\n<p>双写的流程：</p>\n<ul>\n<li>1.先写数据库，然后写es，es只存常搜索的索引字段。</li>\n<li>2.读取时先读es，找到对应主键后，然后根据主键在读mysql。（这种场景主要出现在mysql是分表的，而主键配置的是分片键，非分片键的查询将扫描全表）<br>\n首先不建议进行双写，因为会造成数据不一致这样新的问题。造成不一致的原因为写入es或者更新es字段失败，加上补充机制后也没有成功。</li>\n</ul>\n<p>双写的同步</p>\n<p>分页查询mysql中的数据，放入mq中（放入mq中的原因，为读取mysql的线程会远比执行同步的线程速度快），同步线程从mq中拉起数据，然后和es对比，如果不同，与mysql中的数据为准，进行删除复制。</p>\n<p>补偿机制</p>\n<p>我认为任何对es写失败，更新失败，删除失败都应该纪录下来，然后去手动操作使其同步。</p>\n<h2> 五、ElasticSearch安装配置</h2>\n<h3> 1.安装ElasticSearch</h3>\n<p>解压下载的压缩包，本次使用7.14.0版本</p>\n<p>从v7开始，elasticsearch不用单独安装JDK，因为它在下载时会自动下载对应的jdk包。因此不用额外下载jdk和配置环境变量。</p>\n<p>在终端cd到elasticsearch的bin目录，运行命令./elasticsearch即可开启es数据库服务（在终端通过按control + c可停止服务）。在网页中访问localhost:9200看到json结果即启动成功。</p>\n<p>如下图所示：</p>\n<figure><figcaption>img_127.png</figcaption></figure>\n<h3> 2.安装Kibana</h3>\n<p>下载可视化工具Kibanahttps://www.elastic.co/cn/downloads/kibana</p>\n<p>解压下载的压缩包，并将其复制粘贴至自己想要存放的目录。Kibana的版本最好和es保持一致，如这次同样使用7.14.0版本</p>\n<p>启动Kibana</p>\n<p>在终端cd到Kibana目录下，运行命令./Kibana即可开启Kibana的端口访问。在网页中访问http://localhost:5601跳转到如下界面即访问成功。</p>\n<p>访问下面地址：<a href=\"http://localhost:5601/app/dev_tools#/console\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:5601/app/dev_tools#/console</a> 可进入管理后台</p>\n<figure><figcaption>img_128.png</figcaption></figure>\n<p>ElasticSearch可视化工具之cerebro</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Jenkins",
      "url": "https://ujava.cn/assembly/jenkins.html",
      "id": "https://ujava.cn/assembly/jenkins.html",
      "summary": "1.背景 在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试； 或者前后端分离后，经常会修改接口，然后重新部署； 这些情况都会涉及到频繁的打包部署； 手动打包常规步骤： 1.提交代码 2.问一下同组小伙伴有没有要提交的代码 3.拉取代码并打包（war包，或者jar包） 4.上传到Linux服务器 5.查看当前程序是否在运行 6.关闭当前程序 7.启动新的jar包 8.观察日志看是否启动成功 9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）",
      "content_html": "<h2> 1.背景</h2>\n<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>\n<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>\n<p>这些情况都会涉及到频繁的打包部署；</p>\n<p>手动打包常规步骤：</p>\n<ul>\n<li>1.提交代码</li>\n<li>2.问一下同组小伙伴有没有要提交的代码</li>\n<li>3.拉取代码并打包（war包，或者jar包）</li>\n<li>4.上传到Linux服务器</li>\n<li>5.查看当前程序是否在运行</li>\n<li>6.关闭当前程序</li>\n<li>7.启动新的jar包</li>\n<li>8.观察日志看是否启动成功</li>\n<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>\n</ul>\n<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>\n<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>\n<p>只是Jenkins相对来说，使用得更广泛。</p>\n<h2> 2.Jenkins服务器搭建及基本配置</h2>\n<h3> 2.1.简介</h3>\n<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>\n<h3> 2.2.Jenkins自动化部署实现原理</h3>\n<figure><figcaption>img_70.png</figcaption></figure>\n<h3> 2.3.Jenkins部署环境</h3>\n<p>基本环境：</p>\n<ul>\n<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>\n<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>\n<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>\n</ul>\n<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>\n<h3> 2.4.Jenkins安装</h3>\n<ul>\n<li>1.下载安装包jenkins.war；</li>\n<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>\n<li>3.打开浏览器进入链接 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080</a>.</li>\n<li>4.填写初始密码，激活系统</li>\n</ul>\n<figure><figcaption>img_71.png</figcaption></figure>\n<ul>\n<li>5.进入插件安装选择</li>\n</ul>\n<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>\n<figure><figcaption>img_72.png</figcaption></figure>\n<p>选择后，进入插件安装页面<br>\n</p>\n<ul>\n<li>\n<p>6.设置初始用户和密码<br>\n</p>\n</li>\n<li>\n<p>7.进入系统，安装完成<br>\n</p>\n</li>\n</ul>\n<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>\n<h3> 2.5.Jenkins基本配置</h3>\n<h4> 2.5.1.系统初始化配置</h4>\n<figure><figcaption>img_76.png</figcaption></figure>\n<p><strong>1.Configure System (系统设置)</strong></p>\n<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>\n<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>\n<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>\n</p>\n<p><strong>2.Configure Global Security (全局安全配置)</strong></p>\n<p>a.配置用户相关的权限</p>\n<figure><figcaption>img_78.png</figcaption></figure>\n<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>\n<p>默认是勾选上了的，这里去掉勾选</p>\n<figure><figcaption>img_79.png</figcaption></figure>\n<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>\n<p>a.配置maven的全局settings路径<br>\n</p>\n<p>b.配置jdk<br>\n</p>\n<p>c.配置git</p>\n<figure><figcaption>img_82.png</figcaption></figure>\n<p>d.配置maven的安装路径</p>\n<figure><figcaption>img_83.png</figcaption></figure>\n<p><strong>4.配置必要插件</strong></p>\n<p>主要是检查如下这两个插件是否已安装</p>\n<ul>\n<li>插件1：Publish over SSH</li>\n<li>插件2：Deploy to container Plugin</li>\n</ul>\n<figure><figcaption>img_84.png</figcaption></figure>\n<p>添加图片注释，不超过 140 字（可选）</p>\n<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>\n<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>\n<h3> 3.1.Jenkins服务器上创建项目和配置</h3>\n<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>\n<p><strong>1.创建一个工程</strong></p>\n<figure><figcaption>img_85.png</figcaption></figure>\n<p><strong>2.General(基础配置)</strong></p>\n<p>仅需填写标准部分，其他可不填写</p>\n<figure><figcaption>img_86.png</figcaption></figure>\n<p><strong>3.源码管理</strong><br>\n</p>\n<p>上图中点击“添加”按钮添加一组账号和密码<br>\n</p>\n<p><strong>4.构建触发器</strong></p>\n<figure><figcaption>img_89.png</figcaption></figure>\n<p>如上图：当前项目的回调地址为：</p>\n<p><a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>\n<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>\n<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>\n<p><strong>5.构建环境（无需配置）</strong></p>\n<p><strong>6.构建</strong></p>\n<figure><figcaption>img_90.png</figcaption></figure>\n<p><strong>7.构建后操作</strong></p>\n<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>\n<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>\n<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>\n</p>\n<p>案例中给出的stop.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>案例中给出的start.sh脚本如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>\n<h3> 3.2.Linux服务器配置</h3>\n<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>\n<figure><figcaption>img_92.png</figcaption></figure>\n<h3> 3.3.GitHub服务器配置</h3>\n<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>\n<p>特别注意：为了保证回调地址网可以使用，</p>\n<p>我已经将地址：<a href=\"http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C\" target=\"_blank\" rel=\"noopener noreferrer\">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>\n<p>通过花生壳进行外网映射为：<a href=\"http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2\" target=\"_blank\" rel=\"noopener noreferrer\">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>\n<p>所以，下面配置的是外网映射地址。</p>\n<figure><figcaption>img_93.png</figcaption></figure>\n<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>\n<h2> 4.测试</h2>\n<p><strong>1.测试代码</strong><br>\n</p>\n<p><strong>2.提交代码到git,触发构建</strong></p>\n<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>\n</p>\n<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>\n<p>从下图中可以看出，正在构建</p>\n<figure><figcaption>img_96.png</figcaption></figure>\n<p><strong>5.查看当次构建的控制台日志</strong></p>\n<figure><figcaption>img_97.png</figcaption></figure>\n<p>说明已经启动成功</p>\n<p><strong>6.查看Linux服务器，是否上传代码</strong></p>\n<figure><figcaption>img_98.png</figcaption></figure>\n<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>\n<figure><figcaption>img_99.png</figcaption></figure>\n<p><strong>8.浏览器上访问，看是否能用</strong></p>\n<figure><figcaption>img_100.png</figcaption></figure>\n<p>说明，已经正常启动可以使用。</p>\n<p><strong>9.再次确认是否能自动化部署</strong></p>\n<p>修改代码，重新提交代码，循环1到8步查看。</p>\n<p>如果测试结果是你预期的，那么自动化部署成功。</p>\n<h2> 5.总结&amp;资料下载</h2>\n<h3> 5.1.总结</h3>\n<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>\n<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>\n<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>\n<p>但是，本着学习是为了解决生产的原则，</p>\n<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>\n<p>没必要把Jenkins的所有功能都学完在使用，</p>\n<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>\n<h3> 5.2.相关资料</h3>\n<ul>\n<li>1.案例中的源码地址：<a href=\"https://github.com/processfactory/demo01.git\" target=\"_blank\" rel=\"noopener noreferrer\">https://github.com/processfactory/demo01.git</a></li>\n<li>2.官方文档：Jenkins 用户手册</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Kubernetes",
      "url": "https://ujava.cn/assembly/k8s.html",
      "id": "https://ujava.cn/assembly/k8s.html",
      "summary": "一、Kubernetes简介 Kubernetes中文官网：Kubernetes GitHub：github.com/kubernetes/kubernetes Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。",
      "content_html": "<h2> 一、Kubernetes简介</h2>\n<p>Kubernetes中文官网：<a href=\"https://kubernetes.io/zh/\" target=\"_blank\" rel=\"noopener noreferrer\">Kubernetes</a></p>\n<p>GitHub：<a href=\"http://github.com/kubernetes/kubernetes\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/kubernetes</a></p>\n<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>\n<p>Kubernetes集群组件逻辑图<br>\n</p>\n<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>\n<p>Master节点组件及功能<br>\n</p>\n<p>Slave节点组件及功能<br>\n</p>\n<p>安装部署</p>\n<p>生产环境部署k8s主要有两种方式：</p>\n<p>二进制包</p>\n<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>\n<p>kubeadm工具</p>\n<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>\n<ul>\n<li>kubeadm init：初始化一个Master节点</li>\n<li>kubeadm join：将Worker节点加入集群</li>\n<li>kubeadm upgrade：升级K8s版本</li>\n<li>kubeadm token：管理 kubeadm join 使用的令牌</li>\n<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>\n<li>kubeadm version：打印 kubeadm 版本</li>\n<li>kubeadm alpha：预览可用的新功能</li>\n</ul>\n<h2> 二、准备工作</h2>\n<p>软硬件要求</p>\n<ul>\n<li>Linux操作系统，Ubuntu 或 CentOS</li>\n<li>每台节点至少2G</li>\n<li>Master节点至少2C</li>\n<li>集群节点网络互通</li>\n</ul>\n<p>集群规划</p>\n<figure><figcaption>img_104.png</figcaption></figure>\n<p>环境配置</p>\n<p>修改hosts配置</p>\n<p>配置所有节点的IP和域名映射</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置SSH免密登录</p>\n<p>先生成公钥对，再把公钥远程复制到所有节点。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>关闭Swap分区</p>\n<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>禁用SELinux</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>关闭防火墙</p>\n<p>所有节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>修改内核参数</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置集群时钟同步</p>\n<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>配置k8s的Yum源</p>\n<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 三、安装Docker</h2>\n<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>\n<h2> 四、安装K8S集群</h2>\n<p>安装三大组件-kubeadm、kubelet、kubectl</p>\n<ul>\n<li>kubeadm：用来初始化k8s集群的指令。</li>\n<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>\n<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化k8s集群</p>\n<ul>\n<li>apiserver-advertise-address：apiserver监听地址</li>\n<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>\n<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>\n<li>service-cidr：为Service分配的IP地址段</li>\n<li>pod-network-cidr：为pod分配的IP地址段</li>\n</ul>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>成功界面：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>\n<p>加入节点</p>\n<p>所有Node节点执行如下命令：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>修改角色：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>安装网络插件</p>\n<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>\n</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、测试K8S集群</h2>\n<p>创建nginx pod</p>\n<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>对外暴露访问</p>\n<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>访问nginx</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>\n<h2> 六、安装Dashboard</h2>\n<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>\n<p>Github：<a href=\"http://github.com/kubernetes/dashboard\" target=\"_blank\" rel=\"noopener noreferrer\">github.com/kubernetes/dashboard</a></p>\n<p>通过kubectl命令安装</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div></div></div><p>查看service</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>浏览器输入访问地址：<a href=\"https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82\" target=\"_blank\" rel=\"noopener noreferrer\">https://192.168.5.10:31128/，需要token才能访问。</a></p>\n<figure><figcaption>img_107.png</figcaption></figure>\n<p>创建访问账号</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>获取token</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>登录界面</p>\n<p>输入上面的token，进入dashboard首页</p>\n<figure><figcaption>img_108.png</figcaption></figure>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-27T02:45:40.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Mock",
      "url": "https://ujava.cn/assembly/mock.html",
      "id": "https://ujava.cn/assembly/mock.html",
      "summary": "简介 通过Mock方式，测试编写的程序 通用类定义 @SpringBootTest(classes = Application.class) @RunWith(SpringJUnit4ClassRunner.class) @Slf4j public class BaseTest { @BeforeClass public static void before() { } }",
      "content_html": "<h2> 简介</h2>\n<p>通过Mock方式，测试编写的程序</p>\n<p>通用类定义</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式一（直接操作库表）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式二（启动容器）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 方式三（不启动容器）</h2>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Mock静态数据</h2>\n<p>在实际工作当中，我们经常会遇到需要对静态方法进行 mock 的情况。在 mockito 2.x 的时代，我们需要借助 powmock 才能实现。当<br>\nmockito 进化到了 3.4.0 版本以后，也开始对静态方法 mock 进行了支持（主要是通过 mockito-inline 包）。</p>\n<p>简单的介绍就到这里，下面让我们进入主题吧。</p>\n<p>首先确保 pom 文件中 mockito 相关 jar 包的版本（这里我用的版本是 3.7.7），如下：</p>\n<div class=\"language-xml line-numbers-mode\" data-ext=\"xml\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>使用方式</p>\n<p>Mockito.mockStatic(Class mockClass)，如下：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这样基本上就 OK 了。唯一需要注意下的就是 httpClient.close()。</p>\n<p>如果项目中未引入 mockito-inline，会出现如下错误信息：</p>\n<div class=\"language-sql line-numbers-mode\" data-ext=\"sql\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>错误提示 static mocking is already registered in the current thread To create a new mock, the existing static mock<br>\nregistration must be deregistered</p>\n<p>当多个单元测试都使用了同一个 static mock 对象，且使用完成后都没有进行 close。此时，若这几个单元测试用一起执行，第一个单元测试占用了<br>\nstatic mock 对象，第二个单元测试就没有办法再占用了。</p>\n<p>如果出现了这种情况，解决办法也很简单，就是关闭 static mock 对象，如下：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>如果你的很多单元测试中都用到了 mockStatic(HTTPClient.class)，且觉得在每个单元测试当中都写一遍 mockStatic()…close()<br>\n很低效，可以采用下边的方式：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> Mock缓存数据</h2>\n<p>在Mockito中，你可以使用Mockito.when配合相应的调用记录方法来模拟缓存场景。以下是一个简单的例子，展示了如何使用Mockito来模拟一个缓存方法的行为：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子中，我们首先通过ConcurrentHashMap模拟了一个简单的缓存。然后我们使用Mockito.spy创建了一个被测试方法所在类的模拟实例。通过Mockito.doReturn我们配置了当调用getFromCache方法并传递特定的key时，模拟方法返回预先定义的值。最后，我们使用Mockito.verify来验证缓存访问方法是否被调用了。这个例子展示了如何使用Mockito来模拟和验证缓存相关的行为。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:25:51.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件Reactor",
      "url": "https://ujava.cn/assembly/reactor.html",
      "id": "https://ujava.cn/assembly/reactor.html",
      "summary": "前言 说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。 一、经典的同步阻塞模型 img_46.png 这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。",
      "content_html": "<h2> 前言</h2>\n<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>\n<h2> 一、经典的同步阻塞模型</h2>\n<figure><figcaption>img_46.png</figcaption></figure>\n<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>\n<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>\n<ul>\n<li>read：从socket读取数据。</li>\n<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>\n<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>\n<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>\n1.下面看传统的BIO代码：</li>\n</ul>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>\n<p>我们的目标是：</p>\n<ul>\n<li>随着负载的增加可以优雅降级；</li>\n<li>能够随着资源的改进，性能可以持续提升；</li>\n<li>同时还要满足可用性和性能指标：</li>\n<li>低延迟</li>\n<li>满足高峰需求</li>\n<li>可调节的服务质量</li>\n</ul>\n<p>阻塞 （针对的是被调用方）</p>\n<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>\n让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>\n<p>同步 （针对的是调用方）</p>\n<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>\n如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>\n<p>NIO就很好的解决了传统Socket问题：</p>\n<ul>\n<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>\n<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>\n</ul>\n<p>2.client端代码：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>\n<h2> 二、单reactor单线程设计</h2>\n<figure><figcaption>img_47.png</figcaption></figure>\n<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>\n<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>\n<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>\n<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>\n<p>代码示例</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>定义了一个Reactor类。</p>\n<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>\n<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>\n监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>\n<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>\n<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>\n<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>\n<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>\n<p>下面我们可以进行测试了：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>\n那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>\n<h2> 三、单reactor多线程设计</h2>\n<figure><figcaption>img_48.png</figcaption></figure>\n<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>\n<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>\n<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看测试结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>\n<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>\n<h2> 四、多reactor多线程设计</h2>\n<figure><figcaption>img_49.png</figcaption></figure>\n<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>\n只负责处理客户端的写事件。</p>\n<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>查看结果：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>\n<h2> 五、Reactor模型结构图</h2>\n<figure><figcaption>img_50.png</figcaption></figure>\n<ul>\n<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>\n<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>\n<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>\n<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>\n<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>\n</ul>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件SpringCloud",
      "url": "https://ujava.cn/assembly/springcloud.html",
      "id": "https://ujava.cn/assembly/springcloud.html",
      "summary": "SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。 一、SpringCloud概述 SpringCloud：SpringCloud官网",
      "content_html": "<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>\n<h2> 一、SpringCloud概述</h2>\n<p>SpringCloud：<a href=\"https://spring.io/projects/spring-cloud\" target=\"_blank\" rel=\"noopener noreferrer\">SpringCloud官网</a></p>\n<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>\n<h2> 二、Spring Cloud 和 Dubbo 对比</h2>\n<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>\nSpring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>\nDubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>\n下面是Spring Cloud和Dubbo的一些比较：<br>\n</p>\n<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>\n<p>需要根据具体的业务需求来选择合适的微服务框架。</p>\n<h2> 三、Spring Cloud 优缺点</h2>\n<p>其主要优点有：</p>\n<ul>\n<li>\n<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>\n</li>\n<li>\n<p>约定优于配置，基于注解，没有配置文件。</p>\n</li>\n<li>\n<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>\n</li>\n<li>\n<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>\n</li>\n<li>\n<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>\n接下来，我们看下它的缺点：</p>\n</li>\n<li>\n<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>\n</li>\n<li>\n<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>\nSpring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>\n</li>\n</ul>\n<h2> 四、SpringCloud组件</h2>\n<h3> 1、Eureka</h3>\n<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2、Feign</h3>\n<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 3、Ribbon</h3>\n<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 4、Hystrix</h3>\n<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 5、Config</h3>\n<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2> 五、SpringCloud应用场景</h2>\n<h3> 1、微服务架构</h3>\n<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>\n<h3> 2、分布式配置中心</h3>\n<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>\n<h3> 3、服务调用和负载均衡</h3>\n<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>\n<h3> 4、高可用和容错机制</h3>\n<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>\n<h2> 六、结语</h2>\n<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "组件WebFlux",
      "url": "https://ujava.cn/assembly/webflux.html",
      "id": "https://ujava.cn/assembly/webflux.html",
      "summary": "因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。 然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。 所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。 我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。",
      "content_html": "<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>\n<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>\n<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>\n<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>\n<p>话说这么多，开始今天的学习吧。</p>\n<h2> 什么是 WebFlux</h2>\n<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>\n<figure><figcaption>img_51.png</figcaption></figure>\n<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>\n<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>\n<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>\n<h2> 反应式库</h2>\n<h3> 1. Reactive Stream</h3>\n<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>\n<p>我们先看下这个概念：</p>\n<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>\n<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>\n<p>它由以下几个组件组成：</p>\n<ul>\n<li>发布者：发布元素到订阅者</li>\n<li>订阅者：消费元素</li>\n<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>\n<li>处理器：发布者与订阅者之间处理数据</li>\n</ul>\n<h3> 2. Reactor</h3>\n<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>\n<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>\nReactor 就是 Spring WebFlux 的首选 反应式库。</p>\n<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>\n<ul>\n<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>\n<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>\n两个都是发布者 Publisher。</li>\n</ul>\n<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>\n<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>\n<ul>\n<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>\n<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>\n<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>\n</ul>\n<p>代码初体验</p>\n<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>\n<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>\n</p>\n<ol>\n<li>Mono</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>\n<ul>\n<li>接口耗时：0</li>\n<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>\n</ul>\n<ol start=\"2\">\n<li>Flux</li>\n</ol>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>\n<h2> 操作数据库</h2>\n<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>\n<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>\n<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>\n<h3> 1. 创建项目</h3>\n<p>选择这几个依赖，创建新的 project:</p>\n<figure><figcaption>img_53.png</figcaption></figure>\n<p>pom.xml 文件里是这样的：</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>然后是 application.properties:</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3> 2. 创建数据库表</h3>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建一个简单的 test_user 表。</p>\n<h3> 3. 创建相关类</h3>\n<p>实体类</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserRepository，就相当于 DAO</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>UserController 控制器</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>\n<h3> 4. 启动测试</h3>\n<p>项目启动之后，我们使用 Postman 测试一下。</p>\n<h3> 请求地址路由</h3>\n<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>\n<p>创建 Userhandler.java</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>创建 RouterConfiguration</p>\n<div class=\"language-java line-numbers-mode\" data-ext=\"java\"><div class=\"line-numbers\" aria-hidden=\"true\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>\n<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>\n<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>\n<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>\n<li>通过 addRoute 方法可以配置多个路由策略。<br>\n测试</li>\n</ul>\n<p>修改：</p>\n<p>查询和前面一样：</p>\n<h3> 适用性</h3>\n<p>官网上是这样建议的：</p>\n<ul>\n<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>\n<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>\n<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>\n<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>\n</ul>\n<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>\n",
      "date_published": "2024-04-15T03:25:51.000Z",
      "date_modified": "2024-04-15T03:42:50.000Z",
      "authors": [],
      "tags": [
        "设计组件"
      ]
    },
    {
      "title": "反应器(Reactor)模式",
      "url": "https://ujava.cn/design/other/reactor.html",
      "id": "https://ujava.cn/design/other/reactor.html",
      "summary": "概述 Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。",
      "content_html": "<h2> 概述</h2>\n<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "读写锁模式",
      "url": "https://ujava.cn/design/other/readerwriterlock.html",
      "id": "https://ujava.cn/design/other/readerwriterlock.html",
      "summary": "概述 当访问数据结构模式时，常规锁不会区分“读锁”和“写锁” 由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。 众所周知，读写器锁的存在解决了这个问题 “多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成 并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者 正在修改或写入数据，并被取消阻止，直到写入程序完成写入。",
      "content_html": "<h2> 概述</h2>\n<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>\n由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>\n众所周知，读写器锁的存在解决了这个问题<br>\n“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>\n并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>\n正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "注册(Registry)模式",
      "url": "https://ujava.cn/design/other/registry.html",
      "id": "https://ujava.cn/design/other/registry.html",
      "summary": "概述 存储单个类的对象，并提供对它们的全局访问点。 与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。",
      "content_html": "<h2> 概述</h2>\n<p>存储单个类的对象，并提供对它们的全局访问点。<br>\n与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "存储库(Repository)模式",
      "url": "https://ujava.cn/design/other/repository.html",
      "id": "https://ujava.cn/design/other/repository.html",
      "summary": "概述 存储库层添加在域和数据映射层之间，以将域对象与 数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个 存储库模式在域类数量很大或很重的系统中特别有用 利用查询。",
      "content_html": "<h2> 概述</h2>\n<p>存储库层添加在域和数据映射层之间，以将域对象与<br>\n数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>\n存储库模式在域类数量很大或很重的系统中特别有用<br>\n利用查询。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "资源获取即初始化模式",
      "url": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "id": "https://ujava.cn/design/other/resourceacquisitioninit.html",
      "summary": "概述 资源获取即初始化模式可用于实现异常安全的资源管理。",
      "content_html": "<h2> 概述</h2>\n<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "重试(Retry)模式",
      "url": "https://ujava.cn/design/other/retry.html",
      "id": "https://ujava.cn/design/other/retry.html",
      "summary": "概述 透明地重试涉及与外部资源通信的某些操作， 特别是在网络上，将调用代码与重试实现细节隔离开来。",
      "content_html": "<h2> 概述</h2>\n<p>透明地重试涉及与外部资源通信的某些操作，<br>\n特别是在网络上，将调用代码与重试实现细节隔离开来。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "角色对象(Role Object)模式",
      "url": "https://ujava.cn/design/other/roleobject.html",
      "id": "https://ujava.cn/design/other/roleobject.html",
      "summary": "概述 通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色 对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为 单独的对象、不同的上下文是分开的，并且简化了系统配置。",
      "content_html": "<h2> 概述</h2>\n<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>\n对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>\n单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "事务(Saga)模式",
      "url": "https://ujava.cn/design/other/saga.html",
      "id": "https://ujava.cn/design/other/saga.html",
      "summary": "概述 这种模式用于分布式服务，以原子方式执行一组操作。 这是数据库中事务的模拟，但就微服务架构而言，这是执行的 在分布式环境中",
      "content_html": "<h2> 概述</h2>\n<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>\n这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>\n在分布式环境中</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分离接口模式",
      "url": "https://ujava.cn/design/other/separatedinterface.html",
      "id": "https://ujava.cn/design/other/separatedinterface.html",
      "summary": "概述 在不同的包中分离接口定义和实现。这允许客户端 完全不知道实现。",
      "content_html": "<h2> 概述</h2>\n<p>在不同的包中分离接口定义和实现。这允许客户端<br>\n完全不知道实现。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "序列化实体模式",
      "url": "https://ujava.cn/design/other/serializedentity.html",
      "id": "https://ujava.cn/design/other/serializedentity.html",
      "summary": "概述 序列化实体模式。 序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。",
      "content_html": "<h2> 概述</h2>\n<p>序列化实体模式。<br>\n序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "雇工(Servant)模式",
      "url": "https://ujava.cn/design/other/servant.html",
      "id": "https://ujava.cn/design/other/servant.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务层模式",
      "url": "https://ujava.cn/design/other/servicelayer.html",
      "id": "https://ujava.cn/design/other/servicelayer.html",
      "summary": "概述 Servant用于为一组类提供一些行为。 而不是在每个类中定义这种行为——或者当我们无法将其排除在外时 公共父类中的这种行为-它在Servant中定义过一次。",
      "content_html": "<h2> 概述</h2>\n<p>Servant用于为一组类提供一些行为。<br>\n而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>\n公共父类中的这种行为-它在Servant中定义过一次。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务定位模式",
      "url": "https://ujava.cn/design/other/servicelocator.html",
      "id": "https://ujava.cn/design/other/servicelocator.html",
      "summary": "概述 使用封装获取服务所涉及的过程 强抽象层。",
      "content_html": "<h2> 概述</h2>\n<p>使用封装获取服务所涉及的过程<br>\n强抽象层。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "服务工作者模式",
      "url": "https://ujava.cn/design/other/serviceworker.html",
      "id": "https://ujava.cn/design/other/serviceworker.html",
      "summary": "概述 将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。",
      "content_html": "<h2> 概述</h2>\n<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "分区(Sharding)模式",
      "url": "https://ujava.cn/design/other/sharding.html",
      "id": "https://ujava.cn/design/other/sharding.html",
      "summary": "概述 Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。 shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。",
      "content_html": "<h2> 概述</h2>\n<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>\nshard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "空间分区模式",
      "url": "https://ujava.cn/design/other/spatialpartition.html",
      "id": "https://ujava.cn/design/other/spatialpartition.html",
      "summary": "概述 正如《游戏编程模式》一书中所解释的那样 Bob Nystrom认为，空间分区模式通过将对象存储在 按位置组织的数据结构。",
      "content_html": "<h2> 概述</h2>\n<p>正如<a href=\"http://gameprogrammingpatterns.com/spatial-partition.html\" target=\"_blank\" rel=\"noopener noreferrer\">《游戏编程模式》</a>一书中所解释的那样<br>\nBob Nystrom认为，空间分区模式通过将对象存储在<br>\n按位置组织的数据结构。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "特殊例子模式",
      "url": "https://ujava.cn/design/other/specialcase.html",
      "id": "https://ujava.cn/design/other/specialcase.html",
      "summary": "概述 定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。",
      "content_html": "<h2> 概述</h2>\n<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "规范(Specification)模式",
      "url": "https://ujava.cn/design/other/specification.html",
      "id": "https://ujava.cn/design/other/specification.html",
      "summary": "概述 规范模式将如何匹配候选对象的语句与候选对象分开 与之匹配的。它不仅在选择中有用，而且对 验证和按订单建造。",
      "content_html": "<h2> 概述</h2>\n<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>\n与之匹配的。它不仅在选择中有用，而且对<br>\n验证和按订单建造。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "步骤建立者模式",
      "url": "https://ujava.cn/design/other/stepbuilder.html",
      "id": "https://ujava.cn/design/other/stepbuilder.html",
      "summary": "概述 Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。 用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。",
      "content_html": "<h2> 概述</h2>\n<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>\n用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "扼杀者(Strangler)模式",
      "url": "https://ujava.cn/design/other/strangler.html",
      "id": "https://ujava.cn/design/other/strangler.html",
      "summary": "概述 通过逐步替换特定的功能，逐步迁移遗留系统 新的应用程序和服务。随着旧系统的功能被替换 系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后 扼杀旧系统，让你退役。",
      "content_html": "<h2> 概述</h2>\n<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>\n新的应用程序和服务。随着旧系统的功能被替换<br>\n系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>\n扼杀旧系统，让你退役。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "子类沙盒模式",
      "url": "https://ujava.cn/design/other/subclasssandbox.html",
      "id": "https://ujava.cn/design/other/subclasssandbox.html",
      "summary": "概述 子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。",
      "content_html": "<h2> 概述</h2>\n<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "表模块(Table Module)模式",
      "url": "https://ujava.cn/design/other/tablemodule.html",
      "id": "https://ujava.cn/design/other/tablemodule.html",
      "summary": "概述 表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。",
      "content_html": "<h2> 概述</h2>\n<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T06:36:55.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "模版方法模式",
      "url": "https://ujava.cn/design/other/templatemethod.html",
      "id": "https://ujava.cn/design/other/templatemethod.html",
      "summary": "概述 在操作中定义算法的骨架，将一些步骤推迟到子类中。样板 方法允许子类在不更改算法的情况下重新定义算法的某些步骤 结构",
      "content_html": "<h2> 概述</h2>\n<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>\n方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>\n结构</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:22:04.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "本地线程存储模式",
      "url": "https://ujava.cn/design/other/threadlocalstorage.html",
      "id": "https://ujava.cn/design/other/threadlocalstorage.html",
      "summary": "概述 提供为每个线程提供一个变量副本的功能，使其线程安全。",
      "content_html": "<h2> 概述</h2>\n<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    },
    {
      "title": "线程池模式",
      "url": "https://ujava.cn/design/other/threadpool.html",
      "id": "https://ujava.cn/design/other/threadpool.html",
      "summary": "概述 通常情况下，要执行的任务是短暂的，并且任务数量很大。 为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁 线程而不是执行实际任务。线程池通过重用现有的 线程，并消除创建新线程的延迟。",
      "content_html": "<h2> 概述</h2>\n<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>\n为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>\n线程而不是执行实际任务。线程池通过重用现有的<br>\n线程，并消除创建新线程的延迟。</p>\n",
      "date_published": "2024-03-04T06:36:55.000Z",
      "date_modified": "2024-03-04T07:11:24.000Z",
      "authors": [],
      "tags": [
        "设计模式"
      ]
    }
  ]
}