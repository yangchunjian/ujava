import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as l,a as i,b as a,d as n,e as o}from"./app-8a5cd404.js";const g={},d=o('<h2 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h2><h3 id="内存管理主要做了什么" tabindex="-1"><a class="header-anchor" href="#内存管理主要做了什么" aria-hidden="true">#</a> 内存管理主要做了什么？</h3><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png" alt="内存管理主要做的事情" tabindex="0" loading="lazy"><figcaption>内存管理主要做的事情</figcaption></figure><p>操作系统的内存管理非常重要，主要负责下面这些事情：</p><ul><li><strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</li><li><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</li><li><strong>内存扩充</strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</li><li><strong>内存映射</strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</li><li><strong>内存优化</strong>：通过调整内存分配策略和回收算法来优化内存使用效率。</li><li><strong>内存安全</strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</li><li>......</li></ul><h3 id="什么是内存碎片" tabindex="-1"><a class="header-anchor" href="#什么是内存碎片" aria-hidden="true">#</a> 什么是内存碎片？</h3><p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：</p><ul><li><strong>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)</strong>：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。</li><li><strong>外部内存碎片(External Memory Fragmentation，简称为外部碎片)</strong>：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。</li></ul><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png" alt="内存碎片" tabindex="0" loading="lazy"><figcaption>内存碎片</figcaption></figure><p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。</p><h3 id="常见的内存管理方式有哪些" tabindex="-1"><a class="header-anchor" href="#常见的内存管理方式有哪些" aria-hidden="true">#</a> 常见的内存管理方式有哪些？</h3><p>内存管理方式可以简单分为下面两种：</p><ul><li><strong>连续内存管理</strong>：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。</li><li><strong>非连续内存管理</strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。</li></ul><h4 id="连续内存管理" tabindex="-1"><a class="header-anchor" href="#连续内存管理" aria-hidden="true">#</a> 连续内存管理</h4><p><strong>块式管理</strong> 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。</p><p>在 Linux 系统中，连续内存管理采用了 <strong>伙伴系统（Buddy System）算法</strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：<strong>必须是相邻的才是伙伴</strong>）。</p><p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。</p><p>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png" alt="伙伴系统（Buddy System）内存管理" tabindex="0" loading="lazy"><figcaption>伙伴系统（Buddy System）内存管理</figcaption></figure><p>虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 2^n 的内存块，因此当需要分配的内存大小不是 2^n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7=128 大小的内存块。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/buddy-system-memory-waste.png" alt="伙伴系统内存浪费问题" tabindex="0" loading="lazy"><figcaption>伙伴系统内存浪费问题</figcaption></figure><p>对于内部内存碎片的问题，Linux 采用 <strong>SLAB</strong> 进行解决。由于这部分内容不是本篇文章的重点，这里就不详细介绍了。</p><h4 id="非连续内存管理" tabindex="-1"><a class="header-anchor" href="#非连续内存管理" aria-hidden="true">#</a> 非连续内存管理</h4><p>非连续内存管理存在下面 3 种方式：</p><ul><li><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</li><li><strong>页式管理</strong>：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统广泛使用的一种内存管理方式。</li><li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</li></ul><h3 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h3><h4 id="什么是虚拟内存-有什么用" tabindex="-1"><a class="header-anchor" href="#什么是虚拟内存-有什么用" aria-hidden="true">#</a> 什么是虚拟内存?有什么用？</h4><p><strong>虚拟内存(Virtual Memory)</strong> 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。</p><figure><img src="https://oss.javaguide.cn/xingqiu/virtual-memory.png" alt="虚拟内存作为进程访问主存的桥梁" tabindex="0" loading="lazy"><figcaption>虚拟内存作为进程访问主存的桥梁</figcaption></figure><p>总结来说，虚拟内存主要提供了下面这些能力：</p><ul><li><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li><strong>多个进程共享物理内存</strong>：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><h4 id="没有虚拟内存有什么问题" tabindex="-1"><a class="header-anchor" href="#没有虚拟内存有什么问题" aria-hidden="true">#</a> 没有虚拟内存有什么问题？</h4><p>如果没有虚拟内存的话，程序直接访问和操作的都是物理内存，看似少了一层中介，但多了很多问题。</p><p><strong>具体有什么问题呢？</strong> 这里举几个例子说明(参考虚拟内存提供的能力回答这个问题)：</p><ol><li>用户程序可以访问任意物理内存，可能会不小心操作到系统运行必需的内存，进而造成操作系统崩溃，严重影响系统的安全。</li><li>同时运行多个程序容易崩溃。比如你想同时运行一个微信和一个 QQ 音乐，微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就可能会造成微信这个程序会崩溃。</li><li>程序运行过程中使用的所有数据或指令都要载入物理内存，根据局部性原理，其中很大一部分可能都不会用到，白白占用了宝贵的物理内存资源。</li><li>......</li></ol><h4 id="什么是虚拟地址和物理地址" tabindex="-1"><a class="header-anchor" href="#什么是虚拟地址和物理地址" aria-hidden="true">#</a> 什么是虚拟地址和物理地址？</h4><p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p><p>也就是说，我们编程开发的时候实际就是在和虚拟地址打交道。比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的虚拟地址。</p><p>操作系统一般通过 CPU 芯片中的一个重要组件 <strong>MMU(Memory Management Unit，内存管理单元)</strong> 将虚拟地址转换为物理地址，这个过程被称为 <strong>地址翻译/地址转换（Address Translation）</strong> 。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png" alt="地址翻译过程" tabindex="0" loading="lazy"><figcaption>地址翻译过程</figcaption></figure><p>通过 MMU 将虚拟地址转换为物理地址后，再通过总线传到物理内存设备，进而完成相应的物理内存读写请求。</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种: <strong>分段机制</strong> 和 <strong>分页机制</strong> 。</p><h4 id="什么是虚拟地址空间和物理地址空间" tabindex="-1"><a class="header-anchor" href="#什么是虚拟地址空间和物理地址空间" aria-hidden="true">#</a> 什么是虚拟地址空间和物理地址空间？</h4><ul><li>虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。</li><li>物理地址空间是物理地址的集合，是物理内存的范围。</li></ul><h4 id="虚拟地址与物理内存地址是如何映射的" tabindex="-1"><a class="header-anchor" href="#虚拟地址与物理内存地址是如何映射的" aria-hidden="true">#</a> 虚拟地址与物理内存地址是如何映射的？</h4><p>MMU 将虚拟地址翻译为物理地址的主要机制有 3 种:</p><ol><li>分段机制</li><li>分页机制</li><li>段页机制</li></ol><p>其中，现代操作系统广泛采用分页机制，需要重点关注！</p><h3 id="分段机制" tabindex="-1"><a class="header-anchor" href="#分段机制" aria-hidden="true">#</a> 分段机制</h3><p><strong>分段机制（Segmentation）</strong> 以段(—段 <strong>连续</strong> 的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。</p><h4 id="段表有什么用-地址翻译过程是怎样的" tabindex="-1"><a class="header-anchor" href="#段表有什么用-地址翻译过程是怎样的" aria-hidden="true">#</a> 段表有什么用？地址翻译过程是怎样的？</h4><p>分段管理通过 <strong>段表（Segment Table）</strong> 映射虚拟地址和物理地址。</p><p>分段机制下的虚拟地址由两部分组成：</p><ul><li><strong>段号</strong>：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。</li><li><strong>段内偏移量</strong>：相对于该段起始地址的偏移量。</li></ul><p>具体的地址翻译过程如下：</p><ol><li>MMU 首先解析得到虚拟地址中的段号；</li><li>通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）；</li><li>从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。</li></ol><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png" alt="分段机制下的地址翻译过程" tabindex="0" loading="lazy"><figcaption>分段机制下的地址翻译过程</figcaption></figure><p>段表中还存有诸如段长(可用于检查虚拟地址是否超出合法范围)、段类型（该段的类型，例如代码段、数据段等）等信息。</p><p><strong>通过段号一定要找到对应的段表项吗？得到最终的物理地址后对应的物理内存一定存在吗？</strong></p><p>不一定。段表项可能并不存在：</p><ul><li><strong>段表项被删除</strong>：软件错误、软件恶意行为等情况可能会导致段表项被删除。</li><li><strong>段表项还未创建</strong>：如果系统内存不足或者无法分配到连续的物理内存块就会导致段表项无法被创建。</li></ul><h4 id="分段机制为什么会导致内存外部碎片" tabindex="-1"><a class="header-anchor" href="#分段机制为什么会导致内存外部碎片" aria-hidden="true">#</a> 分段机制为什么会导致内存外部碎片？</h4><p>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。从而造成物理内存资源利用率的降低。</p><p>举个例子：假设可用物理内存为 5G 的系统使用分段机制分配内存。现在有 4 个进程，每个进程的内存占用情况如下：</p><ul><li>进程 1：0~1G（第 1 段）</li><li>进程 2：1~3G（第 2 段）</li><li>进程 3：3~4.5G（第 3 段）</li><li>进程 4：4.5~5G（第 4 段）</li></ul><p>此时，我们关闭了进程 1 和进程 4，则第 1 段和第 4 段的内存会被释放，空闲物理内存还有 1.5G。由于这 1.5G 物理内存并不是连续的，导致没办法将空闲的物理内存分配给一个需要 1.5G 物理内存的进程。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-external-memory-fragmentation.png" alt="分段机制导致外部内存碎片" tabindex="0" loading="lazy"><figcaption>分段机制导致外部内存碎片</figcaption></figure><h3 id="分页机制" tabindex="-1"><a class="header-anchor" href="#分页机制" aria-hidden="true">#</a> 分页机制</h3><p><strong>分页机制（Paging）</strong> 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p><p><strong>注意：这里的页是连续等长的，不同于分段机制下不同长度的段。</strong></p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p><h4 id="页表有什么用-地址翻译过程是怎样的" tabindex="-1"><a class="header-anchor" href="#页表有什么用-地址翻译过程是怎样的" aria-hidden="true">#</a> 页表有什么用？地址翻译过程是怎样的？</h4><p>分页管理通过 <strong>页表（Page Table）</strong> 映射虚拟地址和物理地址。我这里画了一张基于单级页表进行地址翻译的示意图。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table.png" alt="单级页表" tabindex="0" loading="lazy"><figcaption>单级页表</figcaption></figure><p>在分页机制下，每个应用程序都会有一个对应的页表。</p><p>分页机制下的虚拟地址由两部分组成：</p><ul><li><strong>页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li><li><strong>页内偏移量</strong>：物理页起始地址+页内偏移量=物理内存地址。</li></ul><p>具体的地址翻译过程如下：</p><ol><li>MMU 首先解析得到虚拟地址中的虚拟页号；</li><li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；</li><li>用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。</li></ol><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png" alt="分页机制下的地址翻译过程" tabindex="0" loading="lazy"><figcaption>分页机制下的地址翻译过程</figcaption></figure><p>页表中还存有诸如访问标志（标识该页面有没有被访问过）、脏数据标识位等信息。</p><p><strong>通过虚拟页号一定要找到对应的物理页号吗？找到了物理页号得到最终的物理地址后对应的物理页一定存在吗？</strong></p><p>不一定！可能会存在 <strong>页缺失</strong> 。也就是说，物理内存中没有对应的物理页或者物理内存中有对应的物理页但虚拟页还未和物理页建立映射（对应的页表项不存在）。关于页缺失的内容，后面会详细介绍到。</p><h4 id="单级页表有什么问题-为什么需要多级页表" tabindex="-1"><a class="header-anchor" href="#单级页表有什么问题-为什么需要多级页表" aria-hidden="true">#</a> 单级页表有什么问题？为什么需要多级页表？</h4><p>以 32 位的环境为例，虚拟地址空间范围共有 2^32（4G）。假设 一个页的大小是 2^12（4KB），那页表项共有 4G / 4K = 2^20 个。每个页表项为一个地址，占用 4 字节，2^20 * 2^2/1024*1024= 4MB。也就是说一个程序啥都不干，页表大小就得占用 4M。</p><p>系统运行的应用程序多起来的话，页表的开销还是非常大的。而且，绝大部分应用程序可能只能用到页表中的几项，其他的白白浪费了。</p><p>为了解决这个问题，操作系统引入了 <strong>多级页表</strong> ，多级页表对应多个页表，每个页表也前一个页表相关联。32 位系统一般为二级页表，64 位系统一般为四级页表。</p><p>这里以二级页表为例进行介绍：二级列表分为一级页表和二级页表。一级页表共有 1024 个页表项，一级页表又关联二级页表，二级页表同样共有 1024 个页表项。二级页表中的一级页表项是一对多的关系，二级页表按需加载（只会用到很少一部分二级页表），进而节省空间占用。</p><p>假设只需要 2 个二级页表，那两级页表的内存占用情况为: 4KB（一级页表占用） + 4KB * 2（二级页表占用） = 12 KB。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/multilevel-page-table.png" alt="多级页表" tabindex="0" loading="lazy"><figcaption>多级页表</figcaption></figure><p>多级页表属于时间换空间的典型场景，利用增加页表查询的次数减少页表占用的空间。</p><h4 id="tlb-有什么用-使用-tlb-之后的地址翻译流程是怎样的" tabindex="-1"><a class="header-anchor" href="#tlb-有什么用-使用-tlb-之后的地址翻译流程是怎样的" aria-hidden="true">#</a> TLB 有什么用？使用 TLB 之后的地址翻译流程是怎样的？</h4><p>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>转址旁路缓存(Translation Lookasjde Buffer，TLB，也被称为快表)</strong> 。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation-mmu.png" alt="加入 TLB 之后的地址翻译" tabindex="0" loading="lazy"><figcaption>加入 TLB 之后的地址翻译</figcaption></figure><p>在主流的 AArch64 和 x86-64 体系结构下，TLB 属于 (Memory Management Unit，内存管理单元) 内部的单元，本质上就是一块高速缓存（Cache），缓存了虚拟页号到物理页号的映射关系，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表。</p><p>使用 TLB 之后的地址翻译流程是这样的：</p><ol><li>用虚拟地址中的虚拟页号作为 key 去 TLB 中查询；</li><li>如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。</li><li>如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。</li><li>当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/page-table-tlb.png" alt="使用 TLB 之后的地址翻译流程" tabindex="0" loading="lazy"><figcaption>使用 TLB 之后的地址翻译流程</figcaption></figure><p>由于页表也在主存中，因此在没有 TLB 之前，每次读写内存数据时 CPU 要访问两次主存。有了 TLB 之后，对于存在于 TLB 中的页表数据只需要访问一次主存即可。</p><p>TLB 的设计思想非常简单，但命中率往往非常高，效果很好。这就是因为被频繁访问的页就是其中的很小一部分。</p><p>看完了之后你会发现快表和我们平时经常在开发系统中使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p><h4 id="换页机制有什么用" tabindex="-1"><a class="header-anchor" href="#换页机制有什么用" aria-hidden="true">#</a> 换页机制有什么用？</h4><p>换页机制的思想是当物理内存不够用的时候，操作系统选择将一些物理页的内容放到磁盘上去，等要用到的时候再将它们读取到物理内存中。也就是说，换页机制利用磁盘这种较低廉的存储设备扩展的物理内存。</p><p>这也就解释了一个日常使用电脑常见的问题：为什么操作系统中所有进程运行所需的物理内存即使比真实的物理内存要大一些，这些进程也是可以正常运行的，只是运行速度会变慢。</p><p>这同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的物理内存空间来支持程序的运行。</p><h4 id="什么是页缺失" tabindex="-1"><a class="header-anchor" href="#什么是页缺失" aria-hidden="true">#</a> 什么是页缺失？</h4><p>根据维基百科:</p><blockquote><p>页缺失（Page Fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断。</p></blockquote><p>常见的页缺失有下面这两种：</p><ul><li><strong>硬性页缺失（Hard Page Fault）</strong>：物理内存中没有对应的物理页。于是，Page Fault Handler 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。</li><li><strong>软性页缺失（Soft Page Fault）</strong>：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Handler 会指示 MMU 建立相应的虚拟页和物理页的映射关系。</li></ul><p>发生上面这两种缺页错误的时候，应用程序访问的是有效的物理内存，只是出现了物理页缺失或者虚拟页和物理页的映射关系未建立的问题。如果应用程序访问的是无效的物理内存的话，还会出现 <strong>无效缺页错误（Invalid Page Fault）</strong> 。</p><h4 id="常见的页面置换算法有哪些" tabindex="-1"><a class="header-anchor" href="#常见的页面置换算法有哪些" aria-hidden="true">#</a> 常见的页面置换算法有哪些?</h4><p>当发生硬性页缺失时，如果物理内存中没有空闲的物理页面可用的话。操作系统就必须将物理内存中的一个物理页淘汰出去，这样就可以腾出空间来加载新的页面了。</p><p>用来选择淘汰哪一个物理页的规则叫做 <strong>页面置换算法</strong> ，我们可以把页面置换算法看成是淘汰物物理页的规则。</p><p>页缺失太频繁的发生会非常影响性能，一个好的页面置换算法应该是可以减少页缺失出现的次数。</p><p>常见的页面置换算法有下面这 5 种（其他还有很多页面置换算法都是基于这些算法改进得来的）：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/image-20230409113009139.png" alt="常见的页面置换算法" tabindex="0" loading="lazy"><figcaption>常见的页面置换算法</figcaption></figure><ol><li><strong>最佳页面置换算法（OPT，Optimal）</strong>：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。</li><li><strong>先进先出页面置换算法（FIFO，First In First Out）</strong> : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。</li><li><strong>最近最久未使用页面置换算法（LRU ，Least Recently Used）</strong>：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。</li><li><strong>最少使用页面置换算法（LFU，Least Frequently Used）</strong> : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。</li><li><strong>时钟页面置换算法（Clock）</strong>：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。</li></ol><p><strong>FIFO 页面置换算法性能为何不好？</strong></p><p>主要原因主要有二：</p><ol><li><strong>经常访问或者需要长期存在的页面会被频繁调入调出</strong>：较早调入的页往往是经常被访问或者需要长期存在的页，这些页会被反复调入和调出。</li><li><strong>存在 Belady 现象</strong>：被置换的页面并不是进程不会访问的，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。出现该异常的原因是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面访问的频率和紧迫性。</li></ol><p><strong>哪一种页面置换算法实际用的比较多？</strong></p><p>LRU 算法是实际使用中应用的比较多，也被认为是最接近 OPT 的页面置换算法。</p><p>不过，需要注意的是，实际应用中这些算法会被做一些改进，就比如 InnoDB Buffer Pool（ InnoDB 缓冲池，MySQL 数据库中用于管理缓存页面的机制）就改进了传统的 LRU 算法，使用了一种称为&quot;Adaptive LRU&quot;的算法（同时结合了 LRU 和 LFU 算法的思想）。</p><h3 id="分页机制和分段机制有哪些共同点和区别" tabindex="-1"><a class="header-anchor" href="#分页机制和分段机制有哪些共同点和区别" aria-hidden="true">#</a> 分页机制和分段机制有哪些共同点和区别？</h3><p><strong>共同点</strong>：</p><ul><li>都是非连续内存管理的方式。</li><li>都采用了地址映射的方法，将虚拟地址映射到物理地址，以实现对内存的管理和保护。</li></ul><p><strong>区别</strong>：</p><ul><li>分页机制以页面为单位进行内存管理，而分段机制以段为单位进行内存管理。页的大小是固定的，由操作系统决定，通常为 2 的幂次方。而段的大小不固定，取决于我们当前运行的程序。</li><li>页是物理单位，即操作系统将物理内存划分成固定大小的页面，每个页面的大小通常是 2 的幂次方，例如 4KB、8KB 等等。而段则是逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。</li><li>分段机制容易出现外部内存碎片，即在段与段之间留下碎片空间(不足以映射给虚拟地址空间中的段)。分页机制解决了外部内存碎片的问题，但仍然可能会出现内部内存碎片。</li><li>分页机制采用了页表来完成虚拟地址到物理地址的映射，页表通过一级页表和二级页表来实现多级映射；而分段机制则采用了段表来完成虚拟地址到物理地址的映射，每个段表项中记录了该段的起始地址和长度信息。</li><li>分页机制对程序没有任何要求，程序只需要按照虚拟地址进行访问即可；而分段机制需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段。</li></ul><h3 id="段页机制" tabindex="-1"><a class="header-anchor" href="#段页机制" aria-hidden="true">#</a> 段页机制</h3><p>结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。</p><p>在段页式机制下，地址翻译的过程分为两个步骤：</p><ol><li>段式地址映射。</li><li>页式地址映射。</li></ol><h3 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理" aria-hidden="true">#</a> 局部性原理</h3><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 <strong>局部性原理（Locality Principle）</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p><p>局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p><p>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：</p><ul><li><strong>时间局部性</strong>：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。</li><li><strong>空间局部性</strong>：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。</li></ul><p>总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p><h2 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统" aria-hidden="true">#</a> 文件系统</h2><h3 id="文件系统主要做了什么" tabindex="-1"><a class="header-anchor" href="#文件系统主要做了什么" aria-hidden="true">#</a> 文件系统主要做了什么？</h3><p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：</p><ol><li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</li><li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li><li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li><li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。</li></ol><h3 id="硬链接和软链接有什么区别" tabindex="-1"><a class="header-anchor" href="#硬链接和软链接有什么区别" aria-hidden="true">#</a> 硬链接和软链接有什么区别？</h3><p>在 Linux/类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：</p><p><strong>1、硬链接（Hard Link）</strong></p><ul><li>在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li><li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li><li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li><li><code>ln</code> 命令用于创建硬链接。</li></ul><p><strong>2、软链接（Symbolic Link 或 Symlink）</strong></p><ul><li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li><li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li><li>软连接类似于 Windows 系统中的快捷方式。</li><li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li><li><code>ln -s</code> 命令用于创建软链接。</li></ul><h3 id="硬链接为什么不能跨文件系统" tabindex="-1"><a class="header-anchor" href="#硬链接为什么不能跨文件系统" aria-hidden="true">#</a> 硬链接为什么不能跨文件系统？</h3><p>我们之前提到过，硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。</p><p>然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</p><h3 id="提高文件系统性能的方式有哪些" tabindex="-1"><a class="header-anchor" href="#提高文件系统性能的方式有哪些" aria-hidden="true">#</a> 提高文件系统性能的方式有哪些？</h3><ul><li><strong>优化硬件</strong>：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li><li><strong>选择合适的文件系统选型</strong>：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li><li><strong>运用缓存</strong>：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li><li><strong>避免磁盘过度使用</strong>：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li><li><strong>对磁盘进行合理的分区</strong>：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li></ul><h3 id="常见的磁盘调度算法有哪些" tabindex="-1"><a class="header-anchor" href="#常见的磁盘调度算法有哪些" aria-hidden="true">#</a> 常见的磁盘调度算法有哪些？</h3><p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p><p>一次磁盘读写操作的时间由磁盘寻道/寻找时间、延迟时间和传输时间决定。磁盘调度算法可以通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间。</p><p>常见的磁盘调度算法有下面这 6 种（其他还有很多磁盘调度算法都是基于这些算法改进得来的）：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/disk-scheduling-algorithms.png" alt="常见的磁盘调度算法" tabindex="0" loading="lazy"><figcaption>常见的磁盘调度算法</figcaption></figure><ol><li><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li><li><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li><li><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li><li><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</li><li><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</li><li><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</li></ol><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',161),p=i("li",null,"《计算机操作系统—汤小丹》第四版",-1),h=i("li",null,"《深入理解计算机系统》",-1),c=i("li",null,"《重学操作系统》",-1),u=i("li",null,"《现代操作系统原理与实现》",-1),f={href:"https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/qq_44272681/article/details/124199068",target:"_blank",rel:"noopener noreferrer"},m={href:"https://draveness.me/whys-the-design-os-virtual-memory/",target:"_blank",rel:"noopener noreferrer"},x={href:"https://liam.page/2017/09/01/page-fault/",target:"_blank",rel:"noopener noreferrer"},y={href:"https://juejin.cn/post/6844903507594575886",target:"_blank",rel:"noopener noreferrer"};function L(v,B){const t=r("ExternalLinkIcon");return s(),l("div",null,[d,i("ul",null,[p,h,c,u,i("li",null,[a("王道考研操作系统知识点整理："),i("a",f,[a("https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html"),n(t)])]),i("li",null,[a("内存管理之伙伴系统与 SLAB："),i("a",b,[a("https://blog.csdn.net/qq_44272681/article/details/124199068"),n(t)])]),i("li",null,[a("为什么 Linux 需要虚拟内存："),i("a",m,[a("https://draveness.me/whys-the-design-os-virtual-memory/"),n(t)])]),i("li",null,[a("程序员的自我修养（七）：内存缺页错误："),i("a",x,[a("https://liam.page/2017/09/01/page-fault/"),n(t)])]),i("li",null,[a("虚拟内存的那点事儿："),i("a",y,[a("https://juejin.cn/post/6844903507594575886"),n(t)])])])])}const T=e(g,[["render",L],["__file","operating-system-basic-questions-02.html.vue"]]);export{T as default};
