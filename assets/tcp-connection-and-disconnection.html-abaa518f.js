import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as s,c as l,a as t,b as n,d as r,e as o}from"./app-8a5cd404.js";const c={},g=o('<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><h2 id="建立连接-tcp-三次握手" tabindex="-1"><a class="header-anchor" href="#建立连接-tcp-三次握手" aria-hidden="true">#</a> 建立连接-TCP 三次握手</h2><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解" tabindex="0" loading="lazy"><figcaption>TCP 三次握手图解</figcaption></figure><p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p><ul><li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li><strong>三次握手</strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li></ul><p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p><h3 id="为什么要三次握手" tabindex="-1"><a class="header-anchor" href="#为什么要三次握手" aria-hidden="true">#</a> 为什么要三次握手?</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><ol><li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><p>三次握手就能确认双方收发功能都正常，缺一不可。</p>',10),d={href:"https://www.zhihu.com/question/24853633/answer/115173386",target:"_blank",rel:"noopener noreferrer"},h=o('<h3 id="第-2-次握手传回了-ack-为什么还要传回-syn" tabindex="-1"><a class="header-anchor" href="#第-2-次握手传回了-ack-为什么还要传回-syn" aria-hidden="true">#</a> 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="断开连接-tcp-四次挥手" tabindex="-1"><a class="header-anchor" href="#断开连接-tcp-四次挥手" aria-hidden="true">#</a> 断开连接-TCP 四次挥手</h2><figure><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解" tabindex="0" loading="lazy"><figcaption>TCP 四次挥手图解</figcaption></figure><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p><ol><li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后，此时服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li><li><strong>第三次挥手</strong>：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入 <strong>LAST-ACK</strong> 状态。</li><li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h3 id="为什么要四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么要四次挥手" aria-hidden="true">#</a> 为什么要四次挥手？</h3><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ol><li><strong>第一次挥手</strong>：A 说“我没啥要说的了”</li><li><strong>第二次挥手</strong>：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li><strong>第四次挥手</strong>：A 回答“知道了”，这样通话才算结束。</li></ol><h3 id="为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手" tabindex="-1"><a class="header-anchor" href="#为什么不能把服务器发送的-ack-和-fin-合并起来-变成三次挥手" aria-hidden="true">#</a> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h3 id="如果第二次挥手时服务器的-ack-没有送达客户端-会怎样" tabindex="-1"><a class="header-anchor" href="#如果第二次挥手时服务器的-ack-没有送达客户端-会怎样" aria-hidden="true">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h3 id="为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态" tabindex="-1"><a class="header-anchor" href="#为什么第四次挥手客户端需要等待-2-msl-报文段最长寿命-时间后才进入-closed-状态" aria-hidden="true">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></blockquote><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>',20),p=t("li",null,[t("p",null,"《计算机网络（第 7 版）》")],-1),C=t("li",null,[t("p",null,"《图解 HTTP》")],-1),u={href:"https://www.9tut.com/tcp-and-udp-tutorial",target:"_blank",rel:"noopener noreferrer"};function A(S,f){const e=i("ExternalLinkIcon");return s(),l("div",null,[g,t("p",null,[n("更详细的解答可以看这个："),t("a",d,[n("TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎"),r(e)]),n(" 。")]),h,t("ul",null,[p,C,t("li",null,[t("p",null,[n("TCP and UDP Tutorial："),t("a",u,[n("https://www.9tut.com/tcp-and-udp-tutorial"),r(e)])])])])])}const N=a(c,[["render",A],["__file","tcp-connection-and-disconnection.html.vue"]]);export{N as default};
