import{_ as e,c as t,a as n,o as r}from"./app-CDjra8Lf.js";const i={};function s(p,a){return r(),t("div",null,a[0]||(a[0]=[n('<h4 id="_1-【强制】好的单元测试必须遵守-air-原则。" tabindex="-1"><a class="header-anchor" href="#_1-【强制】好的单元测试必须遵守-air-原则。"><span>1.【强制】好的单元测试必须遵守 AIR 原则。</span></a></h4><p>说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p><ul><li>⚫ A：Automatic（自动化）</li><li>⚫ I：Independent（独立性）</li><li>⚫ R：Repeatable（可重复）</li></ul><h4 id="_2-【强制】单元测试应该是全自动执行的-并且非交互式的。测试用例通常是被定期执行的-执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用-system-out-来进行人肉验证-单元测试必须使用-assert-来验证。" tabindex="-1"><a class="header-anchor" href="#_2-【强制】单元测试应该是全自动执行的-并且非交互式的。测试用例通常是被定期执行的-执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用-system-out-来进行人肉验证-单元测试必须使用-assert-来验证。"><span>2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用 System.out 来进行人肉验证，单元测试必须使用 assert 来验证。</span></a></h4><h4 id="_3-【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护-单元测试用例之间决不能互相调用-也不能依赖执行的先后次序。" tabindex="-1"><a class="header-anchor" href="#_3-【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护-单元测试用例之间决不能互相调用-也不能依赖执行的先后次序。"><span>3.【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</span></a></h4><p>反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p><h4 id="_4-【强制】单元测试是可以重复执行的-不能受到外界环境的影响。" tabindex="-1"><a class="header-anchor" href="#_4-【强制】单元测试是可以重复执行的-不能受到外界环境的影响。"><span>4.【强制】单元测试是可以重复执行的，不能受到外界环境的影响。</span></a></h4><p>说明：单元测试通常会被放到持续集成中，每次有代码 push 时单元测试都会被执行。如果单测对外部环境（网络、服 务、中间件等）有依赖，容易导致持续集成机制的不可用。</p><p>正例：为了不受外界环境影响，要求设计代码时就把 SUT（Software under test）的依赖改成注入，在测试时用 Spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。</p><h4 id="_5-【强制】对于单元测试-要保证测试粒度足够小-有助于精确定位问题。单测粒度至多是类级别-一般是方法级别。" tabindex="-1"><a class="header-anchor" href="#_5-【强制】对于单元测试-要保证测试粒度足够小-有助于精确定位问题。单测粒度至多是类级别-一般是方法级别。"><span>5.【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</span></a></h4><p>说明：测试粒度小才能在出错时尽快定位到出错的位置。单元测试不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p><h4 id="_6-【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。" tabindex="-1"><a class="header-anchor" href="#_6-【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。"><span>6.【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。</span></a></h4><p>说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p><h4 id="_7-【强制】单元测试代码必须写在如下工程目录-src-test-java-不允许写在业务代码目录下。" tabindex="-1"><a class="header-anchor" href="#_7-【强制】单元测试代码必须写在如下工程目录-src-test-java-不允许写在业务代码目录下。"><span>7.【强制】单元测试代码必须写在如下工程目录： src/test/java，不允许写在业务代码目录下。</span></a></h4><p>说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。</p><h4 id="_8-【推荐】单测的基本目标-语句覆盖率达到-70-核心模块的语句覆盖率和分支覆盖率都要达到-100" tabindex="-1"><a class="header-anchor" href="#_8-【推荐】单测的基本目标-语句覆盖率达到-70-核心模块的语句覆盖率和分支覆盖率都要达到-100"><span>8.【推荐】单测的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%</span></a></h4><p>说明：在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元测试。</p><h4 id="_9-【推荐】编写单元测试代码遵守-bcde-原则-以保证被测试模块的交付质量。" tabindex="-1"><a class="header-anchor" href="#_9-【推荐】编写单元测试代码遵守-bcde-原则-以保证被测试模块的交付质量。"><span>9.【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</span></a></h4><ul><li>⚫ B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li>⚫ C：Correct，正确的输入，并得到预期的结果。</li><li>⚫ D：Design，与设计文档相结合，来编写单元测试。</li><li>⚫ E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li></ul><h4 id="_10-【推荐】对于数据库相关的查询-更新-删除等操作-不能假设数据库里的数据是存在的-或者直接操作数据库把数据插入进去-请使用程序插入或者导入数据的方式来准备数据。" tabindex="-1"><a class="header-anchor" href="#_10-【推荐】对于数据库相关的查询-更新-删除等操作-不能假设数据库里的数据是存在的-或者直接操作数据库把数据插入进去-请使用程序插入或者导入数据的方式来准备数据。"><span>10.【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</span></a></h4><p>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。</p><h4 id="_11-【推荐】和数据库相关的单元测试-可以设定自动回滚机制-不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。" tabindex="-1"><a class="header-anchor" href="#_11-【推荐】和数据库相关的单元测试-可以设定自动回滚机制-不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。"><span>11.【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</span></a></h4><p>正例：在基础技术部的内部单元测试中，使用 FOUNDATION_UNIT_TEST_的前缀来标识单元测试相关代码。</p><h4 id="_12-【推荐】对于不可测的代码在适当的时机做必要的重构-使代码变得可测避免为了达到测试要求而书写不规范测试代码。" tabindex="-1"><a class="header-anchor" href="#_12-【推荐】对于不可测的代码在适当的时机做必要的重构-使代码变得可测避免为了达到测试要求而书写不规范测试代码。"><span>12.【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测避免为了达到测试要求而书写不规范测试代码。</span></a></h4><h4 id="_13-【推荐】在设计评审阶段-开发人员需要和测试人员一起确定单元测试范围-单元测试最好覆盖所有测试用例-uc-。" tabindex="-1"><a class="header-anchor" href="#_13-【推荐】在设计评审阶段-开发人员需要和测试人员一起确定单元测试范围-单元测试最好覆盖所有测试用例-uc-。"><span>13.【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。</span></a></h4><h4 id="_14-【推荐】单元测试作为一种质量保障手段-在项目提测前完成单元测试-不建议项目发布后补充单元测试用例。" tabindex="-1"><a class="header-anchor" href="#_14-【推荐】单元测试作为一种质量保障手段-在项目提测前完成单元测试-不建议项目发布后补充单元测试用例。"><span>14.【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</span></a></h4><h4 id="_15-【参考】为了更方便地进行单元测试-业务代码应避免以下情况" tabindex="-1"><a class="header-anchor" href="#_15-【参考】为了更方便地进行单元测试-业务代码应避免以下情况"><span>15.【参考】为了更方便地进行单元测试，业务代码应避免以下情况：</span></a></h4><ul><li>⚫ 构造方法中做的事情过多。</li><li>⚫ 存在过多的全局变量和静态方法。</li><li>⚫ 存在过多的外部依赖。</li><li>⚫ 存在过多的条件语句。</li></ul><p>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p><h4 id="_16-【参考】不要对单元测试存在如下误解" tabindex="-1"><a class="header-anchor" href="#_16-【参考】不要对单元测试存在如下误解"><span>16.【参考】不要对单元测试存在如下误解：</span></a></h4><ul><li>⚫ 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li><li>⚫ 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li><li>⚫ 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li><li>⚫ 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li></ul>',31)]))}const l=e(i,[["render",s],["__file","unit.html.vue"]]),d=JSON.parse('{"path":"/standard/unit.html","title":"规范测试","lang":"zh-CN","frontmatter":{"title":"规范测试","icon":"laptop-code","category":["设计规范"],"tag":["规范"],"description":"1.【强制】好的单元测试必须遵守 AIR 原则。 说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 ⚫ A：Automatic（自动化） ⚫ I：Independent（独立性） ⚫ R：Repeatable（可重复） 2.【强制】单元测试...","head":[["meta",{"property":"og:url","content":"https://ujava.cn/standard/unit.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"规范测试"}],["meta",{"property":"og:description","content":"1.【强制】好的单元测试必须遵守 AIR 原则。 说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 ⚫ A：Automatic（自动化） ⚫ I：Independent（独立性） ⚫ R：Repeatable（可重复） 2.【强制】单元测试..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-15T03:32:25.000Z"}],["meta",{"property":"article:tag","content":"规范"}],["meta",{"property":"article:modified_time","content":"2024-04-15T03:32:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"规范测试\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-15T03:32:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1697614827000,"updatedTime":1713151945000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":6}]},"readingTime":{"minutes":4.9,"words":1469},"filePathRelative":"standard/unit.md","localizedDate":"2023年10月18日","excerpt":"<h4>1.【强制】好的单元测试必须遵守 AIR 原则。</h4>\\n<p>说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>\\n<ul>\\n<li>⚫ A：Automatic（自动化）</li>\\n<li>⚫ I：Independent（独立性）</li>\\n<li>⚫ R：Repeatable（可重复）</li>\\n</ul>\\n<h4>2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用 System.out 来进行人肉验证，单元测试必须使用 assert 来验证。</h4>","autoDesc":true}');export{l as comp,d as data};
