import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as t,e as n}from"./app-Dt_L4O6f.js";const a={};function r(p,l){return e(),t("div",null,l[0]||(l[0]=[n('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p><h2 id="一、微服务拆分的原则" tabindex="-1"><a class="header-anchor" href="#一、微服务拆分的原则"><span>一、微服务拆分的原则</span></a></h2><p>微服务拆分原则有以下几个：</p><ul><li>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</li><li>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</li><li>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</li><li>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</li><li>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</li><li>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</li><li>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</li><li>使用有界上下文。</li><li>确定核心域并保持竞争优势。</li><li>对通用域进行成本优化。</li><li>考虑支持领域。</li><li>引入反腐层。</li><li>识别数据通信模式。</li><li>引入事件驱动架构。</li><li>使API简洁明了。</li><li>将相关的微服务合并为更大的服务。</li><li>引入无缝开发支持工具。</li></ul><p><strong>不管是哪种拆分原则，目标都是需要将相同或相似的服务聚合在一起，形成一个独立的自治服务。</strong></p><h2 id="二、微服务拆分的时机" tabindex="-1"><a class="header-anchor" href="#二、微服务拆分的时机"><span>二、微服务拆分的时机</span></a></h2><p>并非所有公司都适合采用微服务架构，尤其是规模较小且业务相对固定的公司。对于这些公司来说，从服务层面，他们不会有更多变化，通过优化现有服务即可满足需求。从成本方面，构建微服务架构，需要很多资源和配套的中间件。因此，对于那些规模较大，业务服务复杂度高，同时业务也在不断更新或新增的项目，微服务架构则是非常适合的选择。</p><p>在确定使用微服务架构后，服务的拆分是一项重要任务。根据拆分原则，我们可以在恰当的时机进行服务拆分。然而，根据行业经验来看，并<strong>不建议在项目构建初期进行服务拆分</strong>。主要原因有以下几点：</p><ul><li>项目构建初期，服务单一，数据量较少，及时是单体系统都可以支撑业务。</li><li>项目构建初期，服务没有形成体系，更没有规模服务，很难做到微服务的单一职责和服务自治。</li><li>业务架构不够成熟，目前提供的服务，很有可能会优化，甚至更改技术栈重构。</li></ul><p>因此，项目构建初期无需将其拆分，因为强行拆分此时可能会产生适得其反的效果。而遇到下面这些情况就可以进行服务拆分了。</p><ul><li>项目足够成熟并且业务稳定，团队成员不断扩大并且目前的服务想要扩展很难。只有在项目成熟的情况下，业务专家才可以从精确的划分出业务领域，进而将各个服务分解到业务领域内，最终形成各自独立的微服务。</li><li></li></ul><p>项目要求CI/CD（持续集成/持续交付）。尤其是很多新兴的互联网公司，要求系统在尽可能不停机的情况下，还需要持续上线新的功能。使用敏捷开发，可以更好地让开发者在完成周期形的业务交付，而DevOps则可以将这些代码，进行自动化测试、构建和集成，不断的完成新的需求提交，并保证代码的质量和稳定性。</p><ul><li>正式运行的项目，部分服务需要停机。当上线一些有问题的服务时，将该部分服务停机，这个情况对单体应用是非常有困难的。而微服务架构中，可以对存在问题的微服务进行下线处理，从而达到快速解决问题的目的。</li></ul><h2 id="三、微服务拆分的方法" tabindex="-1"><a class="header-anchor" href="#三、微服务拆分的方法"><span>三、微服务拆分的方法</span></a></h2><p>在掌握了准确的微服务拆分时机和有了强有力的拆分原则后，拆分方法将成为下一个关键环节。现在微服务拆分的方法有很多种，常见的包括：</p><ul><li>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。</li><li>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。</li><li>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。</li><li>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。</li><li>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。</li></ul><p>从行业经验来看，可以确定领域驱动设计（Domain Driven Design，简称DDD）在微服务拆分方面具有显著优势。</p><ul><li>DDD是一种软件开发方法论，它强调将软件划分为不同的领域，每个领域都由一个核心模型驱动。</li><li>微服务架构的核心概念是将单一的应用程序拆分为一组小型、自治的服务。而DDD则提供了一种方法来设计这些微服务的边界和交互。</li><li>领域驱动设计引入了领域模型的概念，该模型描述了业务领域的核心概念和实体，而不关注技术实现细节。这使得团队可以专注于业务逻辑，而不被底层技术细节所干扰。</li><li>通过将领域模型作为微服务拆分的基础，可以确保每个微服务都是高内聚的，并且只关注自己领域内的业务逻辑。这种拆分方式使得每个微服务都能够独立开发、部署和维护，从而提高了系统的可伸缩性和可靠性。</li><li>此外，DDD还强调了领域驱动设计的语言在业务团队和开发团队之间的沟通和理解的重要性。通过共享统一的语言和概念，可以确保业务需求能够准确地传达给开发团队，并且开发团队能够将其转化为可行的技术解决方案。<br> 因此，DDD是一种非常适合成为微服务拆分的方法论。它能够帮助开发人员更好地理解业务需求，找到合适的服务边界，构建高质量的领域模型和微服务。</li></ul>',19)]))}const c=i(a,[["render",r],["__file","split.html.vue"]]),h=JSON.parse('{"path":"/synthesis/split.html","title":"微服务拆分原则","lang":"zh-CN","frontmatter":{"title":"微服务拆分原则","icon":"laptop-code","category":["设计高频"],"tag":["高频"],"description":"简介 微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。 一、微服务拆分的原则 微服务拆分原则有以下几个： 单一职责原则：每个微服务应该有一个...","head":[["meta",{"property":"og:url","content":"https://ujava.cn/synthesis/split.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"微服务拆分原则"}],["meta",{"property":"og:description","content":"简介 微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。 一、微服务拆分的原则 微服务拆分原则有以下几个： 单一职责原则：每个微服务应该有一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-27T13:05:13.000Z"}],["meta",{"property":"article:author","content":"UJava"}],["meta",{"property":"article:tag","content":"高频"}],["meta",{"property":"article:modified_time","content":"2024-04-27T13:05:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"微服务拆分原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-27T13:05:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"一、微服务拆分的原则","slug":"一、微服务拆分的原则","link":"#一、微服务拆分的原则","children":[]},{"level":2,"title":"二、微服务拆分的时机","slug":"二、微服务拆分的时机","link":"#二、微服务拆分的时机","children":[]},{"level":2,"title":"三、微服务拆分的方法","slug":"三、微服务拆分的方法","link":"#三、微服务拆分的方法","children":[]}],"git":{"createdTime":1713152570000,"updatedTime":1714223113000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":2}]},"readingTime":{"minutes":6.97,"words":2091},"filePathRelative":"synthesis/split.md","localizedDate":"2024年4月15日","excerpt":"<h2>简介</h2>\\n<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>\\n<h2>一、微服务拆分的原则</h2>\\n<p>微服务拆分原则有以下几个：</p>\\n<ul>\\n<li>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</li>\\n<li>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</li>\\n<li>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</li>\\n<li>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</li>\\n<li>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</li>\\n<li>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</li>\\n<li>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</li>\\n<li>使用有界上下文。</li>\\n<li>确定核心域并保持竞争优势。</li>\\n<li>对通用域进行成本优化。</li>\\n<li>考虑支持领域。</li>\\n<li>引入反腐层。</li>\\n<li>识别数据通信模式。</li>\\n<li>引入事件驱动架构。</li>\\n<li>使API简洁明了。</li>\\n<li>将相关的微服务合并为更大的服务。</li>\\n<li>引入无缝开发支持工具。</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};
