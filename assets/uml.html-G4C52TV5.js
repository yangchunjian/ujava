import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,e as i}from"./app-alMYtcyv.js";const e="/assets/img_19-MahVL_yv.png",p="/assets/img_18-dP0_RXg1.png",t="/assets/img_20-CttZVEwr.png",c="/assets/img_21-nNgK0B1X.png",l="/assets/img_22-5WFOQMl7.png",o="/assets/img_23-NUvoa2yW.png",u="/assets/img_24-uWKZE0a8.png",d={},r=i(`<h2 id="面向对象概念" tabindex="-1"><a class="header-anchor" href="#面向对象概念" aria-hidden="true">#</a> 面向对象概念</h2><p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。</p><p>它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p><h3 id="扩展-面向功能概念" tabindex="-1"><a class="header-anchor" href="#扩展-面向功能概念" aria-hidden="true">#</a> 扩展：面向功能概念</h3><p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p><p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p><p>结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p><p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p><ul><li>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。</li><li>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高</li></ul><h2 id="面向对象的三大特性" tabindex="-1"><a class="header-anchor" href="#面向对象的三大特性" aria-hidden="true">#</a> 面向对象的三大特性</h2><p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态</p><ul><li>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</li><li>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</li><li>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征<br> 注意：如果说是对象的四大特性，那么还需要把抽象加上</li></ul><p>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p><h2 id="封装" tabindex="-1"><a class="header-anchor" href="#封装" aria-hidden="true">#</a> 封装</h2><p>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</p><p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p><ul><li>隐藏类的实现细节；</li><li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li><li>可进行数据检查，从而有利于保证对象信息的完整性；</li><li>便于修改，提高代码的可维护性。</li></ul><h3 id="封装的实现" tabindex="-1"><a class="header-anchor" href="#封装的实现" aria-hidden="true">#</a> 封装的实现</h3><p>为了实现良好的封装，需要从两个方面考虑：</p><ul><li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；</li><li>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。<br> 封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</li></ul><h2 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h2><p>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><h3 id="继承的实现" tabindex="-1"><a class="header-anchor" href="#继承的实现" aria-hidden="true">#</a> 继承的实现</h3><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Animal</span> animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="c-和java继承区别" tabindex="-1"><a class="header-anchor" href="#c-和java继承区别" aria-hidden="true">#</a> C++和Java继承区别</h3><p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p><p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。</p><p>Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。</p><p>比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p><p>准确来说，Java是可以实现&quot;多继承&quot;的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><p>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征</p><p>因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p><p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass(); ，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p><h3 id="多态的实现" tabindex="-1"><a class="header-anchor" href="#多态的实现" aria-hidden="true">#</a> 多态的实现</h3><p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。</p><p>在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。</p><ul><li>对于父类型，可以有三种形式，即普通的类、抽象类、接口</li><li>对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法<br> 具体案例如下：</li></ul><p>多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。</p><p>例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token class-name">Car</span> car<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token class-name">Bus</span> bus<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token class-name">Truck</span> truck<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 driver.drive(obj) 这样的方式来调用，对调用者足够的友好。</p><p>但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。</p><p>当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，类似的代码会堆积的越来越多，显得臃肿。</p><p>采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vehicle子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token class-name">Vehicle</span> vehicle<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>
<span class="token keyword">void</span> <span class="token function">didi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Car</span> extend <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">void</span> <span class="token function">didi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Bus</span> extend <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">void</span> <span class="token function">didi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Truck</span> extend <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">void</span> <span class="token function">didi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="类-对象-之间的关系" tabindex="-1"><a class="header-anchor" href="#类-对象-之间的关系" aria-hidden="true">#</a> 类(对象)之间的关系</h2><h3 id="uml类图" tabindex="-1"><a class="header-anchor" href="#uml类图" aria-hidden="true">#</a> UML类图</h3><p>类之间的关系，类与接口之间关系可以分一下几种</p><ul><li>泛化关系(Generalization)</li><li>实现关系 (Realization)</li><li>聚合关系 (Aggregation)</li><li>组合关系 (Composition)</li><li>关联关系 (Association)</li><li>依赖关系 (Dependency)</li></ul><figure><img src="`+e+'" alt="img_19.png" tabindex="0" loading="lazy"><figcaption>img_19.png</figcaption></figure><h3 id="泛化关系-generalization" tabindex="-1"><a class="header-anchor" href="#泛化关系-generalization" aria-hidden="true">#</a> 泛化关系 (Generalization)</h3><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><figure><img src="'+p+'" alt="img_18.png" tabindex="0" loading="lazy"><figcaption>img_18.png</figcaption></figure><h3 id="实现关系-realization" tabindex="-1"><a class="header-anchor" href="#实现关系-realization" aria-hidden="true">#</a> 实现关系 (Realization)</h3><p>用来实现一个接口，在 Java 中使用 implement 关键字。</p><figure><img src="'+t+'" alt="img_20.png" tabindex="0" loading="lazy"><figcaption>img_20.png</figcaption></figure><h3 id="聚合关系-aggregation" tabindex="-1"><a class="header-anchor" href="#聚合关系-aggregation" aria-hidden="true">#</a> 聚合关系 (Aggregation)</h3><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><figure><img src="'+c+'" alt="img_21.png" tabindex="0" loading="lazy"><figcaption>img_21.png</figcaption></figure><h3 id="组合关系-composition" tabindex="-1"><a class="header-anchor" href="#组合关系-composition" aria-hidden="true">#</a> 组合关系 (Composition)</h3><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。<br><img src="'+l+'" alt="img_22.png" loading="lazy"></p><h3 id="关联关系-association" tabindex="-1"><a class="header-anchor" href="#关联关系-association" aria-hidden="true">#</a> 关联关系 (Association)</h3><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。</p><p>因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><figure><img src="'+o+'" alt="img_23.png" tabindex="0" loading="lazy"><figcaption>img_23.png</figcaption></figure><h3 id="依赖关系-dependency" tabindex="-1"><a class="header-anchor" href="#依赖关系-dependency" aria-hidden="true">#</a> 依赖关系 (Dependency)</h3><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。</p><p>A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类中的(某中方法的)局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li></ul><figure><img src="'+u+'" alt="img_24.png" tabindex="0" loading="lazy"><figcaption>img_24.png</figcaption></figure>',75),k=[r];function h(v,m){return n(),s("div",null,k)}const f=a(d,[["render",h],["__file","uml.html.vue"]]);export{f as default};
