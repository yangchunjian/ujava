import{_ as o,r as s,o as a,c as p,a as l,b as t,e as r,d as i}from"./app-BIc8QNIB.js";const c="/assets/img_147-DQLSAxR6.png",g={},u={href:"https://blog.csdn.net/fly910905/article/details/84025425",target:"_blank",rel:"noopener noreferrer"},d={href:"https://blog.csdn.net/fly910905/article/details/83547744",target:"_blank",rel:"noopener noreferrer"};function h(b,e){const n=s("ExternalLinkIcon");return a(),p("div",null,[e[6]||(e[6]=l('<h2 id="filter过滤器" tabindex="-1"><a class="header-anchor" href="#filter过滤器"><span>Filter过滤器</span></a></h2><blockquote><ul><li><strong>过滤器拦截web访问url地址</strong>。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用<strong>Java的回调机制</strong>进行实现。</li><li>Filter<strong>过滤器</strong>：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li><li><strong>过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)</strong>，并对请求响应做出像响应的过滤操作，</li><li>比如<strong>设置字符编码，鉴权操作</strong>等</li></ul></blockquote><h2 id="interceptor拦截器" tabindex="-1"><a class="header-anchor" href="#interceptor拦截器"><span>Interceptor拦截器</span></a></h2><blockquote><ul><li><strong>拦截器拦截以 .action结尾的url，拦截Action的访问</strong>。 Interfactor是基于<strong>Java的反射机制</strong>（APO思想）进行实现，不依赖Servlet容器。</li><li><strong>拦截器可以在方法执行之前(preHandle)和方法执行之后(afterCompletion)进行操作，回调操作(postHandle)</strong>，<strong>可以获取执行的方法的名称</strong>，请求(HttpServletRequest)</li><li>Interceptor：<strong>可以控制请求的控制器和方法</strong>，但<strong>控制不了请求方法里的参数(只能获取参数的名称，不能获取到参数的值)</strong></li><li>**（**用于处理页面提交的请求响应并进行处理，例如做国际化，做主题更换，过滤等）。</li></ul></blockquote><h2 id="spring-aop拦截器" tabindex="-1"><a class="header-anchor" href="#spring-aop拦截器"><span>Spring AOP拦截器</span></a></h2>',5)),t("blockquote",null,[t("ul",null,[t("li",null,[t("p",null,[e[1]||(e[1]=t("strong",null,"只能拦截Spring管理Bean的访问（业务层Service）",-1)),e[2]||(e[2]=r("。 具体AOP详情参照 ")),t("a",u,[e[0]||(e[0]=r("Spring AOP：原理、 通知、连接点、切点、切面、表达式")),i(n)])])]),t("li",null,[t("p",null,[e[4]||(e[4]=r("实际开发中，AOP常和事务结合：")),t("a",d,[e[3]||(e[3]=r("Spring的事务管理:声明式事务管理(切面)")),i(n)])])]),e[5]||(e[5]=l(`<li><p><strong>AOP操作可以对操作进行横向的拦截</strong>，最大的优势在于他可<strong>以获取执行方法的参数( ProceedingJoinPoint.getArgs() )</strong>，对方法进行统一的处理。</p></li><li><p>Aspect : 可以自定义切入的点，有方法的参数，<strong>但是拿不到http请求，可以通过其他方式如RequestContextHolder</strong>获得(</p><div class="language-cobol line-numbers-mode" data-ext="cobol" data-title="cobol"><pre class="language-cobol"><code>ServletRequestAttributes servletRequestAttributes<span class="token operator">=</span> <span class="token punctuation">(</span>ServletRequestAttributes<span class="token punctuation">)</span> RequestContextHolder<span class="token punctuation">.</span>getRequestAttributes<span class="token punctuation">(</span><span class="token punctuation">)</span>;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>)。</p></li><li><p>常见<strong>使用日志，事务，请求参数安全验证</strong>等</p></li>`,3))])]),e[7]||(e[7]=l('<h3 id="spring对aop的支持" tabindex="-1"><a class="header-anchor" href="#spring对aop的支持"><span>Spring对AOP的支持</span></a></h3><p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。</p><blockquote><p>Spring创建代理的规则为：<br> 1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了<br> 2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB</p></blockquote><p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</p><blockquote><p>1、定义普通业务组件<br> 2、定义切入点，一个切入点可能横切多个业务组件<br> 3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</p></blockquote><ul><li>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，</li><li>即：代理对象的方法=增强处理+被代理对象的方法。</li></ul><h2 id="filter与interceptor联系与区别" tabindex="-1"><a class="header-anchor" href="#filter与interceptor联系与区别"><span>Filter与Interceptor联系与区别</span></a></h2><blockquote><ul><li>拦截器是基于java的反射机制，使用代理模式，而过滤器是基于函数回调。</li><li>拦截器不依赖servlet容器，过滤器依赖于servlet容器。</li><li>拦截器只能对action起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。</li><li>拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。</li><li>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</li></ul></blockquote><p>从上面对拦截器与过滤器的描述来看，它俩是非常相似的，都能对客户端发来的请求进行处理，它们的区别如下：</p><ul><li><strong>作用域不同</strong><ul><li>过滤器依赖于servlet容器，只能在 servlet容器，web环境下使用</li><li>拦截器依赖于spring容器，可以在spring容器中调用，不管此时Spring处于什么环境</li></ul></li><li><strong>细粒度的不同</strong><ul><li>过滤器的控制比较粗，只能在请求进来时进行处理，对请求和响应进行包装</li><li>拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，也可以在渲染视图呈现给用户之后调用</li></ul></li><li><strong>中断链执行的难易程度不同</strong><ul><li>拦截器可以 <code>preHandle</code>方法内返回 false 进行中断</li><li>过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面</li></ul></li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h3><p>简单总结一下，拦截器相比过滤器有更细粒度的控制，依赖于Spring容器，可以在请求之前或之后启动，过滤器主要依赖于servlet，过滤器能做的，拦截器基本上都能做。</p><h2 id="filter、interceptor、aop拦截方向和抛出异常方向图" tabindex="-1"><a class="header-anchor" href="#filter、interceptor、aop拦截方向和抛出异常方向图"><span>Filter、Interceptor、aop拦截方向和抛出异常方向图</span></a></h2><figure><img src="'+c+'" alt="img_147.png" tabindex="0" loading="lazy"><figcaption>img_147.png</figcaption></figure>',14))])}const f=o(g,[["render",h],["__file","interceptorfilter.html.vue"]]),m=JSON.parse('{"path":"/synthesis/interceptorfilter.html","title":"Interceptor、Filter、AOP区别","lang":"zh-CN","frontmatter":{"title":"Interceptor、Filter、AOP区别","icon":"laptop-code","category":["设计高频"],"tag":["高频"],"description":"Filter过滤器 过滤器拦截web访问url地址。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用Java的回调机制进行实现。 Filter过滤器：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。 过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletRe...","head":[["meta",{"property":"og:url","content":"https://ujava.cn/synthesis/interceptorfilter.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"Interceptor、Filter、AOP区别"}],["meta",{"property":"og:description","content":"Filter过滤器 过滤器拦截web访问url地址。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用Java的回调机制进行实现。 Filter过滤器：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。 过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletRe..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-25T03:33:51.000Z"}],["meta",{"property":"article:author","content":"UJava"}],["meta",{"property":"article:tag","content":"高频"}],["meta",{"property":"article:modified_time","content":"2024-04-25T03:33:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Interceptor、Filter、AOP区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-25T03:33:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"Filter过滤器","slug":"filter过滤器","link":"#filter过滤器","children":[]},{"level":2,"title":"Interceptor拦截器","slug":"interceptor拦截器","link":"#interceptor拦截器","children":[]},{"level":2,"title":"Spring AOP拦截器","slug":"spring-aop拦截器","link":"#spring-aop拦截器","children":[{"level":3,"title":"Spring对AOP的支持","slug":"spring对aop的支持","link":"#spring对aop的支持","children":[]}]},{"level":2,"title":"Filter与Interceptor联系与区别","slug":"filter与interceptor联系与区别","link":"#filter与interceptor联系与区别","children":[{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]},{"level":2,"title":"Filter、Interceptor、aop拦截方向和抛出异常方向图","slug":"filter、interceptor、aop拦截方向和抛出异常方向图","link":"#filter、interceptor、aop拦截方向和抛出异常方向图","children":[]}],"git":{"createdTime":1714016031000,"updatedTime":1714016031000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":1}]},"readingTime":{"minutes":4.25,"words":1274},"filePathRelative":"synthesis/interceptorfilter.md","localizedDate":"2024年4月25日","excerpt":"<h2>Filter过滤器</h2>\\n<blockquote>\\n<ul>\\n<li><strong>过滤器拦截web访问url地址</strong>。 严格意义上讲，filter只是适用于web中，依赖于Servlet容器，利用<strong>Java的回调机制</strong>进行实现。</li>\\n<li>Filter<strong>过滤器</strong>：和框架无关，可以控制最初的http请求，但是更细一点的类和方法控制不了。</li>\\n<li><strong>过滤器可以拦截到方法的请求和响应(ServletRequest request, ServletResponse response)</strong>，并对请求响应做出像响应的过滤操作，</li>\\n<li>比如<strong>设置字符编码，鉴权操作</strong>等</li>\\n</ul>\\n</blockquote>","autoDesc":true}');export{f as comp,m as data};
