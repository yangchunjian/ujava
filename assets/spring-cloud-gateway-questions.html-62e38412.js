import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c as p,a,b as n,d as s,e as t}from"./app-8a5cd404.js";const r={},c={href:"https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw",target:"_blank",rel:"noopener noreferrer"},d=a("h2",{id:"什么是-spring-cloud-gateway",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#什么是-spring-cloud-gateway","aria-hidden":"true"},"#"),n(" 什么是 Spring Cloud Gateway？")],-1),u=a("p",null,[n("Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 "),a("strong",null,"Zuul"),n("。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。")],-1),g=a("p",null,"为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。",-1),h=a("figure",null,[a("img",{src:"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway- demo.png",alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),m=a("p",null,"Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。",-1),y=a("p",null,"Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。",-1),b={href:"https://github.com/spring-cloud/spring-cloud-gateway",target:"_blank",rel:"noopener noreferrer"},k={href:"https://spring.io/projects/spring-cloud-gateway",target:"_blank",rel:"noopener noreferrer"},w=a("h2",{id:"spring-cloud-gateway-的工作流程",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#spring-cloud-gateway-的工作流程","aria-hidden":"true"},"#"),n(" Spring Cloud Gateway 的工作流程？")],-1),v=a("p",null,"Spring Cloud Gateway 的工作流程如下图所示：",-1),f=a("figure",null,[a("img",{src:"https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-workflow.png",alt:"Spring Cloud Gateway 的工作流程",tabindex:"0",loading:"lazy"}),a("figcaption",null,"Spring Cloud Gateway 的工作流程")],-1),_={href:"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter",target:"_blank",rel:"noopener noreferrer"},S=t('<p>具体的流程分析：</p><ol><li><strong>路由判断</strong>：客户端的请求到达网关后，先经过 Gateway Handler Mapping 处理，这里面会做断言（Predicate）判断，看下符合哪个路由规则，这个路由映射后端的某个服务。</li><li><strong>请求过滤</strong>：然后请求到达 Gateway Web Handler，这里面有很多过滤器，组成过滤器链（Filter Chain），这些过滤器可以对请求进行拦截和修改，比如添加请求头、参数校验等等，有点像净化污水。然后将请求转发到实际的后端服务。这些过滤器逻辑上可以称作 Pre-Filters，Pre 可以理解为“在...之前”。</li><li><strong>服务处理</strong>：后端服务会对请求进行处理。</li><li><strong>响应过滤</strong>：后端处理完结果后，返回给 Gateway 的过滤器再次做处理，逻辑上可以称作 Post-Filters，Post 可以理解为“在...之后”。</li><li><strong>响应返回</strong>：响应经过过滤处理后，返回给客户端。</li></ol><p>总结：客户端的请求先通过匹配规则找到合适的路由，就能映射到具体的服务。然后请求经过过滤器处理后转发给具体的服务，服务处理后，再次经过过滤器处理，最后返回给客户端。</p><h2 id="spring-cloud-gateway-的断言是什么" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-的断言是什么" aria-hidden="true">#</a> Spring Cloud Gateway 的断言是什么？</h2><p>断言（Predicate）这个词听起来极其深奥，它是一种编程术语，我们生活中根本就不会用它。说白了它就是对一个表达式进行 if 判断，结果为真或假，如果为真则做这件事，否则做那件事。</p><p>在 Gateway 中，如果客户端发送的请求满足了断言的条件，则映射到指定的路由器，就能转发到指定的服务上进行处理。</p><p>断言配置的示例如下，配置了两个路由规则，有一个 predicates 断言配置，当请求 url 中包含 <code>api/thirdparty</code>，就匹配到了第一个路由 <code>route_thirdparty</code>。</p><figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-example.png" alt="断言配置示例" tabindex="0" loading="lazy"><figcaption>断言配置示例</figcaption></figure><p>常见的路由断言规则如下图所示：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-rules.png" alt="Spring Cloud GateWay 路由断言规则" tabindex="0" loading="lazy"><figcaption>Spring Cloud GateWay 路由断言规则</figcaption></figure><h2 id="spring-cloud-gateway-的路由和断言是什么关系" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-的路由和断言是什么关系" aria-hidden="true">#</a> Spring Cloud Gateway 的路由和断言是什么关系？</h2><p>Route 路由和 Predicate 断言的对应关系如下：：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-predicate-route.png" alt="路由和断言的对应关系" tabindex="0" loading="lazy"><figcaption>路由和断言的对应关系</figcaption></figure><ul><li><strong>一对多</strong>：一个路由规则可以包含多个断言。如上图中路由 Route1 配置了三个断言 Predicate。</li><li><strong>同时满足</strong>：如果一个路由规则中有多个断言，则需要同时满足才能匹配。如上图中路由 Route2 配置了两个断言，客户端发送的请求必须同时满足这两个断言，才能匹配路由 Route2。</li><li><strong>第一个匹配成功</strong>：如果一个请求可以匹配多个路由，则映射第一个匹配成功的路由。如上图所示，客户端发送的请求满足 Route3 和 Route4 的断言，但是 Route3 的配置在配置文件中靠前，所以只会匹配 Route3。</li></ul><h2 id="spring-cloud-gateway-如何实现动态路由" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-如何实现动态路由" aria-hidden="true">#</a> Spring Cloud Gateway 如何实现动态路由？</h2><p>在使用 Spring Cloud Gateway 的时候，官方文档提供的方案总是基于配置文件或代码配置的方式。</p><p>Spring Cloud Gateway 作为微服务的入口，需要尽量避免重启，而现在配置更改需要重启服务不能满足实际生产过程中的动态刷新、实时变更的业务需求，所以我们需要在 Spring Cloud Gateway 运行时动态配置网关。</p><p>实现动态路由的方式有很多种，其中一种推荐的方式是基于 Nacos 配置中心来做。简单来说，我们将将路由配置放在 Nacos 中存储，然后写个监听器监听 Nacos 上配置的变化，将变化后的配置更新到 GateWay 应用的进程内。</p>',18),C={href:"https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config",target:"_blank",rel:"noopener noreferrer"},x=t(`<h2 id="spring-cloud-gateway-的过滤器有哪些" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-的过滤器有哪些" aria-hidden="true">#</a> Spring Cloud Gateway 的过滤器有哪些？</h2><p>过滤器 Filter 按照请求和响应可以分为两种：</p><ul><li><strong>Pre 类型</strong>：在请求被转发到微服务之前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</li><li><strong>Post 类型</strong>：微服务处理完请求后，返回响应给网关，网关可以再次进行处理，例如修改响应内容或响应头、日志输出、流量监控等。</li></ul><p>另外一种分类是按照过滤器 Filter 作用的范围进行划分：</p><ul><li><strong>GatewayFilter</strong>：局部过滤器，应用在单个路由或一组路由上的过滤器。标红色表示比较常用的过滤器。</li><li><strong>GlobalFilter</strong>：全局过滤器，应用在所有路由上的过滤器。</li></ul><h3 id="局部过滤器" tabindex="-1"><a class="header-anchor" href="#局部过滤器" aria-hidden="true">#</a> 局部过滤器</h3><p>常见的局部过滤器如下图所示：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-gatewayfilters.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>具体怎么用呢？这里有个示例，如果 URL 匹配成功，则去掉 URL 中的 “api”。</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过滤器</span>
  <span class="token punctuation">-</span> RewritePath=/api/(<span class="token punctuation">?</span>&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span> <span class="token comment"># 将跳转路径中包含的 “api” 替换成空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然我们也可以自定义过滤器，本篇不做展开。</p><h3 id="全局过滤器" tabindex="-1"><a class="header-anchor" href="#全局过滤器" aria-hidden="true">#</a> 全局过滤器</h3><p>常见的全局过滤器如下图所示：</p><figure><img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/spring-cloud-gateway-globalfilters.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>全局过滤器最常见的用法是进行负载均衡。配置如下所示：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> route_member <span class="token comment"># 第三方微服务路由规则</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//passjava<span class="token punctuation">-</span>member <span class="token comment"># 负载均衡，将请求转发到注册中心注册的 passjava-member 服务</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment"># 断言</span>
            <span class="token punctuation">-</span> Path=/api/member/<span class="token important">**</span> <span class="token comment"># 如果前端请求路径包含 api/member，则应用这条路由规则</span>
          <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment">#过滤器</span>
            <span class="token punctuation">-</span> RewritePath=/api/(<span class="token punctuation">?</span>&lt;segment<span class="token punctuation">&gt;</span>.<span class="token important">*)</span><span class="token punctuation">,</span>/$\\<span class="token punctuation">{</span>segment<span class="token punctuation">}</span> <span class="token comment"># 将跳转路径中包含的api替换成空</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有个关键字 <code>lb</code>，用到了全局过滤器 <code>LoadBalancerClientFilter</code>，当匹配到这个路由后，会将请求转发到 passjava-member 服务，且支持负载均衡转发，也就是先将 passjava-member 解析成实际的微服务的 host 和 port，然后再转发给实际的微服务。</p><h2 id="spring-cloud-gateway-支持限流吗" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-支持限流吗" aria-hidden="true">#</a> Spring Cloud Gateway 支持限流吗？</h2><p>Spring Cloud Gateway 自带了限流过滤器，对应的接口是 <code>RateLimiter</code>，<code>RateLimiter</code> 接口只有一个实现类 <code>RedisRateLimiter</code> （基于 Redis + Lua 实现的限流），提供的限流功能比较简易且不易使用。</p><p>从 Sentinel 1.6.0 版本开始，Sentinel 引入了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：route 维度和自定义 API 维度。也就是说，Spring Cloud Gateway 可以结合 Sentinel 实现更强大的网关流量控制。</p><h2 id="spring-cloud-gateway-如何自定义全局异常处理" tabindex="-1"><a class="header-anchor" href="#spring-cloud-gateway-如何自定义全局异常处理" aria-hidden="true">#</a> Spring Cloud Gateway 如何自定义全局异常处理？</h2><p>在 SpringBoot 项目中，我们捕获全局异常只需要在项目中配置 <code>@RestControllerAdvice</code>和 <code>@ExceptionHandler</code>就可以了。不过，这种方式在 Spring Cloud Gateway 下不适用。</p><p>Spring Cloud Gateway 提供了多种全局处理的方式，比较常用的一种是实现<code>ErrorWebExceptionHandler</code>并重写其中的<code>handle</code>方法。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@RequiredArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalErrorWebExceptionHandler</span> <span class="token keyword">implements</span> <span class="token class-name">ErrorWebExceptionHandler</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ObjectMapper</span> objectMapper<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>`,25),G={href:"https://cloud.spring.io/spring-cloud-gateway/reference/html/",target:"_blank",rel:"noopener noreferrer"},j={href:"https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter",target:"_blank",rel:"noopener noreferrer"},R={href:"https://zhuanlan.zhihu.com/p/347028665",target:"_blank",rel:"noopener noreferrer"};function P(F,N){const e=o("ExternalLinkIcon");return l(),p("div",null,[a("blockquote",null,[a("p",null,[n("本文重构完善自"),a("a",c,[n("6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构"),s(e)]),n("这篇文章。")])]),d,u,g,h,m,y,a("ul",null,[a("li",null,[n("GitHub 地址： "),a("a",b,[n("https://github.com/spring-cloud/spring-cloud-gateway"),s(e)])]),a("li",null,[n("官网： "),a("a",k,[n("https://spring.io/projects/spring-cloud-gateway"),s(e)])])]),w,v,f,a("p",null,[n("这是 Spring 官方博客中的一张图，原文地址："),a("a",_,[n("https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter"),s(e)]),n("。")]),S,a("p",null,[n("其实这些复杂的步骤并不需要我们手动实现，通过 Nacos Server 和 Spring Cloud Alibaba Nacos Config 即可实现配置的动态变更，官方文档地址："),a("a",C,[n("https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config"),s(e)]),n(" 。")]),x,a("ul",null,[a("li",null,[n("Spring Cloud Gateway 官方文档："),a("a",G,[n("https://cloud.spring.io/spring-cloud-gateway/reference/html/"),s(e)])]),a("li",null,[n("Creating a custom Spring Cloud Gateway Filter："),a("a",j,[n("https://spring.io/blog/2022/08/26/creating-a-custom-spring-cloud-gateway-filter"),s(e)])]),a("li",null,[n("全局异常处理: "),a("a",R,[n("https://zhuanlan.zhihu.com/p/347028665"),s(e)])])])])}const W=i(r,[["render",P],["__file","spring-cloud-gateway-questions.html.vue"]]);export{W as default};
