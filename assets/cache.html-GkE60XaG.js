import{_ as n}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as s,e as t}from"./app-RDqxnX9v.js";const e="/assets/img-Cs0ewhTS.png",p="/assets/img_1-__TX-k3O.png",c={},o=t('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p><p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p><ul><li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li><li>虚拟主存： 作为磁盘数据的缓存。</li><li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li><li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br> 本文总结互联网技术体系中尤为重要的缓存技术。</li></ul><h2 id="基本思想" tabindex="-1"><a class="header-anchor" href="#基本思想" aria-hidden="true">#</a> 基本思想</h2><ul><li>缓存是以空间换时间，提升查询性能。缓存遵循“近水楼台先得月”法则：邻近 CPU 优先，邻近用户优先（CDN）。</li><li>缓存依据：访问局部性原理。时间局部性 - 某个存储器位置在短时间内被再次访问；空间局部性 -<br> 若某个存储器位置被访问，则邻近存储器位置也很可能会被访问。重复引用相同变量的程序具有良好的时间局部性。步长为 1<br> 的引用模式的程序具有良好的空间局部性。一个典型例子是数组求和。求和变量体现了时间局部性，数组访问体现了空间局部性。可以用缓存命中率来衡量局部性。</li><li>顺序引用模式：顺序地每隔 k 个元素地访问一个连续向量中的每个元素，称为步长为 k 的顺序引用模式 。 k 越大，空间局部性越差。步长为<br> 1 的顺序引用模式是局部性原理的重要应用之一。高效访问顺序与存储结构设计及存储细节是紧密关联的。数组和列表是连续存储结构，因此顺序引用模式很吃香。</li><li>存储器层次结构：对于每个 k, 位于第 k 层的更快更小的存储设备作为位于第 k+1 层的更慢更大的存储设备的缓存。数据总是以块为传送单元，在第<br> k 层和第 k+1 层之间进行复制的。层次结构中，相邻的两层的块大小是一样的；不同层次的块大小可以不同。越靠近慢而大的存储层次，块大小越大。</li></ul><h2 id="缓存问题" tabindex="-1"><a class="header-anchor" href="#缓存问题" aria-hidden="true">#</a> 缓存问题</h2><p>缓存问题主要包括缓存结构设计、缓存一致性分析、缓存策略（热身/替换/清理）、缓存保护（击穿/雪崩/穿透）。<br> 一致性问题涉及准确性；缓存策略涉及性能（缓存命中率及主存占用）；而缓存保护涉及稳定性（在大并发请求下且缓存未能命中时保护原始数据源不被压倒）。</p><h4 id="缓存结构设计" tabindex="-1"><a class="header-anchor" href="#缓存结构设计" aria-hidden="true">#</a> 缓存结构设计</h4><p>缓存数据结构主要包括记录型和哈希型。记录型的缓存，是一个连续存储阵列，可简化为多维数组；哈希型的缓存，是基于哈希表。 CPU<br> 高速缓存是基于记录型的，因为硬件上不宜做复杂的运算；应用缓存通常是基于哈希型的，比如 Redis 缓存。</p><h4 id="cpu高速缓存" tabindex="-1"><a class="header-anchor" href="#cpu高速缓存" aria-hidden="true">#</a> CPU高速缓存</h4><p>CPU 高速缓存可使用 (S, E, B, m) 来表示组织结构。m 位存储器具有 2^m 个存储器地址，其对应的高速缓存组织划分为 S = 2^s 个组，每组<br> E 个缓存行，每个缓存行包括一个有效位、t 个标记位、B = 2^b 个字节，缓存大小 C = S * E * B。 其中 s<br> 是组索引，标识缓存块在哪个组里；t = m-s-b 标识缓存块在缓存组的哪个缓存行里；b 是字节在缓存行里的偏移量。[s,t,b]<br> 标识了缓存字节在缓存结构里的位置。发生缓存替换时，替换的是某个组里的某个缓存行。</p><p>E = 1 时，DMC Directed-Map Cache ；1 &lt; E &lt; C/B 时，SAC Set Associative Cache ；E = C/B 时 Full Associative Cache FAC。 DMC<br> 每组只有一个缓存行，在组中查找缓存行没有开销，但容易发生组的冲突不命中； SAC 在组中查找缓存行有一定开销，但可以减少组的冲突不命中概率；<br> FAC 只有一个组，在定位组时无开销，替换缓存行时有更大的选择，但在查找缓存行时开销比较大。在硬件层，搜索和匹配标记位是昂贵的操作，因此<br> FAC 一般应用在搜索和匹配操作代价不高的地方，比如虚拟主存或应用缓存。</p><p>高速缓存定位字的步骤是：首先从 m 中拿到 s 位组索引，找到缓存行所在的组；再根据 t 位标记位找到匹配的组内的缓存行；最后，根据 b<br> 位偏移量找到字在缓存块中的位置。如果有效位未置位，则可能是过期缓存；如果 t 位标记位无法匹配所有的组，则是缓存未命中。</p><figure><img src="'+e+'" alt="img.png" tabindex="0" loading="lazy"><figcaption>img.png</figcaption></figure><p>CPU 写主存时可采用两种方式：直写和回写。直写会在更新缓存是直接写入缓存，而回写在更新缓存时只是标记缓存块的缓存状态，只有在替换缓存块时才会写回主存。这就导致了<br> CPU 缓存与主存的一致性问题。这个问题是通过 MESI 协议来解决的。</p><h4 id="mesi协议" tabindex="-1"><a class="header-anchor" href="#mesi协议" aria-hidden="true">#</a> MESI协议</h4><p>MESI 协议是 SMP 体系结构的 CPU 缓存一致性协议，涉及读写时多个 CPU 高速缓存如何与主存保持一致<br> 。主要设计思想包括：缓存条目状态的状态转换自动机、写缓冲器、总线事务定义及缓存控制、操作异步化队列、操作屏障。</p><h4 id="一致性概念" tabindex="-1"><a class="header-anchor" href="#一致性概念" aria-hidden="true">#</a> 一致性概念</h4><p>多处理器存储系统是一致的，如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（将所有进程的读写操作排成一个全序），此序列与执行结果一致，并且在此序列中：</p><ul><li>任何特定进程发出的操作，所表现出的序和该进程向存储系统发出他们的序相同；</li><li>每个读操作返回的值是对相应单元按串行顺序写入的最后一个值。</li></ul><h4 id="一致性前提" tabindex="-1"><a class="header-anchor" href="#一致性前提" aria-hidden="true">#</a> 一致性前提</h4><ul><li>系统总线上的所有事务对所有处理器的高速缓存控制器可见，且以相同顺序可见。</li><li>为响应存储的所有必要事务都出现在总线上，且缓存控制器采取适当的措施。</li><li>当高速缓存监听到与之相关的写操作事务时，要么使缓存块拷贝作废，要么更新它。处理器随后的访问，要么缓存不命中而加载新的值，要么直接看到新的值。</li></ul><h4 id="cpu宏观结构" tabindex="-1"><a class="header-anchor" href="#cpu宏观结构" aria-hidden="true">#</a> CPU宏观结构</h4><p>CPU 宏观结构主要包括：CPU Core, Store Buffer , CPU Cache , System BUS 。 CPU Cache 和 Store Buffer 是 CPU 专有的，System<br> BUS 是共享的消息通道。 CPU Cache 是一个缓存条目的阵列（多维数组），每个缓存条目有 tag, data, flag 三个值，tag 表示主存地址，flag<br> 表示缓存条目的状态。flag 定义了如下值：</p><ul><li>Modified(M)：已修改状态。某个处理器缓存副本拥有已修改的值, 主存里的是过期的；</li><li>Exclusive(E)：干净独占状态。仅有该处理器缓存副本与主存一致且主存状态是最新的，独占控制权，缓存能够写操作并转移到 M<br> 状态，却不产生总线事务;</li><li>Shared(S)：至少两个处理器缓存副本与主存一致，主存有最新的值，其他处理器可能有最新的或者过期的值;</li><li>Invalid(I)：初始状态，缓存无效状态。</li></ul><p>缓存条目状态简称为 CES。CES 的状态转换图可以定位为一个有限状态自动机。理解 CES 的有限状态转换机是关键。如下图所示，A/B 表示当观察<br> A 事件时，将产生一个 B 总线事务。Flush’ 表示清除相应的存储块，前提是使用了缓存到缓存的共享，且清除是由提供数据的缓存。BusRd(<br> S) 表示由共享信号 S 生成的总线读事务。缓存控制器通过共享信号 S 在地址阶段确定是否有其它缓存拥有同样的缓存拷贝。如果一个缓存确定自己拥有同样的存储块拷贝，就会发出<br> S 信号。</p><p>MESI 协议定义了一些总线事务（总线读事务、总线排它读事务、总线写事务、回写事务）。结合 CES 状态转换图、总线事务及 CPU<br> 缓存读写控制来实现一致性。</p><h4 id="缓存读" tabindex="-1"><a class="header-anchor" href="#缓存读" aria-hidden="true">#</a> 缓存读</h4><p>读是指拿到变量的最新值并读取到 CPU 寄存器。假设处理器 P1 和 P2 均拥有变量 x 的副本。如果 P1 发现 x 的 CES 为 M/E/S，则直接获取副本<br> x 的值。若 P1 发现变量 x 的 CES 为 I，则遵循如下步骤：</p><ul><li>STEP1 -- 发送 BUS Read 事务；</li><li>STEP2 -- P2 拥有变量 x 的最新副本（ CES 为 M），嗅探到 x Read 事务，就会将 x 的最新副本写入主存，构造 Read Response 发送到<br> BUS 上，并将 CES 更新为 S ；如果有多个处理器缓存都拥有变量 x 的最新副本，则通过某种策略来选择从某个高速缓存来提供新值还是直接由主存来提供新值。</li><li>STEP3 -- P1 嗅探到到 x Read Response ，将 CES 更新为 S，写入相应的缓存块。<br> 注意：任何一个处理器在嗅探到缓存块的 BUS Read 事务，且相应缓存块为 M 状态时，都会执行 STEP2 操作。</li></ul><h4 id="缓存写" tabindex="-1"><a class="header-anchor" href="#缓存写" aria-hidden="true">#</a> 缓存写</h4><p>写是指将变量 x 的最新值写到缓存块。对一个处于 E 或 I 状态的缓存块的写操作，将其置为 M<br> 状态之前，所有其他处理器缓存拷贝都必须通过一个排它读总线事务将自己的缓存作废。如果缓存状态是 M/E ，则不发送总线事务；遵循如下步骤：</p><ul><li>STEP1：P1 发送总线排它读事务；</li><li>STEP2：其他处理器嗅探到总线排它读事务，更新 CES 为 I，再发送 Invalidate Acknowledge ；后续读会产生一次缓存不命中，从而通过一次总线读事务读取最新值。</li><li>STEP3：P1 收到所有 Invalidate Acknowledge ，将 CES 更新为 E，获得数据控制权。然后写入缓存行，将 CES 更新为 M。CPU<br> 写需要等待其他处理器都发送 Invalidate Acknowledge 消息，此时会有写等待问题。</li></ul><h4 id="缓存替换" tabindex="-1"><a class="header-anchor" href="#缓存替换" aria-hidden="true">#</a> 缓存替换</h4><p>当一个缓存块被替换时：</p><ul><li>如果缓存块处于 S 或 I, 则逻辑上直接更新为 I; 如果缓存块处于 M 状态，则从 M 到 I 的状态转换会触发一次回写事务，将缓存块的状态写入主存。</li></ul><h4 id="写等待问题" tabindex="-1"><a class="header-anchor" href="#写等待问题" aria-hidden="true">#</a> 写等待问题</h4><p>写缓冲器（Store Buffer）、无效化队列（Invalidate Queue）。CPU 会直接先写 Store Buffer ，再同步缓存。其他处理器则会将消息存入<br> Invalidate Queue 就发送 Invalidate Acknowledge ，异步去更新 CES 。 写缓冲器和无效化队列将 CPU<br> 缓存副本更新变成异步处理。读则采用存储转发，先查询写缓冲器，再查询高速缓存。相当于写缓冲器又加了一层缓存。写缓存异步化又会带来一致性问题。</p><h4 id="主存屏障" tabindex="-1"><a class="header-anchor" href="#主存屏障" aria-hidden="true">#</a> 主存屏障</h4><p>Store Barrier 和 Load Barrier 。Store Barrier 将 Store Buffer 的数据写入缓存； Load Barrier 根据 Invalidate Queue<br> 的主存地址，将相应的 CES 更新为 I。</p><h2 id="缓存读写一致性" tabindex="-1"><a class="header-anchor" href="#缓存读写一致性" aria-hidden="true">#</a> 缓存读写一致性</h2><p>要正确使用缓存，必然要保证缓存并发读写的一致性。缓存读写一致性需要保证：</p><ul><li>源数据与缓存的同一数据达成一致性（或者达成不一致时延可接受的最终一致性）。</li><li>以源数据的数据为准。<br> 可以采用 [ xC, xDB, yC, yDB ] 操作序列分析读写一致性问题，x,y 是读、更新、删除，C 表示缓存，DB 表示数据库（源数据）。</li></ul><p>首先框定讨论范围：两个线程 A, B，一个变量 x ，数据源 DB 和 缓存 C ，其中 C 从 DB 中获取，需要与 DB 保持一致， A,B 有读写操作，读为<br> RD， 写可以进一步分为更新值 UP 和删除值操作 DE，读写时序不确定。</p><p>缓存读模式是确定的：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读 DB。这点无异议。如果 A, B<br> 并发读，均直接从 C 中获取当前值即可。如果 C 中没有值，那么 A, B 可能都会从 DB 获取。在大并发的情形下，会有缓存击穿/穿透的问题。缓存击穿和穿透的问题在后面讨论。</p><p>当两个线程处于并发读-并发写，或者并发写-并发写的时候，可以有两种方案：加锁和不加锁。</p><ul><li>对更新 DB 和更新 C 进行加分布式锁，使之原子化。加锁会更简单，但吞吐量会比较低；</li><li>对更新 DB 和 更新 C 不加锁，保证合理的执行顺序，使之达到最终一致性（业务可接受一定的不一致时延）。<br> 以下主要讨论不加锁的方案。分情形讨论：</li></ul><h4 id="a写-b读" tabindex="-1"><a class="header-anchor" href="#a写-b读" aria-hidden="true">#</a> A写-B读</h4><p>先指明期望结果：</p><ul><li><p>如果 B 在 A 写之前读，那么 B 读到的是写之前的值，直接从 C 中获取即可。没问题。</p></li><li><p>如果 B 在 A 写之后读，那么 B 读到的应该是写之后的值。<br> 那么 A 该如何写，才能保证 B 读到最新的值？</p></li><li><p>A 先更新 C，再写 DB。会有什么问题 ？ 如果 A 先更新了 C ，然后更新 DB 失败了，那么 C 与 DB 就不一致了。DB 里是旧值。不符合一致性保证。当然，读<br> C 会读到新值。可以有一种思路，就是缓存作为读写的前置环节，负责缓存与 DB 的最终一致性。这种方案也是可以接受的。这是 Write<br> Behind Caching Pattern 模式。</p></li><li><p>A 先删除 C， 再写 DB。会有什么问题？ 如果操作时序是 [ A 删除 C， B 读 C，A 更新 DB ]， 那么在 A 更新 DB 之前，B 读 C 未命中，从<br> DB 读到旧值，而 A 更新 DB， DB 与 C 的值不一致。不符合一致性保证。</p></li><li><p>A 先写 DB ，再更新 C。会有什么问题？ 1. 更新缓存可能是代价昂贵的操作，频繁更新缓存会导致吞吐量降低；在更新 C<br> 之前读到的是旧值，如果更新操作比较耗时，那么 DB 和 C 的不一致时延会比较大，会影响业务。</p></li><li><p>A 先写 DB ，再删除 C。 会有什么问题？ 避免了更新代价高的问题，在删除 C 之前读到的是旧值，在删除 C<br> 之后读到新值。由于删除缓存往往代价很小，不一致时延通常可接受。这是 Cache Aside Pattern 模式。</p></li></ul><h4 id="a写-b写" tabindex="-1"><a class="header-anchor" href="#a写-b写" aria-hidden="true">#</a> A写-B写</h4><ul><li>期望结果：无论 A 先写还是 B 先写，最终写入的 DB 和 C 的值应当一致。</li><li>A 先更新 C，再写 DB。 会有什么问题？如果操作时序是 [ A 写 C x， B 写 C y， B 写 DB y， A 写 DB x]，会导致 C 是 y , DB 是 x<br> ，DB 与 C 中的数据不一致。</li><li>A 先写 DB， 再更新 C。会有什么问题？[ A 写 DB x， B 写 DB y， B 写 C y， A 写 C x]，会导致 C 是 x , DB 是 y ，DB 与 C 中的数据不一致。<br> 从上述分析可知：1. 更新缓存操作可能是一个代价昂贵的操作，会导致 DB 与 C 达到最终一致性的不一致时延较长，对业务有影响； 2.<br> 在并发写-写模式下，DB 和 C 的数据会不一致，从而读到不一致的数据。因此，一般不采用更新缓存的方式，而是直接删除缓存。</li></ul><p>常见的缓存读写模式有 Cache Aside Pattern 和 Write Behind Caching Pattern 。</p><ul><li>Cache Aside Pattern：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读<br> DB。读更写删。读模式基本是固定的；写入数据时，先更新 DB ，再删除缓存。可以采集 DB binlog 异步删除缓存。如果是主从<br> DB，则必须采集最后一个从库 binlog （最终一致性）。</li><li>Write Behind Caching Pattern --- 写入时只更新缓存，异步去更新 DB 。牺牲短暂的一致性来获得高吞吐量。</li></ul><h2 id="缓存热身" tabindex="-1"><a class="header-anchor" href="#缓存热身" aria-hidden="true">#</a> 缓存热身</h2><p>空缓存会直接导致不命中，从而影响第一次读的性能。如果大并发访问空缓存（类似缓存雪崩），很容易导致大量并发请求直接打到 DB 上，使得<br> DB 压力陡增。</p><p>缓存热身即是预先把一些数据加载到缓存，提升第一次访问的性能，同时防止第一次访问面临大并发时会将后台打出问题。比如在应用启动后，可以将一些<br> TOPN 商品异步加载到缓存（不能影响应用启动）；商家做活动前，把一些活动商品和活动信息数据加载到缓存（可配置化）；把一些极少变动的静态数据加载到缓存。加载缓存可以使用应用通知机制，比如实现<br> ApplicationListener 的<br> onApplicationEvent 方法。</p><h2 id="缓存替换策略" tabindex="-1"><a class="header-anchor" href="#缓存替换策略" aria-hidden="true">#</a> 缓存替换策略</h2><p>缓存总有未命中的情况：</p><ul><li>空不命中：总是不会命中，亦称冷缓存。避免冷缓存的方法是进行“缓存热身”。将 k+1 层的缓存块放到第 k<br> 层的策略称为放置策略。通常采用取模的方式: j = i Mod N ，即：将第 k+1 层的第 i 个块对 N 取模后，放到第 k 层的第 i 个块里。</li><li>冲突不命中：比如按取模的放置策略，有可能在缓存未满的情况下，总是对第 k 层的同一个块进行替换。比如 j mod 4 ，当 j=0,4,8,12<br> 时，总是会放在到第 0 块上。缓存抖动是一种特殊的冲突不命中，指高速缓存反复加载或驱逐相同的高速缓存块/组/行。</li><li>容量不命中：缓存容量满了。</li></ul><p>缓存替换策略是指当缓存未命中，且缓存容量已满时，判断要替换哪个块的缓存数据。原则上，应该淘汰：1. 只访问过一次的数据； 2.<br> 相比其他数据更少访问的； 3. 在一段时间内没有再访问的。</p><p>缓存替换策略主要有 FIFO, LRU, LFU。</p><ul><li>FIFO ： 最先进入缓存的首先被淘汰。队列实现。或者使用双向链表，新进入元素添加到链表尾，丢弃链表头的元素。FIFO适合丢弃那些只有一次访问的数据。</li><li>LRU ：最近最少使用淘汰。使用链表实现，若缓存命中，则将节点移至首部，淘汰尾部节点。 LRU 适合热点数据访问。LRU<br> 无法识别哪些缓存是最多被访问的。偶发性、周期性的批量操作可能导致缓存被大量替换，造成缓存污染，使得 LRU 的效率大幅下降。实际采用<br> LRU-K 算法，将缓存分为两级，数据在较短时间被访问 K 次以上，则进入二级缓存。两级都采用 LRU 策略。</li><li>LFU ： 最少次数使用淘汰。引用计数 + 优先级队列（堆）。</li></ul><h2 id="缓存清理策略" tabindex="-1"><a class="header-anchor" href="#缓存清理策略" aria-hidden="true">#</a> 缓存清理策略</h2><p>当缓存对应的原始数据更新后，缓存里的数据就与原始数据不一致了，即缓存失效了。这时候需要及时清理缓存，避免读到过期数据以及过期数据占用过大的内存。缓存清理策略是指什么时候清理过期或失效缓存。</p><ul><li>TTL： 设置过期时间。 TTL 一般以数据变化频繁度为依据来设置。不同业务数据的过期时间不一样。</li><li>写时失效： 写失效、写更新。写失效 - 标记缓存数据已过期，读时清理或替换；写更新 - 在更新数据时就替换缓存项。</li><li>读时失效：写时只标注失效信息，读时判断是否失效并加载最新数据。如果有大量缓存对象要更新，可以采用读时失效将写更新成本分摊到每一个读上。缓存对象时，同时存储相应的版本号或时间戳。需要展示数据时，通过对比版本号来判断是否缓存已失效。</li></ul><h2 id="缓存击穿-雪崩-穿透" tabindex="-1"><a class="header-anchor" href="#缓存击穿-雪崩-穿透" aria-hidden="true">#</a> 缓存击穿/雪崩/穿透</h2><ul><li>缓存击穿【重点】。 热点问题。大并发集中对热点 key 进行访问，当这个 key<br> 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。基本方案：多级缓存（不同失效时间）+<br> 热点散列 + 热点识别、熔断降级、互斥锁、不过期+异步更新。</li><li>缓存雪崩。 大量 key 同时失效，导致大量请求打到 DB，造成巨大 DB 压力和系统不稳定。基本方案：过期时间+随机化。</li><li>缓存穿透。大量不存在的 key 的非法访问请求，同样会使得大量请求打到 DB。使用布隆过滤器过滤大量非法请求。还有一种方法是空值缓存，失效时间设置小一些，应对短时间内无效重复<br> key 的大量查询。</li><li>缓存命中统计、缓存监控。</li></ul><h2 id="缓存实现" tabindex="-1"><a class="header-anchor" href="#缓存实现" aria-hidden="true">#</a> 缓存实现</h2><p>以本地缓存为例，来分析缓存实现。本地缓存通常在单机共享范围内：某个进程内的被多次访问的主存数据；单机范围内的多进程共享的主存数据。要实现缓存功能，通常需要考虑如下因素：</p><ul><li><p>缓存的规格指定，会影响缓存的创建和性能。</p></li><li><p>缓存的值的计算和迟加载。</p></li><li><p>缓存策略的配置。</p></li><li><p>缓存对并发的支持。</p></li><li><p>缓存更新的通知与监听。</p></li><li><p>缓存的监控与统计。<br> Guava.Cache 是本地缓存的一个实现。核心类是 CacheBuilderSpec (规格指定)、CacheBuilder (根据缓存规格创建缓存)、LocalCache (<br> 缓存功能的核心实现类)。 LocalCache 的底层是一个哈希表，支持并发访问，实现了 ConcurrentMap 接口。实现要点如下：</p></li><li><p>缓存数据的读写与 ConcurrentHashMap 类似。</p></li><li><p>有两个用双向链表实现的优先级队列： writeQueue 和 accessQueue ，用来控制缓存何时过期。writeQueue 按写时间排序，accessQueue<br> 按访问时间排序。在每次写入或更新或清理操作的时候，会执行清理操作，根据这两个队列来判断缓存数据是否过期，如果过期则从缓存数据哈希表中移除。</p></li></ul><h2 id="高效应用缓存" tabindex="-1"><a class="header-anchor" href="#高效应用缓存" aria-hidden="true">#</a> 高效应用缓存</h2><h4 id="缓存友好的代码" tabindex="-1"><a class="header-anchor" href="#缓存友好的代码" aria-hidden="true">#</a> 缓存友好的代码</h4><p>针对连续型存储的高速缓存，编写对缓存友好的代码。比如聚焦核心函数的循环；减少循环内部不命中的数量；对局部变量的反复引用；步长为<br> 1 的顺序引用模式；多重循环中的循环变量的次序。</p><p>换言之，每个循环都会在高速缓存上产生很大的影响，进而影响程序运行性能。对于上层应用可能感知不明显，但是对于底层却很重要。</p><figure><img src="'+p+`" alt="img_1.png" tabindex="0" loading="lazy"><figcaption>img_1.png</figcaption></figure><h4 id="服务实例缓存" tabindex="-1"><a class="header-anchor" href="#服务实例缓存" aria-hidden="true">#</a> 服务实例缓存</h4><p>凡是将数据进行变换后存储起来，在将来的计算中重复多次使用，都是缓存的实现形式。最常见的就是服务单例缓存。比如在类<br> DefaultSingletonBeanRegistry 中的 singletonObjects 单例缓存，可用来解决循环引用依赖问题 ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token doc-comment comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span>singletonFactories<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span><span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Object</span> singletonObject<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>singletonObject<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span><span class="token punctuation">{</span>
        singletonObject<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>singletonObject<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>allowEarlyReference<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>singletonFactory<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        singletonObject<span class="token operator">=</span>singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span>singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span>singletonObject<span class="token operator">!=</span><span class="token constant">NULL_OBJECT</span><span class="token operator">?</span>singletonObject<span class="token operator">:</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="缓存与动态规划" tabindex="-1"><a class="header-anchor" href="#缓存与动态规划" aria-hidden="true">#</a> 缓存与动态规划</h4><p>动态规划法通常会复用到子问题的解，因此可以使用缓存来存储子问题的解。一个简单的例子如下，计算阶乘：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> factorialCalc <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Log</span> log <span class="token operator">=</span> <span class="token class-name">LogFactory</span><span class="token punctuation">.</span><span class="token function">getLog</span><span class="token punctuation">(</span>factorialCalc<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> num <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">String</span> info <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;fac(%d)=%d&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token function">fac</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">String</span> info2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">&quot;facWithCache(%d)=%d&quot;</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token function">facWithCache</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>info2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printCacheInfo</span><span class="token punctuation">(</span>cache<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printCacheInfo</span><span class="token punctuation">(</span><span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;cache contents: &quot;</span> <span class="token operator">+</span> cache<span class="token punctuation">.</span><span class="token function">asMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;cache stat: &quot;</span> <span class="token operator">+</span> cache<span class="token punctuation">.</span><span class="token function">stats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">fac</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">fac</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Cache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">recordStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">facWithCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token number">1L</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Long</span> facN_1 <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>facN_1 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            facN_1 <span class="token operator">=</span> <span class="token function">facWithCache</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">long</span> facN <span class="token operator">=</span> n <span class="token operator">*</span> facN_1<span class="token punctuation">;</span>
        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> facN<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> facN<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="http缓存" tabindex="-1"><a class="header-anchor" href="#http缓存" aria-hidden="true">#</a> HTTP缓存</h4><ul><li>HTTP 缓存原理：HTTP 缓存服务器上会保存原始服务器上的文档副本。当 HTTP 请求到来时，若缓存命中，则直接返回文档副本，而无需再与原始服务器通信。</li><li>缓存再验证：HTTP<br> 缓存服务器会发送特殊请求（无需取整个文档对象），与原始服务器的文档比较，检测缓存副本是否过期；如果检测到未过期 ,<br> 缓存服务器会获取到新的首部和新的过期时间，更新缓存首部，再将文档副本标识为“未过期”的；若检测到缓存副本过期了，则从原始服务器取最新的文档并生成新的文档副本。</li><li>缓存命中统计：缓存请求命中占比；缓存字节命中占比。</li><li>缓存层次结构：可以使用多级缓存。可分为私有缓存和公有缓存，私有缓存通常是用户浏览器缓存，存放在本地磁盘上；公有缓存则是 HTTP<br> 缓存服务器（可能是代理服务器、CDN服务器）。私有缓存可以作为第一级缓存，公有缓存作为第二级或第 N 级缓存。</li><li>缓存过期标识：可使用 Cache-Control 和 Expires 来标明缓存副本何时过期，是否需要做缓存再验证。缓存服务器从 HTTP<br> 请求中解析出首部，并与缓存里的 Cache-Control ( max-age 从生成文档到过期的生存时间，秒为单位 ) 和 Expires (<br> 过期绝对日期 ) 配置进行比较，如果已经超过指定期限，则要做缓存再验证操作。由于时钟不准确，一般不推荐使用 Expires 首部。</li><li>条件再验证：将缓存再验证与获取新的缓存副本合为一个请求。主要有 If-Modified-Since 和 If-None-Match。</li><li>If-Modified-Since 首部：将 If-Modified-Since 首部添加的 GET 请求中，告知原始服务器，仅当其内容已经修改，才返回修改后的文档对象。若原始服务器文档没有修改，则返回<br> 304 Not Modified ；若文档已修改，返回完整的对象；若文档已删除，则返回 404 Not Found ，缓存服务器会将副本删除。If-Modified-Since<br> 可以与 Last-Modified 配合使用。</li><li>If-None-Match:Etags: 当日期不足以区分文档的过期时，可以使用 If-None-Match:Etags 。实际上类似一个版本号。</li><li>Cache-Control: no-store （禁止缓存复制响应）, no-cache ( 在进行再验证之前不可提供缓存副本 ), must-revalidation (<br> 必须进行缓存再验证), max-age ( 在指定秒数之后进行缓存再验证 ), max-stale, min-fresh</li><li>试探性过期算法：如果 If-Modified-Since 和 If-None-Match<br> 都没有提供，则根据最近修改时间，智能推断需要缓存的时间。若最近修改时间很久，则认为文档稳定，可以缓存更长时间，若最近修改时间很近，则认为文档易变，将缓存时间改下一点。有点自适应缓存的意味。LM-Factor<br> 是一种常用的试探性过期算法。<code>$time_since_modify = max(0, $server_Date - $server_Last_Modified); $server_freshness_limit = int($time_since_modify * $lm_factor);</code></li><li>设置缓存的工具： Apache web 服务器 ( mod_headers, mod_expires )，META HTTP-EQUIV 标签。</li></ul><h4 id="分布式缓存" tabindex="-1"><a class="header-anchor" href="#分布式缓存" aria-hidden="true">#</a> 分布式缓存</h4><p>一般采用 Redis 来做多机共享的分布式缓存。一些有效做法：</p><ul><li>命名空间规范和隔离，部署隔离，避免业务相互影响和耦合。</li><li>采用批量获取缓存数据的方法提升查询性能，减少网络传输开销。</li><li>尽量使用 O(1) 的命令，避免使用遍历性命令。</li><li>单个 key 的 value 不超过 10KB, list, set, map 等不超过 1000 个元素。</li><li>设置合理的定期删除/惰性删除/缓存替换策略。</li><li>测量缓存的命中率及性能提升情况；若数据不理想，则要仔细分析原因并优化。</li><li>监控大对象缓存。</li></ul><p>要避免的坑：</p><ul><li>内存占用和缓存同步要特别注意，避免内存占用大、同步慢影响了业务。</li><li>缓存主要用来提升性能，不要当做持久化存储使用，避免数据丢失的风险。</li><li>避免滥用和浪费缓存资源。主存缓存是比较昂贵的资源。</li></ul>`,90),i=[o];function l(u,r){return a(),s("div",null,i)}const b=n(c,[["render",l],["__file","cache.html.vue"]]);export{b as default};
