import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as l,c as r,a as n,b as s,d as a,w as i,e as o}from"./app-8a5cd404.js";const u={},k=n("p",null,"JDK 19 定于 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。",-1),d=n("p",null,"JDK 19 只有 7 个新特性：",-1),h={href:"https://openjdk.org/jeps/405",target:"_blank",rel:"noopener noreferrer"},v={href:"https://openjdk.org/jeps/422",target:"_blank",rel:"noopener noreferrer"},m={href:"https://openjdk.org/jeps/424",target:"_blank",rel:"noopener noreferrer"},_={href:"https://openjdk.org/jeps/425",target:"_blank",rel:"noopener noreferrer"},f={href:"https://openjdk.java.net/jeps/426",target:"_blank",rel:"noopener noreferrer"},g={href:"https://openjdk.java.net/jeps/427",target:"_blank",rel:"noopener noreferrer"},j={href:"https://openjdk.org/jeps/428",target:"_blank",rel:"noopener noreferrer"},b=n("p",null,"这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。",-1),J={href:"https://openjdk.org/projects/jdk/19/",target:"_blank",rel:"noopener noreferrer"},S=n("h2",{id:"jep-424-外部函数和内存-api-预览",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-424-外部函数和内存-api-预览","aria-hidden":"true"},"#"),s(" JEP 424: 外部函数和内存 API（预览）")],-1),P=n("p",null,"Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。",-1),w={href:"https://openjdk.java.net/jeps/412",target:"_blank",rel:"noopener noreferrer"},A={href:"https://openjdk.org/jeps/419",target:"_blank",rel:"noopener noreferrer"},y={href:"https://openjdk.org/jeps/424",target:"_blank",rel:"noopener noreferrer"},I=n("p",null,"在没有外部函数和内存 API 之前：",-1),E={href:"https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"sun.misc.Unsafe",-1),q=n("code",null,"Unsafe",-1),L=n("code",null,"Unsafe",-1),V={href:"https://www.baeldung.com/jni",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/java-native-access/jna",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/jnr/jnr-ffi",target:"_blank",rel:"noopener noreferrer"},D={href:"https://github.com/bytedeco/javacpp",target:"_blank",rel:"noopener noreferrer"},F=o(`<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p><p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p><ul><li>分配外部内存：<code>MemorySegment</code>、、<code>MemoryAddress</code>和<code>SegmentAllocator</code>）；</li><li>操作和访问结构化的外部内存：<code>MemoryLayout</code>, <code>VarHandle</code>；</li><li>控制外部内存的分配和释放：<code>MemorySession</code>；</li><li>调用外部函数：<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>。</li></ul><p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code>radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 1. 在C库路径上查找外部函数</span>
<span class="token class-name">Linker</span> linker <span class="token operator">=</span> <span class="token class-name">Linker</span><span class="token punctuation">.</span><span class="token function">nativeLinker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SymbolLookup</span> stdlib <span class="token operator">=</span> linker<span class="token punctuation">.</span><span class="token function">defaultLookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MethodHandle</span> radixSort <span class="token operator">=</span> linker<span class="token punctuation">.</span><span class="token function">downcallHandle</span><span class="token punctuation">(</span>
                             stdlib<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">&quot;radixsort&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 分配堆上内存以存储四个字符串</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> javaStrings   <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;mouse&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;car&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 分配堆外内存以存储四个指针</span>
<span class="token class-name">SegmentAllocator</span> allocator <span class="token operator">=</span> <span class="token function">implicitAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MemorySegment</span> offHeap  <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">allocateArray</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 4. 将字符串从堆上复制到堆外</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在堆外分配一个字符串，然后存储指向它的指针</span>
    <span class="token class-name">MemorySegment</span> cString <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">allocateUtf8String</span><span class="token punctuation">(</span>javaStrings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    offHeap<span class="token punctuation">.</span><span class="token function">setAtIndex</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> cString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 5. 通过调用外部函数对堆外数据进行排序</span>
radixSort<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>offHeap<span class="token punctuation">,</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token class-name">MemoryAddress</span><span class="token punctuation">.</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 6. 将(重新排序的)字符串从堆外复制到堆上</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">MemoryAddress</span> cStringPtr <span class="token operator">=</span> offHeap<span class="token punctuation">.</span><span class="token function">getAtIndex</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    javaStrings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cStringPtr<span class="token punctuation">.</span><span class="token function">getUtf8String</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">assert</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>javaStrings<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">&quot;car&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mouse&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jep-425-虚拟线程-预览" tabindex="-1"><a class="header-anchor" href="#jep-425-虚拟线程-预览" aria-hidden="true">#</a> JEP 425: 虚拟线程（预览）</h2><p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p><p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>`,9),T={href:"https://www.zhihu.com/question/536743167",target:"_blank",rel:"noopener noreferrer"},C=n("p",null,"Java 虚拟线程的详细解读和原理可以看下面这两篇文章：",-1),H={href:"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q",target:"_blank",rel:"noopener noreferrer"},R={href:"https://www.cnblogs.com/throwable/p/16758997.html",target:"_blank",rel:"noopener noreferrer"},K=n("h2",{id:"jep-426-向量-api-第四次孵化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-426-向量-api-第四次孵化","aria-hidden":"true"},"#"),s(" JEP 426: 向量 API（第四次孵化）")],-1),U={href:"https://openjdk.java.net/jeps/338",target:"_blank",rel:"noopener noreferrer"},B={href:"http://openjdk.java.net/jeps/11",target:"_blank",rel:"noopener noreferrer"},G={href:"https://openjdk.java.net/jeps/414",target:"_blank",rel:"noopener noreferrer"},O={href:"https://openjdk.java.net/jeps/417",target:"_blank",rel:"noopener noreferrer"},z={href:"https://openjdk.java.net/jeps/426",target:"_blank",rel:"noopener noreferrer"},X=n("h2",{id:"jep-428-结构化并发-孵化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-428-结构化并发-孵化","aria-hidden":"true"},"#"),s(" JEP 428: 结构化并发(孵化)")],-1),Q=n("p",null,[s("JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代"),n("code",null,"java.util.concurrent"),s("，目前处于孵化器阶段。")],-1),W=n("p",null,"结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。",-1),Y={href:"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html",target:"_blank",rel:"noopener noreferrer"},Z=n("code",null,"StructuredTaskScope",-1),$=n("code",null,"StructuredTaskScope",-1),nn=o(`<p><code>StructuredTaskScope</code> 的基本用法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StructuredTaskScope</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用fork方法派生线程来执行子任务</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>task2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待线程完成</span>
        scope<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 结果的处理可能包括处理或重新抛出异常</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> process results<span class="token operator">/</span>exceptions <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token comment">// close</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>`,3);function sn(an,tn){const t=e("ExternalLinkIcon"),p=e("RouterLink");return l(),r("div",null,[k,d,n("ul",null,[n("li",null,[n("a",h,[s("JEP 405: Record Patterns（记录模式）"),a(t)]),s("（预览）")]),n("li",null,[n("a",v,[s("JEP 422: Linux/RISC-V Port"),a(t)])]),n("li",null,[n("a",m,[s("JEP 424: Foreign Function & Memory API（外部函数和内存 API）"),a(t)]),s("（预览）")]),n("li",null,[n("a",_,[s("JEP 425: Virtual Threads（虚拟线程）"),a(t)]),s("（预览）")]),n("li",null,[n("a",f,[s("JEP 426: Vector（向量）API"),a(t)]),s("（第四次孵化）")]),n("li",null,[n("a",g,[s("JEP 427: Pattern Matching for switch（switch 模式匹配）"),a(t)])]),n("li",null,[n("a",j,[s("JEP 428: Structured Concurrency（结构化并发）"),a(t)]),s("（孵化）")])]),b,n("p",null,[s("相关阅读："),n("a",J,[s("OpenJDK Java 19 文档"),a(t)])]),S,P,n("p",null,[s("外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 "),n("a",w,[s("JEP 412"),a(t)]),s(" 提出。第二轮孵化由"),n("a",A,[s(" JEP 419"),a(t)]),s(" 提出并集成到了 Java 18 中，预览由 "),n("a",y,[s("JEP 424"),a(t)]),s(" 提出并集成到了 Java 19 中。")]),I,n("ul",null,[n("li",null,[s("Java 通过 "),n("a",E,[x,a(t)]),s(" 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），"),q,s(" 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 "),L,s(" 类会使得程序出错的概率变大。")]),n("li",null,[s("Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章："),n("a",V,[s("Guide to JNI (Java Native Interface)"),a(t)]),s(" ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然"),n("a",M,[s("JNA"),a(t)]),s("、"),n("a",N,[s("JNR"),a(t)]),s("和"),n("a",D,[s("JavaCPP"),a(t)]),s("等框架对 JNI 进行了改进，但效果还是不太理想。")])]),F,n("p",null,[s("知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看："),n("a",T,[s("https://www.zhihu.com/question/536743167"),a(t)]),s(" 。")]),C,n("ul",null,[n("li",null,[n("a",H,[s("Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量"),a(t)])]),n("li",null,[n("a",R,[s("虚拟线程 - VirtualThread 源码透视"),a(t)])])]),K,n("p",null,[s("向量（Vector） API 最初由 "),n("a",U,[s("JEP 338"),a(t)]),s(" 提出，并作为"),n("a",B,[s("孵化 API"),a(t)]),s("集成到 Java 16 中。第二轮孵化由 "),n("a",G,[s("JEP 414"),a(t)]),s(" 提出并集成到 Java 17 中，第三轮孵化由 "),n("a",O,[s("JEP 417"),a(t)]),s(" 提出并集成到 Java 18 中，第四轮由 "),n("a",z,[s("JEP 426"),a(t)]),s(" 提出并集成到了 Java 19 中。")]),n("p",null,[s("在 "),a(p,{to:"/java/new-features/java18.html"},{default:i(()=>[s("Java 18 新特性概览")]),_:1}),s(" 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。")]),X,Q,W,n("p",null,[s("结构化并发的基本 API 是"),n("a",Y,[Z,a(t)]),s("。"),$,s(" 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。")]),nn])}const pn=c(u,[["render",sn],["__file","java19.html.vue"]]);export{pn as default};
