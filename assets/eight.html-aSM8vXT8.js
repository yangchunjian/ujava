import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as l,c as e,e as r}from"./app-aGKuwAom.js";const a={},h=r('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>工作了一两年的软件工程师，大概没有不听说过“可复用性”的概念。可复用性可以从两个视角来体现：</p><ul><li>创造者： 可以提供通用的服务和成果，别人直接在其工作的基础上构建自己的成果。整个过程不断叠加构建出恢弘的建筑。</li><li>使用者： 可以直接使用已有的服务和成果，无需重复创作，达到高效。</li></ul><p>理性学科，比如数学、物理是遵循可复用性的生动体现和典范。因为大家都知道，不充分了解别人的成果，根本无法进行自己的工作，而且即使耗费大量时间和精力作出成果，如果与已有成果重复了，基本等于零。遗憾的是，工程领域里，却充斥着大量的重复创作和浪费，且很少有人察觉这种浪费。</p><p>当你想要一个小功能点的时候，从以下场景上想想：</p><ul><li>你发现有一个函数能够实现想要的功能，一行代码调用就能搞定，心欢喜焉；</li><li>你发现有一个函数能够实现想要的功能，做一个简单的适配就能搞定，心戚戚然焉；</li><li>你发现有一个函数能够实现想要的功能，但参数不是想要的，得改改参数，抽离出一个子函数出来；</li><li>你发现有一个函数能够实现大部分功能，还需要做点修改才能适配自己的需要，于是在里面添加了一个新的逻辑；</li><li>你发现有一个函数能够实现，但这个函数做了太多事情，需要从中抽离出自己想要的部分；</li><li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有点麻烦，但还可以接受；</li><li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有点麻烦，但不困难；</li><li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有些困难，而且容易导致问题，需要大量回归测试。</li><li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分很困难，不如重写一个。</li><li>你没有发现现有函数能够实现。自己重写一个。<br> 以上场景，可复用性逐渐降低，而重复创造和浪费的概率逐渐增大。软件行业发展到至今，几乎不太存在最后一种情况，但很尴尬的是，据我所接手的业务工程，处于第一种情形的极少，处于前三种情形的也不多，大多数都落在了后六种情形上。</li></ul><h2 id="是什么阻碍了做到代码可复用性" tabindex="-1"><a class="header-anchor" href="#是什么阻碍了做到代码可复用性" aria-hidden="true">#</a> 是什么阻碍了做到代码可复用性</h2><p>现在，让我们来看看，是什么阻碍了代码可复用性。</p><h4 id="违反单一事实原则" tabindex="-1"><a class="header-anchor" href="#违反单一事实原则" aria-hidden="true">#</a> 违反单一事实原则</h4><p>违反单一事实原则，可以说是阻碍可复用性的首要“罪魁祸首”。“单一事实”原则，可以说是中高级工程师耳熟能详的一个基本代码原则。遗憾的是，真正做到这一点的并不多。这体现了一个有趣的事实：越是简单的事情，越做不好。起床、吃饭都是极为简单而且基本没有“技术含量”的事情，人体天然能够支持的能力，然而，真正坚持专注做到做好的有多少人呢？</p><p>举出违反单一事实的例子非常容易，在代码工程里俯拾即是。随便拿一个函数，看看它干了什么事，想想它能够在什么情形下被复用。大多数已有的函数和类，不是把技术逻辑和业务逻辑混杂在一起，就是恨不得一下子把所有事情都做了，瀑布一泻而下，疑是银河落九天。</p><p>先不要谈什么设计原则或设计模式，先把“单一事实”原则切实做好。如何做好单一事实原则？</p><ul><li>想清楚这个函数做什么事，遏制想做两件及以上事情的冲动； 克制！大家都知道产品设计要克制，过于臃肿的产品谁都不想用，但过于臃肿的代码谁又想去碰呢？</li><li>如果需要做两件事，拆分出两个可以组合的函数；</li><li>如果想要新增流程或逻辑，新增函数，然后在其中调用；</li><li>仔细定义参数，参数最小化；</li><li>每个方法不超过 50 行（除去空行）；</li><li>拆分，新增函数，成为无意识的习惯！<br> 惟有养成这样严格遵循“单一事实”原则的习惯，才能在项目工期很赶的时候，依然能够写出质量不错的不臃肿的代码。</li></ul><h4 id="参数过多" tabindex="-1"><a class="header-anchor" href="#参数过多" aria-hidden="true">#</a> 参数过多</h4><p>由于特别容易做很多事情的倾向性，因此参数往往过多。当你发现一个函数里的参数过多，这个函数很可能违反了单一事实职责。或者是，在某种程度上，逻辑拆分存在问题。</p><p>参数过多的直接后果就是：</p><ul><li>如果你想复用这个函数，就得推敲和构造这么多参数；</li><li>你需要猜测每个参数的含义，与自己所需功能的相关性，过滤掉不需要设置的参数；</li><li>当传空的参数时，往往是一种不佳的代码体现； 而当传很多空的参数时，很难看；</li><li>理工科的人，需要一点艺术的熏陶。只懂逻辑不懂表达和设计的人只能写出难看的代码，虽然或许很管用。</li></ul><h4 id="领域逻辑没有抽离" tabindex="-1"><a class="header-anchor" href="#领域逻辑没有抽离" aria-hidden="true">#</a> 领域逻辑没有抽离</h4><p>说起来，软件工程领域落到实处的进步真是很慢（大概对于任何涉及多人协作的事情都是如此）。从最初的一团面条，到后来有人提出了<br> Controller-Service-Dao 分层理念，大家才开始有了分层抽离的概念，知道把参数校验写在 Controller 里，把应用业务逻辑写在 Service<br> 里，把数据访问相关写在 Dao 层里。</p><p>不过，这样还远远不够。Controller 和 Dao 倒是清晰了，但 Service 还是很臃肿。为什么？因为程序员习惯于把各种业务逻辑、技术逻辑、业务流程都扔到<br> Service 里，哪怕有些技术逻辑是一个可以复用的工具类，哪怕有些业务逻辑是可以复用的领域知识。</p><p>DDD 是一种设计理念，但看上去掌握这种设计理念的人不多。实际上，我觉得 DDD 对代码编写更有启发。把 DDD<br> 相关的领域知识，放到富血模型里或者领域层里。比如，对于一个安全业务工程，安全检测相关的逻辑，就很适合单独抽离到领域层里；比如，K8S<br> 相关的资产，就适合把 Pod, Controller, Container Image 这些基础概念的关联关系抽离出来，放在领域层里，应用业务层只需要使用领域层的方法即可，而无需充斥在各种<br> Service 里。</p><p>DDD 的核心思想就是：领域知识是一个业务工程里的核心资产。领域层是需要持续沉淀而稳定提升的。如果系统要做大的技术重构，按道理领域层应该是不用动的，动的是技术层。对于复杂业务工程来说，一定要有领域层。</p><h4 id="代码拆分太粗放" tabindex="-1"><a class="header-anchor" href="#代码拆分太粗放" aria-hidden="true">#</a> 代码拆分太粗放</h4><p>代码放置太粗放，也是导致代码可复用性差的一个因素。只按照 Controller - Service - Dao 来拆分代码，自然很多代码重担就落在了<br> Service 里，因为 Controller 和 Dao 的职责比较固定，逻辑也偏少。</p><p>更加细致的代码拆分是怎样的？</p><p>以下是业务层的：</p><ul><li>Controller : 仅作为请求转发层和参数适配层；</li><li>Service: 参数校验与业务逻辑流程。很多人把参数校验放在 Controller 层，我觉得不妥。因为如果要复用 Service 的方法，参数校验也是要复用的；</li><li>Dao: 数据库访问层。可以作为数据库中间件的适配和隔离；</li><li>Model: 与数据库直接交互的数据对象，目前基本是贫血模型，只有属性；</li><li>DTO： 数据传输对象，目前基本是贫血模式，实际上应该是富写模型，放在领域层；</li><li>Helper: 业务辅助类，领域层。可复用的业务逻辑判断、业务流程需要放在这里；</li><li>Exception: 异常处理和错误管理相关；</li><li>Constants: 业务枚举，业务常量；</li><li>Config: 系统配置相关；</li><li>Loader：系统初始化相关；</li><li>Cache: 业务缓存；</li><li>Components: 业务组件；</li><li>Receiver：数据消费接收器；</li><li>Handler: 事件处理类；</li><li>Context: 长流程里的上下文语境类；</li><li>Strategy： 同一业务目标的不同业务处理逻辑的策略类。用于分离不同业务的差异很好用；</li><li>Plugin: 业务插件，用于扩展；</li><li>Listener: 监听器；</li><li>Scheduler: 定时任务调度；</li><li>Job: 业务任务；</li><li>Producer: 任务生产者；</li><li>Consumer: 任务消费者；</li><li>Switch: 开关控制；</li><li>Wrapper: 包装器；</li><li>Adapter: 适配器。</li></ul><p>以下是技术层的：</p><ul><li>Concurrent: 线程池、分布式锁等。</li><li>Util: 工具类，可复用的技术逻辑。</li><li>Interceptor: 拦截器，用于流程修改和业务逻辑转换。</li><li>[De]Serializer: JSON 自定义序列化与反序列化</li></ul><p>总之，当仔细去思考业务中的大大小小的关注点，把关注点的粒度最小化，就能发现更多放置代码的层次和地方。这并非是固定不变的。</p><p>还有一个问题： 整体工程结构是按技术结构拆分还是按业务功能拆分？</p><ul><li>按照技术结构拆分，然后在每个技术子包里有业务拆分的子包。益处是，技术结构清晰；弊端是，业务实现则需要从各个子包里寻找拼凑出来，对业务不友好；</li><li>按照业务功能拆分。每个业务下有自己的技术子包。益处是，很容易定位一个业务的所有相关实现；弊端是，公共的部分容易散落在具体业务里，且子包数量会膨胀。<br> 目前基本是按照技术结构拆分，符合研发同学对设计理念的认知。也许有一天，会开始按照业务拆分。</li></ul><h4 id="不合理的访问级别" tabindex="-1"><a class="header-anchor" href="#不合理的访问级别" aria-hidden="true">#</a> 不合理的访问级别</h4><p>由于倾向于把很多业务逻辑都放在 Service 里，自然很多潜在可复用的方法就会被设置成 private， 外部无法复用。当要复用时：</p><ul><li>可复用的方法放在很大的 Service 和 Flow 里，即使可以复用，但依赖这么大一个类或不恰当的层次，心有戚戚然焉；适合被依赖的最好是一个具有单一职责的小组件类；</li><li>可复用的方法是 private，需要改成 public ，增加相应接口定义。<br> 这种情形，通常就是代码放置的层次和地方不合理。应该抽离到一个单独的小组件类里，设置为 public 方法。</li></ul><h4 id="惰性" tabindex="-1"><a class="header-anchor" href="#惰性" aria-hidden="true">#</a> 惰性</h4><p>惰性是人固有的生理特性，也是阻碍人持续进步的最大的因素。或许是老天爷开的善意玩笑吧。毕竟，生物的基本设定就是，能够躺着就不想坐着。</p><p>简单的事情如果做不好，基本可以归为惰性的缘故。就像单一事实原则，到底是这个原则实际上很难做到，还是因为惰性而不愿意主动多走一步？</p><h4 id="缺乏可复用代码的意识和技巧" tabindex="-1"><a class="header-anchor" href="#缺乏可复用代码的意识和技巧" aria-hidden="true">#</a> 缺乏可复用代码的意识和技巧</h4><p>没有思考过，没有学习过，没有被教授过，没有练习过，写可复用代码。这样，写出的代码就是“山大王代码”。这是我的地盘，只能我动，其它人只能远观不能亵玩焉。</p><p>缺乏写可复用代码的意识，如果异常处理做得比较周密，还能成为一个合格的程序员，起码能保证基本的工程质量。但别指望他能做一些对团队整体有益的事情。</p><p>如果有写可复用代码的意识，而缺乏写可复用代码的方法和技巧，那么就从做好单一事实职责开始吧！</p><p>如果要有更强的写可复用代码的意识，每写一段代码，都会思考，哪些部分是通用的，哪些部分是差异的，然后努力将公共的或者差异的部分提取出来，这样，才能逐渐提升写可复用代码的意识和技能。</p><h4 id="缺乏分离与解耦差异的技能" tabindex="-1"><a class="header-anchor" href="#缺乏分离与解耦差异的技能" aria-hidden="true">#</a> 缺乏分离与解耦差异的技能</h4><p>如果要达到更高层次的可复用性，则需要掌握分离和解耦差异的技能。善于把业务逻辑和流程进行分离和解耦，让每个组件自行负责各自的工作，让关注点清晰可辨，让交互自然流畅。</p><p>为什么代码难以复用？正常情况下，一段代码总会有一些特定差异的逻辑和一些通用的逻辑，而且差异的逻辑往往潜藏在代码的任任意位置。由于缺乏将特定差异的逻辑提取出来的技巧，就会导致代码很正常但就是难以复用。</p><p>函数式编程和设计模式，能够很大程度上提升代码的可复用性。函数式编程，用函数来表达差异；设计模式，确定了明确的组件职责，让交互更加自然，容易扩展。</p><h4 id="细小关注点没有抽离" tabindex="-1"><a class="header-anchor" href="#细小关注点没有抽离" aria-hidden="true">#</a> 细小关注点没有抽离</h4><p>软件系统中充满着各种大大小小的关注点，技术关注点，业务关注点。哪怕是一段中文乱码处理，也是一个小关注点。细小的关注点没有抽离出来，就会导致高度的重复。我是见证了职业生涯所遇到的最高程度的代码重复艺术。</p><h4 id="瀑布流代码的益处与弊处" tabindex="-1"><a class="header-anchor" href="#瀑布流代码的益处与弊处" aria-hidden="true">#</a> 瀑布流代码的益处与弊处</h4><p>当然，不能只是负向批评。难以复用的瀑布流代码也是有其益处的：读起来贴合程序员的自然思维。好的瀑布流代码读起来很流畅。遗憾的是，<br> 很少瀑布流代码能够做到这一点。大多数瀑布流代码都会面临后期的各种修改，逐渐因为各种分支语句导致水滴四溅，甚为壮观唯美。</p><p>与其益处相比，其弊处更多：</p><ul><li>如果代码只写一次，那么很清爽；</li><li>如果代码会被改动多次，每次改动都会影响整个流程，每次都需要大范围的回归测试；</li><li>多个人一起改动，容易产生冲突，在代码合并和解决冲突上会耗费很多时间和精力。</li></ul><h2 id="团队协作" tabindex="-1"><a class="header-anchor" href="#团队协作" aria-hidden="true">#</a> 团队协作</h2><p>为什么代码可复用性如此重要？</p><p>软件开发是团队协作的生动体现。然而，<br> 团队协作并不是“你在我代码上修修补补，我在你代码上修修补补”这种简单低级的协作。何为真正的团队协作？每个成员都充分分享和贡献自己的创作和成果，同时每个人都能从团队其它成员的创作和成果上获得新知、经验和工具，高效促进自己的工作。</p><p>代码可复用性体现了团队协作的高效程度。</p><ul><li>每个成员都致力于创造可复用的构件；</li><li>每个成员都把别人写的代码当成自己写的代码，改进和测试所使用到构件；</li><li>大多数时候，并不需要从头写起，而是可以直接在某个基础上开始工作；</li><li>如果要修改，则是新增而不是在里面修改，即符合开闭原则。<br> 代码可复用性差，那么研发效率不会高到哪里去。</li></ul><p>如何衡量代码可复用性？ 非常简单。当你开始构建一个功能时：</p><ul><li>过程：想要一个基础功能时，是否有现成可用；是否专注于构建自己所关注的业务自身相关的逻辑，而不是还要构建技术逻辑，构建一些基础业务逻辑，处理复杂的技术和业务交互；</li><li>结果： 最终写了多少行代码。代码越多，说明现有工程的可复用性越差（前提是你已经通读了整个工程的代码，知道没有可复用的，或者复用起来很麻烦）。</li></ul><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>软件开发是团队协作的生动体现，代码可复用性体现了团队协作的高效程度。本文探讨了阻碍代码可复用性的因素，以及如何做到代码可复用性的方法和技巧，希望对大家有所益处。</p><p>PS: 细想一下，做到代码可复用性还真的不那么容易：</p><ul><li>严格遵循单一事实原则。保持克制。避免一个方法做两件事；</li><li>最小化输入参数；</li><li>领域层逻辑抽离；</li><li>识别小业务组件并抽离，设置合理的访问级别；</li><li>细致放置代码到合适的地方，合理的包拆分；</li><li>细致识别小关注点并分离出来；</li><li>思考通用与差异的部分；</li><li>练习分离和解耦差异的技巧：函数式编程与设计模式。</li></ul>',64),p=[h];function d(n,t){return l(),e("div",null,p)}const u=i(a,[["render",d],["__file","eight.html.vue"]]);export{u as default};
