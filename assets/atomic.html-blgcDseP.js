const e=JSON.parse('{"key":"v-f64d5bcc","path":"/java/atomic.html","title":"Java原子类","lang":"zh-CN","frontmatter":{"title":"Java原子类","category":"Java","icon":"laptop-code","tag":["设计Java"],"description":"一、原子类简介 1 什么是原子类 Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。原子性的意思是对于一组操作，要么全部执行成功，要么全部执行失败，不能只有其中某几个执行成功。在多线程的情况下能够保证操作&nbsp;不会被中断，从而能保证并发安全 2. 与锁的区别 原子类作用和锁挺像，都可以保证并发情况下的线程安全。但是原子类比锁更具有优势： 粒度更细： 原子变量可以把多线程竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度都要比原子变量的粒度大 效率更高： 通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况","head":[["meta",{"property":"og:url","content":"https://ujava.cn/java/atomic.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"Java原子类"}],["meta",{"property":"og:description","content":"一、原子类简介 1 什么是原子类 Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。原子性的意思是对于一组操作，要么全部执行成功，要么全部执行失败，不能只有其中某几个执行成功。在多线程的情况下能够保证操作&nbsp;不会被中断，从而能保证并发安全 2. 与锁的区别 原子类作用和锁挺像，都可以保证并发情况下的线程安全。但是原子类比锁更具有优势： 粒度更细： 原子变量可以把多线程竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度都要比原子变量的粒度大 效率更高： 通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-23T07:07:33.000Z"}],["meta",{"property":"article:author","content":"UJava"}],["meta",{"property":"article:tag","content":"设计Java"}],["meta",{"property":"article:modified_time","content":"2024-04-23T07:07:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java原子类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-23T07:07:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"一、原子类简介","slug":"一、原子类简介","link":"#一、原子类简介","children":[{"level":3,"title":"1 什么是原子类","slug":"_1-什么是原子类","link":"#_1-什么是原子类","children":[]},{"level":3,"title":"2. 与锁的区别","slug":"_2-与锁的区别","link":"#_2-与锁的区别","children":[]},{"level":3,"title":"3. 原子类的底层实现","slug":"_3-原子类的底层实现","link":"#_3-原子类的底层实现","children":[]},{"level":3,"title":"4. 原子类种类","slug":"_4-原子类种类","link":"#_4-原子类种类","children":[]}]},{"level":2,"title":"二、原子类使用案例","slug":"二、原子类使用案例","link":"#二、原子类使用案例","children":[{"level":3,"title":"1. Atomic* 基本类型原子类","slug":"_1-atomic-基本类型原子类","link":"#_1-atomic-基本类型原子类","children":[]},{"level":3,"title":"2. Atomic*Array数组类型原子类","slug":"_2-atomic-array数组类型原子类","link":"#_2-atomic-array数组类型原子类","children":[]},{"level":3,"title":"3. Atomic*Reference引用类型原子类","slug":"_3-atomic-reference引用类型原子类","link":"#_3-atomic-reference引用类型原子类","children":[]},{"level":3,"title":"4. Atomic*FieldUpdater 升级类型原子类","slug":"_4-atomic-fieldupdater-升级类型原子类","link":"#_4-atomic-fieldupdater-升级类型原子类","children":[]}]},{"level":2,"title":"三、Adder累加器","slug":"三、adder累加器","link":"#三、adder累加器","children":[{"level":3,"title":"1. LongAdder 简介：","slug":"_1-longadder-简介","link":"#_1-longadder-简介","children":[]},{"level":3,"title":"2. 代码演示","slug":"_2-代码演示","link":"#_2-代码演示","children":[]},{"level":3,"title":"3. LongAdder 高并发性能好的原因","slug":"_3-longadder-高并发性能好的原因","link":"#_3-longadder-高并发性能好的原因","children":[]}]},{"level":2,"title":"四. Accumulator累加器","slug":"四-accumulator累加器","link":"#四-accumulator累加器","children":[{"level":3,"title":"1. 基本用法演示","slug":"_1-基本用法演示","link":"#_1-基本用法演示","children":[]},{"level":3,"title":"2. 灵活使用","slug":"_2-灵活使用","link":"#_2-灵活使用","children":[]},{"level":3,"title":"3. 使用场景：","slug":"_3-使用场景","link":"#_3-使用场景","children":[]}]}],"git":{"createdTime":1713856053000,"updatedTime":1713856053000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":1}]},"readingTime":{"minutes":9.66,"words":2899},"filePathRelative":"java/atomic.md","localizedDate":"2024年4月23日","excerpt":"<h2> 一、原子类简介</h2>\\n<h3> 1 什么是原子类</h3>\\n<p>Java中提供了一些原子类，原子类包装了一个变量，并且提供了一系列对变量进行原子性操作的方法。原子性的意思是对于一组操作，要么全部执行成功，要么全部执行失败，不能只有其中某几个执行成功。在多线程的情况下能够保证操作&nbsp;<code>不会被中断</code>，从而能保证并发安全</p>\\n<h3> 2. 与锁的区别</h3>\\n<p>原子类作用和锁挺像，都可以保证并发情况下的<code>线程安全</code>。但是原子类比锁更<code>具有优势</code>：</p>\\n<ul>\\n<li>\\n<p>粒度更细：</p>\\n<p>原子变量可以把多线程竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度都要比原子变量的粒度大</p>\\n</li>\\n<li>\\n<p>效率更高：</p>\\n<p>通常，使用原子类的效率会比使用锁的效率更高，除了高度竞争的情况</p>\\n</li>\\n</ul>","copyright":{"author":"UJava(ujava.cn)","license":"MIT"},"autoDesc":true}');export{e as data};
