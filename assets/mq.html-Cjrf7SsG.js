import{_ as i,o as a,c as e,a as d}from"./app-Ca2ol-z6.js";const r="/assets/img_7-CBi_xM6k.png",p="/assets/img_8-DK3_-8kF.png",n="/assets/img_9-BA1aiMI5.png",o="/assets/img_10-Cb3BK0Tx.png",l="/assets/img_11-DXktquUc.png",c="/assets/img_12-WPcBMZ0q.png",s="/assets/img_13-Bqoa9Muv.png",g="/assets/img_14-1Kooj03I.png",m={};function M(Q,t){return a(),e("div",null,t[0]||(t[0]=[d('<p>想必你在面试或者工作的过程中，被问过以下问题：</p><ul><li>（1）为什么你们项目要用消息队列？</li><li>（2）用了消息队列后有什么好处？</li><li>（3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？</li><li>（4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？</li></ul><p>如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。</p><p>技术选型是开发工作前最重要的，也是最体现技术的环节。</p><p>目前主流的消息队列分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ。</p><p>这篇文章重点介绍这四种消息队列的概述、对比和选型，不深入研究每种队列内部的实现原理。</p><figure><img src="'+r+'" alt="img_7.png" tabindex="0" loading="lazy"><figcaption>img_7.png</figcaption></figure><h2 id="消息队列是什么" tabindex="-1"><a class="header-anchor" href="#消息队列是什么"><span>消息队列是什么？</span></a></h2><p>消息队列是在消息的传输过程中保存消息的容器，简单点理解就是传递消息的队列，具备先进先出的特点，一般用于异步、解耦、流量削锋等问题，实现高性能、高可用、高扩展的架构。一个消息队列可以被一个或多个消费者消费，一般包含以下元素：</p><ul><li>Producer：消息生产者，负责产生和发送消息到 Broker。</li><li>Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue。</li><li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li></ul><h2 id="消息队列应用场景" tabindex="-1"><a class="header-anchor" href="#消息队列应用场景"><span>消息队列应用场景</span></a></h2><p>常见的消息队列使用场景有 6 个：</p><ul><li>应用解耦：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li><li>异步处理：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li><li>流量削锋：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li><li>日志处理：将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li><li>消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯，比如实现聊天室等。</li><li>消息广播：如果没有消息队列，每当一个新业务方接入，都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁订阅，是下游的事，无疑极大地减少了开发和联调的工作量。<br> 比较核心的有 3 个：解耦、异步、削峰，下面着重讲下：</li></ul><p>解耦</p><p>假设在没有消息队列的情况下，现在有上游服务 A 用来发布消息，下游服务 B、C 用来接收服务 A 的消息。但随着业务需要，现在有服务<br> D、E、F 需要接收服务 A 的消息，那么就出现问题了，每次新加入服务都要改一次代码，可想而知这是极大的工作量。</p><figure><img src="'+p+'" alt="img_8.png" tabindex="0" loading="lazy"><figcaption>img_8.png</figcaption></figure><p>如果引入消息队列，那就好办了，只需要下游服务自己订阅消息队列，而无需改动服务 A 的代码。</p><figure><img src="'+n+'" alt="img_9.png" tabindex="0" loading="lazy"><figcaption>img_9.png</figcaption></figure><p>异步</p><p>先来看没有消息队列的场景下。</p><p>服务 A 的某个接口接收到请求，分别需要在服务A、服务B、服务C、服务D进行写库。假设用户发起请求到服务 A 耗时 10ms，自己写库需要<br> 50ms，在服务 B 写库需要 250ms，在服务 C 写库需要 300ms，在服务 D 写库需要400ms，在没有消息队列的情况下，也就是同步操作，总耗时会是<br> 10 + 50ms + 250ms + 300ms + 400ms = 1.01s。用户发送个请求，结果感觉有点卡顿，响应的非常慢，任谁都是很难忍受的。</p><figure><img src="'+o+'" alt="img_10.png" tabindex="0" loading="lazy"><figcaption>img_10.png</figcaption></figure><p>如果使用了消息队列，那么服务 A 只需要把对服务A、B、C、D 进行写库的操作分别放进四个消息队列，假如用户发起请求到服务器耗时是10ms，发送消息到四个消息队列的耗时是10ms，那么总耗时就是<br> 20 ms 。用户点击了按钮后立马返回，没有卡顿现象，体验效果就会有极大的提升了。</p><figure><img src="'+l+'" alt="img_11.png" tabindex="0" loading="lazy"><figcaption>img_11.png</figcaption></figure><p>一般接口同步处理时间很长，不能通过水平扩容来解决，且业务场景允许异步，就可以使用异步解决，比如文件上传下载受限于用户的网络带宽因素，扩容也无用，以及上述同步操作耗时长等情况，都可以先放进消息队列，等服务再进行拉取消费。</p><p>削峰</p><p>在淘宝双十一活动日，特别是 0<br> 点的秒杀活动高峰期时，接口流量会飙升，远远高于平时，就像一个山峰，没有做好处理的话，在高峰期数据库就可能被流量打死，从而导致整个服务奔溃。如果为了在高峰期能顶住流量而常备高流量设备，会有极大的成本浪费。如果是在要高峰期前进行临时服务扩容，很可能会出现许多扩容问题，没有那么简单。</p><p>使用消息队列的话，就可以将高峰期过多的流量请求放进消息队列，等高峰期过后，服务再慢慢进行处理，就不会出现峰值流量了，而是一个相对平稳的状态。</p><p>举个例子：</p><ul><li>大量的用户在中午高峰期的时候，每秒有 4k 个请求，那么每秒就有 4k 个请求放到 MQ 里。</li><li>服务A 每秒只能处理 2k 个请求，因为 Mysql 每秒最多处理 2k 个请求。</li><li>服务A 就每秒从 MQ 拉取 2k 个请求进行处理，不会超过自己每秒能处理的最大请求量，所以高峰期服务 A 就不会挂掉。</li><li>对于MQ，每秒 4k 个请求进来，但是却只有 2k 个请求出去，导致在高峰期 1h 内可能有几十万的请求积压在 MQ<br> 中。这个短暂的高峰期请求积压是可以接受的，因为过了这个时间点，每秒就 100 个请求进 MQ，但这时服务 A 还是会按照每秒 2k 的速度处理<br> MQ 积压的请求。</li><li>所以，高峰期一过，服务 A 就会快速的将 MQ 积压的消息处理掉。</li></ul><figure><img src="'+c+'" alt="img_12.png" tabindex="0" loading="lazy"><figcaption>img_12.png</figcaption></figure><h2 id="消息队列模型" tabindex="-1"><a class="header-anchor" href="#消息队列模型"><span>消息队列模型</span></a></h2><p>点对点模式：多个生产者可以向同一个消息队列发送消息，一个消息只能被一个消费者消费，在被消费成功后，这条消息会被移除。如果消费者处理消息失败了，那么这条消息会重新被消费。</p><figure><img src="'+s+'" alt="img_13.png" tabindex="0" loading="lazy"><figcaption>img_13.png</figcaption></figure><p>发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。多个生产者可以将多个消息写到同一个 Topic 中，被同一个消费者消费。</p><figure><img src="'+g+'" alt="img_14.png" tabindex="0" loading="lazy"><figcaption>img_14.png</figcaption></figure><h2 id="消息队列对比" tabindex="-1"><a class="header-anchor" href="#消息队列对比"><span>消息队列对比</span></a></h2><p>消息队列有 ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ、Kafka，其中 ZeroMQ 太过轻量，主要用于学习，实际是不会应用到生产，所以主要对比<br> Kafka、RocketMQ、RabbitMQ、ActiveMQ 这四种 MQ。</p><table><thead><tr><th>特性</th><th>Kafka</th><th>RocketMQ</th><th>RabbitMQ</th><th>ActiveMQ</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>10万级别，吞吐量高是kafka最大的优点</td><td>10万级，RocketMQ 也是可以支撑高吞吐的 MQ</td><td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td></tr><tr><td>支持主题数</td><td>百级，topic 达到百级时吞吐量会大幅度下降，要尽量保证 topic 数量不要过多，否则需要增加更多机器资源</td><td>千级，topic 达到千级时吞吐量会有较小幅度的下降。可以支撑大量 topic 是 RocketMQ 的一大优点</td><td>百万级</td><td>千级</td></tr><tr><td>消息顺序性</td><td>分区有序</td><td>有序</td><td>有序</td><td>有序</td></tr><tr><td>消息重复</td><td>至少一次，最多一次</td><td>至少一次，最多一次</td><td>至少一次</td><td>至少一次</td></tr><tr><td>时效性</td><td>ms级</td><td>ms级</td><td>微秒级，RabbitMQ的一大优点</td><td>ms级</td></tr><tr><td>可用性</td><td>非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td><td>非常高，分布式架构</td><td>高，基于主从架构实现高可用性</td><td>高，基于主从架构实现高可用性</td></tr><tr><td>消息可靠性</td><td>经过参数优化配置，理论上消息可以做到0丢失</td><td>经过参数优化配置，理论上消息可以做到0丢失</td><td>有较低的概率丢失数据</td><td>有较低的概率丢失数据</td></tr><tr><td>消息回溯</td><td>支持（按offset回溯）</td><td>支持（按时间回溯）</td><td>不支持</td><td>不支持</td></tr><tr><td>功能支持</td><td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td><td>MQ功能较为完善，还是分布式的，扩展性好</td><td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td>MQ领域的功能极其完备</td></tr><tr><td>伸缩性</td><td>高伸缩性，每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中</td><td>高伸缩性，灵活的分布式横向扩展部署架构，整体架构和 kafka 很像</td><td>一般</td><td></td></tr><tr><td>管理界面</td><td>普通</td><td>完善</td><td>普通</td><td>普通</td></tr><tr><td>持久化</td><td>消息可以持久化到磁盘</td><td>消息可以持久化到磁盘</td><td>持久化不好，可以持久化到内存、文件</td><td>可以持久化到内存、文件、数据库</td></tr><tr><td>消息路由</td><td>不支持</td><td>不支持</td><td>支持</td><td></td></tr><tr><td>语言支持</td><td>支持多语言，Java优先</td><td>支持Java、C++，但C++不成熟</td><td>支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等</td><td>支持多语言，Java优先</td></tr><tr><td>社区活跃度</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr></tbody></table><h2 id="消息队列选型" tabindex="-1"><a class="header-anchor" href="#消息队列选型"><span>消息队列选型</span></a></h2><p>Kafka 和 RocketMQ 都支持 10w 级别的高吞吐量。</p><p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用<br> Kafka 绝对没错，社区活跃度高，业内标准。</p><p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ<br> 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用<br> RocketMQ。</p><p>RabbitMQ<br> 适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高，能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用<br> Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p><p>ActiveMQ 现在很少有人用，没怎么经过大规模吞吐量场景的考验，社区不怎么活跃，官方社区现在对 ActiveMQ 5.x 维护也越来越少，所以不推荐使用。</p>',45)]))}const f=i(m,[["render",M],["__file","mq.html.vue"]]),k=JSON.parse('{"path":"/assembly/mq.html","title":"组件MQ","lang":"zh-CN","frontmatter":{"title":"组件MQ","icon":"laptop-code","category":["设计组件"],"tag":["组件"],"description":"想必你在面试或者工作的过程中，被问过以下问题： （1）为什么你们项目要用消息队列？ （2）用了消息队列后有什么好处？ （3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？ （4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？ 如果你只会回答 ”我只会用这个消...","head":[["meta",{"property":"og:url","content":"https://ujava.cn/assembly/mq.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"组件MQ"}],["meta",{"property":"og:description","content":"想必你在面试或者工作的过程中，被问过以下问题： （1）为什么你们项目要用消息队列？ （2）用了消息队列后有什么好处？ （3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？ （4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？ 如果你只会回答 ”我只会用这个消..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-16T08:43:59.000Z"}],["meta",{"property":"article:author","content":"UJava"}],["meta",{"property":"article:tag","content":"组件"}],["meta",{"property":"article:modified_time","content":"2024-04-16T08:43:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"组件MQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-16T08:43:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"消息队列是什么？","slug":"消息队列是什么","link":"#消息队列是什么","children":[]},{"level":2,"title":"消息队列应用场景","slug":"消息队列应用场景","link":"#消息队列应用场景","children":[]},{"level":2,"title":"消息队列模型","slug":"消息队列模型","link":"#消息队列模型","children":[]},{"level":2,"title":"消息队列对比","slug":"消息队列对比","link":"#消息队列对比","children":[]},{"level":2,"title":"消息队列选型","slug":"消息队列选型","link":"#消息队列选型","children":[]}],"git":{"createdTime":1713257039000,"updatedTime":1713257039000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":1}]},"readingTime":{"minutes":10.17,"words":3052},"filePathRelative":"assembly/mq.md","localizedDate":"2024年4月16日","excerpt":"<p>想必你在面试或者工作的过程中，被问过以下问题：</p>\\n<ul>\\n<li>（1）为什么你们项目要用消息队列？</li>\\n<li>（2）用了消息队列后有什么好处？</li>\\n<li>（3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？</li>\\n<li>（4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？</li>\\n</ul>\\n<p>如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。</p>\\n<p>技术选型是开发工作前最重要的，也是最体现技术的环节。</p>","autoDesc":true}');export{f as comp,k as data};
