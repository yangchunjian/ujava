const e=JSON.parse('{"key":"v-15d6b915","path":"/java/reentrantlock.html","title":"Java ReentrantLock锁的设计思想","lang":"zh-CN","frontmatter":{"title":"Java ReentrantLock锁的设计思想","category":"Java","icon":"laptop-code","tag":["设计Java"],"description":"一、开头 在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。 主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题： 线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度 过多线程造成线程之间的上下文切换，导致效率低下 因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。” 简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。","head":[["meta",{"property":"og:url","content":"https://ujava.cn/java/reentrantlock.html"}],["meta",{"property":"og:site_name","content":"UJava"}],["meta",{"property":"og:title","content":"Java ReentrantLock锁的设计思想"}],["meta",{"property":"og:description","content":"一、开头 在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。 主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题： 线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度 过多线程造成线程之间的上下文切换，导致效率低下 因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。” 简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-05T00:56:06.000Z"}],["meta",{"property":"article:author","content":"UJava"}],["meta",{"property":"article:tag","content":"设计Java"}],["meta",{"property":"article:modified_time","content":"2024-03-05T00:56:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java ReentrantLock锁的设计思想\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-05T00:56:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"UJava\\",\\"url\\":\\"https://ujava.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"一、开头","slug":"一、开头","link":"#一、开头","children":[]},{"level":2,"title":"二、关健术语","slug":"二、关健术语","link":"#二、关健术语","children":[]},{"level":2,"title":"三、基本概述","slug":"三、基本概述","link":"#三、基本概述","children":[{"level":3,"title":"1.AQS基础同步器基本理论","slug":"_1-aqs基础同步器基本理论","link":"#_1-aqs基础同步器基本理论","children":[]},{"level":3,"title":"2. JDK显式锁统一概念模型","slug":"_2-jdk显式锁统一概念模型","link":"#_2-jdk显式锁统一概念模型","children":[]},{"level":3,"title":"3.ReentrantLock(可重入锁)的设计与实现","slug":"_3-reentrantlock-可重入锁-的设计与实现","link":"#_3-reentrantlock-可重入锁-的设计与实现","children":[]}]},{"level":2,"title":"四、具体实现","slug":"四、具体实现","link":"#四、具体实现","children":[]},{"level":2,"title":"五、最后","slug":"五、最后","link":"#五、最后","children":[]}],"git":{"createdTime":1706515597000,"updatedTime":1709600166000,"contributors":[{"name":"yangchunjian","email":"1091938307@qq.com","commits":5}]},"readingTime":{"minutes":20.66,"words":6198},"filePathRelative":"java/reentrantlock.md","localizedDate":"2024年1月29日","excerpt":"<h2> 一、开头</h2>\\n<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。<br>\\n主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题：</p>\\n<ul>\\n<li>线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度</li>\\n<li>过多线程造成线程之间的上下文切换，导致效率低下</li>\\n</ul>\\n<p>因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。”<br>\\n简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。</p>","copyright":{"author":"UJava(ujava.cn)","license":"MIT"},"autoDesc":true}');export{e as data};
