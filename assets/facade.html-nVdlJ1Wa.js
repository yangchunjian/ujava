import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o,c,e as d}from"./app-itiH1JMU.js";const t={},a=d('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p><strong>介绍</strong>：外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个简单的接口来访问复杂系统中的子系统，从而隐藏了子系统的复杂性。外观模式属于对象型模式，它通过创建一个外观类，将客户端与子系统解耦，使得客户端只需要与外观类交互即可完成操作。通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，<code>或者解决性能、分布式事务等问题</code>。当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。<code>如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系</code>。</p><p><strong>场景</strong>：1.子系统相对独立时可使用，<code>Tomcat源码</code>中有很多不同组件，每个组件要相互通信。<code>mybatis源码</code></p><p><strong>优点</strong>：</p><ul><li>1.<code>松耦合</code>，用户与子系统解耦，屏蔽子系统；可以提高子系统的独立性；</li><li>2.<code>使用简单</code>，用户只与门面对接，有统一的入口；不需要知道所有子系统及内部构造；</li><li>3.<code>更好的划分访问层次</code></li></ul><p><strong>不足</strong>：</p><ul><li>1.<code>没有面向抽象编程</code>，而是通过增加中介层，转换服务提供方的服务接口；</li><li>2.<code>不符合开闭原则</code>，如果要改东西很麻烦，<code>继承重写都不合适</code></li></ul>',7),r=[a];function n(s,i){return o(),c("div",null,r)}const f=e(t,[["render",n],["__file","facade.html.vue"]]);export{f as default};
