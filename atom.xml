<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://ujava.cn/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://ujava.cn/</id>
  <title>UJava</title>
  <subtitle> 【Java学习 + Java面试】首选UJava！  </subtitle>
  <icon>https://ujava.cn/favicon.ico</icon>
  <updated>2024-04-15T02:55:53.726Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://ujava.cn/atom.xml"/>
  <link rel="alternate" href="https://ujava.cn/"/>
  <category term="设计高频"/>
  <category term="设计模式"/>
  <entry>
    <title type="text">服务器高并发之提高TCP连接数</title>
    <id>https://ujava.cn/highfreq/tcpcount.html</id>
    <link href="https://ujava.cn/highfreq/tcpcount.html"/>
    <updated>2024-04-15T02:55:40.000Z</updated>
    <summary type="html"><![CDATA[<h2> 前言</h2>
<ul>
<li>测试服务器系统：ubuntu server 20.04.3</li>
<li>nginx负载均衡服务器：centos 7</li>
<li>服务器上我放了一个web系统用来测试连接数：<a href="https://github.com/yedf/handy" target="_blank" rel="noopener noreferrer">开源的支持高并发的服务器</a></li>
<li>发出请求的是我的电脑，电脑系统：win7</li>
<li>发出请求用的是python的压测工具：locust</li>
</ul>
<h2> TCP连接能连接多少</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 前言</h2>
<ul>
<li>测试服务器系统：ubuntu server 20.04.3</li>
<li>nginx负载均衡服务器：centos 7</li>
<li>服务器上我放了一个web系统用来测试连接数：<a href="https://github.com/yedf/handy" target="_blank" rel="noopener noreferrer">开源的支持高并发的服务器</a></li>
<li>发出请求的是我的电脑，电脑系统：win7</li>
<li>发出请求用的是python的压测工具：locust</li>
</ul>
<h2> TCP连接能连接多少</h2>
<p>要想弄清楚一个服务器能接受多少连接数，就需要根据socket五元组来看，即源IP+源端口+目标IP+目标端口+类型（TCP/UDP）。只要五元组不重复，就可以新增tcp连接。不过由于测试的时候一般类型都是相同的，所有大多数都是称为四元组。<br>
由于服务器的IP和web系统的端口一般是固定的，每个客户端的IP又不相同，那么照这样看连接数应该基本上相当于没限制才对。其实不然，实际上每个连接还要占用一定的内存和一个文件描述符。</p>
<p><strong>那么一个TCP socket占用多少内存呢？</strong><br>
大约是3K多，当然如果有发送或者接收的缓存区文件存在则另算，在响应较快、缓存文件不大的情况下内存应该不会成为瓶颈。</p>
<p><strong>服务器又能打开多少文件描述符呢？</strong><br>
可以通过以下命令查看<br>
系统级：当前系统可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/file-max</code>&nbsp;查看<br>
用户级：指定用户可打开的最大数量，通过&nbsp;<code>cat /etc/security/limits.conf</code>&nbsp;查看<br>
进程级：单个进程可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/nr_open</code>&nbsp;查看</p>
<p>修改方式<br>
修改单个进程可打开的最大文件描述符为10000，即可打开10000个连接：<code>echo 10000 &gt; /proc/sys/fs/nr_open</code><br>
用户级修改：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，每创建一个tcp连接，还需要消耗一个线程来处理（也可以采用IO多路复用的方式，一个线程管理多个TCP连接），所以和CPU也有关系，不能通过单纯的提高内存的方式来增加连接数。<br>
常用查看连接数命令：<br>
<code>netstat -nat | grep -i "8085" | wc -l # 查询指定端口的连接数</code><br>
<code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # 查看TCP连接数及状态命令</code></p>
<h2> 实际测试</h2>
<p>此时是使用我的电脑向nginx负载均衡服务器发送请求，然后转发给web服务器。</p>
<h3> 测试1 未调整的情况下测试</h3>
<p><strong>客户端情况：</strong><br>
初始：可用端口55000个，性能够用<br>
结果：本地性能未达瓶颈，但是设置的1000并发人数，请求数平均只有437.3。<br>
</p>
<p><strong>nginx服务器情况：</strong><br>
初始：可用端口60000个，用户级65535，性能够用<br>
结果：本地性能未达瓶颈，但是出现很多TIME_WAIT数，最高时8000多。<br>
</p>
<p><strong>服务器情况：</strong><br>
初始：用户级65535。<br>
结果：最高连接数23，平均2.<br>
</p>
<h3> 测试1分析</h3>
<p>先分析一下TIME_WAIT、CLOSE_WAIT出现的原因及解决方法<br>
分析这里，就必须要简短回顾一下四次挥手（当client发起结束请求时）<br>
<br>
简短来说：<br>
1、一端没有close，那么另一端将有大量的close_wait状态；<br>
2、主动close的一端，在量特别大的情况下将造成大量的time_wait状态（由于Linux中一般默认的2msl为60s，那么正常情况下每秒1000的请求会造成60*1000=60000个time_wait记录，几百几千问题不大）</p>
<p>既然主动close的一方才会有time_wait记录，那么这里就说明nginx服务器是主动关闭的一方，那nginx服务器关闭的对象又是谁呢？<br>
在仅修改了nginx的代理地址，未改变其他配置情况下，通过wireshark抓包得知：</p>
<ul>
<li>客户端与nginx端相互通信都是http/1.1的链接，这里是nginx端先发起的fin请求；</li>
<li>nginx端到服务器端的请求是http/1.0，服务器端返回的请求是http/1.1，这里是nginx端先发起的fin请求。</li>
</ul>
<h3> 测试1优化</h3>
<p>依上面的场景分析，如果要减少time_wait数，提高连接数，则需要从以下方面来解决</p>
<ol>
<li>调整负载均衡服务器和web服务器/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，修改成&nbsp;<code>net.ipv4.ip_local_port_range=1024 65535</code>，保证至少可以使用6万个随机端口，就算保留1分钟，也能支持每秒1000的并发；</li>
<li>加多负载均衡服务器的ip，直接翻番；</li>
<li>负载均衡与服务器端也建立长连接，不关闭就不会有等待；</li>
<li>扩大nginx的keep-alive超时时间，最大请求数，使得长连接不会这么早关闭；</li>
<li>在nginx服务器上调整time_wait参数net.ipv4.tcp_tw_reuse=1，尽可能去复用连接（另外net.ipv4.tcp_tw_recycle参数在4.10以上内核中被移除了）。</li>
</ol>
<p>另外还有一些参数可以调整，不过一般默认是够用的</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>待优化测试验证</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T02:55:40.000Z</published>
  </entry>
  <entry>
    <title type="text">高并发场景下如何优化微服务的性能</title>
    <id>https://ujava.cn/highfreq/performance.html</id>
    <link href="https://ujava.cn/highfreq/performance.html"/>
    <updated>2024-04-15T02:24:32.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1.背景介绍</h2>
<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>
<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>
<h2> 2.核心概念与联系</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 1.背景介绍</h2>
<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>
<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>
<h2> 2.核心概念与联系</h2>
<p>在微服务架构中，计算性能的重构主要包括以下几个方面：</p>
<p>分布式计算：将计算任务分散到多个节点上，通过网络间通信实现数据交换和任务协同。<br>
并发处理：利用多核处理器和多线程技术，实现并发处理，提高计算效率。<br>
数据分区：将数据划分为多个部分，每个服务只处理自己的数据，减少通信开销。<br>
负载均衡：将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>
这些概念和技术在微服务架构中相互联系，共同实现高性能计算。</p>
<h2> 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解</h2>
<p>在微服务架构中，重构计算的核心算法原理包括以下几个方面：</p>
<h1> 分布式计算：使用MapReduce算法实现分布式计算，将大型数据集划分为多个子任务，每个子任务在多个节点上并行执行，最后通过reduce阶段将结果聚合到一个最终结果中。<br>
MapReduce=(Map,Shuffle,Reduce)<br>
MapReduce</h1>
<h1> (<br>
Map<br>
,<br>
Shuffle<br>
,<br>
Reduce<br>
)<br>
并发处理：使用线程池技术实现并发处理，将任务分配到多个线程中执行，提高计算效率。<br>
线程池=(核心线程数,最大线程数,工作队列)<br>
线程池</h1>
<h1> (<br>
核心线程数<br>
,<br>
最大线程数<br>
,<br>
工作队列<br>
)<br>
数据分区：使用哈希分区算法实现数据分区，将数据按照某个关键字划分为多个部分，每个服务只处理自己的数据。<br>
哈希分区=(关键字,哈希函数,分区数)<br>
哈希分区</h1>
<h1> (<br>
关键字<br>
,<br>
哈希函数<br>
,<br>
分区数<br>
)<br>
负载均衡：使用Consistent Hashing算法实现负载均衡，将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>
一致性哈希=(虚拟节点,哈希函数,节点集)<br>
一致性哈希</h1>
<p>(<br>
虚拟节点<br>
,<br>
哈希函数<br>
,<br>
节点集<br>
)</p>
<h2> 4.具体代码实例和详细解释说明</h2>
<p>在这里，我们以一个简单的Word Count示例来展示如何在微服务架构中实现高性能计算。</p>
<p>使用MapReduce算法实现分布式计算：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用线程池技术实现并发处理：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用哈希分区算法实现数据分区：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用一致性哈希算法实现负载均衡：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.未来发展趋势与挑战</h2>
<p>随着大数据和人工智能的发展，微服务架构在计算性能方面面临着越来越大的挑战。未来的发展趋势包括：</p>
<ul>
<li>
<p>更高性能的分布式计算：通过优化算法和数据结构，提高分布式计算的性能。</p>
</li>
<li>
<p>更智能的负载均衡：通过学习算法和自适应机制，实现更智能的负载均衡。</p>
</li>
<li>
<p>更高效的数据存储和处理：通过新的存储技术和处理方法，提高数据存储和处理的效率。<br>
挑战包括：</p>
</li>
<li>
<p>系统复杂性：微服务架构的系统复杂性增加，导致开发、测试和维护的难度增加。</p>
</li>
<li>
<p>数据一致性：在分布式计算中，保证数据的一致性变得越来越难以实现。</p>
</li>
<li>
<p>安全性和隐私：在大数据时代，数据安全性和隐私保护成为关键问题。</p>
</li>
</ul>
<h2> 6.附录常见问题与解答</h2>
<p>Q: 微服务架构与传统架构有什么区别？</p>
<p>A: 微服务架构将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。而传统架构通常是基于大型应用程序和单个进程结构的。</p>
<p>Q: 如何选择合适的算法和数据结构？</p>
<p>A: 在选择算法和数据结构时，需要考虑问题的特点，如问题规模、时间复杂度、空间复杂度等。同时，也需要考虑算法和数据结构的实现难度和性能。</p>
<p>Q: 如何保证微服务架构的高性能？</p>
<p>A: 要保证微服务架构的高性能，需要关注分布式计算、并发处理、数据分区和负载均衡等方面。同时，还需要关注系统的设计和优化，如选择合适的算法和数据结构、减少通信开销、提高系统可扩展性等。</p>
<p>Q: 如何处理微服务架构中的数据一致性问题？</p>
<p>A: 在微服务架构中，数据一致性问题可以通过使用分布式事务、版本控制和幂等性等方法来解决。同时，还可以通过设计合理的系统架构和算法来减少数据一致性问题的影响。</p>
<p>Q: 如何保证微服务架构的安全性和隐私？</p>
<p>A: 保证微服务架构的安全性和隐私需要关注多方面，如身份验证、授权、加密、审计等。同时，还需要关注数据存储和处理的安全性，如使用安全的存储技术和处理方法。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T02:24:32.000Z</published>
  </entry>
  <entry>
    <title type="text">微服务架构构建之微服务拆分</title>
    <id>https://ujava.cn/highfreq/split.html</id>
    <link href="https://ujava.cn/highfreq/split.html"/>
    <updated>2024-04-15T02:16:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>
<h2> 一、微服务拆分的原则</h2>
<p>微服务拆分原则有以下几个：</p>
<p>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</p>
<p>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>
<h2> 一、微服务拆分的原则</h2>
<p>微服务拆分原则有以下几个：</p>
<p>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</p>
<p>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</p>
<p>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</p>
<p>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</p>
<p>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</p>
<p>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</p>
<p>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</p>
<p>同样，也可以参考一下，这篇文章对服务拆分原则的理解。以下摘自该文章。</p>
<p>使用有界上下文。</p>
<p>确定核心域并保持竞争优势。</p>
<p>对通用域进行成本优化。</p>
<p>考虑支持领域。</p>
<p>引入反腐层。</p>
<p>识别数据通信模式。</p>
<p>引入事件驱动架构。</p>
<p>使API简洁明了。</p>
<p>将相关的微服务合并为更大的服务。</p>
<p>引入无缝开发支持工具。</p>
<p>不管是哪种拆分原则，目标都是需要将相同或相似的服务聚合在一起，形成一个独立的自治服务。</p>
<h2> 二、微服务拆分的时机</h2>
<p>通过《02-微服务架构的概念与优缺点》可以了解到微服务架构具备很多的优点，能够有效解决项目业务扩大所带来的问题。然而，并非所有公司都适合采用微服务架构，尤其是规模较小且业务相对固定的公司。对于这些公司来说，从服务层面，他们不会有更多变化，通过优化现有服务即可满足需求。从成本方面，构建微服务架构，需要很多资源和配套的中间件。因此，对于那些规模较大，业务服务复杂度高，同时业务也在不断更新或新增的项目，微服务架构则是非常适合的选择。</p>
<p>在确定使用微服务架构后，服务的拆分是一项重要任务。根据拆分原则，我们可以在恰当的时机进行服务拆分。然而，根据行业经验来看，并不建议在项目构建初期进行服务拆分。主要原因有以下几点：</p>
<p>项目构建初期，服务单一，数据量较少，及时是单体系统都可以支撑业务。</p>
<p>项目构建初期，服务没有形成体系，更没有规模服务，很难做到微服务的单一职责和服务自治。</p>
<p>业务架构不够成熟，目前提供的服务，很有可能会优化，甚至更改技术栈重构。</p>
<p>因此，项目构建初期无需将其拆分，因为强行拆分此时可能会产生适得其反的效果。而遇到下面这些情况就可以进行服务拆分了。</p>
<p>项目足够成熟并且业务稳定，团队成员不断扩大并且目前的服务想要扩展很难。只有在项目成熟的情况下，业务专家才可以从精确的划分出业务领域，进而将各个服务分解到业务领域内，最终形成各自独立的微服务。</p>
<p>项目要求CI/CD（持续集成/持续交付）。尤其是很多新兴的互联网公司，要求系统在尽可能不停机的情况下，还需要持续上线新的功能。使用敏捷开发，可以更好地让开发者在完成周期形的业务交付，而DevOps则可以将这些代码，进行自动化测试、构建和集成，不断的完成新的需求提交，并保证代码的质量和稳定性。</p>
<p>正式运行的项目，部分服务需要停机。当上线一些有问题的服务时，将该部分服务停机，这个情况对单体应用是非常有困难的。而微服务架构中，可以对存在问题的微服务进行下线处理，从而达到快速解决问题的目的。</p>
<h2> 三、微服务拆分的方法</h2>
<p>在掌握了准确的微服务拆分时机和有了强有力的拆分原则后，拆分方法将成为下一个关键环节。现在微服务拆分的方法有很多种，常见的包括：</p>
<p>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。</p>
<p>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>
<p>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。</p>
<p>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。</p>
<p>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>
<p>从行业经验来看，可以确定领域驱动设计（Domain Driven Design，简称DDD）在微服务拆分方面具有显著优势。</p>
<p>DDD是一种软件开发方法论，它强调将软件划分为不同的领域，每个领域都由一个核心模型驱动。 微服务架构的核心概念是将单一的应用程序拆分为一组小型、自治的服务。而DDD则提供了一种方法来设计这些微服务的边界和交互。 领域驱动设计引入了领域模型的概念，该模型描述了业务领域的核心概念和实体，而不关注技术实现细节。这使得团队可以专注于业务逻辑，而不被底层技术细节所干扰。 通过将领域模型作为微服务拆分的基础，可以确保每个微服务都是高内聚的，并且只关注自己领域内的业务逻辑。这种拆分方式使得每个微服务都能够独立开发、部署和维护，从而提高了系统的可伸缩性和可靠性。 此外，DDD还强调了领域驱动设计的语言在业务团队和开发团队之间的沟通和理解的重要性。通过共享统一的语言和概念，可以确保业务需求能够准确地传达给开发团队，并且开发团队能够将其转化为可行的技术解决方案。 因此，DDD是一种非常适合成为微服务拆分的方法论。它能够帮助开发人员更好地理解业务需求，找到合适的服务边界，构建高质量的领域模型和微服务。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T02:16:22.000Z</published>
  </entry>
  <entry>
    <title type="text">4种MySQL同步ES方案</title>
    <id>https://ujava.cn/highfreq/synchronousdata.html</id>
    <link href="https://ujava.cn/highfreq/synchronousdata.html"/>
    <updated>2024-04-12T08:16:59.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>
<figure><figcaption>img_129.png</figcaption></figure>
<h1> <strong>1.前言</strong></h1>
<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>
这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>
我们先看看下面 4 种常用的数据同步方案。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>
<figure><figcaption>img_129.png</figcaption></figure>
<h1> <strong>1.前言</strong></h1>
<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>
这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>
我们先看看下面 4 种常用的数据同步方案。</p>
<h1> <strong>2.数据同步方案</strong></h1>
<h2> <strong>2.1同步双写</strong></h2>
<p>这是一种最为简单的方式，在将数据写到 MySQL 时，同时将数据写到 ES。</p>
<figure><figcaption>img_130.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>业务逻辑简单；</li>
<li>实时性高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>硬编码，有需要写入 MySQL 的地方都需要添加写入 ES 的代码；</li>
<li>业务强耦合；</li>
<li>存在双写失败丢数据风险；</li>
<li>性能较差，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。</li>
</ul>
<h2> <strong>2.2异写同步</strong></h2>
<p>针对多数据源写入的场景，可以借助 MQ 实现异步的多源写入。</p>
<figure><figcaption>img_131.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>性能高；</li>
<li>不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息；</li>
<li>多源写入之间相互隔离，便于扩展更多的数据源写入。</li>
</ul>
<p>缺点：</p>
<ul>
<li>硬编码问题，接入新的数据源需要实现新的消费者代码；</li>
<li>系统复杂度增加，引入了消息中间件；</li>
<li>MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时。</li>
</ul>
<h2> <strong>2.3基于SQL抽取</strong></h2>
<p>上面两种方案中都存在硬编码问题，代码的侵入性太强，如果对实时性要求不高的情况下，可以考虑用定时器来处理：</p>
<ol>
<li>数据库的相关表中增加一个字段为 timestamp 的字段，任何 CURD 操作都会导致该字段的时间发生变化；</li>
<li>原来程序中的 CURD 操作不做任何变化；</li>
<li>增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；</li>
<li>逐条写入到 ES 中。</li>
</ol>
<figure><figcaption>img_132.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>不改变原来代码，没有侵入性、没有硬编码；</li>
<li>没有业务强耦合，不改变原来程序的性能；</li>
<li>Worker 代码编写简单不需要考虑增删改查。</li>
</ul>
<p>缺点：</p>
<ul>
<li>时效性较差，由于是采用定时器根据固定频率查询表来同步数据，尽管将同步周期设置到秒级，也还是会存在一定时间的延迟；</li>
<li>对数据库有一定的轮询压力，一种改进方法是将轮询放到压力不大的从库上。</li>
</ul>
<p><strong>经典方案：借助 Logstash 实现数据同步，其底层实现原理就是根据配置定期使用 SQL 查询新增的数据写入 ES 中，实现数据的增量同步。</strong></p>
<h2> <strong>2.4基于Binlog实现同步</strong></h2>
<p>上面三种方案要么有代码侵入，要么有硬编码，要么有延迟，那么有没有一种方案既能保证数据同步的实时性又没有代入侵入呢？</p>
<p>当然有，可以利用 MySQL 的 Binlog 来进行同步。</p>
<figure><figcaption>img_133.png</figcaption></figure>
<p>具体步骤如下：</p>
<ul>
<li>读取 MySQL 的 Binlog 日志，获取指定表的日志信息；</li>
<li>将读取的信息转为 MQ；</li>
<li>编写一个 MQ 消费程序；</li>
<li>不断消费 MQ，每消费完一条消息，将消息写入到 ES 中。</li>
</ul>
<p>优点：</p>
<ul>
<li>没有代码侵入、没有硬编码；</li>
<li>原有系统不需要任何变化，没有感知；</li>
<li>性能高；</li>
<li>业务解耦，不需要关注原来系统的业务逻辑。</li>
</ul>
<p>缺点：</p>
<ul>
<li>构建 Binlog 系统复杂；</li>
<li>如果采用 MQ 消费解析的 Binlog 信息，也会像方案二一样存在 MQ 延时的风险。</li>
</ul>
<h1> <strong>3.数据迁移工具</strong></h1>
<p>对于上面 4 种数据同步方案，“基于 Binlog 实时同步”方案是目前最常用的，也诞生了很多优秀的数据迁移工具，这里主要对这些迁移工具进行介绍。</p>
<p>这些数据迁移工具，很多都是基于 Binlog 订阅的方式实现，<strong>模拟一个 MySQL Slave 订阅 Binlog 日志，从而实现 CDC</strong>（Change Data Capture），将已提交的更改发送到下游，包括 INSERT、DELETE、UPDATE。</p>
<p>至于如何伪装？大家需要先了解 MySQL 的主从复制原理，需要学习这块知识的同学，可以看我之前写的高并发教程，里面有详细讲解。</p>
<h2> <strong>3.1Canal</strong></h2>
<p>基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持 MySQL。</p>
<p>Canal 原理就是伪装成 MySQL 的从节点，从而订阅 master 节点的 Binlog 日志，主要流程为：</p>
<ol>
<li>Canal 服务端向 MySQL 的 master 节点传输 dump 协议；</li>
<li>MySQL 的 master 节点接收到 dump 请求后推送 Binlog 日志给 Canal 服务端，解析 Binlog 对象（原始为 byte 流）转成 Json 格式；</li>
<li>Canal 客户端通过 TCP 协议或 MQ 形式监听 Canal 服务端，同步数据到 ES。</li>
</ol>
<figure><figcaption>img_134.png</figcaption></figure>
<h2> <strong>3.2阿里DTS</strong></h2>
<p>数据传输服务 DTS（Data Transmission Service）支持 RDBMS、NoSQL、OLAP 等多种数据源之间的数据传输。</p>
<p>它提供了数据迁移、实时数据订阅及数据实时同步等多种数据传输方式。相对于第三方数据流工具，DTS 提供丰富多样、高性能、高安全可靠的传输链路，同时它提供了诸多便利功能，极大方便了传输链路的创建及管理。</p>
<p>特点：</p>
<ul>
<li>多数据源：支持 RDBMS、NoSQL、OLAP 等多种数据源间的数据传输；</li>
<li>多传输方式：支持多种传输方式，包括数据迁移、实时数据订阅及数据实时同步；</li>
<li>高性能：底层采用了多种性能优化措施，全量数据迁移高峰期时性能可以达到70MB/s，20万的TPS，使用高规格服务器来保证每条迁移或同步链路都能拥有良好的传输性能；</li>
<li>高可用：底层为服务集群，如果集群内任何一个节点宕机或发生故障，控制中心都能够将这个节点上的所有任务快速切换到其他节点上，链路稳定性高；</li>
<li>简单易用：提供可视化管理界面，提供向导式的链路创建流程，用户可以在其控制台简单轻松地创建传输链路；</li>
<li>需要付费。</li>
</ul>
<h2> <strong>3.3Databus</strong></h2>
<p>Databus 是一个低延迟、可靠的、支持事务的、保持一致性的数据变更抓取系统。由 LinkedIn 于 2013 年开源。</p>
<p>Databus 通过挖掘数据库日志的方式，将数据库变更实时、可靠的从数据库拉取出来，业务可以通过定制化 client 实时获取变更并进行其他业务逻辑。</p>
<p>特点：</p>
<ul>
<li>多数据源：Databus 支持多种数据来源的变更抓取，包括 Oracle 和 MySQL。</li>
<li>可扩展、高度可用：Databus 能扩展到支持数千消费者和事务数据来源，同时保持高度可用性。</li>
<li>事务按序提交：Databus 能保持来源数据库中的事务完整性，并按照事务分组和来源的提交顺寻交付变更事件。</li>
<li>低延迟、支持多种订阅机制：数据源变更完成后，Databus 能在毫秒级内将事务提交给消费者。同时，消费者使用D atabus 中的服务器端过滤功能，可以只获取自己需要的特定数据。</li>
<li>无限回溯：对消费者支持无限回溯能力，例如当消费者需要产生数据的完整拷贝时，它不会对数据库产生任何额外负担。当消费者的数据大大落后于来源数据库时，也可以使用该功能。</li>
</ul>
<h2> <strong>3.4其他</strong></h2>
<p><strong>Flink</strong></p>
<ul>
<li>有界数据流和无界数据流上进行有状态计算分布式处理引擎和框架。</li>
<li>官网地址：<a href="https://flink.apache.org" target="_blank" rel="noopener noreferrer">https://flink.apache.org</a></li>
</ul>
<p><strong>CloudCanal</strong></p>
<ul>
<li>数据同步迁移系统，商业产品。</li>
<li>官网地址：<a href="https://www.clougence.com/?utm_source=wwek" target="_blank" rel="noopener noreferrer">https://www.clougence.com/?utm_source=wwek</a></li>
</ul>
<p><strong>Maxwell</strong></p>
<ul>
<li>使用简单，直接将数据变更输出为json字符串，不需要再编写客户端。</li>
<li>官网地址：<a href="http://maxwells-daemon.io" target="_blank" rel="noopener noreferrer">http://maxwells-daemon.io</a></li>
</ul>
<p><strong>DRD</strong></p>
<ul>
<li>阿里巴巴集团自主研发的分布式数据库中间件产品，专注于解决单机关系型数据库扩展性问题，具备轻量(无状态)、灵活、稳定、高效等特性。</li>
<li>官方地址：<a href="https://www.aliyun.com/product/drds" target="_blank" rel="noopener noreferrer">https://www.aliyun.com/product/drds</a></li>
</ul>
<p><strong>yugong</strong></p>
<ul>
<li>帮助用户完成从 Oracle 数据迁移到 MySQL。</li>
<li>访问地址：<a href="https://github.com/alibaba/yugong" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/yugong</a></li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-12T08:16:59.000Z</published>
  </entry>
  <entry>
    <title type="text">微服务架构和分布式架构的区别</title>
    <id>https://ujava.cn/highfreq/microservice.html</id>
    <link href="https://ujava.cn/highfreq/microservice.html"/>
    <updated>2024-04-12T07:48:57.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>
</blockquote>
<h2> 1、含义不同</h2>
<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>
</blockquote>
<h2> 1、含义不同</h2>
<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>
<p><strong>分布式架构</strong>：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。</p>
<h2> 2、概念层面不同</h2>
<p><strong>微服务架构</strong>：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。</p>
<p><strong>分布式架构</strong>：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。</p>
<h2> 3、解决问题不同</h2>
<p><strong>微服务架构</strong>：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。</p>
<p><strong>分布式架构</strong>：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。</p>
<h2> 4、部署方式不同</h2>
<p><strong>微服务架构</strong>：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。</p>
<p><strong>分布式架构</strong>：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。</p>
<h2> 5、耦合度不同</h2>
<p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势，不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>
<h3> 拓展阅读</h3>
<h2> 分布式是否属于微服务？</h2>
<p>答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-12T07:48:57.000Z</published>
  </entry>
  <entry>
    <title type="text">ElasticSearch架构设计</title>
    <id>https://ujava.cn/highfreq/elasticsearch.html</id>
    <link href="https://ujava.cn/highfreq/elasticsearch.html"/>
    <updated>2024-04-10T09:23:29.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、 简介</h2>
<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<h3> 1.ES优点</h3>
<ul>
<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>
<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 一、 简介</h2>
<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<h3> 1.ES优点</h3>
<ul>
<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>
<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>
</ul>
<h3> 2.ES缺点</h3>
<ul>
<li>1.对硬件要求较高，es比较吃内存，需要存储资源来支持大量数据的处理。</li>
<li>2.不支持事务等ACID属性。</li>
</ul>
<h3> 3.ES使用场景</h3>
<p>1.聊天消息</p>
<ul>
<li>数据量大，业务关系简单，会通过关键字搜索聊天信息</li>
<li>非核心业务，不会频繁crud</li>
<li>没有事务的场景，可以不用支持事务</li>
</ul>
<p>2.日志纪录</p>
<p>Elasticsearch 一个典型应用就是 ELK 日志分析系统。如nginx接入请求的访问日志纪录。</p>
<p>3.热点数据搜索</p>
<p>如电商业务的商品搜索等。</p>
<h3> 4.DSL语言高级查询</h3>
<h4> 1.Query DSL概述</h4>
<p>Domain Specific Language 领域专用语言</p>
<ul>
<li>Elasticsearch provides a ful1 Query DSL based on JSON to define queries</li>
<li>Elasticsearch提供了基于JSON的DSL来定义查询。</li>
</ul>
<p>DSL由叶子查询子句和复合查询子句两种子句组成。</p>
<figure><figcaption>img_111.png</figcaption></figure>
<h4> 2.模糊匹配</h4>
<p>模糊匹配主要是针对文本类型的字段，文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据，模糊匹配主要通过match等参数来实现</p>
<ul>
<li>match : 通过match关键词模糊匹配条件内容</li>
<li>prefix : 前缀匹配</li>
<li>regexp : 通过正则表达式来匹配数据</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.精确匹配</h4>
<ul>
<li>term : 单个条件相等</li>
<li>terms : 单个字段属于某个值数组内的值</li>
<li>range : 字段属于某个范围内的值</li>
<li>exists : 某个字段的值是否存在</li>
<li>ids : 通过ID批量查询</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.聚合搜索</h4>
<p><strong>1.bucket和metric</strong></p>
<p>bucket就是一个聚合搜索时的数据分组。</p>
<p>如：销售部门有员工张三和李四，开发部门有员工王五和赵六。那么根据部门分组聚合得到结果就是两个bucket。销售部门bucket中有张三和李四，开发部门 bucket中有王五和赵六。</p>
<p>metric就是对一个bucket数据执行的统计分析。如上述案例中，开发部门有2个员工，销售部门有2个员工，这就是metric。</p>
<p>metric有多种统计，如：求和，最大值，最小值，平均值等。</p>
<p>用一个大家容易理解的SQL语法来解释，如：select count() from table group by column。那么group by column分组后的每组数据就是bucket。对每个分组执行的count()就是metric。</p>
<p>es最重要的核心功能是数据检索，统计分析我认为不是es最核心的功能，想这种离线统计应该由其他的替代方案去做，所以如果想了解更多es聚合搜索相关知识可以参考官网或者其他博客</p>
<h3> 5.文档映射</h3>
<p>ES中映射可以分为动态映射和静态映射</p>
<h4> 1.动态映射</h4>
<p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。<br>
动态映射规则如下：</p>
<figure><figcaption>img_112.png</figcaption></figure>
<h4> 2.静态映射</h4>
<p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。</p>
<h4> 3.核心类型（Core datatype）</h4>
<ul>
<li>字符串：string，string类型包含 text 和 keyword。</li>
<li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li>
<li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li>
<li>数值型：long、integer、short、byte、double、float</li>
<li>日期型：date</li>
<li>布尔型：boolean</li>
</ul>
<h4> 4.数据建模</h4>
<p>就是针对于关系型数据库的一对多数据模型，而我自己认为es的主要应用场景是全文搜索引擎，这种复杂的业务关系就应该由关系型数据库如mysql去完成数据建模和存储，而不是交给es去建模存储，当然es也是提供了Parent / Child相关机制继续数据建模，如果有场景使用到，自己去参考对应的官方文档了解即可，但我自己不建议这样做。</p>
<h4> 5.分页查询</h4>
<p>1.语法</p>
<p>在存在大量数据时，一般我们进行查询都需要进行分页查询。例如：我们指定页码、并指定每页显示多少条数据，然后Elasticsearch返回对应页码的数据。</p>
<p>在执行查询时，可以指定from（从第几条数据开始查起）和size（每页返回多少条）数据，就可以轻松完成分页。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.scroll解决深分页问题</p>
<p>前面使用from和size方式，查询在1W条数据以内都是OK的，但如果数据比较多的时候，会出现性能问题。Elasticsearch做了一个限制，不允许查询的是10000条以后的数据。如果要查询1W条以后的数据，需要使用Elasticsearch中提供的scroll游标来查询。</p>
<p>在进行大量分页时，每次分页都需要将要查询的数据进行重新排序，这样非常浪费性能。</p>
<p>使用scroll是将要用的数据一次性排序好，然后分批取出,性能要比from + size好得多。</p>
<p>使用scroll查询后，排序后的数据会保持一定的时间，后续的分页查询都从该快照取数据即可。</p>
<p>第一次使用scroll分页查询</p>
<p>此处，我们让排序的数据保持1分钟，所以设置scroll为1m</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后，我们注意到，在响应结果中有一项：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后续，我们需要根据这个_scroll_id来进行查询</p>
<p>第二次直接使用scroll id进行查询</p>
<h3> 6.suggest search</h3>
<p>suggest search（completion suggest）：就是建议搜索或称为搜索建议，也可以叫做自动完成-auto completion。类似百度中的搜索联想提示功能。</p>
<p>ES实现suggest的时候，性能非常高，其构建的不是倒排索引，也不是正排索引，就是纯的用于进行前缀搜索的一种特殊的数据结构，而且会全部放在内存中，所以suggest search进行的前缀搜索提示，性能是非常高。</p>
<p>需要使用suggest的时候，必须在定义index时，为其mapping指定开启suggest。</p>
<p>具体如下:</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>suggest 搜索：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、ES核心原理</h2>
<p>ES存储模型</p>
<p>Elasticsearch与关系数据库结构对应</p>
<figure><figcaption>img_113.png</figcaption></figure>
<p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p>
<h3> 1.索引（Index）</h3>
<p>相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</p>
<p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引<br>
一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</p>
<h3> 2.文档类型（Type）</h3>
<p>相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</p>
<p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p>
<h3> 3.文档（Document）</h3>
<p>相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；</p>
<p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示；</p>
<h3> 4.字段（Field）</h3>
<p>文档的一个Key/Value对；</p>
<ul>
<li>词（Term）：表示文本中的一个单词；</li>
<li>标记（Token）：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li>
</ul>
<p>相当于是数据表的字段|列</p>
<h3> 5.倒排索引</h3>
<p>全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。</p>
<p>之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。</p>
<p>假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。</p>
<p>正排索引示例：</p>
<figure><figcaption>img_114.png</figcaption></figure>
<p>（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）</p>
<p>正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了“面向对象葵花宝典是什么”，网站根据文章标题查询文章的内容展示给用户。</p>
<p>倒排索引示例：</p>
<figure><figcaption>img_115.png</figcaption></figure>
<p>（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）</p>
<p>倒排索引适用于根据关键词来查询文档内容，它是根据文章内容中的关键字建立索引，而值对应于文档ID，而搜索出来的结果就是文档ID所在行的所有内容。</p>
<p>例如，用户只是想看“设计”相关的文章，网站需要将文章内容中包含“设计”一词的文章都搜索出来展示给用户。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项根据字典顺序升序排列<br>
Elasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。</li>
</ul>
<h3> 6.分词器</h3>
<p>对于英文来说，分词比较简单，只需要按照单词的空格来进行分词。<br>
如下所示<br>
</p>
<p>如果要搜索hello这个关键词，则匹配的结果将是下面两个内容</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果。</p>
<p>这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。</p>
<p>ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。</p>
<p>修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分词器工作流程<br>
<br>
分词器由三部分组成：</p>
<ul>
<li>Character Filter：将文本中html标签剔除掉。</li>
<li>Tokenizer：按照规则进行分词，在英文中按照空格分词</li>
<li>Token Filter：将切分的单词进行加工，小写，删除 stopwords(停顿词，a、an、the、is等),增加同义词</li>
</ul>
<p>每个组件的作用，可参考下面的例子</p>
<p>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签</p>
<p>tokenizer：分词，hello you and me --&gt; hello, you, and, me</p>
<p>token filter：lowercase，stop word，synonymom，liked --&gt; like，Tom --&gt; tom，a/the/an --&gt; 干掉，small --&gt; little</p>
<p>ES内置分词器</p>
<ul>
<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>
<li>Simple Analyzer - 按照非字母切分(符号被过滤), 小写处理</li>
<li>Stop Analyzer - 小写处理，停用词过滤(the,a,is)</li>
<li>Whitespace Analyzer - 按照空格切分，不转小写</li>
<li>Keyword Analyzer - 不分词，直接将输入当作输出</li>
<li>Patter Analyzer - 正则表达式，默认\W+(非字符分割)</li>
<li>Language - 提供了30多种常见语言的分词器</li>
<li>Customer Analyzer 自定义分词器</li>
</ul>
<p>每个内置分词器的作用，可参考下面的例子</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定制分词器</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定制化自己的分词器</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IK热更新</p>
<p>每次都是在es的扩展词典中，手动添加新词语，很坑</p>
<p>（1）每次添加完，都要重启es才能生效，非常麻烦</p>
<p>（2）es是分布式的，可能有数百个节点，你不能每次都一个一个节点上面去修改</p>
<p>es不停机，直接我们在外部某个地方添加新的词语，es中立即热加载到这些新词语<br>
IKAnalyzer.cfg.xml</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.es评分机制</h3>
<p>当你通过关键字搜索相关文档时，可能会出现多个文档，这些文档的顺序是通过一个max_score属性的大小从高到低顺序展现出来的，max_score属性就是我们所说的评分。</p>
<p>打分算法</p>
<p>relevance score算法，简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度</p>
<p>Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法</p>
<p>总公式</p>
<p>max_score = boost * idf * tf</p>
<figure><figcaption>img_118.png</figcaption></figure>
<p>对于查询权重我们可以自己定义</p>
<p>如下面所示：</p>
<figure><figcaption>img_119.png</figcaption></figure>
<p>TF算法</p>
<p>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关</p>
<ul>
<li>搜索请求：hello world</li>
<li>doc1：hello you, and world is very good</li>
<li>doc2：hello, how are you</li>
</ul>
<p>doc1这个文档匹配了2个单词，所以doc1的得分要高一些。</p>
<p>2.IDF算法<br>
Inverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关</p>
<ul>
<li>搜索请求：hello world</li>
<li>doc1：hello, tuling is very good</li>
<li>doc2：hi world, how are you</li>
</ul>
<p>比如说，在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次；world这个单词在所有的document中，一共出现了100次，所以world这个单词得分就更高。</p>
<p>那么匹配world的doc得分就越高,越有可能排在搜索结果前面。</p>
<p>Field-length norm：field长度，field越长，相关度越弱<br>
搜索请求：hello world</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>hello world在整个index中出现的次数是一样多的，那么doc1更相关，title field更短</p>
<p><strong>2.空间向量模型（vector space model）</strong></p>
<p>每个doc vector计算出对query vector的弧度，最后基于这个弧度给出一个doc相对于query中多个term的总分数</p>
<p>弧度越大，分数月底; 弧度越小，分数越高</p>
<p>如果是多个term，那么就是线性代数来计算，无法用图表示</p>
<figure><figcaption>img_120.png</figcaption></figure>
<p>了解即可，掌握对应的打分算法我自己认为就足够了，不用砖牛角尖</p>
<h2> 三、ElasticSearch架构设计</h2>
<p>es集群架构</p>
<p>如下图 ，就是一个三个节点组成的es集群，p0、p1、p2表示一个节点中的分片，R0、R1、R2表示分片对应的副本<br>
<br>
在Elasticsearch主要分成两类节点，一类是Master，一类是DataNode。</p>
<h3> 1.Master节点</h3>
<p>在Elasticsearch启动时，会选举出来一个Master节点。</p>
<p>当某个节点启动后，然后使用Zen Discovery机制找到集群中的其他节点，并建立连接。</p>
<p>discovery.seed_hosts: [“192.168.21.130”, “192.168.21.131”, “192.168.21.132”]</p>
<p>并从候选主节点中选举出一个主节点。</p>
<p>cluster.initial_master_nodes: [“node1”, “node2”,“node3”]</p>
<p>Master节点主要负责</p>
<ul>
<li>管理索引（创建索引、删除索引）、分配分片</li>
<li>维护元数据</li>
<li>管理集群节点状态</li>
<li>不负责数据写入和查询，比较轻量级</li>
</ul>
<p>一个Elasticsearch集群中，只有一个Master节点。在生产环境中，内存可以相对小一点，但机器要稳定。</p>
<h3> 2.DataNode节点</h3>
<p>在Elasticsearch集群中，会有N个DataNode节点。</p>
<p>DataNode节点主要负责：</p>
<p>数据写入、数据检索，</p>
<p>大部分Elasticsearch的压力都在DataNode节点上在生产环境中，内存最好配置大一些</p>
<h3> 3.分片</h3>
<p>Elasticsearch是一个分布式的搜索引擎，索引的数据也是分成若干部分，分布在不同的服务器节点中，分布在不同服务器节点中的索引数据，就是分片（Shard）。</p>
<p>Elasticsearch会自动管理分片，如果发现分片分布不均衡，就会自动迁移一个索引（index）由多个shard（分片）组成，而分片是分布在不同的服务器上的.</p>
<h3> 4.副本</h3>
<p>为了对Elasticsearch的分片进行容错，假设某个节点不可用，会导致整个索引库都将不可用。所以，需要对分片进行副本容错，每一个分片都会有对应的副本。</p>
<p>在Elasticsearch中，默认创建的索引为1个分片、每个分片有1个主分片和1个副本分片。</p>
<p>每个分片都会有一个Primary Shard（主分片），也会有若干个Replica Shard（副本分片）</p>
<p>Primary Shard和Replica Shard不在同一个节点上</p>
<h3> 5.es集群读写流程</h3>
<p>es 写数据流程</p>
<figure><figcaption>img_122.png</figcaption></figure>
<p>1.选择任意一个DataNode发送请求，例如：node2。此时，node2就成为一个coordinating node（协调节点）</p>
<p>2.计算得到文档要写入的分片</p>
<p><code>shard = hash(routing) % number_of_primary_shards</code><br>
routing 是一个可变值，默认是文档的 _id</p>
<p>3.coordinating node会进行路由，将请求转发给对应的primary shard所在的DataNode（假设primary shard在node1、replica shard在node2）</p>
<p>4.node1节点上的Primary Shard处理请求，写入数据到索引库中，并将数据同步到Replica shard</p>
<p>5.Primary Shard和Replica Shard都保存好了文档，返回client</p>
<p>es 读数据流程</p>
<figure><figcaption>img_123.png</figcaption></figure>
<p>1.client发起查询请求，某个DataNode接收到请求，该DataNode就会成为协调节点（Coordinating Node）</p>
<p>2.协调节点（Coordinating Node）将查询请求广播到每一个数据节点，这些数据节点的分片会处理该查询请求</p>
<p>3.每个分片进行数据查询，将符合条件的数据放在一个优先队列中，并将这些数据的文档ID、节点信息、分片信息返回给协调节点</p>
<p>4.协调节点将所有的结果进行汇总，并进行全局排序</p>
<p>5.协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据返回给客户端</p>
<p>注意：写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
<p>自己总结：es的检索流程和mysql数据表查询非主键索引的思路有些相似，先从索引表查询出对应的主键索引值，在进行回表查询具体的行数据。</p>
<p>es删除/更新数据底层原理</p>
<p>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p>
<p>es 底层写数据原理</p>
<figure><figcaption>img_124.png</figcaption></figure>
<p>简述：先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；然后刷新到os cache中（同时将数据备份到translog日志文件），最后刷新到 segment file磁盘文件中</p>
<p>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件作备份（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。最后存入到commit point磁盘文件中。</p>
<p>refresh到文件系统缓存</p>
<p>当数据写入到ES分片时，会首先写入到内存中，然后通过内存的buffer生成一个segment，并刷到文件系统缓存中。</p>
<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。</p>
<p>这个过程就是 refresh 。</p>
<p>只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。</p>
<p>定时 refresh到文件系统缓存机制</p>
<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file ，每秒钟会产生一个新的磁盘文件 segment file ，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。<br>
但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>
<p>segment file合并</p>
<p>buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，此时会定期执行 merge，减少索引查询时IO开销。<br>
每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉（之前执行过的delete的数据），然后将新的 segment file 写入到一个 commit point磁盘 。</p>
<p>知识扩展</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache ，先进入操作系统级别的一个内存缓存中去。</p>
<p>备份到translog磁盘</p>
<p>刷新到translog文件以保障数据不丢失，translog的设计思想和mysql的redo log是相似的。</p>
<p>每隔5s,从os cache 中同步到translog磁盘里面去做备份。</p>
<p>那么translog 日志文件的作用是什么？</p>
<p>你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>
<p>flush到磁盘文件</p>
<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file文件系统缓存中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p>
<p>数据最终被flush到磁盘文件就完成了数据的最终归宿。</p>
<figure><figcaption>img_125.png</figcaption></figure>
<p>commit操作流程</p>
<p>commit 操作首先就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。<br>
然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。<br>
最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>
<p>这个 commit 操作叫做 flush 。</p>
<p>默认 30 分钟自动执行一次 flush ，将文件系统缓存的数据刷入到磁盘。<br>
但如果 translog 过大，也会触发 flush 。</p>
<p>flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>
<p>es准实时机制</p>
<p>为什么叫 es 是准实时的？</p>
<p>NRT ，全称 near real-time 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</p>
<p>可以通过 es 的 restful api 或者 java api ，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>
<p>es会数据丢失吗？</p>
<p>可能会丢失有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果备份到translog过程中宕机，会导致 5 秒的数据丢失。</p>
<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。<br>
也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>
<p>es集群脑裂</p>
<p>关于集群脑裂的定义请参考我的另一篇博文</p>
<p><a href="https://blog.csdn.net/sinat_34814635/article/details/129914369" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/sinat_34814635/article/details/129914369</a></p>
<p>那么es是如何解决脑裂问题的？</p>
<p>es是直到有足够的master候选节点时，才可以选举出一个master，否则就不要选举出一个master。</p>
<p>这个参数必须被设置为集群中master候选节点的quorum数量，也就是大多数，至于quorum的算法，就是：master候选节点数量 / 2 + 1。</p>
<p>综上所述，一个生产环境的es集群，至少要有3个节点，同时将这个参数设置为quorum，也就是2。discovery.zen.minimum_master_nodes设置为2</p>
<p>那么这个是参数是如何避免脑裂问题的产生的呢？比如我们有3个节点，quorum是2.现在网络故障，1个节点在一个网络区域，另外2个节点在另外一个网络区域，不同的网络区域内无法通信。</p>
<p>这个时候有两种情况情况：</p>
<p>（1）如果master是单独的那个节点，另外2个节点是master候选节点，那么此时那个单独的master节点因为没有指定数量的候选master node在自己当前所在的集群内，因此就会取消当前master的角色，尝试重新选举，但是无法选举成功。然后另外一个网络区域内的node因为无法连接到master，就会发起重新选举，因为有两个master候选节点，满足了quorum，因此可以成功选举出一个master。此时集群中就会还是只有一个master。</p>
<p>（2）如果master和另外一个node在一个网络区域内，然后一个node单独在一个网络区域内。那么此时那个单独的node因为连接不上master，会尝试发起选举，但是因为master候选节点数量不到quorum，因此无法选举出master。而另外一个网络区域内，原先的那个master还会继续工作。这也可以保证集群内只有一个master节点。</p>
<p>综上所述，集群中master节点的数量至少3台，三台主节点通过在elasticsearch.yml中配置discovery.zen.minimum_master_nodes: 2，就可以避免脑裂问题的产生。</p>
<h2> 四、ElasticSearch应用</h2>
<h3> 1.Elasticsearch SQL</h3>
<figure><figcaption>img_126.png</figcaption></figure>
<p>Elasticsearch SQL允许执行类SQL的查询，可以使用REST接口、命令行或者是JDBC，都可以使用SQL来进行数据的检索和数据的聚合。</p>
<p>Elasticsearch SQL特点：</p>
<p>本地集成</p>
<p>Elasticsearch SQL是专门为Elasticsearch构建的。每个SQL查询都根据底层存储对相关节点有效执行。</p>
<p>没有额外的要求</p>
<p>不依赖其他的硬件、进程、运行时库，Elasticsearch SQL可以直接运行在Elasticsearch集群上</p>
<p>轻量且高效</p>
<p>像SQL那样简洁、高效地完成查询</p>
<p>Elasticsearch SQL提供了sql转换的功能，但是只能满足一些简单的查询，例如：不支持JOIN、不支持较复杂的子查询。官方还是推荐使用DSL语句来实现</p>
<h3> 2.Java客户端</h3>
<p>这个就自己看官网吧</p>
<h3> 3.es和mysql的双写</h3>
<p>双写的流程：</p>
<ul>
<li>1.先写数据库，然后写es，es只存常搜索的索引字段。</li>
<li>2.读取时先读es，找到对应主键后，然后根据主键在读mysql。（这种场景主要出现在mysql是分表的，而主键配置的是分片键，非分片键的查询将扫描全表）<br>
首先不建议进行双写，因为会造成数据不一致这样新的问题。造成不一致的原因为写入es或者更新es字段失败，加上补充机制后也没有成功。</li>
</ul>
<p>双写的同步</p>
<p>分页查询mysql中的数据，放入mq中（放入mq中的原因，为读取mysql的线程会远比执行同步的线程速度快），同步线程从mq中拉起数据，然后和es对比，如果不同，与mysql中的数据为准，进行删除复制。</p>
<p>补偿机制</p>
<p>我认为任何对es写失败，更新失败，删除失败都应该纪录下来，然后去手动操作使其同步。</p>
<h2> 五、ElasticSearch安装配置</h2>
<h3> 1.安装ElasticSearch</h3>
<p>解压下载的压缩包，本次使用7.14.0版本</p>
<p>从v7开始，elasticsearch不用单独安装JDK，因为它在下载时会自动下载对应的jdk包。因此不用额外下载jdk和配置环境变量。</p>
<p>在终端cd到elasticsearch的bin目录，运行命令./elasticsearch即可开启es数据库服务（在终端通过按control + c可停止服务）。在网页中访问localhost:9200看到json结果即启动成功。</p>
<p>如下图所示：</p>
<figure><figcaption>img_127.png</figcaption></figure>
<h3> 2.安装Kibana</h3>
<p>下载可视化工具Kibanahttps://www.elastic.co/cn/downloads/kibana</p>
<p>解压下载的压缩包，并将其复制粘贴至自己想要存放的目录。Kibana的版本最好和es保持一致，如这次同样使用7.14.0版本</p>
<p>启动Kibana</p>
<p>在终端cd到Kibana目录下，运行命令./Kibana即可开启Kibana的端口访问。在网页中访问http://localhost:5601跳转到如下界面即访问成功。</p>
<p>访问下面地址：<a href="http://localhost:5601/app/dev_tools#/console" target="_blank" rel="noopener noreferrer">http://localhost:5601/app/dev_tools#/console</a> 可进入管理后台</p>
<figure><figcaption>img_128.png</figcaption></figure>
<p>ElasticSearch可视化工具之cerebro</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-10T08:44:25.000Z</published>
  </entry>
  <entry>
    <title type="text">Mock单测方式</title>
    <id>https://ujava.cn/highfreq/mock.html</id>
    <link href="https://ujava.cn/highfreq/mock.html"/>
    <updated>2024-04-10T02:25:44.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>通过Mock方式，测试编写的程序</p>
<p>通用类定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> <span class="token class-name">Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringJUnit4ClassRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@BeforeClass</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>通过Mock方式，测试编写的程序</p>
<p>通用类定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式一（直接操作库表）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式二（启动容器）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式三（不启动容器）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mock静态数据</h2>
<p>在实际工作当中，我们经常会遇到需要对静态方法进行 mock 的情况。在 mockito 2.x 的时代，我们需要借助 powmock 才能实现。当<br>
mockito 进化到了 3.4.0 版本以后，也开始对静态方法 mock 进行了支持（主要是通过 mockito-inline 包）。</p>
<p>简单的介绍就到这里，下面让我们进入主题吧。</p>
<p>首先确保 pom 文件中 mockito 相关 jar 包的版本（这里我用的版本是 3.7.7），如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式</p>
<p>Mockito.mockStatic(Class mockClass)，如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样基本上就 OK 了。唯一需要注意下的就是 httpClient.close()。</p>
<p>如果项目中未引入 mockito-inline，会出现如下错误信息：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误提示 static mocking is already registered in the current thread To create a new mock, the existing static mock<br>
registration must be deregistered</p>
<p>当多个单元测试都使用了同一个 static mock 对象，且使用完成后都没有进行 close。此时，若这几个单元测试用一起执行，第一个单元测试占用了<br>
static mock 对象，第二个单元测试就没有办法再占用了。</p>
<p>如果出现了这种情况，解决办法也很简单，就是关闭 static mock 对象，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的很多单元测试中都用到了 mockStatic(HTTPClient.class)，且觉得在每个单元测试当中都写一遍 mockStatic()…close()<br>
很低效，可以采用下边的方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mock缓存数据</h2>
<p>在Mockito中，你可以使用Mockito.when配合相应的调用记录方法来模拟缓存场景。以下是一个简单的例子，展示了如何使用Mockito来模拟一个缓存方法的行为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先通过ConcurrentHashMap模拟了一个简单的缓存。然后我们使用Mockito.spy创建了一个被测试方法所在类的模拟实例。通过Mockito.doReturn我们配置了当调用getFromCache方法并传递特定的key时，模拟方法返回预先定义的值。最后，我们使用Mockito.verify来验证缓存访问方法是否被调用了。这个例子展示了如何使用Mockito来模拟和验证缓存相关的行为。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-03-25T03:10:48.000Z</published>
  </entry>
  <entry>
    <title type="text">设计限流</title>
    <id>https://ujava.cn/highfreq/throttling.html</id>
    <link href="https://ujava.cn/highfreq/throttling.html"/>
    <updated>2024-03-22T03:28:44.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>漏桶和令牌桶的区别</p>
<h2> 漏桶</h2>
<figure><figcaption>漏桶</figcaption></figure>
<h2> 令牌桶</h2>
<figure><figcaption>令牌桶</figcaption></figure>
]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>漏桶和令牌桶的区别</p>
<h2> 漏桶</h2>
<figure><figcaption>漏桶</figcaption></figure>
<h2> 令牌桶</h2>
<figure><figcaption>令牌桶</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-03-21T13:06:03.000Z</published>
  </entry>
  <entry>
    <title type="text">反应器(Reactor)模式</title>
    <id>https://ujava.cn/design/other/reactor.html</id>
    <link href="https://ujava.cn/design/other/reactor.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">读写锁模式</title>
    <id>https://ujava.cn/design/other/readerwriterlock.html</id>
    <link href="https://ujava.cn/design/other/readerwriterlock.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>
由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>
众所周知，读写器锁的存在解决了这个问题<br>
“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>
并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>
正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>
由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>
众所周知，读写器锁的存在解决了这个问题<br>
“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>
并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>
正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">注册(Registry)模式</title>
    <id>https://ujava.cn/design/other/registry.html</id>
    <link href="https://ujava.cn/design/other/registry.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>存储单个类的对象，并提供对它们的全局访问点。<br>
与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>存储单个类的对象，并提供对它们的全局访问点。<br>
与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">存储库(Repository)模式</title>
    <id>https://ujava.cn/design/other/repository.html</id>
    <link href="https://ujava.cn/design/other/repository.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>存储库层添加在域和数据映射层之间，以将域对象与<br>
数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>
存储库模式在域类数量很大或很重的系统中特别有用<br>
利用查询。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>存储库层添加在域和数据映射层之间，以将域对象与<br>
数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>
存储库模式在域类数量很大或很重的系统中特别有用<br>
利用查询。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">资源获取即初始化模式</title>
    <id>https://ujava.cn/design/other/resourceacquisitioninit.html</id>
    <link href="https://ujava.cn/design/other/resourceacquisitioninit.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">重试(Retry)模式</title>
    <id>https://ujava.cn/design/other/retry.html</id>
    <link href="https://ujava.cn/design/other/retry.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>透明地重试涉及与外部资源通信的某些操作，<br>
特别是在网络上，将调用代码与重试实现细节隔离开来。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>透明地重试涉及与外部资源通信的某些操作，<br>
特别是在网络上，将调用代码与重试实现细节隔离开来。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">角色对象(Role Object)模式</title>
    <id>https://ujava.cn/design/other/roleobject.html</id>
    <link href="https://ujava.cn/design/other/roleobject.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>
对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>
单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>
对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>
单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务(Saga)模式</title>
    <id>https://ujava.cn/design/other/saga.html</id>
    <link href="https://ujava.cn/design/other/saga.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>
这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>
在分布式环境中</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>
这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>
在分布式环境中</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">分离接口模式</title>
    <id>https://ujava.cn/design/other/separatedinterface.html</id>
    <link href="https://ujava.cn/design/other/separatedinterface.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在不同的包中分离接口定义和实现。这允许客户端<br>
完全不知道实现。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在不同的包中分离接口定义和实现。这允许客户端<br>
完全不知道实现。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">序列化实体模式</title>
    <id>https://ujava.cn/design/other/serializedentity.html</id>
    <link href="https://ujava.cn/design/other/serializedentity.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>序列化实体模式。<br>
序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>序列化实体模式。<br>
序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">雇工(Servant)模式</title>
    <id>https://ujava.cn/design/other/servant.html</id>
    <link href="https://ujava.cn/design/other/servant.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务层模式</title>
    <id>https://ujava.cn/design/other/servicelayer.html</id>
    <link href="https://ujava.cn/design/other/servicelayer.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务定位模式</title>
    <id>https://ujava.cn/design/other/servicelocator.html</id>
    <link href="https://ujava.cn/design/other/servicelocator.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用封装获取服务所涉及的过程<br>
强抽象层。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用封装获取服务所涉及的过程<br>
强抽象层。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务工作者模式</title>
    <id>https://ujava.cn/design/other/serviceworker.html</id>
    <link href="https://ujava.cn/design/other/serviceworker.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">分区(Sharding)模式</title>
    <id>https://ujava.cn/design/other/sharding.html</id>
    <link href="https://ujava.cn/design/other/sharding.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>
shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>
shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">空间分区模式</title>
    <id>https://ujava.cn/design/other/spatialpartition.html</id>
    <link href="https://ujava.cn/design/other/spatialpartition.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>正如<a href="http://gameprogrammingpatterns.com/spatial-partition.html" target="_blank" rel="noopener noreferrer">《游戏编程模式》</a>一书中所解释的那样<br>
Bob Nystrom认为，空间分区模式通过将对象存储在<br>
按位置组织的数据结构。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>正如<a href="http://gameprogrammingpatterns.com/spatial-partition.html" target="_blank" rel="noopener noreferrer">《游戏编程模式》</a>一书中所解释的那样<br>
Bob Nystrom认为，空间分区模式通过将对象存储在<br>
按位置组织的数据结构。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">特殊例子模式</title>
    <id>https://ujava.cn/design/other/specialcase.html</id>
    <link href="https://ujava.cn/design/other/specialcase.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">规范(Specification)模式</title>
    <id>https://ujava.cn/design/other/specification.html</id>
    <link href="https://ujava.cn/design/other/specification.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>
与之匹配的。它不仅在选择中有用，而且对<br>
验证和按订单建造。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>
与之匹配的。它不仅在选择中有用，而且对<br>
验证和按订单建造。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">步骤建立者模式</title>
    <id>https://ujava.cn/design/other/stepbuilder.html</id>
    <link href="https://ujava.cn/design/other/stepbuilder.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>
用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>
用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">扼杀者(Strangler)模式</title>
    <id>https://ujava.cn/design/other/strangler.html</id>
    <link href="https://ujava.cn/design/other/strangler.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>
新的应用程序和服务。随着旧系统的功能被替换<br>
系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>
扼杀旧系统，让你退役。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>
新的应用程序和服务。随着旧系统的功能被替换<br>
系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>
扼杀旧系统，让你退役。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">子类沙盒模式</title>
    <id>https://ujava.cn/design/other/subclasssandbox.html</id>
    <link href="https://ujava.cn/design/other/subclasssandbox.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">表模块(Table Module)模式</title>
    <id>https://ujava.cn/design/other/tablemodule.html</id>
    <link href="https://ujava.cn/design/other/tablemodule.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">模版方法模式</title>
    <id>https://ujava.cn/design/other/templatemethod.html</id>
    <link href="https://ujava.cn/design/other/templatemethod.html"/>
    <updated>2024-03-04T07:22:04.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>
方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>
结构</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>
方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>
结构</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">本地线程存储模式</title>
    <id>https://ujava.cn/design/other/threadlocalstorage.html</id>
    <link href="https://ujava.cn/design/other/threadlocalstorage.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">线程池模式</title>
    <id>https://ujava.cn/design/other/threadpool.html</id>
    <link href="https://ujava.cn/design/other/threadpool.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>
为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>
线程而不是执行实际任务。线程池通过重用现有的<br>
线程，并消除创建新线程的延迟。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>
为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>
线程而不是执行实际任务。线程池通过重用现有的<br>
线程，并消除创建新线程的延迟。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">节流(Throttling)模式</title>
    <id>https://ujava.cn/design/other/throttling.html</id>
    <link href="https://ujava.cn/design/other/throttling.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">读者容错模式</title>
    <id>https://ujava.cn/design/other/tolerantreader.html</id>
    <link href="https://ujava.cn/design/other/tolerantreader.html"/>
    <updated>2024-03-04T07:22:04.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>
是在从另一个服务读取数据时尽可能宽容。这样，当<br>
交流模式发生变化，读者一定不能断。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>
是在从另一个服务读取数据时尽可能宽容。这样，当<br>
交流模式发生变化，读者一定不能断。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">蹦床(Trampoline)模式</title>
    <id>https://ujava.cn/design/other/trampoline.html</id>
    <link href="https://ujava.cn/design/other/trampoline.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>
并且交织功能的执行而不将它们硬编码在一起。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>
并且交织功能的执行而不将它们硬编码在一起。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务脚本模式</title>
    <id>https://ujava.cn/design/other/transactionscript.html</id>
    <link href="https://ujava.cn/design/other/transactionscript.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>
来自演示文稿的请求。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>
来自演示文稿的请求。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">双(Twin)模式</title>
    <id>https://ujava.cn/design/other/twin.html</id>
    <link href="https://ujava.cn/design/other/twin.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>
java中的继承</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>
java中的继承</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务脚本模式</title>
    <id>https://ujava.cn/design/other/typeobject.html</id>
    <link href="https://ujava.cn/design/other/typeobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">工作单元模式</title>
    <id>https://ujava.cn/design/other/unitofwork.html</id>
    <link href="https://ujava.cn/design/other/unitofwork.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>
一次性持久化，以最大限度地减少数据库往返。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>
一次性持久化，以最大限度地减少数据库往返。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">更新方法模式</title>
    <id>https://ujava.cn/design/other/updatemethod.html</id>
    <link href="https://ujava.cn/design/other/updatemethod.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">值对象模式</title>
    <id>https://ujava.cn/design/other/valueobject.html</id>
    <link href="https://ujava.cn/design/other/valueobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供遵循值语义而不是引用语义的对象。<br>
这意味着值对象的相等性不是基于身份的。两个值对象是<br>
当它们具有相同的值时相等，而不一定是同一对象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供遵循值语义而不是引用语义的对象。<br>
这意味着值对象的相等性不是基于身份的。两个值对象是<br>
当它们具有相同的值时相等，而不一定是同一对象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">版本号模式</title>
    <id>https://ujava.cn/design/other/versionnumber.html</id>
    <link href="https://ujava.cn/design/other/versionnumber.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">页面对象模式</title>
    <id>https://ujava.cn/design/other/pageobject.html</id>
    <link href="https://ujava.cn/design/other/pageobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>
组件。这样一来，它允许测试类本身专注于测试逻辑。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>
组件。这样一来，它允许测试类本身专注于测试逻辑。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">参数对象模式</title>
    <id>https://ujava.cn/design/other/parameterobject.html</id>
    <link href="https://ujava.cn/design/other/parameterobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">部分响应模式</title>
    <id>https://ujava.cn/design/other/partialresponse.html</id>
    <link href="https://ujava.cn/design/other/partialresponse.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">管道(Pipeline)模式</title>
    <id>https://ujava.cn/design/other/pipeline.html</id>
    <link href="https://ujava.cn/design/other/pipeline.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">毒丸(Poison Pill)模式</title>
    <id>https://ujava.cn/design/other/poisonpill.html</id>
    <link href="https://ujava.cn/design/other/poisonpill.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">演示模型模式</title>
    <id>https://ujava.cn/design/other/presentationmodel.html</id>
    <link href="https://ujava.cn/design/other/presentationmodel.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">优先级队列模式</title>
    <id>https://ujava.cn/design/other/priorityqueue.html</id>
    <link href="https://ujava.cn/design/other/priorityqueue.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">私有类数据模式</title>
    <id>https://ujava.cn/design/other/privateclassdata.html</id>
    <link href="https://ujava.cn/design/other/privateclassdata.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">生产者消费者模式</title>
    <id>https://ujava.cn/design/other/producerconsumer.html</id>
    <link href="https://ujava.cn/design/other/producerconsumer.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">承诺(Promise)模式</title>
    <id>https://ujava.cn/design/other/promise.html</id>
    <link href="https://ujava.cn/design/other/promise.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">属性(Property)模式</title>
    <id>https://ujava.cn/design/other/property.html</id>
    <link href="https://ujava.cn/design/other/property.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">基于队列的负载均衡模式</title>
    <id>https://ujava.cn/design/other/queuebasedloadlevel.html</id>
    <link href="https://ujava.cn/design/other/queuebasedloadlevel.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">页面控制模式</title>
    <id>https://ujava.cn/design/other/pagecontroller.html</id>
    <link href="https://ujava.cn/design/other/pagecontroller.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T02:16:14.000Z</published>
  </entry>
  <entry>
    <title type="text">层模式</title>
    <id>https://ujava.cn/design/other/layers.html</id>
    <link href="https://ujava.cn/design/other/layers.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>层是一种体系结构模式，其中软件职责在不同的</p>
<p>应用程序的层。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>层是一种体系结构模式，其中软件职责在不同的</p>
<p>应用程序的层。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">懒加载模式</title>
    <id>https://ujava.cn/design/other/lazyloading.html</id>
    <link href="https://ujava.cn/design/other/lazyloading.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>延迟加载是一种设计模式，通常用于将对象的初始化推迟到需要它的时间点。如果使用得当，它有助于提高程序运行的效率。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">领导者选举模式</title>
    <id>https://ujava.cn/design/other/leaderelection.html</id>
    <link href="https://ujava.cn/design/other/leaderelection.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>领导者选举模式通常用于云系统设计。它有助于确保任务实例正确选择领导实例，并且不会相互冲突、导致共享资源争用或无意中干扰其他任务实例正在执行的工作。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">领导者跟随者模式</title>
    <id>https://ujava.cn/design/other/leaderfollowers.html</id>
    <link href="https://ujava.cn/design/other/leaderfollowers.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>领导者/跟随者（Leader/Followers） 模式提供了一个并发模型，在该模型中，多个线程可以有效地取消多路复用事件，并调度处理线程共享的 IO 句柄的事件处理程序。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">锁定对象模式</title>
    <id>https://ujava.cn/design/other/lockableobject.html</id>
    <link href="https://ujava.cn/design/other/lockableobject.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>可锁定对象设计模式可确保只有一个用户使用目标对象。与内置的同步机制（例如使用“synchronized”关键字）相比，此模式可以在不确定的时间内锁定对象，并且与请求的持续时间无关。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">日志整合模式</title>
    <id>https://ujava.cn/design/other/logaggregation.html</id>
    <link href="https://ujava.cn/design/other/logaggregation.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>集中、简化和优化日志管理流程，以便快速获得见解，快速识别和解决问题，并有效监控系统的整体运行状况。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">标记接口模式</title>
    <id>https://ujava.cn/design/other/markerinterface.html</id>
    <link href="https://ujava.cn/design/other/markerinterface.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用空界面作为标记来区分经过特殊处理的对象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用空界面作为标记来区分经过特殊处理的对象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">主从模式</title>
    <id>https://ujava.cn/design/other/masterworker.html</id>
    <link href="https://ujava.cn/design/other/masterworker.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当手头的问题可以通过划分为多个部分来解决时，可以使用Master Worker模式，这些部分需要经过相同的计算，并且可能需要聚合才能得到最终结果。并行处理是使用一个由一个主机和一些工人组成的系统来执行的，其中主机在工人之间分配工作，从他们那里得到结果，并同化所有结果以给出最终结果。唯一的通信是在主机和工作程序之间——没有工作程序在彼此之间通信，用户只与主机通信以完成所需的工作。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">元数据对象关系映射模式</title>
    <id>https://ujava.cn/design/other/metadatamapping.html</id>
    <link href="https://ujava.cn/design/other/metadatamapping.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>保存元数据中对象关系映射的详细信息。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>保存元数据中对象关系映射的详细信息。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">模块模式</title>
    <id>https://ujava.cn/design/other/module.html</id>
    <link href="https://ujava.cn/design/other/module.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>模块模式用于实现软件模块的概念，由模块化编程定义，在对概念的不完全直接支持的编程语言中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">单体(monad)模式</title>
    <id>https://ujava.cn/design/other/monad.html</id>
    <link href="https://ujava.cn/design/other/monad.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>
<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>
<ul>
<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>
<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>基于线性代数的单子模式代表了将运算逐步链接在一起的方式。绑定函数可以描述为基于“相同类型”合约将一个人的输出传递给另一个人的输入。</p>
<p>从形式上讲，monad 由一个类型构造函数 M 和两个操作组成：</p>
<ul>
<li>bind - 将 monadic 对象和一个函数从普通对象转换为 monadic 值并返回 monadic value</li>
<li>return - 它接受普通类型对象并返回包装在 monadic 值中的此对象。</li>
</ul>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">单态(MonoState)模式</title>
    <id>https://ujava.cn/design/other/monostate.html</id>
    <link href="https://ujava.cn/design/other/monostate.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>强制执行一种行为，例如在所有实例之间共享相同的状态。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">多态(Multiton)模式</title>
    <id>https://ujava.cn/design/other/multiton.html</id>
    <link href="https://ujava.cn/design/other/multiton.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>确保类只有有限数量的实例，并提供对它们的全局访问点。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">静音(Mute Idiom)模式</title>
    <id>https://ujava.cn/design/other/muteidiom.html</id>
    <link href="https://ujava.cn/design/other/muteidiom.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>
同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供一个模板来抑制任何已声明但不能发生或只应记录的异常；<br>
同时执行一些业务逻辑。该模板消除了重复写入“try-catch”块的需要。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">模型视图控制器(MVC)模式</title>
    <id>https://ujava.cn/design/other/mvc.html</id>
    <link href="https://ujava.cn/design/other/mvc.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>将用户界面分为三个相互关联的组件：模型、视图和控制器。让模型管理数据，视图显示数据，控制器调解更新数据并重新绘制显示。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">模型视图反应(MVI)模式</title>
    <id>https://ujava.cn/design/other/mvi.html</id>
    <link href="https://ujava.cn/design/other/mvi.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>MVI 是原始 MVC 体系结构模式的派生。MVI 不使用主动控制器，而是使用称为 intent 的反应式组件：它是一个将用户输入事件转换为模型更新的组件。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">模型视图分离(MVP)模式</title>
    <id>https://ujava.cn/design/other/mvp.html</id>
    <link href="https://ujava.cn/design/other/mvp.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>应用“关注点分离”原则，使开发人员能够构建和测试用户界面。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">模型视图视图模型(MVVM)模式</title>
    <id>https://ujava.cn/design/other/mvvm.html</id>
    <link href="https://ujava.cn/design/other/mvvm.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>应用“<a href="https://java-design-patterns.comprinciplesseparate-of-concerns" target="_blank" rel="noopener noreferrer">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>应用“<a href="https://java-design-patterns.comprinciplesseparate-of-concerns" target="_blank" rel="noopener noreferrer">关注点分离</a>”将逻辑与UI组件分开，并允许开发人员在不影响逻辑的情况下处理UI，反之亦然。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">裸对象(Naked Objects)模式</title>
    <id>https://ujava.cn/design/other/nakedobjects.html</id>
    <link href="https://ujava.cn/design/other/nakedobjects.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<ul>
<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>
<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>
<li>裸对象模式具有许多优点，包括：
<ul>
<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>
<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>
<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<ul>
<li>裸对象设计模式是一种基于直接操作思想为软件应用程序构建用户界面（UI）的方法。这意味着用户可以直接与应用程序的底层域对象交互，而无需任何中介UI元素。</li>
<li>裸对象模式是通过以一种既有意义又可访问的方式向用户公开域对象来实现的。这通常是通过根据域对象定义自动生成UI来完成的。UI以简单明了的方式向用户显示域对象，允许用户创建、检索、更新和删除对象，以及调用对象上的方法。</li>
<li>裸对象模式具有许多优点，包括：
<ul>
<li>1.减少开发时间和成本：裸对象模式可以显著减少开发和维护软件应用程序所需的时间和成本。这是因为UI是自动生成的，并且域对象被设计为用户可见且可操作。</li>
<li>2.授权用户：裸对象模式允许用户直接访问应用程序的底层域对象。这使他们能够以自然和直观的方式与应用程序进行交互。</li>
<li>3.增加了灵活性和适应性：裸对象模式具有高度的灵活性和适应性。这是因为UI是根据域对象定义生成的，这意味着UI可以随着域模型的发展而轻松更改。</li>
</ul>
</li>
</ul>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">对象母亲模式</title>
    <id>https://ujava.cn/design/other/objectmother.html</id>
    <link href="https://ujava.cn/design/other/objectmother.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>它用于定义具有独立构建器和工厂接口的不可变内容的工厂。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">对象池模式</title>
    <id>https://ujava.cn/design/other/objectpool.html</id>
    <link href="https://ujava.cn/design/other/objectpool.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当对象的创建成本很高且仅在短时间内需要它们时，使用对象池模式是有利的。对象池为实例化对象提供缓存，跟踪哪些对象正在使用，哪些对象可用。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">乐观线下锁模式</title>
    <id>https://ujava.cn/design/other/optimisticofflinelock.html</id>
    <link href="https://ujava.cn/design/other/optimisticofflinelock.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供避免在关系数据库中同时更改一条记录的能力。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供避免在关系数据库中同时更改一条记录的能力。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
  <entry>
    <title type="text">Flux模式</title>
    <id>https://ujava.cn/design/other/flux.html</id>
    <link href="https://ujava.cn/design/other/flux.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Flux避开MVC，转而支持单向数据流。当<br>
用户与视图交互，视图通过中心传播动作<br>
调度器，到保存应用程序数据和业务的各种存储<br>
逻辑，更新所有受影响的视图。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Flux避开MVC，转而支持单向数据流。当<br>
用户与视图交互，视图通过中心传播动作<br>
调度器，到保存应用程序数据和业务的各种存储<br>
逻辑，更新所有受影响的视图。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">Flyweight模式</title>
    <id>https://ujava.cn/design/other/flyweight.html</id>
    <link href="https://ujava.cn/design/other/flyweight.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用共享可以有效地支持大量细粒度对象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用共享可以有效地支持大量细粒度对象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">前端控制器模式</title>
    <id>https://ujava.cn/design/other/frontcontroller.html</id>
    <link href="https://ujava.cn/design/other/frontcontroller.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>为网站的所有请求引入一个通用处理程序。这样，我们就可以将安全性、国际化、路由和日志记录等常见功能封装在一个地方。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">游戏循环模式</title>
    <id>https://ujava.cn/design/other/gameloop.html</id>
    <link href="https://ujava.cn/design/other/gameloop.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>
<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>
<p>控制游戏的速率。</p>
<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>游戏循环在游戏过程中持续运行。循环的每一圈，它都会处理用户输入</p>
<p>无阻塞，更新游戏状态，并渲染游戏。它追踪时间的流逝</p>
<p>控制游戏的速率。</p>
<p>这种模式将游戏时间的进展与用户输入和处理器速度解耦。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">保护性暂停模式</title>
    <id>https://ujava.cn/design/other/guardedsuspension.html</id>
    <link href="https://ujava.cn/design/other/guardedsuspension.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当您想对不处于正确状态的对象执行方法时，可以使用“保护”挂起模式来处理这种情况。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">半同步半异步模式</title>
    <id>https://ujava.cn/design/other/halfsyncasync.html</id>
    <link href="https://ujava.cn/design/other/halfsyncasync.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>半同步/半异步模式将同步I/O与</p>
<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>
<p>从而降低执行效率。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>半同步/半异步模式将同步I/O与</p>
<p>系统中的异步I/O，以简化并发编程工作，而不需要</p>
<p>从而降低执行效率。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">健康检查模式</title>
    <id>https://ujava.cn/design/other/healthcheck.html</id>
    <link href="https://ujava.cn/design/other/healthcheck.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供监测和诊断服务健康状况的方法，确保微服务架构中服务的稳定性和弹性。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">六边形体系结构模式</title>
    <id>https://ujava.cn/design/other/hexagonalarchitecture.html</id>
    <link href="https://ujava.cn/design/other/hexagonalarchitecture.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>允许应用程序同样由用户、程序、自动测试或批处理脚本驱动，并在与其最终运行时设备和数据库隔离的情况下进行开发和测试。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">同一性映射模式</title>
    <id>https://ujava.cn/design/other/identitymap.html</id>
    <link href="https://ujava.cn/design/other/identitymap.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>
<p>引用对象时使用地图查找对象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过将每个加载的对象保持在地图中，确保每个对象只加载一次。</p>
<p>引用对象时使用地图查找对象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">拦截过滤器模式</title>
    <id>https://ujava.cn/design/other/interceptingfilter.html</id>
    <link href="https://ujava.cn/design/other/interceptingfilter.html"/>
    <updated>2024-03-03T08:20:09.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>
<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>
<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>
<p>这是在向应用程序发出请求之前必须处理的。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>截取过滤器是一种有用的Java设计模式，用于预处理</p>
<p>或者在应用程序中对请求进行后处理。这些过滤器被创建并应用于</p>
<p>请求，然后再将其提供给目标应用程序。这样的使用示例包括认证，</p>
<p>这是在向应用程序发出请求之前必须处理的。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T08:20:09.000Z</published>
  </entry>
  <entry>
    <title type="text">功能切换模式</title>
    <id>https://ujava.cn/design/other/featuretoggle.html</id>
    <link href="https://ujava.cn/design/other/featuretoggle.html"/>
    <updated>2024-03-03T03:41:37.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>
AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>软件开发中使用的一种技术，用于在不更改代码的情况下控制和管理程序中特定特性或功能的推出。它可以根据程序中其他值的状态或属性充当功能的开关开关。这类似于<br>
AB 测试，其中功能是根据位置或设备等属性推出的。实现此设计模式可能会增加代码复杂性，如果此设计模式用于逐步淘汰系统或功能，请务必记住删除冗余代码。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:41:37.000Z</published>
  </entry>
  <entry>
    <title type="text">流接口模式</title>
    <id>https://ujava.cn/design/other/fluentinterface.html</id>
    <link href="https://ujava.cn/design/other/fluentinterface.html"/>
    <updated>2024-03-03T03:41:37.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>流畅的界面提供了一个易于阅读的流畅界面，通常模仿特定领域的语言。使用此模式可以生成几乎可以像人类语言一样阅读的代码。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:41:37.000Z</published>
  </entry>
  <entry>
    <title type="text">环绕执行模式</title>
    <id>https://ujava.cn/design/other/executearound.html</id>
    <link href="https://ujava.cn/design/other/executearound.html"/>
    <updated>2024-03-03T03:36:58.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>环绕执行模式(Execute Around)惯用语将用户从某些操作中解放出来，这些操作应始终在业务方法之前和之后执行。一个很好的例子是资源分配和解除分配，让用户只指定如何处理资源。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:36:58.000Z</published>
  </entry>
  <entry>
    <title type="text">扩展对象模式</title>
    <id>https://ujava.cn/design/other/extensionobject.html</id>
    <link href="https://ujava.cn/design/other/extensionobject.html"/>
    <updated>2024-03-03T03:36:58.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>预计将来需要扩展对象的接口。其他接口由扩展对象定义。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:36:58.000Z</published>
  </entry>
  <entry>
    <title type="text">扇出扇入模式</title>
    <id>https://ujava.cn/design/other/fanoutfanin.html</id>
    <link href="https://ujava.cn/design/other/fanoutfanin.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>(Fan-Out/Fan-In)</p>
<p>当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。<br><br>
该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>(Fan-Out/Fan-In)</p>
<p>当源系统需要运行一个或多个将提取某些数据的长时间运行的进程时，将使用该模式。源不会阻止自己等待回复。<br><br>
该模式将在多个服务或计算机中运行相同的函数来获取数据。这相当于在不同的数据块上多次调用该函数。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:36:58.000Z</published>
  </entry>
  <entry>
    <title type="text">事件异步模式</title>
    <id>https://ujava.cn/design/other/eventasynchronous.html</id>
    <link href="https://ujava.cn/design/other/eventasynchronous.html"/>
    <updated>2024-03-03T03:14:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以：</p>
<ol>
<li>在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。</li>
<li>同时执行多个操作，每个操作完成后接收通知。</li>
<li>等待资源可用，而不停止（“挂起”）您的应用程序。</li>
<li>使用熟悉的事件和委托模型与挂起的异步操作进行通信。</li>
</ol>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>基于事件的异步模式提供了多线程应用程序的优势，同时隐藏了多线程设计中固有的许多复杂问题。使用支持此模式的类可以：</p>
<ol>
<li>在“后台”执行耗时的任务，例如下载和数据库操作，而不会中断应用程序。</li>
<li>同时执行多个操作，每个操作完成后接收通知。</li>
<li>等待资源可用，而不停止（“挂起”）您的应用程序。</li>
<li>使用熟悉的事件和委托模型与挂起的异步操作进行通信。</li>
</ol>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:14:23.000Z</published>
  </entry>
  <entry>
    <title type="text">事件驱动架构模式</title>
    <id>https://ujava.cn/design/other/eventdrivenarchitecture.html</id>
    <link href="https://ujava.cn/design/other/eventdrivenarchitecture.html"/>
    <updated>2024-03-03T03:14:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用事件驱动架构向其他应用程序发送和通知对象的状态更改。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:14:23.000Z</published>
  </entry>
  <entry>
    <title type="text">事件队列模式</title>
    <id>https://ujava.cn/design/other/eventqueue.html</id>
    <link href="https://ujava.cn/design/other/eventqueue.html"/>
    <updated>2024-03-03T03:14:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>事件队列设计模式（也称为消息队列）的目的是解耦系统内事件的发送方和接收方之间的关系。通过将双方解耦，它们不会同时与事件队列交互。从本质上讲，事件队列以异步方式处理和处理请求，因此，该系统可以被描述为先进先出的设计模式模型。如果存在可访问性有限的资源（即音频或数据库），则事件队列是一种合适的模式，但是，您需要提供对查找此资源的所有请求的访问权限。从队列中访问事件时，程序还会将其从队列中删除。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:14:23.000Z</published>
  </entry>
  <entry>
    <title type="text">事件溯源模式</title>
    <id>https://ujava.cn/design/other/eventsourcing.html</id>
    <link href="https://ujava.cn/design/other/eventsourcing.html"/>
    <updated>2024-03-03T03:14:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>不要只在域中存储数据的当前状态，而是使用仅追加存储来记录对该数据执行的一系列操作。存储充当记录系统，可用于具体化域对象。这可以简化复杂域中的任务，避免同步数据模型和业务域，同时提高性能、可伸缩性和响应能力。它还可以为事务数据提供一致性，并维护完整的审计跟踪和历史记录，从而实现补偿操作。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:14:23.000Z</published>
  </entry>
  <entry>
    <title type="text">事件聚合器模式</title>
    <id>https://ujava.cn/design/other/eventaggregator.html</id>
    <link href="https://ujava.cn/design/other/eventaggregator.html"/>
    <updated>2024-03-03T03:00:03.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当客户端想要订阅事件时，具有大量对象的系统可能会导致复杂性。客户端必须为每个对象单独查找和注册，如果每个对象都有多个事件，则每个事件都需要单独的订阅。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-03T03:00:03.000Z</published>
  </entry>
  <entry>
    <title type="text">委托模式</title>
    <id>https://ujava.cn/design/other/delegate.html</id>
    <link href="https://ujava.cn/design/other/delegate.html"/>
    <updated>2024-03-03T03:00:03.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>委托模式提供了一种机制，用于抽象出所需操作的实现和控制。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-01T02:50:49.000Z</published>
  </entry>
  <entry>
    <title type="text">依赖注入模式</title>
    <id>https://ujava.cn/design/other/dependencyinjection.html</id>
    <link href="https://ujava.cn/design/other/dependencyinjection.html"/>
    <updated>2024-03-03T03:00:03.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>依赖注入模式处理对象如何处理其依赖关系。该模式实现了所谓的反转控制原理。控制反转有两个具体规则： - 高级模块不应依赖于低级模块。两者都应该依赖于抽象。- 抽象不应依赖于细节。细节应取决于抽象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-01T02:50:49.000Z</published>
  </entry>
</feed>