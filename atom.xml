<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://ujava.cn/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://ujava.cn/</id>
  <title>UJava</title>
  <subtitle> 【Java学习 + Java面试】首选UJava！  </subtitle>
  <updated>2024-02-29T06:33:58.550Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://ujava.cn/atom.xml"/>
  <link rel="alternate" href="https://ujava.cn/"/>
  <category term="设计模式"/>
  <category term="设计高频"/>
  <category term="Java"/>
  <category term="设计原理"/>
  <category term="设计算法"/>
  <category term="设计思想"/>
  <category term="设计框架"/>
  <category term="必读"/>
  <category term="设计规范"/>
  <category term="思想"/>
  <entry>
    <title type="text">转换器模式</title>
    <id>https://ujava.cn/design/other/converter.html</id>
    <link href="https://ujava.cn/design/other/converter.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>转换器(Converter)模式是一种行为设计模式，它允许在相应类型（例如DTO和逻辑同构类型的域表示）之间进行双向转换的通用方式。此外，该模式还引入了一种在类型之间转换对象集合的通用方法。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">命令查询职责分离(CQRS)模式</title>
    <id>https://ujava.cn/design/other/cqrs.html</id>
    <link href="https://ujava.cn/design/other/cqrs.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>CQRS：命令查询职责分离。一种用于将查询服务与命令或写入服务分离的模式。这个模式很简单，但有很多后果。例如，它可以用于处理复杂的域，或者使用其他难以用经典方式实现的体系结构。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">奇异递归模板(CRTP)模式</title>
    <id>https://ujava.cn/design/other/crtp.html</id>
    <link href="https://ujava.cn/design/other/crtp.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>CRTP 全称 ： Curiously Recurring Template Pattern，也就是常说的奇异递归模板模式</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">柯里化(Currying)模式</title>
    <id>https://ujava.cn/design/other/currying.html</id>
    <link href="https://ujava.cn/design/other/currying.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Currying将具有多个参数的函数分解为具有单个参数的多个函数。只传递了部分参数的curried函数称为部分应用程序。部分应用程序非常有用，因为它可以用于以简洁的方式创建专门的函数。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">数据访问对象(DAO)模式</title>
    <id>https://ujava.cn/design/other/dao.html</id>
    <link href="https://ujava.cn/design/other/dao.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。</p>
<p>使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>数据访问对象（DAO）是一个为某种类型的数据库或其他持久性机制提供抽象接口的对象。通过将应用程序调用映射到持久层，DAO在不公开数据库细节的情况下提供了一些特定的数据操作。这种隔离支持单一责任原则。它将特定于域的对象和数据类型（DAO的公共接口）方面的数据访问应用程序需求与特定DBMS如何满足这些需求区分开来。</p>
<p>使用DAO模式，我们可以使用各种方法调用来检索/添加/删除/更新数据，而无需直接与数据源交互。下面的示例演示了基本的CRUD操作：选择、添加、更新和删除。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">数据总线模式</title>
    <id>https://ujava.cn/design/other/databus.html</id>
    <link href="https://ujava.cn/design/other/databus.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p><a href="http://wiki.c2.com/?DataBusPattern" target="_blank" rel="noopener noreferrer">http://wiki.c2.com/?DataBusPattern</a></p>
<p>数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p><a href="http://wiki.c2.com/?DataBusPattern" target="_blank" rel="noopener noreferrer">http://wiki.c2.com/?DataBusPattern</a></p>
<p>数据总线模式提供了一种方法，在该方法中，应用程序的不同部分可以在彼此之间传递消息，而不需要知道对方的存在。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">数据本地化模式</title>
    <id>https://ujava.cn/design/other/datalocality.html</id>
    <link href="https://ujava.cn/design/other/datalocality.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能</p>
<p>按照处理顺序将数据保存在连续内存中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当您遇到性能问题时，请使用数据本地化模式。利用这一点，通过提高数据位置性来提高性能</p>
<p>按照处理顺序将数据保存在连续内存中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">数据映射器模式</title>
    <id>https://ujava.cn/design/other/datamapper.html</id>
    <link href="https://ujava.cn/design/other/datamapper.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>数据映射器（DM）是将内存中的对象与数据库分离的一层软件。它的职责是在两者之间传输数据，并将它们相互隔离。使用Data Mapper，内存中的对象甚至不必知道存在数据库；它们不需要SQL接口代码，当然也不需要数据库模式的知识。（数据库架构总是不知道使用它的对象。）由于它是Mapper的一种形式，Data Mapper本身甚至对域层来说是未知的。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">数据传输对象模式</title>
    <id>https://ujava.cn/design/other/datatransferobject.html</id>
    <link href="https://ujava.cn/design/other/datatransferobject.html"/>
    <updated>2024-02-29T06:34:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>数据传输对象模式是一种设计模式，其中数据传输对象用于一起提供相关信息，以避免对每条信息进行多次调用。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T06:34:22.000Z</published>
  </entry>
  <entry>
    <title type="text">安排执行断言模式</title>
    <id>https://ujava.cn/design/other/aaa.html</id>
    <link href="https://ujava.cn/design/other/aaa.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>安排执行断言模式(Arrange/Act/Assert(AAA))是个单元测试模式</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">抽象文档模式</title>
    <id>https://ujava.cn/design/other/abstractdocument.html</id>
    <link href="https://ujava.cn/design/other/abstractdocument.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>抽象文档模式(abstract document)允许处理其他非静态属性。此模式使用特征的概念来实现类型安全，并将不同类的属性分离到一组接口中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">活动对象模式</title>
    <id>https://ujava.cn/design/other/activeobject.html</id>
    <link href="https://ujava.cn/design/other/activeobject.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>活动对象模式(active object)有助于在不使用“同步”方法的情况下解决同步困难。活动对象将包含线程安全的数据结构（如 BlockingQueue），用于通过将方法的逻辑移动到调用器（通常是 Runnable）并将其存储在 DSA 中来同步方法调用。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">非循环访问者模式</title>
    <id>https://ujava.cn/design/other/acyclicvisitor.html</id>
    <link href="https://ujava.cn/design/other/acyclicvisitor.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang<br>
of Four) Visitor(访问者) 模式固有的依赖关系循环</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>非循环访问者模式(acyclic visitor)允许将新函数添加到现有类层次结构中，而不会影响这些层次结构，并且不会通过使 Visitor 基类退化来创建 GoF(Gang<br>
of Four) Visitor(访问者) 模式固有的依赖关系循环</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">大使模式</title>
    <id>https://ujava.cn/design/other/ambassadorpattern.html</id>
    <link href="https://ujava.cn/design/other/ambassadorpattern.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。<br>
大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>大使模式(ambassador pattern)创建一个帮助程序服务，该服务代表客户端发送网络请求。它通常用于基于云的应用程序中，以卸载远程服务的功能。<br>
大使服务可以看作是与客户端位于同一位置的进程外代理。与代理设计模式类似，大使服务为另一个远程服务提供接口。除了接口之外，大使还提供额外的功能和特性，特别是卸载了常见的连接任务。这通常包括监控、日志记录、路由、安全等。这在代码库难以修改的旧应用程序中非常有用，并允许改进应用程序的网络功能。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">异步方法调用模式</title>
    <id>https://ujava.cn/design/other/asynmethodinvocation.html</id>
    <link href="https://ujava.cn/design/other/asynmethodinvocation.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>异步方法调用(asynchronous method invocation)是一种模式，在等待任务结果时，调用线程不会被阻塞。该模式提供多个独立任务的并行处理，并通过回调或等待所有工作完成来检索结果。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">放弃设计模式</title>
    <id>https://ujava.cn/design/other/balkingdesign.html</id>
    <link href="https://ujava.cn/design/other/balkingdesign.html"/>
    <updated>2024-02-29T03:01:44.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在放弃设计模式(Balking Design Pattern) 中，如果对象的方法在处于不适当的状态时被调用，则该方法将返回而不执行任何操作。使用此模式的对象通常只处于一种容易暂时停止的状态，但持续时间未知</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">业务委托模式</title>
    <id>https://ujava.cn/design/other/businessdelegate.html</id>
    <link href="https://ujava.cn/design/other/businessdelegate.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。<br>
业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>业务委托模式(business delegate)在表示层和业务层之间添加了一个抽象层。通过使用该模式，我们获得了层之间的松散耦合。业务委托封装了有关如何查找、连接到构成应用程序的业务对象并与之交互的知识。<br>
业务委托使用的一些服务是直接实例化的，有些服务可以通过服务查找来检索。业务委托本身也可能包含业务逻辑，可能会将多个服务调用、异常处理、重试等捆绑在一起。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">字节码模式</title>
    <id>https://ujava.cn/design/other/bytecode.html</id>
    <link href="https://ujava.cn/design/other/bytecode.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>字节码模式(bytecode pattern)<br>
的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。<br>
当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>字节码模式(bytecode pattern)<br>
的目的是通过将数据编码为虚拟机的指令来为行为提供数据的灵活性。指令集定义了可以执行的低级操作。一系列指令被编码为字节序列。虚拟机一次执行一个指令，使用堆栈作为中间值。通过组合指令，可以定义复杂的高级行为。<br>
当需要定义大量行为并且实现引擎不是一个好的选择时，应该使用此模式，因为它太低级别了，由于编译时间慢或其他工具问题，迭代它需要很长时间。它有太多的信任。如果要确保所定义的行为不会破坏游戏，则需要将其从代码库的其余部分沙盒化。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">缓存模式</title>
    <id>https://ujava.cn/design/other/caching.html</id>
    <link href="https://ujava.cn/design/other/caching.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。<br>
这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>缓存模式(caching)描述了如何通过不在资源使用后立即释放资源来避免昂贵的资源重新获取。这些资源保留了它们的身份，保存在一些快速访问存储中，并被重新使用以避免再次获取它们。此模式中有四种主要的缓存策略/技术；每个人都有自己的优点和缺点。它们是在单个事务中将数据写入高速缓存和数据库的写操作，将数据立即写入数据库而不是高速缓存的绕写操作，最初将数据写入高速缓冲存储器的后写操作，而数据仅在高速缓冲存储器满时写入数据库，并将保持两个数据源中的数据同步的责任推给应用程序本身。read-through策略也包含在上述四种策略中——如果存在，则将数据从缓存返回给调用方，否则从DB查询并将其存储到缓存中以备将来使用。<br>
这些策略决定了缓存中的数据何时应写回后备存储（即数据库），并有助于保持两个数据源的同步/最新。这种模式可以提高性能，也有助于保持缓存中的数据与底层数据存储中的数据之间的一致性。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">回调模式</title>
    <id>https://ujava.cn/design/other/callback.html</id>
    <link href="https://ujava.cn/design/other/callback.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>回调模式(callback)对于函数被视为一等公民的函数语言来说更为原生。在Java 8之前，可以使用简单的（类似的命令）接口来模拟回调。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">回路生成器模式</title>
    <id>https://ujava.cn/design/other/circuitbuilder.html</id>
    <link href="https://ujava.cn/design/other/circuitbuilder.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>回路生成器模式(Circuit Builder)的目的是稳健地处理远程故障，也就是说，如果一个服务依赖于n个其他服务，并且其中m个服务失败，我们应该能够通过确保用户仍然可以使用实际工作的服务来从故障中恢复，并且资源不会被不工作的服务无用地占用。然而，我们也应该能够检测出m个故障服务何时重新开始运行，以便我们能够使用它</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">客户端会话模式</title>
    <id>https://ujava.cn/design/other/clientsession.html</id>
    <link href="https://ujava.cn/design/other/clientsession.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>客户端会话模式(Client-Session)允许将会话数据存储在客户端，并在每次请求时将这些数据发送到服务器。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">收集参数设计模式</title>
    <id>https://ujava.cn/design/other/collectingparameter.html</id>
    <link href="https://ujava.cn/design/other/collectingparameter.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>收集参数设计模式(Collecting Parameter)旨在返回一个结果，该结果是多种方法的协作结果。此设计模式使用一个“收集参数”，该参数传递给多个函数，在从一个方法传递到另一个方法时累积结果。这与Composed Method设计模式不同，后者通过多种方法修改单个集合。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">集合管道模式</title>
    <id>https://ujava.cn/design/other/collectionpipeline.html</id>
    <link href="https://ujava.cn/design/other/collectionpipeline.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>集合管道模式(Collection Pipeline)</p>
<p>在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>集合管道模式(Collection Pipeline)</p>
<p>在命令式编程中，大多数类型的数据处理通常使用for和while循环。函数组合是一种简单的技术，可以对模块化函数进行排序，以创建更复杂的操作。当您在序列中运行数据时，您就有了一个收集管道。函数组合和收集管道模式使您能够创建复杂的程序，其中数据从上游流到下游，并通过一系列转换进行传递。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">上下文对象模式</title>
    <id>https://ujava.cn/design/other/contextobject.html</id>
    <link href="https://ujava.cn/design/other/contextobject.html"/>
    <updated>2024-02-29T02:52:33.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在上下文对象模式(context object)中，来自底层协议特定类/系统的信息和数据被解耦，并以有组织的格式存储到与协议无关的对象中。该模式确保上下文对象中包含的数据可以在软件系统的不同层之间共享和进一步结构化。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-02-29T02:52:33.000Z</published>
  </entry>
  <entry>
    <title type="text">K8S简介</title>
    <id>https://ujava.cn/highfreq/k8s.html</id>
    <link href="https://ujava.cn/highfreq/k8s.html"/>
    <updated>2024-02-28T02:35:40.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、K8S简介</h2>
<p>Kubernetes中文官网：<a href="https://kubernetes.io/zh/" target="_blank" rel="noopener noreferrer">Kubernetes</a></p>
<p>GitHub：<a href="http://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreferrer">github.com/kubernetes/kubernetes</a></p>
<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 一、K8S简介</h2>
<p>Kubernetes中文官网：<a href="https://kubernetes.io/zh/" target="_blank" rel="noopener noreferrer">Kubernetes</a></p>
<p>GitHub：<a href="http://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreferrer">github.com/kubernetes/kubernetes</a></p>
<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>
<p>Kubernetes集群组件逻辑图<br>
</p>
<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>
<p>Master节点组件及功能<br>
</p>
<p>Slave节点组件及功能<br>
</p>
<p>安装部署</p>
<p>生产环境部署k8s主要有两种方式：</p>
<p>二进制包</p>
<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>
<p>kubeadm工具</p>
<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>
<ul>
<li>kubeadm init：初始化一个Master节点</li>
<li>kubeadm join：将Worker节点加入集群</li>
<li>kubeadm upgrade：升级K8s版本</li>
<li>kubeadm token：管理 kubeadm join 使用的令牌</li>
<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>
<li>kubeadm version：打印 kubeadm 版本</li>
<li>kubeadm alpha：预览可用的新功能</li>
</ul>
<h2> 二、准备工作</h2>
<p>软硬件要求</p>
<ul>
<li>Linux操作系统，Ubuntu 或 CentOS</li>
<li>每台节点至少2G</li>
<li>Master节点至少2C</li>
<li>集群节点网络互通</li>
</ul>
<p>集群规划</p>
<figure><figcaption>img_104.png</figcaption></figure>
<p>环境配置</p>
<p>修改hosts配置</p>
<p>配置所有节点的IP和域名映射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置SSH免密登录</p>
<p>先生成公钥对，再把公钥远程复制到所有节点。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关闭Swap分区</p>
<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>禁用SELinux</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭防火墙</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改内核参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置集群时钟同步</p>
<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置k8s的Yum源</p>
<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、安装Docker</h2>
<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>
<h2> 四、安装K8S集群</h2>
<p>安装三大组件-kubeadm、kubelet、kubectl</p>
<ul>
<li>kubeadm：用来初始化k8s集群的指令。</li>
<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>
<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化k8s集群</p>
<ul>
<li>apiserver-advertise-address：apiserver监听地址</li>
<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>
<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>
<li>service-cidr：为Service分配的IP地址段</li>
<li>pod-network-cidr：为pod分配的IP地址段</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>成功界面：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>
<p>加入节点</p>
<p>所有Node节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改角色：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装网络插件</p>
<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>
</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、测试K8S集群</h2>
<p>创建nginx pod</p>
<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对外暴露访问</p>
<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问nginx</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>
<h2> 六、安装Dashboard</h2>
<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>
<p>Github：<a href="http://github.com/kubernetes/dashboard" target="_blank" rel="noopener noreferrer">github.com/kubernetes/dashboard</a></p>
<p>通过kubectl命令安装</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看service</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器输入访问地址：<a href="https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82" target="_blank" rel="noopener noreferrer">https://192.168.5.10:31128/，需要token才能访问。</a></p>
<figure><figcaption>img_107.png</figcaption></figure>
<p>创建访问账号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>登录界面</p>
<p>输入上面的token，进入dashboard首页</p>
<figure><figcaption>img_108.png</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-27T08:08:33.000Z</published>
  </entry>
  <entry>
    <title type="text">Jenkins详解</title>
    <id>https://ujava.cn/highfreq/jenkins.html</id>
    <link href="https://ujava.cn/highfreq/jenkins.html"/>
    <updated>2024-02-27T07:30:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1.背景</h2>
<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>这些情况都会涉及到频繁的打包部署；</p>
<p>手动打包常规步骤：</p>
<ul>
<li>1.提交代码</li>
<li>2.问一下同组小伙伴有没有要提交的代码</li>
<li>3.拉取代码并打包（war包，或者jar包）</li>
<li>4.上传到Linux服务器</li>
<li>5.查看当前程序是否在运行</li>
<li>6.关闭当前程序</li>
<li>7.启动新的jar包</li>
<li>8.观察日志看是否启动成功</li>
<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1.背景</h2>
<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>这些情况都会涉及到频繁的打包部署；</p>
<p>手动打包常规步骤：</p>
<ul>
<li>1.提交代码</li>
<li>2.问一下同组小伙伴有没有要提交的代码</li>
<li>3.拉取代码并打包（war包，或者jar包）</li>
<li>4.上传到Linux服务器</li>
<li>5.查看当前程序是否在运行</li>
<li>6.关闭当前程序</li>
<li>7.启动新的jar包</li>
<li>8.观察日志看是否启动成功</li>
<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>
</ul>
<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>
<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>
<p>只是Jenkins相对来说，使用得更广泛。</p>
<h2> 2.Jenkins服务器搭建及基本配置</h2>
<h3> 2.1.简介</h3>
<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h3> 2.2.Jenkins自动化部署实现原理</h3>
<figure><figcaption>img_70.png</figcaption></figure>
<h3> 2.3.Jenkins部署环境</h3>
<p>基本环境：</p>
<ul>
<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>
<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>
<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>
</ul>
<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>
<h3> 2.4.Jenkins安装</h3>
<ul>
<li>1.下载安装包jenkins.war；</li>
<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>
<li>3.打开浏览器进入链接 <a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a>.</li>
<li>4.填写初始密码，激活系统</li>
</ul>
<figure><figcaption>img_71.png</figcaption></figure>
<ul>
<li>5.进入插件安装选择</li>
</ul>
<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>
<figure><figcaption>img_72.png</figcaption></figure>
<p>选择后，进入插件安装页面<br>
</p>
<ul>
<li>
<p>6.设置初始用户和密码<br>
</p>
</li>
<li>
<p>7.进入系统，安装完成<br>
</p>
</li>
</ul>
<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>
<h3> 2.5.Jenkins基本配置</h3>
<h4> 2.5.1.系统初始化配置</h4>
<figure><figcaption>img_76.png</figcaption></figure>
<p><strong>1.Configure System (系统设置)</strong></p>
<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>
<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>
<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>
</p>
<p><strong>2.Configure Global Security (全局安全配置)</strong></p>
<p>a.配置用户相关的权限</p>
<figure><figcaption>img_78.png</figcaption></figure>
<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>
<p>默认是勾选上了的，这里去掉勾选</p>
<figure><figcaption>img_79.png</figcaption></figure>
<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>
<p>a.配置maven的全局settings路径<br>
</p>
<p>b.配置jdk<br>
</p>
<p>c.配置git</p>
<figure><figcaption>img_82.png</figcaption></figure>
<p>d.配置maven的安装路径</p>
<figure><figcaption>img_83.png</figcaption></figure>
<p><strong>4.配置必要插件</strong></p>
<p>主要是检查如下这两个插件是否已安装</p>
<ul>
<li>插件1：Publish over SSH</li>
<li>插件2：Deploy to container Plugin</li>
</ul>
<figure><figcaption>img_84.png</figcaption></figure>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>
<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>
<h3> 3.1.Jenkins服务器上创建项目和配置</h3>
<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>
<p><strong>1.创建一个工程</strong></p>
<figure><figcaption>img_85.png</figcaption></figure>
<p><strong>2.General(基础配置)</strong></p>
<p>仅需填写标准部分，其他可不填写</p>
<figure><figcaption>img_86.png</figcaption></figure>
<p><strong>3.源码管理</strong><br>
</p>
<p>上图中点击“添加”按钮添加一组账号和密码<br>
</p>
<p><strong>4.构建触发器</strong></p>
<figure><figcaption>img_89.png</figcaption></figure>
<p>如上图：当前项目的回调地址为：</p>
<p><a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>
<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>
<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>
<p><strong>5.构建环境（无需配置）</strong></p>
<p><strong>6.构建</strong></p>
<figure><figcaption>img_90.png</figcaption></figure>
<p><strong>7.构建后操作</strong></p>
<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>
<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>
<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>
</p>
<p>案例中给出的stop.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例中给出的start.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>
<h3> 3.2.Linux服务器配置</h3>
<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>
<figure><figcaption>img_92.png</figcaption></figure>
<h3> 3.3.GitHub服务器配置</h3>
<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>
<p>特别注意：为了保证回调地址网可以使用，</p>
<p>我已经将地址：<a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>
<p>通过花生壳进行外网映射为：<a href="http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>所以，下面配置的是外网映射地址。</p>
<figure><figcaption>img_93.png</figcaption></figure>
<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>
<h2> 4.测试</h2>
<p><strong>1.测试代码</strong><br>
</p>
<p><strong>2.提交代码到git,触发构建</strong></p>
<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>
</p>
<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>
<p>从下图中可以看出，正在构建</p>
<figure><figcaption>img_96.png</figcaption></figure>
<p><strong>5.查看当次构建的控制台日志</strong></p>
<figure><figcaption>img_97.png</figcaption></figure>
<p>说明已经启动成功</p>
<p><strong>6.查看Linux服务器，是否上传代码</strong></p>
<figure><figcaption>img_98.png</figcaption></figure>
<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>
<figure><figcaption>img_99.png</figcaption></figure>
<p><strong>8.浏览器上访问，看是否能用</strong></p>
<figure><figcaption>img_100.png</figcaption></figure>
<p>说明，已经正常启动可以使用。</p>
<p><strong>9.再次确认是否能自动化部署</strong></p>
<p>修改代码，重新提交代码，循环1到8步查看。</p>
<p>如果测试结果是你预期的，那么自动化部署成功。</p>
<h2> 5.总结&amp;资料下载</h2>
<h3> 5.1.总结</h3>
<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>
<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>
<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>
<p>但是，本着学习是为了解决生产的原则，</p>
<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>
<p>没必要把Jenkins的所有功能都学完在使用，</p>
<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>
<h3> 5.2.相关资料</h3>
<ul>
<li>1.案例中的源码地址：<a href="https://github.com/processfactory/demo01.git" target="_blank" rel="noopener noreferrer">https://github.com/processfactory/demo01.git</a></li>
<li>2.官方文档：Jenkins 用户手册</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-27T06:40:40.000Z</published>
  </entry>
  <entry>
    <title type="text">DevOps基本概念</title>
    <id>https://ujava.cn/highfreq/devops.html</id>
    <link href="https://ujava.cn/highfreq/devops.html"/>
    <updated>2024-02-27T05:50:08.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. DevOps</h2>
<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>
<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>
<p>项目管理模式的演变是受项目的规模大小影响的。</p>
<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>
<br>
后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. DevOps</h2>
<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>
<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>
<p>项目管理模式的演变是受项目的规模大小影响的。</p>
<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>
<br>
后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>
<p><br>
再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>
<br>
再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>
<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>
<p><br>
DevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>
<ul>
<li>DevOps = 人 + 流程 + 平台</li>
<li>人 + 流程 = 文化</li>
<li>流程 + 平台 = 工具</li>
<li>平台 + 人 = 赋能</li>
</ul>
<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>
<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>
<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>
<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>
<h2> 2. CI/CD</h2>
<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>
<p><br>
CI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>
<p><strong>持续集成</strong>：</p>
<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>
</p>
<p><strong>持续交付</strong>：</p>
<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>
</p>
<p><strong>持续部署</strong>：</p>
<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>
</p>
<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>
<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>
<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>
<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>
<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-27T05:50:08.000Z</published>
  </entry>
  <entry>
    <title type="text">SpringCloud详解</title>
    <id>https://ujava.cn/highfreq/springcloud.html</id>
    <link href="https://ujava.cn/highfreq/springcloud.html"/>
    <updated>2024-02-26T05:26:17.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>
<h2> 一、SpringCloud概述</h2>
<p>SpringCloud：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud官网</a></p>]]></summary>
    <content type="html"><![CDATA[<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>
<h2> 一、SpringCloud概述</h2>
<p>SpringCloud：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud官网</a></p>
<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>
<h2> 二、Spring Cloud 和 Dubbo 对比</h2>
<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>
Spring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>
Dubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>
下面是Spring Cloud和Dubbo的一些比较：<br>
</p>
<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>
<p>需要根据具体的业务需求来选择合适的微服务框架。</p>
<h2> 三、Spring Cloud 优缺点</h2>
<p>其主要优点有：</p>
<ul>
<li>
<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>
</li>
<li>
<p>约定优于配置，基于注解，没有配置文件。</p>
</li>
<li>
<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>
</li>
<li>
<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>
</li>
<li>
<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>
接下来，我们看下它的缺点：</p>
</li>
<li>
<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>
</li>
<li>
<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>
Spring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>
</li>
</ul>
<h2> 四、SpringCloud组件</h2>
<h3> 1、Eureka</h3>
<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、Feign</h3>
<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、Ribbon</h3>
<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、Hystrix</h3>
<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、Config</h3>
<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、SpringCloud应用场景</h2>
<h3> 1、微服务架构</h3>
<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>
<h3> 2、分布式配置中心</h3>
<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>
<h3> 3、服务调用和负载均衡</h3>
<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>
<h3> 4、高可用和容错机制</h3>
<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>
<h2> 六、结语</h2>
<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-26T05:26:17.000Z</published>
  </entry>
  <entry>
    <title type="text">什么是serverless</title>
    <id>https://ujava.cn/highfreq/serverless.html</id>
    <link href="https://ujava.cn/highfreq/serverless.html"/>
    <updated>2024-02-26T03:22:45.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1 什么是severless ?</h2>
<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>
<figure><figcaption>img_58.png</figcaption></figure>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>
<ul>
<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>
就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1 什么是severless ?</h2>
<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>
<figure><figcaption>img_58.png</figcaption></figure>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>
<ul>
<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>
就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>
</ul>
<h2> 2 有服务到无服务构架有哪些变化？</h2>
<ul>
<li>弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>
<li>代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>
<li>按使用量计费。Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。<br>
云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</li>
</ul>
<h2> 3 serverless发展历史</h2>
<p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>
<ul>
<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。</li>
<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>
<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a href="http://iron.io" target="_blank" rel="noopener noreferrer">iron.io</a>。</li>
<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>
</ul>
<h2> 4 severless 分类</h2>
<p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。</p>
<ul>
<li>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</li>
<li>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</li>
</ul>
<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>
<h2> 5 severles优缺点</h2>
<h3> 优点</h3>
<ul>
<li>降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</li>
<li>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</li>
<li>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</li>
<li>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</li>
<li>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</li>
<li>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是多快好省。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</li>
<li>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</li>
<li>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</li>
<li>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</li>
<li>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</li>
<li>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</li>
</ul>
<h3> 缺点</h3>
<ul>
<li>状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>
<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>
<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>
</ul>
<h2> 6 serverless使用场景</h2>
<p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。</p>
<ul>
<li>
<p>异步的并发，组件可独立部署和扩展</p>
</li>
<li>
<p>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</p>
</li>
<li>
<p>短暂、无状态的应用，对冷启动时间不敏感</p>
</li>
<li>
<p>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）<br>
Serverless 的使用场景示例如：</p>
</li>
<li>
<p>ETL</p>
</li>
<li>
<p>机器学习及 AI 模型处理</p>
</li>
<li>
<p>图片处理</p>
</li>
<li>
<p>IoT 传感器数据分析</p>
</li>
<li>
<p>流处理</p>
</li>
<li>
<p>聊天机器人<br>
示例：</p>
</li>
</ul>
<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>
<p>一款移动端游戏至少包含如下几个特性：</p>
<ul>
<li>移动端友好的用户体验</li>
<li>用户管理和权限认证</li>
<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息<br>
传统的应用程序架构可能是这样的：</li>
</ul>
<figure><figcaption>img_59.png</figcaption></figure>
<ul>
<li>一个 app 前端，iOS 或者安卓</li>
<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>
<li>使用关系型数据库存储用户数据，如 MySQL<br>
这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</li>
</ul>
<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>
<figure><figcaption>img_60.png</figcaption></figure>
<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>
<h2> 7 serverless核心技术</h2>
<p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>
<ul>
<li>函数的规范定义</li>
<li>函数部署流水线</li>
<li>Workflow 设置</li>
<li>0-m-n 扩缩容</li>
<li>快速冷启动</li>
</ul>
<h2> 总结</h2>
<p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-26T03:22:45.000Z</published>
  </entry>
  <entry>
    <title type="text">企业级架构带来的模式改变</title>
    <id>https://ujava.cn/highfreq/modelchange.html</id>
    <link href="https://ujava.cn/highfreq/modelchange.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>
<h2> 一、价值评估有章可循</h2>
<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>]]></summary>
    <content type="html"><![CDATA[<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>
<h2> 一、价值评估有章可循</h2>
<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>
<p>企业级架构建设循着企业价值创造的链条，可面向业务领域逐步开展需求识别和定义。对于业务领域而言，其主要职责是创造业务价值，承接战略分析成果，进行产品研发。实践中，业务领域需要清晰定义本领域应具备的能力，提出能力建设方案，并在领域范畴内，按照计划—执行—监督的完整价值流，识别出业务活动。业务活动是指创造端对端业务价值的具体工作，其价值交付主要以产品为载体，包括产品服务的客户、产品提供的渠道、产品所需的合作伙伴等，在流程模型中需要进行全面辨识。基于企业级架构方法论形成的业务需求和业务模型，有助于业务价值的体现和评估：</p>
<p>一是基于企业级架构的全局视角，可以减少个别部门的短期促销行为，同时避免不规范需求引发的产品定价、业务流程不一致等问题。二是企业级架构承接业务战略，始终围绕着价值创造建设，而需求在经过“战略解析—能力主题—产品设计—流程设计—能力实现”的工作模型检验后，将能够更好地满足战略需要，有利于提高核心竞争力。三是需求的业务价值更容易量化，基于企业级架构，可建立产品、客户、渠道、合作方贡献度评价体系，对需求带来的效益进行数字化评估。四是业务需求价值评估能力提高，可以使科技产能更好地倾向于重点需求开发，快速形成竞争力。</p>
<h2> 二、数据治理追本溯源</h2>
<p>如果说价值交付是建设企业级架构的核心，那么业务信息则是构成企业级架构的基础，内容涉及业务架构的业务对象以及业务模型的实体模型等。对此，IT架构的数据架构进一步从数据定义、数据管理、数据服务等方向，规定了数据生命周期中各种形态的管理原则。数据架构组成示意如图1所示。例如，针对实体建模，该架构详细描述定义了业务实体和实体属性；针对数据定义，要求开发数据结构准确继承实体模型；针对元数据管理，要求建立企业级数据字典，保证数据能被正确描述和使用。此外，在数据质量管控方面，则是要求在组织、办法和流程等维度进行全面统筹。</p>
<figure><figcaption>数据架构组成示意</figcaption></figure>
<p>实践证明，如果不能全面梳理数据脉络，数据治理的结果往往是事倍功半。对此，企业级架构有助于为全面实施数据治理打开局面：一是在需求的业务建模阶段，业务流程的数据需求和实体模型需要进行相互验证，并通过企业级数据字典进行定义，在源头保证数据准确性。二是从架构设计到实施工艺，从实体建模到数据结构设计，借助企业级架构可形成全面的数据管理办法，保证数据在产生、传输、存储、服务各个环节的一致性。三是基于企业级架构，可将内部能力按业务组件归集，并依照业务组件开发应用组件，同时加强数据副本管理，进而避免因同类业务被不同应用系统承接导致的管理复杂化问题。综上，数据治理是数字化转型的一项基础性工作，而企业级架构恰好提供了一枚“金钥匙”。</p>
<h2> 三、业务与技术更好衔接</h2>
<p>在瀑布式开发模式下，标准化需求确认需要经历多个不同阶段的准入门禁，需求响应缓慢。与之相比，敏捷开发模式强调客户参与，更有助于加速需求交付进程，例如将开发过程前移到需求提出阶段，或是请业务人员加入开发团队等。除此之外，企业级架构也为业务与技术融合提供了一种新的途径：</p>
<ul>
<li>一是在提交业务需求前，通过对活动进行流程建模，以及对业务对象进行实体建模，并采用结构化、标准化语言(如流程建模的BPMN图和实体建模的ER图等)消弭理解歧义，可基于业务模型团队构建衔接业务和技术的桥梁。</li>
<li>二是企业级架构结合内部视角，可从业务流程、职责划分等维度映射业务组件与应用组件的对应关系，进而实现业务和技术的完美对应。</li>
<li>三是企业级架构的流程建模需要勾连相关实体，而建模产出物结合面向对象的设计方法，将能方便地识别出符合客观世界的对象，对象拥有实体属性，并具备流程模型描述的处理能力。</li>
<li>四是企业级架构在进行实体建模时，可对实体进行归类，定义出主实体，并与周边的多个实体组成业务对象(子主题域)。在开发阶段，通过将业务建模的业务对象(子主题域)设计成相应的数据聚合，可有效保证技术和业务理解一致，使用“共同语言”。</li>
</ul>
<p>总体而言，业务模型通过以业务视角来描述战术层和运营层的业务架构，可为IT架构提供高效输入，而善于使用业务架构和业务模型，也将使业务与技术衔接得更好，加快需求响应速度。业务架构基础模型如图2所示。</p>
<figure><figcaption>业务架构基础模型</figcaption></figure>
<h2> 四、方法实践潜移默化</h2>
<p>从实践角度发出，企业级架构不仅是对业务架构和IT架构进行全局设计，还提供了精确描述企业的统一方法论，如可灵活应用在日常工作中，将产生潜移默化的积极影响：</p>
<ul>
<li>一是价值链分析。企业级架构进行企业层面的流程模型设计，遵循价值创造的链条识别业务领域，并在业务领域通过各类活动实现业务价值，接着就是将活动下的任务按能力类别聚合成业务组件。在IT实施阶段，可沿用同样的分析方法，按价值维度将业务组件进一步细分为子域，最后将能力进行聚合，开发出高内聚的微服务。</li>
<li>二是架构视图绘制。企业级架构的IT架构通常包含了四个维度，即安全架构、技术架构、数据架构和应用架构。其中，应用架构可进一步划分为三个阶段，即分层架构、逻辑架构、物理架构，并从功能视图、接口视图、剖面视图等多个维度进行描述。实践中，上述建模方法不仅可用于搭建企业级总体架构，在描述应用系统的内部架构时也同样适用。</li>
<li>三是名词术语。基于企业级架构建设，有助于统一名词术语，改善概念混淆的状况，进而减少沟通成本。例如，在旧文档中信息系统有时被称作“系统”，也有称作“产品”或“应用”的情况。而结合企业级架构建设，可将业务领域下各类活动的系统统一称为“应用”，负责承接业务组件的系统称为“应用组件”，名称更加准确、明白。</li>
<li>四是建模方法。业界常用的建模方法一般指业务建模采用的BPMN图和实体建模采用的ER图，两者作为通用的建模语言，在开发阶段也常被使用。而企业级架构借助建模过程可将上述方法进一步推广到整个组织，进而可大幅提高描述能力和沟通效率。</li>
<li>五是职责定义。企业级架构对工作职责的定义往往是从目标(WHY)、定义(WHAT)、范围(WHERE)等三个维度进行描述，不仅言简意赅，且广泛适用于各种场景。</li>
</ul>
<p>综上，数字化转型是银行机构践行高质量发展的必由之路。自2018年提出数字化转型总体框架以来，中国银行于2019年全面启动数据治理，并在2020年启动了企业级架构建设，通过自上而下对业务架构、技术架构、工艺方法等进行全面整合，数据治理各环节工作变得更加顺畅，需求开发变得更加敏捷，数字化转型目标也愈发清晰可见!</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-23T07:12:07.000Z</published>
  </entry>
  <entry>
    <title type="text">WebFlux详解</title>
    <id>https://ujava.cn/highfreq/webflux.html</id>
    <link href="https://ujava.cn/highfreq/webflux.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>
<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>
<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>
<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>]]></summary>
    <content type="html"><![CDATA[<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>
<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>
<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>
<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>
<p>话说这么多，开始今天的学习吧。</p>
<h2> 什么是 WebFlux</h2>
<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>
<figure><figcaption>img_51.png</figcaption></figure>
<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>
<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>
<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>
<h2> 反应式库</h2>
<h3> 1. Reactive Stream</h3>
<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>
<p>我们先看下这个概念：</p>
<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>
<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>
<p>它由以下几个组件组成：</p>
<ul>
<li>发布者：发布元素到订阅者</li>
<li>订阅者：消费元素</li>
<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>
<li>处理器：发布者与订阅者之间处理数据</li>
</ul>
<h3> 2. Reactor</h3>
<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>
<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>
Reactor 就是 Spring WebFlux 的首选 反应式库。</p>
<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>
<ul>
<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>
<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>
两个都是发布者 Publisher。</li>
</ul>
<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>
<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>
<ul>
<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>
<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>
<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>
</ul>
<p>代码初体验</p>
<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>
<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>
</p>
<ol>
<li>Mono</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>
<ul>
<li>接口耗时：0</li>
<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>
</ul>
<ol start="2">
<li>Flux</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>
<h2> 操作数据库</h2>
<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>
<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>
<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>
<h3> 1. 创建项目</h3>
<p>选择这几个依赖，创建新的 project:</p>
<figure><figcaption>img_53.png</figcaption></figure>
<p>pom.xml 文件里是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是 application.properties:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建数据库表</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个简单的 test_user 表。</p>
<h3> 3. 创建相关类</h3>
<p>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserRepository，就相当于 DAO</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserController 控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>
<h3> 4. 启动测试</h3>
<p>项目启动之后，我们使用 Postman 测试一下。</p>
<h3> 请求地址路由</h3>
<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>
<p>创建 Userhandler.java</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建 RouterConfiguration</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>
<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>
<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>
<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>
<li>通过 addRoute 方法可以配置多个路由策略。<br>
测试</li>
</ul>
<p>修改：</p>
<p>查询和前面一样：</p>
<h3> 适用性</h3>
<p>官网上是这样建议的：</p>
<ul>
<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>
<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>
<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>
<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>
</ul>
<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-22T07:31:35.000Z</published>
  </entry>
  <entry>
    <title type="text">Reactor模型详解</title>
    <id>https://ujava.cn/highfreq/reactor.html</id>
    <link href="https://ujava.cn/highfreq/reactor.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 前言</h2>
<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>
<h2> 一、经典的同步阻塞模型</h2>
<figure><figcaption>img_46.png</figcaption></figure>
<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 前言</h2>
<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>
<h2> 一、经典的同步阻塞模型</h2>
<figure><figcaption>img_46.png</figcaption></figure>
<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>
<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>
<ul>
<li>read：从socket读取数据。</li>
<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>
<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>
<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>
1.下面看传统的BIO代码：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>
<p>我们的目标是：</p>
<ul>
<li>随着负载的增加可以优雅降级；</li>
<li>能够随着资源的改进，性能可以持续提升；</li>
<li>同时还要满足可用性和性能指标：</li>
<li>低延迟</li>
<li>满足高峰需求</li>
<li>可调节的服务质量</li>
</ul>
<p>阻塞 （针对的是被调用方）</p>
<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>
让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>
<p>同步 （针对的是调用方）</p>
<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>
如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>
<p>NIO就很好的解决了传统Socket问题：</p>
<ul>
<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>
<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>
</ul>
<p>2.client端代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>
<h2> 二、单reactor单线程设计</h2>
<figure><figcaption>img_47.png</figcaption></figure>
<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>
<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>
<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>
<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>
<p>代码示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了一个Reactor类。</p>
<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>
<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>
监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>
<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>
<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>
<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>
<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>
<p>下面我们可以进行测试了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>
那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>
<h2> 三、单reactor多线程设计</h2>
<figure><figcaption>img_48.png</figcaption></figure>
<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>
<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>
<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看测试结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>
<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>
<h2> 四、多reactor多线程设计</h2>
<figure><figcaption>img_49.png</figcaption></figure>
<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>
只负责处理客户端的写事件。</p>
<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>
<h2> 五、Reactor模型结构图</h2>
<figure><figcaption>img_50.png</figcaption></figure>
<ul>
<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>
<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>
<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>
<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>
<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-22T06:49:50.000Z</published>
  </entry>
  <entry>
    <title type="text">企业级架构建模之浅谈三大模型关系</title>
    <id>https://ujava.cn/highfreq/modelrelation.html</id>
    <link href="https://ujava.cn/highfreq/modelrelation.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>
<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>
产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>
<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>
<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>
从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>]]></summary>
    <content type="html"><![CDATA[<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>
<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>
产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>
<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>
<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>
从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>
<h2> 01、三大模型概述</h2>
<p><br>
1.企架三大模型之——产品模型</p>
<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。顶层的产品线可以理解为银行业务条线，可包含多个产品组，每一个产品组是对其唯一归属的产品线下具有相似业务性质基础产品的聚合。基础产品包含了聚类可售产品所有可能的特征，为对基础产品进一步划分，可创建不同的产品组件。产品组件的存在不仅能对基础产品做出细分，同时也是最底层产品特征相同或相似的产品条件的归类。产品条件表达产品对金额、利率、期限、数量等业务特征的限制规则，可用于对属性和逻辑的控制参数。</p>
<p>2.企架三大模型之——流程模型</p>
<p>流程模型用标准化的方式表达业务流程结构，可分为五层，逐层把企业业务能力分解为业务领域、价值流、活动、任务和步骤，并通过与产品模型和数据模型协同关系，精准刻画业务需求。顶层的业务领域是紧密相关业务的集合。价值流是一组互不相同、界限分明，但相互关联的生产经营活动，是构成价值创造的动态过程，如存款和贷款的界限分明但共同存在为银行创造价值。这里的活动由不同的事件触发，比如外部事件、时间或条件触发的内部事件，活动的存在是为了达成具体的业务目的，企业执行端到端的行为序列集合；活动也是从用户角度看到的执行业务流程。具体来讲，我们可用任务来表达从银行内部执行的操作。活动和任务具备明确目的性，要求产生可观测、有价值的结果。流程模型中最底层的步骤则涵盖所有最细化的业务规则和业务信息。</p>
<p>3.企架三大模型之——数据模型</p>
<p>数据模型是企业范围内统一的数据视图，通过一系列规范和相关图表反映数据需求和设计。根据规则从企业的视角对业务概念进行逻辑化、一致性的表述，用数据语言表达业务需求并展现业务规则，是联接业务和技术的桥梁，也是业务模型的主要组成部分。具体来看，顶层的业务对象是一组关联实体的集合，要求高内聚松耦合；关联的实体不允许重复或缺失。业务实体可视为以业务视角抽象表示一种客观存在于现实世界并且可以跟其他物体区分开，用一系列业务属性来描述的事物。</p>
<p>因此业务实体所具有的某一业务特性，我们称之为实体属性。若干个属性可共同刻画同一实体。向下延申，属性域值对属性取值范围进行规范，每个属性都有需要遵循的值的范围，通过域明确属性的取值规则。属性域实例只与代码类的域关联，用于进一步明确每一个取值下的规范。一个实例组会有多个取值，每个取值称为实例组的一个实例。业务组件是独立的业务模块，指具有相似资源、人和专业技能的任务组合，通过将标准化的任务按照业务对象聚类形成业务组件。</p>
<h2> 02、模型间协同关系</h2>
<p>第一部分概述中已经对每个模型划分层级，比如产品模型自上而下分别是产品线、产品组、基础产品、产品组件和产品条件。三大模型间的协同关系主要也是讨论模型层级与层级间的联动，下面将分类剖析：</p>
<p>1.产品模型对接流程模型</p>
<p><br>
基础产品与活动（多对多） 基础产品仅关联与产品有关的活动。活动可以看作是某个基础产品在提供服务有哪些环节划分，比如任何与贷款相关的基础产品需要有申请贷款额度、审核客户背景等环节共同搭建贷款服务体系。这些环节我们就可以说是这个基础产品对应的活动。在填写流程模型活动表单时，会体现活动编号、名称、详情等信息，也会专门有一列“产品信息”来体现活动对应到哪些具体的基础产品。基础产品与任务（多对多） 刚才提到活动是环节划分，而任务则是某环节衍生出来要做的事，因此任务与其上层活动所关联的基础产品范围上是一致的。延续”申请贷款额度“这个活动案例，银行方面需要完成的任务就是“受理额度申请”等一系列为了完成客户申请贷款额度而做的工作。我们也可以理解为活动是客户角度看到的环节，而任务是从我们服务提供方内部角度对活动拆解出来需要完成的事项。当活动关联了基础产品，才会建立该活动下层任务与基础产品的关系。产品条件与步骤（多对多） 步骤则是呈现任务中的事项具体如何去操作，是环节最细致的拆分。因此当活动和任务关联了基础产品，步骤作为最底层的拆分理应映射产品模型最下层的参数-产品条件。通常一个步骤需要关联至少一个产品条件，同时每个产品条件需要被至少一个步骤使用。对“受理额度申请”这个任务来说，其中一个“检查账户信息”的具体步骤，在流程模型步骤表单“与产品模型映射”列就可以映射“开户银行类型”这一产品条件，表示对某账户开户银行具体类型的选择。</p>
<p>2.数据模型对接流程模型</p>
<p><br>
任务与业务实体（多对多） 数据模型中的实体由流程模型的任务创建而来。流程模型任务表单有专门一列“业务实体”来呈现关系。比如终止某产品协议就可以关联到“产品协议”这个实体。终止某产品协议是要做的事，要把这件事说清楚便需要创建一个产品协议实体去承接，且实体名称需与数据模型的实体精确匹配。步骤与业务实体（多对多） 步骤是任务的细化，和任务一样可以去操作实体。在实际工作中，会遇到步骤牵扯到多个实体的情况，比如“调查客户背景”这个任务，其中有一个步骤是“核实客户基本信息”，涉及操作“账户”实体和“客户信息”实体，这时可根据业务含义判断是否可拆分步骤，拆至最小颗粒度便于业务和技术人员清晰理解流程。步骤与实体属性（多对多） 实体属性用于描述业务实体。流程模型中的“业务规则”列需要体现涉及业务实体下的属性。主要体现对业务规则有影响的关键属性及对应的取值描述和使用规则。还是举“核实客户基本信息”这个步骤，在创建“客户信息”实体的同时会在业务规则中体现是对公客户还是对私客户，因此属性“客户公私类型”便会建立在数据模型与其做映射，属性的取值也直接影响到该步骤最终的结果。</p>
<p>3.业务组件对接业务对象和任务</p>
<figure><figcaption>img_43.png</figcaption></figure>
<p>业务组件与任务（一对多）</p>
<p>业务组件可视为业务分类器，作为独立的业务模块归集具有相似业务目的的任务。这里的相似主要是领域和数据使用的相似。比如“调查客户背景”和“识别客户风险”两项任务都是为了更好了解和识别客户信息和行为，涉及的数据都可以有账户实体下的所有属性字段。因此我们可以将它们归集在“客户管理”业务组件。一个任务只归属一个业务组件，一个业务组件下可包含多个紧密相关的任务。</p>
<p>业务组件与业务对象（一对一/多）</p>
<figure><figcaption>img_44.png</figcaption></figure>
<p>业务组件归集具有相似业务目的的任务，业务对象归集互相关联的实体，而实体由任务来创建。因此业务组件与业务对象的关联具体体现在业务组件下任务对业务对象下实体的操作。以最基本的存款业务举例，“存款”是业务组件，具体任务有“记录存款信息”和“更换存单”，这两项任务便可操作“存款账户”这个业务对象下的“存款合约”和“存单”两个实体。</p>
<p>3.业务事件承接业务领域和活动</p>
<p><br>
业务领域对业务划分主题类型，其具体发生的行为操作称之为业务事件。围绕业务事件所产生的两条关系可总结为业务领域包含业务事件，而事件会触发一系列活动。比如贷款这个业务领域，我们能想到发生的业务事件包括申请住房贷款、购车贷款、助学贷款等贷款额度，这些事件便可触发申请个人贷款额度的活动，这个活动下面的任务和步骤则是对其需要做的事更细致的划分。一个领域涵盖多个事件，每个活动必由一个或多个业务事件触发。在实际建模工作中，三大模型分别建立再做关联映射大大提升建模难度，为了映射而映射，导致模型质量降低。因此，从建模初期保持三大建模的“实时”匹配尤其重要。无论是顶层领域划分规则还是底层参数设定，三个建模组通过完善的沟通机制共同协商而定，是企业级建模结果能够有效应用于全领域业务的基石。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-22T02:04:39.000Z</published>
  </entry>
  <entry>
    <title type="text">一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构</title>
    <id>https://ujava.cn/highfreq/business.html</id>
    <link href="https://ujava.cn/highfreq/business.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
<h2> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
<h2> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>
<p>很多时候架构的视角/分类没有明显的边界，通常是交叉的；<br>
有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</p>
<h2> 业务架构</h2>
<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>
<p><br>
看看京东业务架构（网上分享图）：<br>
</p>
<h2> 应用/技术架构</h2>
<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>
<p>不限于如下视角，主要表示应用开发中的软件架构视角...</p>
<h3> 视角：功能视角</h3>
<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>
<h3> 视角：技术视角-总体</h3>
<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。<br>
</p>
<h3> 视角：技术视角-数据架构</h3>
<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>
<h3> 视角：技术视角-基础架构</h3>
<p>PAAS，IAAS...</p>
<figure><figcaption>img_35.png</figcaption></figure>
<h3> 视角：技术视角-运维架构</h3>
<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>
<figure><figcaption>img_36.png</figcaption></figure>
<h2> 物理架构</h2>
<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>
<p>以一个银行系统为例</p>
<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。<br>
</p>
<p>物理部署架构设计说明：</p>
<ul>
<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>
<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>
<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>
<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>
<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>
<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。<br>
下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。<br>
</li>
</ul>
<p>物理部署架构设计说明：</p>
<ul>
<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>
<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>
<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>
</ul>
<h2> DDD到各种架构</h2>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<p>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</p>
<p>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</p>
<p>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</p>
<figure><figcaption>img_39.png</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-21T03:01:36.000Z</published>
  </entry>
  <entry>
    <title type="text">企业架构TOGAF内容框架</title>
    <id>https://ujava.cn/highfreq/togaf.html</id>
    <link href="https://ujava.cn/highfreq/togaf.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<figure><figcaption>img_24.png</figcaption></figure>
<h2> 一、内容框架概述</h2>
<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>
<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>]]></summary>
    <content type="html"><![CDATA[<figure><figcaption>img_24.png</figcaption></figure>
<h2> 一、内容框架概述</h2>
<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>
<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>
<p>内容框架对企业架构开发方法中各阶段的输入和输出信息进行了分类总结，并通过内容元模型（Content MetaModel）对构成企业架构内容的各个元素（即企业架构中的各个构建块的类型）以及他们之间的关系进行了定义。内容框架中针对其内容的描述采用了一种与架构开发方法的各阶段相映射的方式进行组织，即对架构开发方法的各个阶段所产出的企业架构内容具体是什么进行描述。</p>
<p>虽然针对企业架构内容的定义非常重要，但是同样重要的还有如何对企业架构的内容进行利用。企业架构的核心目标是为具有不同视角的干系人根据其关注点提供准确的视图，从而使得不同的干系人虽然采用了不同的观察角度和描述方式，但的确是在为共同的目标而进行着无障碍沟通和协作。为了达到这一目标，内容框架对于各种视角（ViewPoint）从表现形式和内容方面都进行了归纳总结，并对一些视图的开发也提供了建议和指南。TOGAF是一个通用性的标准，它的内容不可能涵盖企业中所有的视角，因而在具体实践中，各个企业完全可以根据自身需要对这些视角进行引用、修改和组合，从而总结出适合的视角，并借此开发出相应的视图，从而满足企业中具体干系人的需要。</p>
<p>下图展示了内容框架中各方面内容与企业中客观存在的各种资源之间关系，以及企业架构的内容是如何在内容框架的组织下为各个干系人提供帮助的：</p>
<figure><figcaption>img_25.png</figcaption></figure>
<h2> 二、企业架构工作产品分类</h2>
<p>在内容框架中，企业架构开发方法过程中所涉及到的各种工作产品被归纳为如下几种：</p>
<p>1、架构交付物（Architecture Deliverables）：架构交付物是由合同指定并被相关干系人轮流进行正式的审查和签字认可的工作产品。这些交付物代表着架构项目的输出，以及那些在一个项目完结时以文档形式进行交付的，或者作为参考模型、标准或在某一时点的架构情景快照（snapshot of the Architecture Landscape）被过渡到架构资源库中的工作产品。</p>
<p>2、架构制品（Architectural Artifacts）：与架构交付物相比，架构制品是一个从某个特定视角进行架构描述并具备更细粒度的工作产品。例如，网络图、服务器说明、用例说明、架构需求列表以及业务交互矩阵等。就表现形式来讲，架构制品的内容可以通过目录、矩阵和图形这三种方式来表述。通常情况下，一个架构交付物可以包含多个架构制品，而架构制品也可能会出现在多个架构交付物之中，并且架构制品也将会形成架构资源库的内容。</p>
<p>3、构建块（Building Blocks）：构建块代表着业务、IT或者架构能力的一个组件，并且可以与其他构建块组合在一起来对各种架构和解决方案进行交付。根据所处的架构开发阶段的不同，构建块能够在多个详细度层次上进行定义。例如，在架构开发的早期阶段，一个构建块可能仅仅包含一个名字或一个概要描述，而随着架构开发过程的演进，此构建块可能会被进一步分解为若干具有详尽描述的支持性构建块。从内容和所面对的问题上看，构建块可以被进一步分为如下两种：</p>
<p>架构构建块（ABBs：Architecture Building Blocks）：此种类型的构建块一般用于描述各种需要的能力，并对其后的解决方案构建块的轮廓进行了勾勒。例如，企业中的一个客户服务定义了实现这项能力的各种需求，而对于它的真正落实就需要若干解决方案构建块在各方面（流程、数据以及应用软件等）将这些需求映射到具体的实现技术之上。<br>
解决方案构建块（SBBs：Solution Building Blocks）：此种类型的构建块代表了用于实现各种需求（由架构构建块定义）的具体组件。<br>
<br>
以上三种工作产物虽然在内容和产生背景上有着很大的不同，但是他们之间却有着非常紧密的联系。构建块可以说是企业架构资源库的核心内容，并且也是企业架构过程的终极目标产物，因而把其称为企业的模型也并不为过，而架构制品则可以看成此模型在某个角度的各种视图，属于架构描述的范畴。架构交付物比较特殊，它与架构开发方法各阶段紧密相连，并作为各个阶段的输入与输出载体而存在。</p>
<h2> 三、架构交付物（Architecture Deliverables）</h2>
<p>架构交付物是在整个架构开发方法循环过程中所产生或被使用的契约性、正规化的企业架构内容。它与企业架构开发方法有着紧密的联系。本节将针对这些架构交付物以及它们与架构开发方法各阶段之间的关系进行阐述。需要注意的是，本节的内容只提供了一个关于架构交付物的内容概括。由于企业中可能存在着符合其自身需要的项目和过程管理方法，所以企业也可以根据自己的实际情况对这些交付物进行改造和定制。</p>
<p>架构交付物与企业架构开发方法各阶段之间的对应关系（注意，下表采用了简称来标示各企业架构开发方法阶段）：<br>
</p>
<figure><figcaption>img_28.png</figcaption></figure>
<h3> 1、架构构建块</h3>
<p>构建块是企业架构过程的最终目标之一，它是企业对于各个层面上（业务、应用、数据以及技术等）的可重用部件的抽象。架构构建块的内容侧重于对构建块的需求进行描述，就像软件开发中的接口一样，架构构建块并不涉及具体的实现方式，而只是描述了构建块所需要达成的功能。用于描述架构构建块的文档和模型存储在企业架构资源库之中，企业架构开发过程正是对企业中各种客观存在的或计划中的可重用模块进行抽象建模，并最终将这些内容存储到企业架构资源库之中（或对其内容进行更新）。</p>
<h3> 2、架构合同</h3>
<p>目标</p>
<p>架构合同是企业架构开发团队与赞助团队之间关于架构的交付、质量和适用性的联合协定。为了成功实现这一协定则需要企业进行有效的架构治理。通过实现一个用于合同管理的治理方法，企业将会确保：</p>
<ul>
<li>对组织中所有架构相关活动的完整性检查、变更、决策和审计进行持续监督。</li>
<li>现存或正在开发的架构得以贯彻组织的原则、标准和需求。</li>
<li>明确架构在开发和实现的各个方面中的风险，这些方面涵盖了关于可接受的标准、策略、技术和产品的内部开发，以及架构的运营层面，从而使得组织可以在一个具有弹性的环境中继续其业务。</li>
<li>一系列流程和实践，用于确定关于所有架构制品的开发和使用的责任和规则。</li>
<li>对于为合同负责的治理组织，他们的权限级别及其治理之下的架构范围有一个正式的理解。</li>
</ul>
<p>内容</p>
<p>架构设计和开发合同的内容一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>架构范围</li>
<li>架构以及战略原则和需求</li>
<li>一致性需求</li>
<li>架构开发和管理流程，以及相关角色</li>
<li>目标架构评测标准</li>
<li>定义的交付阶段</li>
<li>按照优先级排序的联合工作计划</li>
<li>时间窗口（Time windows）</li>
<li>架构交付和业务指标</li>
</ul>
<p>业务用户的架构合同一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>范围</li>
<li>战略需求</li>
<li>一致性需求</li>
<li>架构采用者</li>
<li>时间窗口</li>
<li>架构业务指标</li>
<li>服务架构（包括服务水平协议（SLA：Service Level Agreement））</li>
</ul>
<h3> 3、架构定义文档</h3>
<p>目标</p>
<p>架构定义文档是一个包含在整个项目中所产生的各种制品的可交付容器。它跨越所有的架构领域（业务、数据、应用和技术），并可用于检阅架构的所有相关状态（当前态、中间态和目标态）。架构定义文档对架构需求文档在如下方面进行互补：</p>
<ul>
<li>架构定义文档提供了一个解决方案的定性视图，用于沟通架构师的意图。</li>
<li>架构需求说明提供了一个解决方案的定量视图，用于声明在架构实现过程中必须遵守的可测量的标准。<br>
内容</li>
</ul>
<p>架构定义文档内容一般包括：</p>
<ul>
<li>范围</li>
<li>目标、阶段目标和约束</li>
<li>架构原则</li>
<li>基线架构</li>
<li>架构模型（针对每个被建模的状态）：业务架构模型、数据架构模型、应用架构模型、技术架构模型</li>
<li>架构方法的基本原理和理由</li>
<li>架构资源库内容映射：架构情景映射、参考模型映射、标准映射、重用评估</li>
<li>差距分析结果</li>
<li>影响评估</li>
</ul>
<h3> 4、架构原则</h3>
<p>目标</p>
<p>通用的规则和指南，一般是不会进行更改的。这些原则知会并支持一个组织用以实现其任务的方法。它是用于定义和指导组织从价值到行为和结果的一系列结构化思路中的一员。</p>
<p>内容</p>
<p>架构原则一般包括如下几个层面的内容（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>业务原则</li>
<li>数据原则</li>
<li>应用原则</li>
<li>技术原则</li>
</ul>
<h3> 5、架构资源库</h3>
<p>目标</p>
<p>架构资源库在企业中充当了对于所有架构相关项目进行存储的区域。它允许各个项目管理它们的交付物，定位可重用资产，并对干系人以及其他有兴趣者进行信息发布。</p>
<p>内容</p>
<p>架构资源库的内容包括如下几个方面（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>架构框架</li>
<li>标准信息库</li>
<li>架构情景</li>
<li>参考架构</li>
<li>治理日志</li>
</ul>
<h3> 6、架构需求说明</h3>
<p>目标</p>
<p>架构需求说明提供了一组量化的描述，用于概括一个项目的实现与架构相符合所必须做的事情。架构需求说明一般会形成一个实施契约，或是更详细的架构定义契约中的主要组件。</p>
<p>内容</p>
<p>架构需求说明的内容通常包括：</p>
<ul>
<li>成功评测标准</li>
<li>架构需求描述</li>
<li>业务服务契约</li>
<li>应用服务契约</li>
<li>实施导则</li>
<li>实施说明</li>
<li>实施标准</li>
<li>互操作需求</li>
<li>约束</li>
<li>假设</li>
</ul>
<h3> 7、架构路线图</h3>
<p>目标</p>
<p>架构路线图列举出各个变化增量，并把他们放到时间轴之上，从而展示了从当前架构到目标架构的演进过程。架构路线图是迁移架构的重要组件，并在架构开发方法的B、C、D、E、F阶段中以增量的方式开发出来。</p>
<p>内容</p>
<p>架构路线图的内容包括：</p>
<ul>
<li>项目列表：每个涉及到的项目的名称、描述和目标，用于实现所建议的架构的项目列表，并按照优先级进行了排序。</li>
<li>基于时间的迁移规划：迁移的效益、针对各种迁移选择的成本估算。</li>
<li>实施建议：用于衡量项目有效性的评估准则、风险和问题、解决方案构建块的描述和模型。</li>
</ul>
<h3> 8、架构愿景</h3>
<p>目标</p>
<p>架构愿景是在项目生命周期早期创建的，它提供了一个高阶的对于最终架构产品的期望视图。目的是为了在一开始就对架构应该达到的期望结果形成一致意见，从而使得在之后的过程中架构师能够关注于切实可行的关键领域。通过提供一份关于整体架构定义的内容摘要，架构愿景对于干系人之间按沟通也提供了一定的支持。</p>
<p>内容</p>
<p>架构愿景的内容通常包括：</p>
<ul>
<li>问题描述：干系人以及他们的关注点，需要解决的问题/场景列表。</li>
<li>详细目标描述</li>
<li>环境和流程模型：流程描述、涉及到环境的流程步骤、涉及到人员的流程步骤、信息流</li>
<li>执行者以及他们担当的角色和责任：人员方面的执行者和角色、计算机方面的执行者和角色、需求</li>
<li>所产生的架构模型：约束、IT原则、支持流程的架构、映射到架构之上的需求。</li>
</ul>
<h3> 9、业务原则、目标和驱动力</h3>
<p>目标</p>
<p>业务原则、目标和驱动力通过描述企业的需要和工作方式为架构工作提供了背景。此外，许多处于架构原则考虑之外的因素对架构的开发也有着重要的影响。</p>
<p>内容</p>
<p>于不同的组织有着不同的特性，因而关于架构业务背景的内容将会各不相同，企业应该根据各自的情况定义这部分内容。</p>
<h3> 10、能力评估</h3>
<p>目标</p>
<p>在做一份详细的架构定义之前，对企业的当前和目标的能力水平有一个清晰的认识是非常有价值的。对于能力评估，我们可以在如下几个层面进行考虑：</p>
<ul>
<li>企业整体的能力水平是什么？企业希望在何处增强或优化其能力？用于支持企业期望发展的架构关注领域是什么？</li>
<li>企业中的IT功能的能力或成熟度水平是什么？就设计管理、操作管理、技术和组织架构而言，进行架构项目最可能的影响都有哪些？为了与企业文化和IT部门的能力相适应，架构项目所需的正规化和详细度的最适宜水平是什么？</li>
<li>企业架构功能的能力和成熟度是什么？当前存在的架构资产有哪些？这些资产是否被一直维护，并且是否还准确？什么样的标准和参考模型需要被考虑进去？是否在这些在架构项目中有可能创建可重用资产？</li>
<li>能力欠缺存在于何处？为了达成目标能力而需要进行转型的业务范围是什么？在对基本能力欠缺考虑之上的转换风险、文化壁垒以及其他方面考虑都有哪些？<br>
内容</li>
</ul>
<p>能力评估的内容通常包括：</p>
<ul>
<li>业务能力评估：业务能力、针对每项能力性能水平的基线状态评估、针对每项能力性能水平的未来状态期望、针对每项能力如何实现的基线状态评估、针对每项能力将会被如何实现的期望</li>
<li>IT能力评估：变更流程的基线和目标成熟度水平、运营流程的基线和目标成熟度水平、基线能力以及容量评估、针对由于架构项目的执行而对IT组织所可能产生的影响的评估</li>
<li>架构成熟度评估：架构治理流程/组织/角色和责任、架构技能评估、架构资源库中的情景定义的深度/广度/质量、架构资源库中的标准定义的深度/广度/质量、架构资源库中的参考模型的深度/广度/质量、针对可重用潜力的评估。</li>
<li>业务转型准备度评估：准备度因素、对于每个准备度因素的愿景、针对当前和目标准备度的评级、与准备度相关的风险。</li>
</ul>
<h3> 11、变更请求</h3>
<p>目标</p>
<p>在架构的实现过程中，在一切清晰之前，原来的架构定义和需求很可能不适合或不足以达成解决方案的实现。在这种情况下，对实施项目进行调整使之与建议的架构方法发生偏离，或请求架构范围扩展是必需的行为。另外，很多外部因素（例如，市场因素、业务策略变化以及新技术机会）也会为扩展及优化架构提供新的机会。在以上这些环境下，一个变更请求可以被提出，用以开始一个新的架构工作周期。</p>
<p>内容</p>
<p>变更请求的内容通常包括：</p>
<ul>
<li>对于所建议的变更的描述</li>
<li>对于所建议的变更的理由</li>
<li>对于所建议的变更的影响评估：针对相关特定需求的引用、迄今需求所涉及的干系人的优先级、重新审视这些需求的各阶段描述、对需求优先级进行排序的阶段、调查和修正需求的优先级阶段的结果、对于需求管理的建议。</li>
<li>资源库引用编号</li>
</ul>
<h3> 12、 沟通计划</h3>
<p>目标</p>
<p>企业架构包含大量的复杂且相互关联的信息。有效地与适当的人在适当的时间针对目标信息进行交流是成功建设企业架构的重要因素。开发沟通计划可以使这些交流通过一种可计划、可管理的方式进行。</p>
<p>内容</p>
<p>沟通计划的内容通常包括：</p>
<ul>
<li>针对干系人的识别，并根据沟通需求进行分组</li>
<li>明确沟通需求、与架构愿景相关的关键消息、沟通风险和关键成功因素（CSFs：Critical Success Factors）</li>
<li>明确用来与干系人进行沟通的机制，并允许其对架构信息的访问</li>
<li>制定沟通时间表。该时间表展示了沟通将在何时何地进行，以及在何种干系人组之间进行</li>
</ul>
<h3> 13、 合规评估</h3>
<p>目标</p>
<p>一旦一个架构被定义了出来，就必须在整个实施过程中对其进行治理，从而保证原先的架构愿景可以被适当的实现，并且实现中的经验教训也可以反馈到架构过程中。针对实施项目进行周期性的合规检查为重新审核项目过程，并保证设计和实施符合企业策略和架构目标，提供了一种有益的机制。</p>
<p>内容</p>
<p>合规评估的内容通常包括：</p>
<ul>
<li>项目进程和状态的概览</li>
<li>项目架构/设计概览</li>
<li>完整的架构清单：硬件和操作系统清单、软件服务和中间件清单、应用清单、信息管理清单、安全清单、系统管理清单、系统工程清单、方法和工具清单。</li>
</ul>
<h3> 14、实施和迁移计划</h3>
<p>目标</p>
<p>通过过渡框架的描述为解决方案的实施提供一个日程表，包括实施的时间、成本、资源、收益和里程碑。</p>
<p>内容</p>
<p>实施和迁移计划的内容通常包括：</p>
<ul>
<li>实施和迁移战略：战略实施方向、实施排序方法</li>
<li>与其他管理框架的交互：架构与业务规划相协调的方法、整合架构的方法、架构与项目管理相协调的方法、架构与运营管理相协调的方法。</li>
<li>项目章程：项目所能交付的能力、所包含的工作包、业务价值、风险、问题、假设和依赖关系</li>
<li>实施规划：由实施分解出来的各个阶段和工作流、为各阶段和工作流进行工作包分配、里程碑和时间要求、工作分解结构、资源需求和成本</li>
</ul>
<h3> 15、实施治理模型</h3>
<p>目标</p>
<p>一旦一个架构被定义，在整个实施过程中就需要对用于实现架构的过渡框架进行治理。在已经建立了架构功能的组织中可能已经存在了一个治理框架，但是对于特定的过程、组织、角色、责任和度量来说，需要根据项目进行具体的定义。</p>
<p>内容</p>
<p>实施治理模型的内容通常包括：</p>
<ul>
<li>治理流程</li>
<li>治理组织结构</li>
<li>治理角色和相应职责</li>
<li>治理检查点和成功与失败标准</li>
</ul>
<h3> 16、 企业组织架构模型</h3>
<p>目标</p>
<p>为了一个架构框架能够被成功地使用，它必须在企业中获得正确的组织、角色和责任的支持。特别重要的是，对不同企业架构参与者之间边界的定义，以及针对跨边界关系的治理。</p>
<p>内容</p>
<p>企业组织架构模型的内容通常包括：</p>
<ul>
<li>受影响的组织的范围</li>
<li>成熟度评估、差距和决议方法</li>
<li>架构团队的角色和责任</li>
<li>针对架构工作的约束</li>
<li>资金预算需求</li>
<li>治理和支持策略</li>
</ul>
<h3> 17、架构工作要求书</h3>
<p>目标</p>
<p>由赞助组织交付给架构组织的用于启动架构开发工作的文档。架构工作要求书可以产生于预备阶段，可以是经过批准的架构变化请求的结果，或者是源于迁移计划对架构工作的参考。</p>
<p>内容</p>
<p>架构工作要求书的内容通常包括：</p>
<ul>
<li>组织赞助者</li>
<li>组织的任务说明</li>
<li>业务目标（以及变更）</li>
<li>业务的战略规划</li>
<li>时间限制</li>
<li>业务环境的变化</li>
<li>组织方面的约束</li>
<li>预算信息以及财务约束</li>
<li>外部约束以及业务约束</li>
<li>当前业务系统描述</li>
<li>当前架构/IT系统描述</li>
<li>开发组织的描述</li>
<li>开发组织可用资源的描述</li>
</ul>
<h3> 18、需求影响评估</h3>
<p>目标</p>
<p>在整个架构开发方法过程中，总会有新的与架构相关的信息被收集起来。当这些信息被收集后，对架构在当前某方面有影响的新因素也经常会显现出来。需求影响评估就是用来对当前架构需求进行评估，阐明需要进行的变更以及这些变更所带来的影响。</p>
<p>内容</p>
<p>需求影响评估的内容通常包括：</p>
<ul>
<li>对于具体需求的引用</li>
<li>迄今需求的相关干系人优先级</li>
<li>进行重审的各个阶段</li>
<li>进行需求优先级排序的阶段</li>
<li>调查和修正需求的优先级阶段的结果</li>
<li>关于需求管理的建议</li>
<li>资源库引用编号</li>
</ul>
<h3> 19、解决方案构建块</h3>
<p>与架构构建块相类似，解决方案构建块也是存储于架构资源库中的构建块的一种，不过它的内容更倾向于在实现层面对企业中的可重用构建块进行描述。可以说，架构构建块定义了构建块的需求，而解决方案构建块则是此需求在具体实现技术层面的映射。关于解决方案构建块的具体内容请参阅后面的内容。</p>
<h3> 20、架构工作说明书</h3>
<p>目标</p>
<p>架构工作说明书定义了用于完成一个架构项目的方法和范围，它也是用于评测架构项目是否被成功执行的典型文档，并且它也形成了架构服务提供者和使用者之间的合同协议的基础。</p>
<p>内容</p>
<p>架构工作说明书的内容通常包括：</p>
<ul>
<li>架构工作标题说明</li>
<li>项目申请和背景</li>
<li>项目描述和范围</li>
<li>架构愿景的概括</li>
<li>管理办法</li>
<li>范围变更程序</li>
<li>角色、责任和交付物</li>
<li>验收标准和程序</li>
<li>项目计划和日程安排</li>
<li>针对架构连续体的支持</li>
<li>签字批准</li>
</ul>
<h3> 21、定制的架构框架</h3>
<p>目标</p>
<p>TOGAF提供了一个行业的标准架构框架，但是要在一个架构项目中对其进行有效地使用，则必须在两个层面上进行定制。首先，需要对TOGAF模型进行定制，使得它可以融入到企业之中。此种定制包括将TOGAF模型整合入企业的项目和过程管理框架、术语定制、展示方式开发、架构工具的选择、配置和部署等方面之中。任何被采用的框架的形式和详细程度应该与企业的其他背景元素相适应，例如文化、干系人、企业架构的商业模型以及当前架构能力的水平。一旦针对框架完成了上面的定制，企业就需要为具体的架构项目做进一步的框架定制，而在这一层面的定制中，企业需要选择适当的架构交付物和架构制品来满足项目和干系人的需要。</p>
<p>内容</p>
<p>定制的架构框架的内容通常包括：</p>
<ul>
<li>定制架构的方法</li>
<li>定制架构的内容（架构交付物和架构制品）</li>
<li>配置和部署工具</li>
<li>治理模型和其他框架的接口：企业架构管理框架、能力管理框架、项目组合管理框架、项目管理框架、运营管理框架。</li>
</ul>
<h3> 22、过渡架构</h3>
<p>目标</p>
<p>过渡架构展示了企业的增量状态，并反映从当前架构到目标架构的过渡过程。过渡架构被用来将单独的工作包和项目组合为可管理的项目组合和程序，用于描述每个阶段的业务价值。</p>
<p>内容</p>
<p>过渡架构的内容通常包括：</p>
<ul>
<li>机会组合描述：综合的差距、解决方案和依赖关系评估、机会描述、收益评估、能力和能力增量、互操作性和共存的需求</li>
<li>工作包组合描述：工作包描述（名称、描述、目标和交付物）、功能性需求、依赖关系、与机会之间的关系、与架构定义文档和架构需求说明之间的关系。</li>
<li>里程碑和里程碑过渡架构：过渡状态描述、每个过渡状态的业务架构、每个过渡状态的数据架构、每个过渡状态的应用架构、每个过渡状态的技术架构。</li>
<li>实施因素评估和推导矩阵（ImplementationFactor Assessment and Deduction Matrix：用于记录将会影响架构实施和迁移计划的各个因素。此矩阵包括在制定迁移计划时需要考虑的各个因素、它们的描述，以及由此而推断出的在制定计划时需要考虑的行动或约束）：风险、问题、假设、依赖、行动。</li>
<li>综合差距、解决方案和依赖矩阵（Consolidated Gaps，Solutions，and Dependencies matrix：此矩阵使架构师可以对在各领域架构差距分析结果中明确的差距进行分组，并评估潜在的解决方案，以及这些方案与差距之间的依赖关系）：架构领域、差距、潜在解决方案、依赖关系。</li>
</ul>
<h2> 四、架构制品（Architectural Artifacts）</h2>
<p>架构制品是针对某个系统或解决方案的模型描述，与架构交付物和构建块相比，架构制品既不是架构开发方法过程各阶段的合约性产物，亦不是企业中客观存在的各种可重用解决方案，而是针对包括这些构建块在内的企业客观现实的描述，并以解答不同干系人的关注点为其最终目标。可以说，架构交付物面向于企业架构的产生，架构构建块倾向于企业架构的结果，而架构制品则注重于针对企业架构的应用（虽然架构交付物可以包含若干架构制品，但是架构制品在本质上还是被用来为不同的干系人按照其视角提供相应的企业客观视图，况且架构交付物对架构制品的包含本身也是架构制品的应用之一，其目的也是为了在架构开发过程中所涉及的不同干系人之间达成共识）。</p>
<p>企业架构并不是一个静态的过程，不能将建设一个包含企业架构内容的信息资源库当作唯一目标。对于任何企业来说，企业架构的意义都应该在于将其自身的战略决策、业务和信息技术资源联系为一个有机整体，并且不同的干系人从企业架构中获得其所需的关于企业的自上而下（自业务至用于支持各项业务实现的解决方案）的视图，而这方面的内容属于针对企业架构内容的使用范畴。在这一范畴之中，所有的企业架构框架理论，哪怕是几乎不涉及企业架构内容的框架，都会关注于两个概念：视角与视图。其中视角是针对不同干系人企业架构内容的需求描述，而视图是基于某一视角的具体架构内容描述，因而也可以说视角是视图的元类型定义。在这两个概念中，视图比较好理解，亦即根据视角的定义而对企业客观现状的某一侧面描述，相比之下，用于对视图进行定义的视角概念则更为关键。视角是不同干系人对于企业架构内容需求的体现，亦即其采用何种角度对企业客观存在或计划存在的自顶层战略、业务至底层解决方案而进行观察。这些角度的定义基本上应该包括如下几个方面：</p>
<p>1、目标需求：不同的干系人担当着不同的角色及责任，其看问题的角度与担当的任务也因此有着非常紧密的联系。一般来讲，目标需求大体可以分为：</p>
<ul>
<li>设计层面：包括了用于指导和支持与设计决策相关的各种制品。例如架构师、开发人员以及业务流程建模人员等干系人经常会用到的UML图、流程建模图（例如BPMN图）、以及用于描述数据的关系-实体图等制品都属于这一范畴。</li>
<li>决策层面：包括了用于支持高层决策的制品（例如，交叉引用表、情景图、以及各种报告等制品），适用于企业中处于管理高层的各种决策人，例如CEO、CIO等。</li>
<li>告知层面：包括了用于为相关干系人进行解释、说服以及获得其承诺方面的制品（流程概述、图表、宣讲动画等）。这些干系人可能会是一般职工、客户，或者其他在企业中从业务到解决方案这条线上虽不占关键位置却需要对企业架构进行了解的干系人。<br>
2、抽象级别需求：上面描述了不同干系人由于其担负任务的不同，因而对于企业的观察也具有着不同的角度，从而对不同的制品产生兴趣。然而，即使不同的干系人针对企业的相同侧面有着共同的兴趣，但是他们对于描述的抽象级别或详细程度也可能有着不同的要求。例如，对于相同的业务流程来说，可能对于高层管理人员来说需要关注的仅是此流程的输入、输出，而对于其实现细节并不一定关心，而对于流程建模人员来说此业务流程恐怕就需要被细化为粒度更加细小的业务功能组合，而对于软件开发人员来讲，可能还要为某个具体业务行为而考虑其相关的数据结构和实现方案。</li>
</ul>
<p>3、展示需求：上述两点可以说是依据干系人所持的角度在内容方面所进行的分类，而除此之外，由于不同的干系人由于各自的偏好不同，他们可能会对视图的展示也有着非常不同的要求。虽然在TOGAF中，架构制品的描述方式被定义为目录、矩阵和图形三种方式，但就其具体展示方式来说，不同的干系人还可能具有不同的要求和偏好。例如，对于组织结构的展示，有的干系人可能偏好于采用简单的树形结构的展示，而其他干系人则可能更加倾向于图形化的结构图。这种展示需求在图形展示方面尤其突出，某些干系人（特别是来自于内部的干系人，例如领域专家等）可能习惯于采用某种标准的标注体系来对架构内容进行展示，而对于其他干系人来讲（例如客户或非专业的干系人）采用如此方式可能并不能取得很好的效果，而采用更加贴近现实的图标来代替标准图标（通常是若干简单的形状、连线和颜色的组合）则更加友好。虽然展示需求也是视角定义所需靠虑的元素之一，但是在大多数情况下这一层面的定义往往可以采用松耦合的方式来进行描述，即将视角的定义分为内容和展示两个层面，并在两者之间建立关联（通常一个内容定义可以包含若干展示定义）。</p>
<p>上述关于视角分类的定义很容易让人产生非此即彼的感觉，即视角是为干系人服务的，因而应该仅从属于某种干系人。这样的思想除了源于思想的惯性，最主要的还是由于忽视了企业架构的核心精神—在组织中创建无障碍的沟通信息流。作为企业架构的核心概念，如果只把视角看作为企业架构描述用的约束和定义，而忽视了沟通这一本质则是违反企业架构最终目标的。每种干系人对于视角的采用都要着自己的要求，但反过来讲，视角却不一定从属于某种干系人，不同的干系人之间可以共享同样的视角，也只有这样才能保证不同干系人之间的顺畅沟通。正像TOGAF中所举的例子一样，飞机的飞行员和航空管制员对于飞行的视角各具特点，并采用不同的语言和元素来对“飞行”进行描述，但是他们同时也采用一种通用的语言（高度、速度等）来进行沟通。在这个例子中，飞行员和航空管制员在自己的领域内分别采用了自己的视角来对“飞行”进行理解和描述，不过作为沟通用的通用语言却形成了第三个，并且是他们所共享的视角。</p>
<p>企业架构开发过程的结果可以说是在架构资源库中按照架构元模型定义而填充的各种实体元素，这也方便了在对企业架构的使用中按照各个干系人的视角为其提供相应的视图。针对架构的使用需要自动化工具的支持，该工具需要支持视角的定义和管理，并能够从企业架构资源库中根据选定的视角生成相应的视图。</p>
<figure><figcaption>img_29.png</figcaption></figure>
<p>不同的企业架构开发框架对于架构制品、视角和视图的定义，有着不同的描述。例如在Zachman框架中，每一个单元格所代表的是某一种干系人视角针对系统某个方面的描述，而在TOGAF中，The Open Group则采用了一种独特的方式对视角进行了组织和定义。与其他框架理论不同，TOGAF定义了一系列原子架构制品，并倡议在企业架构过程中根据不同干系人的需要对这些原子架构制品进行组合，从而生成对于视角的定义。这些原子架构制品业可被看为原子级的视角定义，实际上在TOGAF中也正是用视角（ViewPoint）这个词来称呼各个架构开发阶段相关的原子架构制品。TOGAF并不强制其用户遵循这些原子架构制品，用户可以根据自己的需要增加新的原子架构制品，或对已经定义的原子架构制品进行修订。根据架构制品的描述形式，TOGAF将这些原子架构制品分为以下三类：</p>
<ul>
<li>目录（Catalogs）：此类型的原子架构制品（视角）以列表的形式对各种构建块进行列举。</li>
<li>矩阵（Matrices）：此类型的原子架构制品（视角）用于展示特定构建块之间的关系。</li>
<li>图形（Diagrams）：此类型的原子架构制品（视角）采用了一种具有丰富表现力的方式对构建块以及他们之间的关系进行了展示。此种方式特别适合用于在干系人之间进行沟通的场合。</li>
</ul>
<h3> 1、架构开发过程与架构制品</h3>
<p>表面上架构制品并不像架构交付物那样与架构开发方法的各个阶段有着很强的契约性关联，但是做为架构交付物的重要组成部分，架构制品与架构开发方法之间也有着非常紧密的联系。在TOGAF中，针对架构制品的组织和描述也是以架构开发方法各阶段为基础的，它详尽展示了在每个架构开发方法阶段中所产生的各个原子架构制品，以及这些架构制品与架构内容元模型各扩展之间的关系。</p>
<figure><figcaption>img_30.png</figcaption></figure>
<h3> 2、架构制品定义</h3>
<p>原则目录（Principles catalog）</p>
<p>原则目录对各项业务原则及架构原则进行列举，用以表明一个好的解决方案或架构看起来应该是什么样子。原则用于对各架构决策点的输出进行评估和认可。原则也可在针对变更举措的架构治理中充当辅助工具。</p>
<p>干系人映射矩阵（Stakeholder Map Matrix）</p>
<p>干系人映射矩阵用于明确参与架构活动的各个干系人、他们的影响、他们的主要问题，以及架构框架所必须解答的关注点。通过对于干系人的识别，并对他们的需求进行理解，架构师可以将注意力集中在能够满足干系人需求的各个领域之中。</p>
<p>价值链图（Value Chain Diagram）</p>
<p>价值链表提供了一张面向高层的企业视图，用于表示企业如何与外界环境交互。与在业务架构阶段中开发出来的更加正式的功能解构图相比较，价值链表更着重于表象上的影响。价值链表的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使得所有参与者能够对架构所涉及到的高层次功能性和组织性环境进行理解。</p>
<p>解决方案概念图（Solution Concept Diagram）</p>
<p>解决方案概念图提供了一个解决方案的高层次方向，用于达成架构所涉及的各个目标。与后续架构开发方法阶段开发出来的、更正式且更详细的架构图相比较，解决方案概念图更像是在一开始阶段关于期望解决方案的一张草图。这张图体现了关键的目标、需求和约束，并对将采用正式架构模型来进行更详细描述的各个工作区域进行了标明。解决方案概念图的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使所有的参与者能够理解架构所需要的究竟是什么，以及一个特定的解决方案被期望以何种方式来满足企业的需求。</p>
<p>组织/执行者目录（Organization/Actor Catalog）</p>
<p>该目录的目标是得到一份明确的包括用户和IT系统所有者在内的所有与IT有互动的参与者列表。该列表可以在开发需求时作为完备性检测的参考。例如，针对于一个对客户进行服务支持的应用的需求，我们可以通过如下几个方面对其进行完备性检测：</p>
<ul>
<li>
<p>需要对何种类型的客户进行支持。</p>
</li>
<li>
<p>是否某种类型的用户存在特定需求或约束。</p>
</li>
<li>
<p>此目录所涉及到的内容元模型实体包括：</p>
</li>
<li>
<p>组织单位</p>
</li>
<li>
<p>执行者</p>
</li>
<li>
<p>位置（如果一个单独的位置目录并不存在，则关于位置的信息就需要在这个目录中加以维护）</p>
</li>
</ul>
<p>驱动力/目标/阶段目标目录（Driver/Goal/Objective Catalog）</p>
<p>该目录的目标是描述组织如何通过目标、工作目标和评测（可选内容）来满足其驱动力的需要，并为此提供一份跨越组织的参考。通过针对驱动力、目标和阶段目标的层层分解，各个变更举措可以采用一种跨越组织边界的方式进行协同，并在随后的活动中使得各个干系人得以被明确，此外，相关的变更举措也能够被整合或协调起来。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单元</li>
<li>驱动力</li>
<li>目标</li>
<li>阶段目标</li>
<li>评测（可选内容）</li>
</ul>
<p>角色目录（Role Catalog）</p>
<p>角色目录的目标是为企业中所有的授权级别或区域提供一份列表。一般情况下，应用的安全或行为应该按照其对授权概念的理解而分别进行定义，但在与用户的计算机相绑定时却造成了复杂且不被期望的后果。如果角色在整个组织和所有应用中都得到了定义、理解和共识，那么更加安全并能够提供更加无缝的用户体验的应用将会出现，因为管理员无需通过迂回的解决方法来使用户执行他们的工作。除了对企业的安全定义进行支持，角色目录还可以是明确组织变更管理影响、定义工作职能，以及执行最终用户培训这些方面的关键输入。</p>
<p>由于每个角色都暗含着关于一系列业务功能的访问，如果这些功能被影响到，那么变更管理将必不可少，组织的职责也需要被重新定义，同时新的培训可能也是需要的。</p>
<p>业务服务/功能目录（Business Service/Function Catalog）</p>
<p>业务服务功能目录的目标是提供一份功能性的解构，使得各种功能可以被过滤、汇报和查询，并能够作为功能结构图的一个有力补充。服务功能目录可以被用来对组织中的各项能力进行明确，并对组织中施加到各种功能上的治理水平加以理解。通过功能解构，用于支持业务变化所需要的各种新能力能够被识别出来，或者对变更措施、应用以及技术组件的范围进行确定。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单位</li>
<li>业务功能</li>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
</ul>
<p>位置目录（Location Catalog）</p>
<p>位置目录为企业的业务运营或房屋建筑相关的资产（例如数据中心或终端用户计算设备）所处位置提供了一份列表。针对此位置列表的维护，各个变更举措的位置范围得以被快速地定义出来，并且针对当前情况和建议的目标解决方案进行评估时，完备性测试也得以被执行。例如，一个用于更新台式计算机操作系统的项目需要识别出这些系统所部署的位置。与此相似，当实施一个新的系统时，一张关于位置的图形描述对于开发适当的部署策略是非常关键的，该部署策略被用于对用户和应用的位置进行了解，并且各个与位置相关的问题（例如，国际化、本地化、针对可用性的时区影响、延时距离影响、网络带宽影响和访问）也得以被明确。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>位置</li>
</ul>
<p>流程/事件/控制/产品目录（Process/Event/Control/Product Catalog）</p>
<p>流程/事件/控制/产品目录为流程、触发流程的事件、流程的输出和施加到流程执行之上的控制提供了一份层次结构，并可被用来作为流程图（Process Flow diagram）的一个有力的补充，这些流程图使得企业可以进行跨越组织和流程的过滤、汇报和查询操作，从而对其范围、通用性或影响进行明确。例如，流程/事件/控制/产品目录使得企业可以查看流程与各子流程之间的关系，从而明确源自于一个高层流程的变更所能带来的影响链。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>流程</li>
<li>事件</li>
<li>控制</li>
<li>产品</li>
</ul>
<p>合同/评测目录（Contract/Measure Catalog）</p>
<p>此目录提供了一份关于所有经过批准的服务合同以及与此相关的评测的列表，从而形成了在整个企业内获得批准的服务水平的主列表。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
<li>合同</li>
<li>评测</li>
</ul>
<p>业务交互矩阵（Business Interaction Matrix）</p>
<p>此矩阵用于描述企业中各组织与业务功能之间的交互关系。理解企业中的业务交互是很重要的，因为它有助于突出整个组织中的价值链以及相互依赖关系。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织</li>
<li>业务功能</li>
<li>业务服务</li>
<li>业务服务之间的通信关系</li>
<li>业务服务之间的依赖关系</li>
</ul>
<p>执行者/角色矩阵（Actor/Role Matrix）</p>
<p>此矩阵用于展示哪些执行者扮演何种角色，并支持对安全性和技能需求的定义。理解执行者与角色之间的关系对定义培训需求、用户安全设置和组织变更管理具有关键性作用。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>执行者</li>
<li>角色</li>
<li>执行者与角色之间的担当关系</li>
</ul>
<p>务足迹图（Business Footprint Diagram）</p>
<p>业务足迹图描述了业务目标、组织单元、业务功能和服务之间的关联，并将这些功能映射到各个提供了所需能力的技术组件之上。它在从技术组件到业务目标的映射中提供了清晰的可追溯性，同时还对已经明确的服务的所有权进行了阐述。业务功能图仅对联系组织单元功能与交付服务的关键因素进行描述，并且还可被用来作为与高层次干系人（CIO、CEO等）进行沟通的平台。</p>
<p>业务服务/信息图（Business Service/Information Diagram）</p>
<p>业务服务/信息图展示了用于对一个或多个业务服务进行支持的信息，包括了由业务服务使用或者产生的数据及其信息源。服务/信息图对信息在架构中的最初表现形式进行了展现，因此为数据架构阶段的进一步描述打下了基础。</p>
<p>功能分解图（Functional Decomposition Diagram）</p>
<p>功能分解图的目标是将组织中与架构相关的各项能力展现在一张图纸之上。通过从功能的视角检视组织的各项能力，企业可以快速针对组织所做的事情进行建模，而不用陷入针对组织如何做所进行的额外讨论之中。</p>
<p>产品生命周期图（Product Lifecycle Diagram）</p>
<p>产品生命周期图的目标是对企业中关键实体的理解进行辅助。就关于产品从生产到撤销过程中所必须遵守的环境的关注、立法和规章来说，理解产品生命周期变得越来越重要。与此相同，在为了保证在控制、流程和程序的设计严谨而进行的业务架构开发过程中，创建涉及个人或敏感信息产品的组织必须对产品生命周期具有一个详尽的理解，例如信用卡、借记卡、智能卡以及用户身份认证等信息。</p>
<p>目标/阶段目标/服务图（Goal/Objective/Ser viceDiagram）</p>
<p>此图的目标是为服务对业务愿景或策略的达成而定义方法。通过将服务与驱动力、目标、阶段目标和相关的评测进行关联，企业可以了解到哪些服务贡献于相似的业务效能方面。此外，该图还为针对某一特定服务所形成的高效能的认定提供了定性的输入。</p>
<p>业务用例图（Business Use-Case Diagram）</p>
<p>业务用例图展示了业务服务的提供者和使用者之间的关系。业务服务被各个执行者或其他的业务服务所使用，而业务用例图则通过针对业务能力在何时以及如何被使用的描述，为业务能力的描述方面提供了额外的价值。此图形的目标是对各执行者和他们在各流程和功能中所担当的角色之间的交互关系进行描述和验证。随着架构过程的演进，这些用例图也将从业务级别发展至包括数据、应用和技术在内的更加详尽的级别。除此之外，业务用例图也可在系统设计工作中得到复用。</p>
<p>组织分解图（Organization Decomposition Diagram）</p>
<p>组织分解图描述了执行者、角色以及他们在组织树中所处位置之间的关系。一份组织分解图应提供了一条组织中决策者和业务拥有者的命令链。虽然组织分解图并不打算将组织与其目标联系在一起，但是在这张图中为最终目标与干系人之间建立直观的联系也是可以的。</p>
<p>流程图（Process Flow Diagram）</p>
<p>流程图的目标是对流程元模型实体相关的所有模型和映射进行描述，它展示了位于各个活动之间的顺序化控制流，并可借助于泳道技术来表达各个流程步骤的归属和实现。例如，用于支持一个流程步骤的应用就可以作为一条泳道来展示。除此之外，流程图也可以被用来细化赋予在流程之上的控制、触发某流程或产生于流程结束时的事件，以及由于流程执行所产生的各种输出产物。流程图在为主题专家描述架构时非常有用，它可以为这些专家描述一个特定功能的工作是如何被完成的。通过这样一个过程，每个流程步骤可以被细化为更小粒度的功能块，而且这些功能块在以后亦可以被当作一个流程来进行进一步的阐述。</p>
<p>事件图（Event Diagram）</p>
<p>事件图的目标是描述事件与流程之间的关系。诸如某些特定信息的到来，或者是某个特定的时间点这样的特定事件会致使业务中特定的工作和行为得以进行，同时也经常会有被称为业务事件（或简称事件）的信息被当作某个流程的触发者。</p>
<p>数据实体/数据组件目录（Data Entity/Data Component Catalog）</p>
<p>数据实体/数据组件目录的目标是明确和维护企业中使用的所有数据的列表，包括数据实体，以及用于存储数据实体的数据组件。一个经过批准的数据实体/数据组件目录支持对信息管理和数据治理策略的定义和应用，并且鼓励对数据进行有效地共享和重用。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>逻辑数据组件</li>
<li>物理数据组件</li>
</ul>
<p>数据实体/业务功能矩阵（Data Entity/Business Function Matrix）</p>
<p>此矩阵用来描述企业中数据实体和业务功能之间的关系。业务功能被具有明显边界的业务服务所支持，并通过业务流程加以实现。通过数据实体与业务功能之间的映射，企业可以得到：</p>
<ul>
<li>将数据实体的所有权分配给各个组织。</li>
<li>理解业务服务的数据和信息交换需求。</li>
<li>支持差距分析，并决定是否有需要被创建的数据实体被遗漏。</li>
<li>为数据实体定义源系统、记录系统和引用系统。</li>
<li>启动企业的数据治理程序的开发（建立数据管家、开发与业务功能相关的数据标准等）。</li>
</ul>
<p>此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>业务功能</li>
<li>数据实体与其所属组织单位的“从属”关系</li>
</ul>
<p>系统/数据矩阵（System/Data Matrix）</p>
<p>此矩阵用于描述系统与系统所访问和更新的数据实体之间的关系（一张两维表，其中一个纬度对应逻辑应用组件，而另外一个则对应数据实体）。系统用于创建、读取、更新和删除与他们相关联的特定数据实体。例如，一个客户关系系统将创建、读取、更新和删除客户实体信息。处在一个被封包好的服务环境中的数据实体可以被分为主数据、引用数据、事务数据、内容数据和历史数据，而用于操作这些数据实体的应用则包括事务应用、信息管理应用和业务仓库应用。针对应用组件和数据实体之间映射是一个非常重要的步骤，因为它可以使得：</p>
<ul>
<li>针对数据的访问能力被分配给组织中的具体应用。</li>
<li>了解在不同应用中数据重复的程度，以及数据生命周期的规模。</li>
<li>了解在何处相同的数据会被不同的应用所更新。</li>
<li>支持差距分析，并确定是否本应存在的应用被遗漏了。</li>
</ul>
<p>类图（Class Diagram）</p>
<p>类图的主要目标是描述企业中重要数据实体（或类）之间的关系。此图用于清晰地展示数据之间的关系，并帮助干系人理解企业下层数据模型。</p>
<p>数据传播图（Data Dissemination Diagram）</p>
<p>数据传播图的目标是展示数据实体、业务服务和应用组件之间关系。此图展示了各个逻辑实体如何被应用组件所实现。它使得针对数据大小的调整得以被有效地执行，同时IT足迹也会得以改善。而且，通过为数据设置业务价值，应用组件的业务重要性的指标也能够在同时被获得。另外，此图还可以展示针对数据复制和主引用的所有权，即它可以展示数据的两个备份以及数据之间的主-备份关系。此图还能够包含服务，比如，封装数据并且驻留在应用之内的服务，或者驻留在应用之上并能够访问封装在应用中的数据的服务。</p>
<p>上面所说的IT footprint中，footprint，即足迹，的本意是由动物遗留下的包含了遗留者本身标识和信息的事物。在信息技术领域，根据哈佛商学院Andrew McAfee所述，技术足迹表示了其在地理、逻辑分区和/或功能方面所能延展到范围，是针对一个信息技术所期望的覆盖范围的描述（A technology's footprint is its geographic, divisional, and/or functional reach. It's a description of how much territory a piece of IT is intended to cover）。在TOGAF中并没有说明数据大小的调整与IT足迹改善之间的关系，也没有说明所谓的IT足迹改善的具体含义。不过通过互联网上的一个关于IT足迹改善的实例，即将原本有着十几台计算机的教室用一台中心计算机和若干终端来代替，笔者有感而发，粗浅的认为这里IT足迹改善意思是说由于数据尺寸得到了很好的调整，那么不必需的冗余信息被削减，因而数据和应用的“足迹”，即其涉及到的范围，将比冗余剔除前更加清晰有效</p>
<p>数据安全图（Data Security Diagram）</p>
<p>数据可以看作是企业的一项资产，简单的讲，数据安全可被认为是确保企业数据不被损害，并且针对数据的访问也要在适当的控制之下。数据安全图的目标是描述何执行者可以访问企业中的哪些数据。此外，此图也可以被用来阐述与数据隐私法规以及其他应用性法规的符合度。此图还需要考虑发生在企业合作伙伴或其他团体对企业系统进行访问之处的信任含义，例如在外包的情形下，信息可能会被企业之外的其他人员（甚至身处国门之外）所管理。</p>
<p>类层次结构图（Class HierarchyDiagram）</p>
<p>类层次结构图的目标是为技术方面的干系人展示一个有关类层次的视图。此图的优点是干系人可以得到一份关于数据实体在技术层面上如何被使用的图形描述，它使得干系人可以了解何人正在针对数据进行使用，以及他是在何时、如何以及为何进行这项活动。</p>
<p>数据迁移图（Data Migration Diagram）</p>
<p>在实现一个以封包服务为基础的解决方案时，数据迁移是非常重要的，特别是将现存的遗留系统替换为一个服务封包时，或者当企业将要迁移到一个更大的封包服务时。每个服务包都倾向于具有属于他们自己的数据模型，并且在数据迁移过程中，遗留的应用数据可能需要在载入到服务封包之前需要进行某种转化。数据迁移活动通常包含如下的步骤：</p>
<ul>
<li>从原有应用中抽取出数据。</li>
<li>配置源数据</li>
<li>执行数据转换，其中包括数据质量相关的各个过程：
<ul>
<li>对数据进行标准化、归一化，并消除数据的重复性（数据清洗）。</li>
<li>针对不同来源的数据进行比对、合并和整合。</li>
<li>进行自源头至目标的映射</li>
</ul>
</li>
<li>将数据加载到目标应用之中。</li>
</ul>
<p>数据迁移图的目标是展示数据如何从源头应用流入到目标应用之中。此图为数据从源头到目标过程的进行提供了一个可视化表达，并可在数据审计和追溯中作为辅助工具。此外，此图所展示的细节程度可以按照需要进行调整。例如，数据迁移图可以仅仅包含一个关于迁移情况的整体布置，也可以为单独的应用提供元数据元素级别的详细信息。</p>
<p>数据生命周期图（Data Lifecycle Diagram）</p>
<p>数据生命周期图是在业务流程的约束之下对业务数据在其整个生命周期（从概念阶段到最终退出）中对其进行管理的核心部分。数据从本质上讲是一个实体，并独立于业务流程和活动。数据状态的每个变化都被表现在这张图中，这也可以包括引起此状态变化事件或规则。数据与流程的分离使得通用数据需求可以被识别出来，从而使得资源共享得以有效达成。</p>
<p>应用组合目录（Application Por tfolio Catalog）</p>
<p>此目录的目标是明确和维护企业中所有应用的列表。一个经过批准的应用组合目录使得一系列应用得以被定义和治理。此目录为后面的矩阵和图形提供了基础，是应用架构开发阶段的起点。现有的应用注册表和资源库（比如SAP的解决方案管理和系统情况目录产品）也从基线和目标两个角度为这个目录的制定提供了输入。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>信息系统服务</li>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
</ul>
<p>接口目录（Interface Catalog）</p>
<p>接口目录用来界定应用之间接口的范围，并对这些接口进行文档化记录，从而使得应用间的所有依赖关系得以被尽可地界定。系统可以用来创建、读取、更新和删除其他系统内的数据。无论是通过循环载入的批处理文件、对其他系统数据库的直接连接，还是通过某种形式的应用程序接口或Web服务，这些行为都是通过接口来实现。针对应用组件之间关系的映射是一个非常重要的步骤，它使得如下情形得以实现：</p>
<ul>
<li>了解应用间交互程度的，从而可以站在应用与其他系统之间依赖性的角度识别出各个关键的交互。</li>
<li>了解应用之间接口的数量和类型。</li>
<li>了解应用之间接口的重复程度。</li>
<li>在考虑目标应用组合时明确各接口的简化潜力。</li>
<li>支持差距分析，并确定是存在本应建立的应用被遗漏了。</li>
</ul>
<p>此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
<li>应用之间的通信关系</li>
</ul>
<p>系统/组织矩阵（System/Organization Matrix）</p>
<p>此矩阵用于描述企业中系统与组织单元之间的关系。业务功能由组织单元来执行，而一些由组织单元执行的功能和服务也将会被IT系统所支持。应用组件与组织单元之间的映射非常重要，它会使得：</p>
<ul>
<li>为执行业务功能的组织单元分配针对应用的使用。</li>
<li>理解由组织单元所执行的业务服务和流程对应用支持需求。</li>
<li>支持差距分析，并确定是否有需要被建立的应用被遗漏。</li>
<li>定义特定组织单元所使用的应用集合</li>
</ul>
<p>。<br>
此矩阵是一张两维表，其中逻辑/物理应用组件在一条坐标轴上，而组织单元在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
<ul>
<li>组织单位与服务之间的从属关系。</li>
<li>执行者与组织单位之间的从属关系，以及其与服务之间的使用关系。</li>
<li>服务与逻辑/物理应用组件之间的实现关系。</li>
</ul>
<p>角色/系统矩阵（Role/System Matrix）</p>
<p>此矩阵用来描述企业中系统与业务角色之间的关系。一个组织中的人们会与各种系统发生交互。在交互过程中，这些用户被假定成为执行一项任务的特定角色，例如，产品购买者。应用组件与角色之间的关系映射非常重要，它使得：</p>
<ul>
<li>
<p>在组织内为特定的角色分配针对应用的使用。</p>
</li>
<li>
<p>理解支持功能的业务服务和流程的应用安全需求，并检查是否与现有策略相符合。</p>
</li>
<li>
<p>支持差距分析，并确定是否有应该被创建的应用被遗漏。</p>
</li>
<li>
<p>定义被特定业务角色所使用的应用集合。<br>
此矩阵是一个两维表，其中逻辑应用组件在一条坐标轴上，而角色在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>角色与功能之间的访问关系。</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>系统/功能矩阵（System/Function Matrix）</p>
<p>此矩阵用于阐述企业中系统与业务功能之间的关系。业务功能由组织单元所执行。一些业务功能和服务将会被IT系统所支持。应用组件与功能之间的关系映射是非常重要的，它使得如下方面成为可能：</p>
<ul>
<li>
<p>为业务功能分配针对应用的使用</p>
</li>
<li>
<p>理解业务服务和流程的应用支持需求</p>
</li>
<li>
<p>支持差距分析，并确定是否有需要被创建的应用被遗漏</p>
</li>
<li>
<p>定义被特定业务功能所使用的应用集合<br>
此矩阵是一张两维表，其中逻辑应用组件位于一条坐标轴上，而功能处在另一条坐标轴之上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>应用交互矩阵（Application Interaction Matrix）</p>
<p>应用交互矩阵的目标是阐述系统之间的沟通关系。在矩阵中展示的应用交互映射与接口目录或者应用通信图示相类似的，只不过以矩阵的形式来展示。此矩阵是一张两维表，其中的每一个维度都包含了应用服务、逻辑应用组件和物理应用组件这些概念。在此矩阵中所描述的关系包括：</p>
<ul>
<li>应用服务之间的使用关系。</li>
<li>逻辑应用组件之间的通信关系。</li>
<li>物理应用组件的通信关系。</li>
</ul>
<p>应用通信图（Application Communication Diagram）</p>
<p>此图的目标是描述所有与应用之间的沟通相关的模型和映射。应用通信图展示了应用的应用组件和接口，并且接口可以关联数据实体，而应用则可以关联业务服务。此图所表述的“通信”应该是符合逻辑的，并且仅用来展示与架构相关的中介技术。</p>
<p>应用和用户位置图（Application and User Location Diagram）</p>
<p>应用和用户位置图展示了应用的地理分布情况。它可以被用来展示：</p>
<ul>
<li>被最终用户所使用的各个应用的地点分布</li>
<li>被执行和/或交付（在客户端情形下）的各个主机应用程序的地点分布情况</li>
<li>被开发、测试和发布的应用所处位置的分布情况</li>
</ul>
<p>此图的目标在于清晰地描述与应用发生交互的业务用户所处的业务位置，而且还包括了应用基础设施的位置。通过此图，我们可以：</p>
<ul>
<li>
<p>识别出足以支持分散在各地的用户群的产品包的数量</p>
</li>
<li>
<p>估算产品或软件的用户许可的类型和数量</p>
</li>
<li>
<p>估算用户的支持等级和支持中心的位置</p>
</li>
<li>
<p>选择系统管理工具、结构，以及用于支持本地或远程的企业用户/客户/合作伙伴的管理系统</p>
</li>
<li>
<p>适当规划业务的技术组件，即服务规模、网络带宽等</p>
</li>
<li>
<p>在实施应用和技术架构解决方案时进行性能方面的考虑<br>
用户通常会采用多种方式与应用进行交互，例如：</p>
</li>
<li>
<p>支持日常业务的运营。</p>
</li>
<li>
<p>参与业务流程的执行过程。</p>
</li>
<li>
<p>访问信息（查询、读取等）。</p>
</li>
<li>
<p>开发应用。</p>
</li>
<li>
<p>管理、维护应用。</p>
</li>
</ul>
<p>系统用例图（System Use-Case Diagram）</p>
<p>系统用例图展示了客户与应用服务提供者之间的关系。应用服务被角色或其他应用服务所使用，并且通过描述功能是在何时被如何使用，应用用例图对应用功能的描述提供了更多意义。此图的目标是帮助描述和验证各个参与者与他们对应用所担当的角色之间的交互。随着架构的进展，这些用例能够从功能性信息演进到包含技术实现细节。架构系统用例还可以在更细节的系统设计工作中被复用。</p>
<p>企业管理能力图（Enterprise Manageability Diagram）</p>
<p>企业管理能力图展示了一个或多个应用是如何与用以支持一个解决方案的运营管理的应用和技术组件进行交互的。此图实际上是针对应用通信图的一个过滤，特别是针对企业管理类软件方面。基于此图的分析可以揭示组织的IT服务管理操作方面重复、差距和机遇。</p>
<p>流程/系统实现图（Process/System Realization Diagram）</p>
<p>流程/系统实现图的目标是清晰地阐述在业务流程执行过程中涉及到多个应用时所产生的事件的顺序。此图可以识别出能够被简化的复杂顺序，以及架构中各种可能的合理化点，从而为业务用户提供更加及时的信息。此外，此图还可被用来明确流程中能够通过减少应用之间的交互流量而进行效率改善的地方。</p>
<p>软件工程图（Software Engineering Diagram）</p>
<p>系统工程图从开发的角度将应用分解为包、模块、服务和操作，它使得在各规划迁移阶段和分析机会与解决方案时进行更加详细的影响分析成为可能。在管理复杂开发环境时，系统工程图对应用开发团队和应用管理团队是非常有用的。</p>
<p>应用迁移图（Application Migration Diagram）</p>
<p>应用迁移图表明了应用从基线到目标应用组件的迁移过程，它通过精确地展示哪些应用和接口在迁移各阶段中需要被映射，使得针对迁移成本的估算更加准确。应用迁移图确定了临时的应用、集结区域以及用于支持迁移的各项基础设施。</p>
<p>软件分布图（Software Distribution Diagram）</p>
<p>软件分布图展示了应用软件在整个组织内的结构和布局，它在系统升级或应用整合项目中是非常有用的。此外，软件分布图还展示了物理应用在整个物理技术领域中是如何分布的，以及这些物理技术的位置。软件分布图对软件是如何被托管的这一问题提供了一份清晰的视图，而且还使得管理操作人员能够了解应用软件在安装成功后是如何被维护的。</p>
<p>技术标准目录（Technology Standards Catalog）</p>
<p>技术标准目标记录了企业中被批准的各项技术标准，涵盖了技术、版本、技术生命周期，以及技术的更新周期。根据组织需要，也可能包括地点或者业务的特定领域的标准信息。此目录提供了一个当前或能够被部署的企业标准技术的快照，并有助于在整个企业内搜寻差异。如果当前已经存在了各种技术标准，那么把它们放入到技术组合目录中将会得到一张关于各技术标准符合性的基线视图。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>技术组合目录（Technology Por tfolio Catalog）</p>
<p>此目录的目标是识别和维护整个企业中在用技术的列表，包括硬件、技术设施软件，以及应用软件。一个经过批准的技术组合支持技术产品和版本的生命周期管理，而且还形成了技术标准定义的基础。技术组合目录为后续的矩阵和图形描述提供了基础，是技术架构开发阶段的起点。技术注册表和资源库从基线和目标的视角为此目录提供了输入。在此目录中的技术应该按照TOGAF技术参考模型（可以按照需要来对模型进行扩展，从而符合针对正在使用的技术产品的分类）进行分类。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>系统/技术矩阵（System/Technology Matrix）</p>
<p>系统/技术矩阵记录了业务系统与技术平台之间的映射关系。此矩阵应该是一张或多张平台分解图的补充，并应与这些图保持一致。此矩阵展示了：</p>
<ul>
<li>逻辑/物理应用组件。</li>
<li>服务、逻辑技术组件以及物理技术组件。</li>
<li>物理技术组件与物理应用组件之间的实现关系。</li>
</ul>
<p>环境和位置图（Environments and Locations Diagram）</p>
<p>环境和位置图描述了哪些应用处于哪些位置，并标识出什么技术和/或应用被用在了哪些地方，以及表示出业务用户一般在何处与应用进行交互。此图还展示了不同部署环境的存在和位置，包括非生产环境，例如开发和预生产。</p>
<p>平台分解图（Platform Decomposition Diagram）</p>
<p>平台分解图描述了用于支持信息系统架构运行的技术平台。此图涵盖了技术设施平台的所有方面，并提供了一个关于企业技术平台的概览。此图可以通过扩展来将技术平台映射到适当的处于特定功能或流程区域内的应用组件。此图还可以被用来展示规范说明的细节，例如产品版本、CPU数量等，或者只是用来提供技术环境概览的非正式的“过眼图”。</p>
<p>此图应该清楚的展示企业应用和针对每个应用区域的技术平台，它可以被进一步分解为：</p>
<ul>
<li>硬件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
<li>软件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>处理图（Processing Diagram）</p>
<p>处理图关注于代码/配置的部署单元（针对业务功能、服务或应用组件的分组），以及这些单元是如何被部署到技术平台之上的。处理图表明了：</p>
<ul>
<li>
<p>哪些应用组件需要被组织起来，并形成部署单元。</p>
</li>
<li>
<p>部署单元之间是如何连接和交互的。</p>
</li>
<li>
<p>应用配置和使用模式是如何针对不同的技术组件而产生负载或容量方面需求。<br>
针对部署单元的组织和分组依赖于对组件的展示、业务逻辑以及数据存储层和服务水平需求这些方面关注点的分离。例如，展示层部署单元是基于如下方面进行分组的：</p>
</li>
<li>
<p>用于提供用户界面或用户访问功能的应用组件。</p>
</li>
<li>
<p>根据位置和用户角色来进行区分的应用组件。<br>
每个部署单元是由若干子单元所组成的，例如：</p>
</li>
<li>
<p>安装单元：包含可执行的代码或封包配置的部分。</p>
</li>
<li>
<p>执行单元：应用组件以及与其相关的运行时状态。</p>
</li>
<li>
<p>持久化单元：代表应用组件的持久化状态的数据。<br>
部署单元可以被部署到专用或共享的技术组件之上（工作站、Web服务器、应用服务器或数据库服务器等）。需要注意的是，技术处理对于服务的定义和粒度具有着较大的影响。</p>
</li>
</ul>
<p>网络计算/硬件图（Networked Computing/Hardware Diagram）</p>
<p>从大型机到客户端-服务器系统的改造开始，以及随后的电子商务和J2EE的出现，大型企业逐步进入到了一个高度网络化的分布式网络计算环境之中。当前，大多数应用都具有一个Web前端，并且就这些应用的部署架构来说，具备三个独立层次的情况还是非常常见的，亦即Web表现层、业务逻辑或应用层，以及一个后台数据存储层。将应用部署到一个共享的通用技术设施环境之中也是一种常见的做法。</p>
<p>由此可见，将逻辑应用与在开发和生产过程中对应用进行支持的技术组件之间的映射关系记录起来是非常重要的。网络计算/硬件图的目标是展示逻辑应用组件在一个分布式网络计算环境中部署的逻辑视图。此图之所以有用，是因为通过此图我们可以：</p>
<ul>
<li>了解应用部署在分布式网络计算环境中的什么地方。</li>
<li>建立针对这些技术组件的授权、安全和访问。</li>
<li>了解在问题解决和故障排除中用以支持应用的技术架构。</li>
<li>对应用所遇到的性能问题进行隔离，确定应用是代码相关的，还是技术平台相关的，并对具体的物理技术组件进行必要的升级。</li>
<li>当新的技术出现并能够因此带来成本缩减时，确定可通过此技术进行优化的区域。</li>
<li>使得应用/技术审计成为可能，并证明企业技术标准的符合性程度。</li>
<li>作为将变更引入到技术架构的用力工具，从而支持有效地变更管理。</li>
<li>当应用从一个共享环境迁移到一个专门的环境时，建立可追溯性和正在进行变化的应用的终端地址，反之亦然。</li>
</ul>
<p>通过适当的定义，网络计算/硬件图的范围可以涵盖某一个特定的应用、业务功能或者是整个企业，而如果选择在企业级别进行开发，那么组织就可以通过一种与应用无关的方式来对网络计算情况进行描述。</p>
<p>通信工程图（Communications Engineering Diagram）</p>
<p>通信工程图描述了处在技术架构中的各资产之间的通信方法（收发信息的方法）。此图展示了客户端和服务器组件之间的逻辑连接，并明确了用于对这些逻辑连接进行实现的网络边界和网络基础设施。需要注意的是，此图并不描述参与通信的信息格式或内容，但它可以对通信协议以及容量方面的问题进行阐述。</p>
<p>项目背景图（Project Context Diagram）</p>
<p>项目背景图展示了作为过渡路线图一部分而实现的工作包的范围。此图会将工作包与在项目中被增加、删除或影响的组织、功能、服务、流程、应用、数据以及技术连接在一起。此图对于项目组合管理和项目动员来说也是一个有价值的工具。</p>
<p>效益图（Benefits Diagram）</p>
<p>效益图展示了在架构定义中识别出来的各种机会，并通过他们的相对规模、效益和复杂度进行分类。此图可被干系人用来对这些识别出来的机会进行选择、对其优先级进行定义，并对他们的顺序进行确定。</p>
<p>需求目录（Requirements Catalog）</p>
<p>需求目录包含企业需要用来满足目标要求的种种事物。在架构行为中所产生的需求一般会通过变更措施来实现，并在机会和解决方案阶段中界定其范围。需求还可以被用来作为质量保证的工具，从而保证针对特定架构的使用始终处在其使用范围之内。</p>
<h3> 3、针对视图的开发</h3>
<p>如前所述，TOGAF中定义了一系列基本的架构制品来担当原子性视角，不同的组织可以根据自身的需要创建、改造或利用这些原子视角，并根据不同干系人的关注点将这些架构制品组合为适合于他们的视角定义，因而针对视图的开发需要明确其目标干系人、他们的关注点，以及所采用的各种基本架构制品和建模方法。TOGAF中针对多种视图的开发方法进行了建议，包括：</p>
<ul>
<li>业务架构视图：此视图是为用户而进行开发的，它从系统用户的角度对系统的功能性方面进行关注。</li>
<li>企业安全视图：此视图是为系统安全工程师而进行开发的，它从安全的角度对系统如何实现，以及安全如何影响系统特性这些方面进行关注，这其中最重要的是，相关干系人能够了解如何确保系统仅能被具有权限的人员或系统来进行访问，以及如何保护系统不受到非授权地侵扰。</li>
<li>软件工程视图：创建一个软件密集型系统是非常耗费资源和时间的，因而建立一个能够帮助最小化劳力付出和风险的导则是非常必要的，而这正是软件工程视图的目标。此视图应该是为开发系统的软件工程师而进行开发的。</li>
<li>系统工程视图：此视图应该是为系统的系统工程人员而进行开发的，并从硬件/软件和网络连接的角度对系统如何被实现进行关注。</li>
<li>通信工程视图：此视图应该是为系统的通信工程人员而进行开发的，并在通信工程师的角度关注于系统是如何被实现的。</li>
<li>数据流视图：此视图应该是为系统的数据库工程师而进行开发的。此视图的主要关注点在于了解如何为正确的人员和应用通过适当的接口并在合适的时间提供正确的数据。</li>
<li>企业管理能力视图：此视图应该是为系统的运营、行政和管理人员而进行开发的。此视图的主要关注点在于了解系统是如何做为一个整体而被管理的，以及系统的所有组件是如何被管理的，这其中关键之处在于管理系统变更，并对预防性维护措施进行预测。</li>
<li>采购视图：此视图应该是为在架构组件的采购过程中所牵涉的人员而进行开发的。此视图的主要关注点在于了解哪些架构的构建块是需要被采购的，以及与采购行为相关的各种约束。</li>
</ul>
<h3> 5、构建块（Building Blocks）</h3>
<p>架构构建块可以说是企业架构内容的核心，也是企业架构开发方法的最终产物。与此相比，架构交付物所面向的是企业架构开发过程，架构制品则可以看作是企业架构内容的表现形式和使用方式，而唯有构建块则是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些企业各个领域中的可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<p>构建块特性</p>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>构建块是为了达成整个组织的需要而定义的功能包。</li>
<li>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</li>
<li>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</li>
<li>构建块通常会与其他相互依存的构建块进行互操作。</li>
</ul>
<p>除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
<ul>
<li>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</li>
<li>一个好的构建块可以由其他构建块组合而成。</li>
<li>一个好的构建块可以是其他构建块的一个组件。</li>
<li>在理想的情况下，一个构建块应是可重用和可替换的，并具备详尽的描述。</li>
</ul>
<p>构建块分类</p>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的，也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者则在实现的层面对能够实现构建块的解决方案进行描述。需要注意的是，由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合，因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>①架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>②解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>解决方案与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<p>构建块的使用原则</p>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同，并且组织也应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用，因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>
<p>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</p>
</li>
<li>
<p>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</p>
</li>
<li>
<p>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并在之后将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</p>
</li>
<li>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
</li>
<li>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
</li>
</ul>
<p>构建块与架构开发方法</p>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，而包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<h2> 五、机构构建块（Building Blocks）</h2>
<p>架构构建块是企业架构内容的核心，也是企业架构开发方法的最终产物。架构交付物面向的是企业架构开发过程，架构制品则是企业架构内容的表现形式和使用方式，而唯有构建块是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<h3> 1、构建块特性</h3>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>
<p>构建块是为了达成整个组织的需要而定义的功能包。</p>
</li>
<li>
<p>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</p>
</li>
<li>
<p>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</p>
</li>
<li>
<p>构建块通常会与其他相互依存的构建块进行互操作。<br>
除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
</li>
<li>
<p>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</p>
</li>
<li>
<p>一个好的构建块可以由其他构建块组合而成。</p>
</li>
<li>
<p>一个好的构建块可以是其他构建块的一个组件。</p>
</li>
<li>
<p>一个构建块应是可重用和可替换的，并具备详尽的描述。</p>
</li>
</ul>
<h3> 2、构建块分类</h3>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的。也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者在实现层面对能够实现构建块的解决方案进行描述。由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合。因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<h3> 3、构建块的使用原则</h3>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同。组织应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用。因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</li>
<li>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</li>
<li>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</li>
</ul>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
<h3> 4、构建块与架构开发方法</h3>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<figure><figcaption>img_31.png</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-02-21T03:01:36.000Z</published>
  </entry>
  <entry>
    <title type="text">Java的四个核心思想</title>
    <id>https://ujava.cn/java/basecore.html</id>
    <link href="https://ujava.cn/java/basecore.html"/>
    <updated>2024-01-31T00:48:57.000Z</updated>
    <summary type="html"><![CDATA[<p>Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。</p>
<h2> Java虚拟机</h2>
<p>Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。</p>]]></summary>
    <content type="html"><![CDATA[<p>Java已经成为一个庞大而复杂的技术平台，对于开发人员而言，要想更好的掌握Java技术，深入理解底层的技术处理细节必不可少。对核心概念和思想的掌握可以帮助我们举一反三、触类旁通，有助于提升我们对整个Java平台的理解力。这里所介绍的是Java技术平台的几个核心概念，其中所蕴含的思想有助于我们更深刻的理解Java技术。</p>
<h2> Java虚拟机</h2>
<p>Java虚拟机的主要任务是装载class文件并且执行其中的字节码。Java虚拟机包含一个类装载器，它可以从程序和API中装载class文件。Java API中只有程序执行时需要的那些类才会被装载。字节码由执行引擎来执行。</p>
<p>不同的Java虚拟机中，执行引擎可能实现得非常不同。在由软件实现的虚拟机中：</p>
<ul>
<li>（1）最简单的执行引擎就是一次性解释字节码。</li>
<li>（2）另一种执行引擎更快，但是也更消耗内存，叫做"即时编译器(just-in-time compiler)"。在这种情况下，第一次被执行的字节码会被编译成本地机器代码。编译出的本地机器代码会被缓存，当以后方法被调用的时候可以重用。</li>
<li>（3）第三种执行引擎是自适应优化器。在这种方法里，虚拟机开始的时候解释字节码，但是会监视运行中程序的活动，并且记录下使用最频繁的代码段。程序运行的时候，虚拟机只把那些活动最频繁的代码编译成本地代码，其他的代码由于使用得不是很频繁，继续保留为字节码-由虚拟机继续解释它们。一个自适应的优化器可以使得Java虚拟机在80%<sub>90%的时间里执行被优化过的本地代码，而只需要编译10%</sub>20%的对性能有影响的代码。</li>
</ul>
<p>当Java虚拟机是由主机操作系统上的软件实现的时候，Java程序通过调用本地方法(native method)和主机交互。Java中有两种方法: Java方法和本地方法。Java方法是由Java语言编写，编译成字节码文件，存储在class文件中的。本地方法是由其他语言(比如c,c++或汇编语言)编写的，编译成何处理器相关的机器代码。本地方法保存在动态链接库中,格式是各个平台专有的。运行中Java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库，并调用这个方法。本地方法是联系Java程序和底层主机操作系统的连接方法。</p>
<p>通过本地方法，Java程序可以直接访问底层操作系统的资源。一个本地方法接口(Java Native Interface, JNI)-使得本地方法可以在特定主机系统的任何一个Java平台实现上运行。</p>
<p>如果希望使用特定主机上的资源，它们又无法从Java API访问，那么可以写一个平台相关的Java程序来调用本地方法。如果希望保证程序的平台无关性，那么只能通过Java API来访问底层系统资源。</p>
<h2> 类装载器的体系结构</h2>
<p>一个Java应用程序可以使用两种类装载器："启动(bootstrap)"类装载器和用户定义的类装载器。启动类装载器(这是系统中唯一的)是Java虚拟机实现的一部分。启动类装载器通常使用某种默认方式从本地磁盘中装载类，包括Java API类(启动类装载器也被称为原始类装载器、系统类装载器或者默认类装载器)。</p>
<p>Java应用程序能够在运行时安装用户定义的类装载器，这种类装载器能够使用自定义的方式来装载类。例如，从网络下载class文件。尽管启动类装载器是虚拟机实现的本质部分，而用户定义的类装载器不是，但用户定义的类装载器能够用Java来编写,能够被编译成class文件，能够被虚拟机装载，还能够像其它对象一样实例化。</p>
<p>由于有用户定义类装载器，所以不必在编译的时候就知道运行中的Java应用程序中最终会加入的所有的类。用户定义的类装载器使得在运行扩展Java应用程序成为可能。当它运行时，应用程序能够解决它需要哪些额外的类，能够决定是使用一个或是更多的用户定义的类装载器来装载。由于类装载器是用Java编写的，所以用任何在Java代码中可以表述的风格来进行类装载。这些类可以通过网络下载，可以从某些数据库中获取，甚至可以动态生成。</p>
<p>每一个类被装载的时候，Java虚拟机都监视这个类，看到它到底是被启动类装载器还是被用户定义类装载器装载。当被装载的类引用了另外一个类时，虚拟机就会使用装载第一个类的类装载器装载引用的类。例如，如果虚拟机使用一个特定的类装载器装载Volcano这个类，它就会使用这个类装载器装载Volcano类使用的所有类。</p>
<p>由于Java虚拟机采取这种方式进行类的装载，所以被装载的类默认情况下只能看到被同一个类装载器装载的别的类。通过这种方法，Java的体系结构允许在一个Java应用程序中建立多个命名空间。运行时的Java程序中的每一个类装载器都有自己的命名空间。</p>
<p>Java应用程序可以创建多个(或多种)被不同的类装载器装载的类并把这些类存放在不同的命名空间中，它们不能相互访问，除非应用程序显示地允许这么做。当编写一个Java应用程序的时候，从不同源文件装载的类可以分隔在不同的命名空间中。通过这种方法，就能够使用Java类装载器的体系结构来控制任何不同源文件中装载的代码之间的相互影响，特别是能够阻止恶意代码获取访问或破坏善意代码的权限。</p>
<p>Web浏览器是一个动态扩展的例子，Web浏览器使用用户定义的类装载器从网络下载用于Java applet的class文件。Web浏览器使用一个用来安装用户定义类装载器的Java应用程序。这个用户定义的类装载器通常被称为Java Applet类装载器，它知道如何向HTTP服务器请求class文件。Java Applet可以作为动态扩展的例子，因为Java应用程序并不知道它什么时候会开始从网络下载浏览器请求的class文件。只有当浏览器遇到有Java applet的页面时，才决定是否需要下载class文件。</p>
<p>Web浏览器启动的Java应用程序通常为每个提供class文件的网络地址分别创建不同的用户定义类装载器，因此，不同的用户定义类装载器装载不同来源的class文件。这就可以把它们分别放置在Java主机应用程序的不同命名空间之下。由于不同来源的Java applet文件放置在不同的命名空间中，恶意的Java applet代码就不会直接访问从别的地方下载的class文件。这就能够限制或阻止不同来源的代码之间的相互访问。</p>
<h2> Java class文件</h2>
<p>Java class文件主要在平台无关性和网络移动性方面使Java更适合网络。它在平台无关性方面的任务是：为Java程序提供独立于底层主机平台的二进制形式的服务。这种途径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件时可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。</p>
<p>当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的"机器语言"。</p>
<p>class文件设计得紧凑，因此它们可以快速地在网络上传送。其次，由于Java程序是动态连接和动态扩展的，class文件可以在需要的时候才下载。这个特点使得Java应用程序能够安排从网络上下载class文件的时间，从而可以最大限度地减少终端用户的等待时间。</p>
<h2> Java API</h2>
<p>Java API通过支持平台无关性和安全性，使得Java适应于网络应用。Java API是运行库的集合，它提供了一套访问主机系统资源的标准方法。运行Java程序时，虚拟机装载程序的class文件是所使用的Java API class文件。所有被装载的class文件(包括从应用程序中和从Java API中提取的)和所有已经装载的动态库(包含本地方法)共同组成了再Java虚拟机上运行的整个程序。</p>
<p>在一个平台能够支持Java程序以前，必须在这个特定平台上明确地实现API的功能。为访问主机上的本地资源，Java API调用了本地方法。由于Java API class文件调用了本地方法，Java程序就不需要再调用它们了。通过这种方法，Java API class文件为底层主机提供了具有平台无关性、标准接口的Java程序。对Java程序而言，无论平台内部如何，Java API都会有同样的表现和可预测的行为。正是由于在每个特定的主机平台上明确地实现了Java虚拟机和Java API,因此，Java程序自身就能够成为具有平台无关性的程序。</p>
<p>Java API在Java安全性模型方面也有贡献。当Java API的方法进行任何有潜在危险的操作(比如进行本地磁盘写操作)之前，都会通过查询访问控制器来检验是否得到了授权。访问控制器是一个类，该类用来执行栈检验，已决定是否允许某种操作。</p>
]]></content>
    <category term="Java"/>
    <published>2024-01-31T00:48:57.000Z</published>
  </entry>
  <entry>
    <title type="text">Java UML类图</title>
    <id>https://ujava.cn/java/uml.html</id>
    <link href="https://ujava.cn/java/uml.html"/>
    <updated>2024-01-30T01:34:07.000Z</updated>
    <summary type="html"><![CDATA[<h2> 面向对象概念</h2>
<p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。</p>
<p>它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p>
<h3> 扩展：面向功能概念</h3>
<p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 面向对象概念</h2>
<p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装、消息等基本概念进行程序设计。</p>
<p>它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p>
<h3> 扩展：面向功能概念</h3>
<p>结构化程序设计方法主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。</p>
<p>因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。</p>
<p>结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。</p>
<p>每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：</p>
<ul>
<li>设计不够直观，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。</li>
<li>适应性差，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高</li>
</ul>
<h2> 面向对象的三大特性</h2>
<p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态</p>
<ul>
<li>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</li>
<li>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</li>
<li>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征<br>
注意：如果说是对象的四大特性，那么还需要把抽象加上</li>
</ul>
<p>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p>
<h2> 封装</h2>
<p>封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</p>
<p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p>
<ul>
<li>隐藏类的实现细节；</li>
<li>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</li>
<li>可进行数据检查，从而有利于保证对象信息的完整性；</li>
<li>便于修改，提高代码的可维护性。</li>
</ul>
<h3> 封装的实现</h3>
<p>为了实现良好的封装，需要从两个方面考虑：</p>
<ul>
<li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；</li>
<li>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。<br>
封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</li>
</ul>
<h2> 继承</h2>
<p>继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<h3> 继承的实现</h3>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> C++和Java继承区别</h3>
<p>首先，Java是单继承的，指的是Java中一个类只能有一个直接的父类。Java不能多继承，则是说Java中一个类不能直接继承多个父类。</p>
<p>其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。</p>
<p>Java语言之所以摒弃了多继承的这项特征，是因为多继承容易产生混淆。</p>
<p>比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。</p>
<p>准确来说，Java是可以实现"多继承"的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<h2> 多态</h2>
<p>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征</p>
<p>因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为向上转型，向上转型由系统自动完成。</p>
<p>当把一个子类对象直接赋给父类引用变量时，例如 BaseClass obj = new SubClass(); ，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是表现出子类方法的行为特征，而不是父类方法的行为特征，这就可能出现：相同类型的变量、调用同一个方法时呈现出多种不同的行为特征，这就是多态。</p>
<h3> 多态的实现</h3>
<p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。</p>
<p>在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。</p>
<ul>
<li>对于父类型，可以有三种形式，即普通的类、抽象类、接口</li>
<li>对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法<br>
具体案例如下：</li>
</ul>
<p>多态可以提高程序的可扩展性，在设计程序时让代码更加简洁而优雅。</p>
<p>例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设计上述代码时，我已采用了重载机制，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 driver.drive(obj) 这样的方式来调用，对调用者足够的友好。</p>
<p>但对于程序的开发者来说，这显得繁琐，因为实际上这个司机可以驾驶更多的交通工具。</p>
<p>当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，类似的代码会堆积的越来越多，显得臃肿。</p>
<p>采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具定义一个父类Vehicle，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vehicle子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 类(对象)之间的关系</h2>
<h3> UML类图</h3>
<p>类之间的关系，类与接口之间关系可以分一下几种</p>
<ul>
<li>泛化关系(Generalization)</li>
<li>实现关系 (Realization)</li>
<li>聚合关系 (Aggregation)</li>
<li>组合关系 (Composition)</li>
<li>关联关系 (Association)</li>
<li>依赖关系 (Dependency)</li>
</ul>
<figure><figcaption>img_19.png</figcaption></figure>
<h3> 泛化关系 (Generalization)</h3>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<figure><figcaption>img_18.png</figcaption></figure>
<h3> 实现关系 (Realization)</h3>
<p>用来实现一个接口，在 Java 中使用 implement 关键字。</p>
<figure><figcaption>img_20.png</figcaption></figure>
<h3> 聚合关系 (Aggregation)</h3>
<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<figure><figcaption>img_21.png</figcaption></figure>
<h3> 组合关系 (Composition)</h3>
<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。<br>
</p>
<h3> 关联关系 (Association)</h3>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。</p>
<p>因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<figure><figcaption>img_23.png</figcaption></figure>
<h3> 依赖关系 (Dependency)</h3>
<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。</p>
<p>A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类中的(某中方法的)局部变量；</li>
<li>A 类是 B 类方法当中的一个参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化；</li>
</ul>
<figure><figcaption>img_24.png</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2024-01-30T01:34:07.000Z</published>
  </entry>
  <entry>
    <title type="text">Java ReentrantLock锁的设计思想</title>
    <id>https://ujava.cn/java/reentrantlock.html</id>
    <link href="https://ujava.cn/java/reentrantlock.html"/>
    <updated>2024-01-29T08:13:44.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、开头</h2>
<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。<br>
主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题：</p>
<ul>
<li>线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度</li>
<li>过多线程造成线程之间的上下文切换，导致效率低下</li>
</ul>
<p>因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。”<br>
简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 一、开头</h2>
<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。<br>
主要原因是，对于多线程实现实现并发，一直以来，多线程都存在2个问题：</p>
<ul>
<li>线程之间内存共享，需要通过加锁进行控制，但是加锁会导致性能下降，同时复杂的加锁机制也会增加编程编码难度</li>
<li>过多线程造成线程之间的上下文切换，导致效率低下</li>
</ul>
<p>因此，在并发编程领域中，一直有一个很重要的设计原则： “ 不要通过内存共享来实现通信，而应该通过通信来实现内存共享。”<br>
简单来说，就是尽可能通过消息通信，而不是内存共享来实现进程或者线程之间的同步。</p>
<h2> 二、关健术语</h2>
<p>本文用到的一些关键词语以及常用术语，主要如下：</p>
<ul>
<li>并发(Concurrent): 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</li>
<li>并行(Parallel): 当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行。</li>
<li>信号量(Semaphore):  是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用，也是作系统用来解决并发中的互斥和同步问题的一种方法。</li>
<li>信号量机制(Semaphores)： 用来解决同步/互斥的问题的，它是1965年,荷兰学者 Dijkstra提出了一种卓有成效的实现进程互斥与同步的方法。</li>
<li>管程(Monitor) :  一般是指管理共享变量以及对共享变量的操作过程，让它们支持并发的一种机制。</li>
<li>互斥(Mutual Exclusion)：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。即就是同一时刻只允许一个线程访问共享资源的问题。</li>
<li>同步(Synchronization)：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。即就是线程之间如何通信、协作的问题。</li>
<li>对象池(Object Pool): 指的是一次性创建出 N 个对象，之后所有的线程重复利用这 N 个对象，当然对象在被释放前，也是不允许其他线程使用的, 一般指保存实例对象的容器。</li>
</ul>
<h2> 三、基本概述</h2>
<p>在Java领域中，我们可以将锁大致分为基于Java语法层面(关键词)实现的锁和基于JDK层面实现的锁。</p>
<p>在Java领域中, 尤其是在并发编程领域，对于多线程并发执行一直有两大核心问题：同步和互斥。其中：</p>
<ul>
<li>互斥(Mutual Exclusion)：一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。即就是同一时刻只允许一个线程访问共享资源的问题。</li>
<li>同步(Synchronization)：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。即就是线程之间如何通信、协作的问题。<br>
针对对于这两大核心问题，利用管程是能够解决和实现的，因此可以说，管程是并发编程的万能钥匙。<br>
虽然，Java在基于语法层面(synchronized 关键字)实现了对管程技术,但是从使用方式和性能上来说，内置锁(synchronized 关键字)的粒度相对过大，不支持超时和中断等问题。<br>
为了弥补这些问题，从JDK层面对其“重复造轮子”，在JDK内部对其重新设计和定义，甚至实现了新的特性。<br>
在Java领域中，从JDK源码分析来看，基于JDK层面实现的锁大致主要可以分为以下4种方式：</li>
</ul>
<figure><figcaption>img_10.png</figcaption></figure>
<ul>
<li>基于Lock接口实现的锁：JDK1.5版本提供的ReentrantLock类</li>
<li>基于ReadWriteLock接口实现的锁：JDK1.5版本提供的ReentrantReadWriteLock类</li>
<li>基于AQS基础同步器实现的锁：JDK1.5版本提供的并发相关的同步器Semaphore，CyclicBarrier以及CountDownLatch等�</li>
<li>基于自定义API操作实现的锁：JDK1.8版本中提供的StampedLock类<br>
从阅读源码不难发现，在Java SDK 并发包主要通过AbstractQueuedSynchronizer(AQS)实现多线程同步机制的封装与定义，而通过Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题。</li>
</ul>
<h3> 1.AQS基础同步器基本理论</h3>
<p>在Java领域中,同步器是专门为多线程并发设计的同步机制，主要是多线程并发执行时线程之间通过某种共享状态来实现同步，只有当状态满足这种条件时线程才往下执行的一种同步机制。</p>
<figure><figcaption>img_11.png</figcaption></figure>
<p>一个标准的AQS同步器主要有同步状态机制，等待队列，条件队列，独占模式，共享模式等五大核心要素组成。<br>
在Java领域中，JDK的JUC(java.util.concurrent.)包中提供了各种并发工具，但是大部分同步工具的实现基于AbstractQueuedSynchronizer类实现，其内部结构主要如下：</p>
<ul>
<li>
<p>同步状态机制(Synchronization Status)：主要用于实现锁(Lock)机制，是指同步状态，其要求对于状态的更新必须原子性的</p>
</li>
<li>
<p>等待队列(Wait Queue)：主要用于存放等待线程获取到的锁资源，并且把线程维护到一个Node(节点)里面和维护一个非阻塞的CHL Node FIFO(先进先出)队列，主要是采用自旋锁+CAS操作来保证节点插入和移除的原子性操作。</p>
</li>
<li>
<p>条件队列(Condition Queue)：用于实现锁的条件机制，一般主要是指替换“等待-通知”工作机制，主要是通过ConditionObject对象实现Condition接口提供的方法实现。</p>
</li>
<li>
<p>独占模式(Exclusive Mode)：主要用于实现独占锁，主要是基于静态内部类Node的常量标志EXCLUSIVE来标识该节点是独占模式</p>
</li>
<li>
<p>共享模式(Shared Mode)：主要用于实现共享锁，主要是基于静态内部类Node的常量标志SHARED来标识该节点是共享模式<br>
我们可以得到一个比较通用的并发同步工具基础模型，大致包含如下几个内容，其中：<br>
</p>
</li>
<li>
<p>条件变量(Conditional Variable)： 利用线程间共享的变量进行同步的一种工作机制</p>
</li>
<li>
<p>共享变量((Shared Variable))：一般指对象实体对象的成员变量和属性</p>
</li>
<li>
<p>阻塞队列(Blocking Queue)：共享变量(Shared Variable)及其对共享变量的操作统一封装</p>
</li>
<li>
<p>等待队列(Wait Queue)：每个条件变量都对应有一个等待队列(Wait Queue),内部需要实现入队操作(Enqueue)和出队操作(Dequeue)方法</p>
</li>
<li>
<p>变量状态描述机(Synchronization Status)：描述条件变量和共享变量之间状态变化，又可以称其为同步状态</p>
</li>
<li>
<p>工作模式(Operation Mode)： 线程资源具有排他性，因此定义独占模式和共享模式两种工作模式<br>
综上所述，条件变量和等待队列的作用是解决线程之间的同步问题；共享变量与阻塞队列的作用是解决线程之间的互斥问题。</p>
</li>
</ul>
<h3> 2. JDK显式锁统一概念模型</h3>
<p>在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。</p>
<figure><figcaption>img_13.png</figcaption></figure>
<p>综合Java领域中的并发锁的各种实现与应用分析来看，一把锁或者一种锁，基本上都会包含以下几个方面：</p>
<ul>
<li>锁的同步器工作机制：主要是考虑共享模式还是独享模式，是否支持超时机制，以及是否支持超时机制？</li>
<li>锁的同步器工作模式：主要是基于AQS基础同步器封装内部同步器，是否考虑公平/非公平模式？</li>
<li>锁的状态变量机制： 主要锁的状态设置，是否共享状态变量？</li>
<li>锁的队列封装定义：主要是指等待队列和条件队列，是否需要条件队列或者等待队列定义？</li>
<li>锁的底层实现操作： 主要是指底层CL锁和CAS操作，是否需要考虑自旋锁或者CAS操作实例对象方法？</li>
<li>锁的组合实现新锁： 主要是基于独占锁和共享锁，是否考虑对应API自定义操作实现？<br>
综上所述，大致可以根据上述这些方向，我们便可以清楚知道Java领域中各种锁实现的基本理论时和实现思想。</li>
</ul>
<h3> 3.ReentrantLock(可重入锁)的设计与实现</h3>
<p>在Java领域中，ReentrantLock(可重入锁)是针对于Java多线程并发控制中对一个线程可以多次对某个锁进行加锁操作，主要是基于内置的AQS基础抽象队列同步器实现的一种并发控制工具类。</p>
<figure><figcaption>img_14.png</figcaption></figure>
<p>一般来说，对于同一个线程是否可以重复占有同一个锁对象的角度来分，大致主要可以分为可重入锁与不可重入锁。其中：</p>
<ul>
<li>可重入锁：一个线程可以多次抢占同一个锁，也就意味着能够支持一个线程对资源的重复加锁，或者说，一个线程可以多次进入同一个锁所同步的临界区代码块。</li>
<li>不可重入锁：一个线程只能抢占一次同一个锁，也就意味着在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能等待，只有拥有锁的线程释放了锁后，其他的线程才能够获取锁。</li>
</ul>
<p>ReentrantLock是JDK中显式锁一个主要基于Lock接口API实现的基础实现类，拥有与内置锁(synchronized)相同的并发性和内存语义，同时提供了限时抢占、可中断抢占等一些高级锁特性。<br>
除此之外，ReentrantLock基于内置的AQS基础抽象队列同步器实现，在线程参与锁资源竞争比较激烈的场景下，能表现出比内置锁较佳的性能。<br>
而且，ReentrantLock是一种独占锁，在独占模式下只能逐一使用锁，也就是说，任意时刻最多只会有一个线程持有锁的控制权。</p>
<ol>
<li>
<h4> 设计思想</h4>
</li>
</ol>
<figure><figcaption>img_15.png</figcaption></figure>
<p>ReentrantLock类最早是在JDK1.5版本提供的，从设计思想上来看，主要包括同步器工作模式，获取锁方法，释放锁方法以及定义Condition队列方法等4个核心要素。其中：</p>
<ul>
<li>实现Lock接口 ：主要基于Lock接口API实现对应方法，拥有与内置锁(synchronized)相同的并发性和内存语义，用于支持和解决解决互斥问题。</li>
<li>同步器工作模式：基于AQS基础抽象队列同步器封装内置实现一个静态的内置同步器抽象类，然后基于这个抽象类分别实现了公平同步器和非公平同步器，用来指定和描述同步器工作模式是公平模式还是非公平模式。</li>
<li>公平/非公平模式：主要描述的是多个线程在同时获取锁时是否按照先到先得的顺序获取锁，如果是则为公平模式，否则为非公平模式。</li>
<li>获取锁方法：主要定义了一个lock()方法来获取锁，表示假如锁已经被其他线程占有或持有，其当前获取锁的线程则进入等待状态。</li>
<li>释放锁方法：主要定义了一个unlock()方法来释放锁，表示假如锁已经被其他线程放弃或释放，其当前获取锁的线程则获得该锁。</li>
<li>定义Condition队列操作方法： 主要是基于Condition接口来定义一个方法实现锁的条件机制，用于支持线程的阻塞和唤醒功能即就是解决同步问题，也就是我们说的线程间的通信方式。</li>
<li>定义等待队列操作方法： 主要是依据条件队列来时进行对应的操作，间接适配AQS基础同步器中对于等待队列的功能，保证获取锁的顺序的公平性</li>
</ul>
<ol start="2">
<li>
<h4> 基本实现</h4>
</li>
</ol>
<figure><figcaption>img_16.png</figcaption></figure>
<p>在ReentrantLock类的JDK1.8版本中，对于ReentrantLock的基本实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>内部同步器：基于AQS基础同步器封装和定义了一个静态内部Sync抽象类，其中抽象了一个内置锁lock()方法</li>
<li>同步器工作模式：提供了 2个构造方法，其中无参数构造方法表示的是默认的工作模式，有参数构造方法主要依据参数来实现指定的工作模式</li>
<li>获取锁： 主要是提供了lock()方法，调用的静态内部Sync抽象类内置锁lock()方法，而本质上是AQS同步器中的acquire()方法</li>
<li>释放锁： 主要是提供了unlock()方法，而本质上是调用的AQS同步器中的release()方法</li>
<li>创建条件队列： 主要是基于Condition接口定义了newCondition() 方法，调用的静态内部Sync抽象类ewCondition()方法，而本质上是调用的AQS同步器中的ConditionObject中的newCondition()方法</li>
</ul>
<p><strong>2.1 基于AQS同步器封装静态内部Sync抽象类</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>Sync类：FairSync公平同步器和NonfairSync非公平同步器的抽象父类。</li>
<li>校验isHeldExclusively()方法： ReentrantLock锁是属于独占模式，需要当前锁持有线程与当前线程是否一致</li>
<li>nonfairTryAcquire()方法： 一般主要用于非公平模式获取锁，其核心是compareAndSetState方法和setExclusiveOwnerThread方法</li>
<li>tryRelease()方法： 其公平/非公平模式都是通过ryRelease()来释放锁操作</li>
<li>newCondition()方法： 基于AQS同步器的ConditionObject对象封装实现，提供给 ReentrantLock类使用</li>
<li>私有readObject()方法：对于输入的对象进行流化处理</li>
</ul>
<p>特别需要注意的是，我们需要重点关注nonfairTryAcquire()方法和tryRelease()方法，其中：</p>
<ul>
<li>获取非公平锁 nonfairTryAcquire()方法：主要是用于获取AQS的状态变量status，其默认取值范围是0和1，其中，0表示未被加锁，1表示已经被加锁</li>
<li>如果状态变量status=0，使用compareAndSetState方法进行CAS原子修改操作，把状态变量修改为1，并且通过setExclusiveOwnerThread设置当前线程为锁的持有线程</li>
<li>如果状态变量status=1，表示当前线程为锁的持有线程，正在进入锁重入操作，状态变量累加1，超过重入次数时，会抛出throw new Error(“Maximum lock count exceeded”)</li>
<li>释放锁tryRelease()方法：主要是检查当前线程是否为锁持有线程，随后AQS同步器状态变量减1，如果不是 throw new IllegalMonitorStateException()</li>
<li>如果状态变量status=0，表示锁已经释放成功，通过setExclusiveOwnerThread设置锁的持有线程为null，也就是置空锁的持有线程</li>
<li>如果状态变量status !=0,  需要状态变量递减1即可，直到锁已经释放成功</li>
</ul>
<p><strong>2.2 基于Sync抽象类封装FairSync公平同步器</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>实现方式： 主要基于AQS封装的内部静态抽象Sync同步类实现，使用的AQS的独占模式。</li>
<li>主要方法： 主要提供了lock()和tryAcquire()方法，其严格意义上来说，仅仅只是实现了tryAcquire()方法，但是最关键的使用hasQueuedPredecessors来保证了锁的公平性。</li>
<li>锁获取方式： 主要是采用完全通过队列来实现实现公平机制，即就是检查是否存在等待队列，如果队列之中已经存在其他线程，直接放弃操作。</li>
</ul>
<p><strong>2.3 基于Sync抽象类封装NonfairSync非公平同步器</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>实现方式： 主要基于AQS封装的内部静态抽象Sync同步类实现，使用的AQS的独占模式。</li>
<li>主要方法： 主要提供了lock()和tryAcquire()方法，其严格意义上来说，仅仅只是实现了tryAcquire()方法，直接调用了Sync同步类的nonfairTryAcquire()方法。</li>
<li>锁获取方式： 主要是采用闯入策略来打破锁的公平，也就是一般准备获取锁的线程会先尝试获取锁，失败之后才进入队列中。</li>
</ul>
<h2> 3. 具体实现</h2>
<p><br>
在ReentrantLock类的JDK1.8版本中，对于ReentrantLock的具体实现如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>获取锁的方法：主要提供了一般模式lock()方法，支持可中断机制lockInterruptibly()方法，无参数tryLock()方法以及有参数的支持超时机制的tryLock(long timeout, TimeUnit unit)方法</li>
<li>释放锁的方法：主要是unlock()方法，间接调用是内部同步器中的release()方法</li>
<li>条件队列操作：主要提供了获取队列中的线程对象getQueuedThreads()，检测队列入队hasWaiters(Condition condition) 方法，以及</li>
<li>等待队列操作：主要提供了获取队列中的线程对象getWaitingThreads(Condition condition)，检测队列入队hasQueuedThread(Thread thread) 方法，以及获取队列长度getQueueLength()方法和getWaitingThreads(Condition condition)方法</li>
<li>其他检测判断：主要有判断是否公平模式isFair()方法，是否当前线程独占isHeldByCurrentThread()方法，以及是否加锁 isLocked()等</li>
</ul>
<p>需要注意的是，在JDK1.8版本之后，对于ReentrantLock的实现有些细微的变化，感兴趣的可自行参考相关版本的源码进行对比分析。</p>
<p>综上所述，从一定意义上讲，ReentrantLock是一种可重入的独占(互斥)锁，属于AQS基础抽象队列同步器中独占模式孵化的产物，支持公平模式与非公平模式，默认采用非公平模式。</p>
<h2> 最后</h2>
<p>通过对Java领域中，JDK内部提供的各种锁的实现来看，一直围绕的核心主要还是基于AQS基础同步器来实现的，但是AQS基础同步器不是一种非它不可的技术标准规范，更多的只是一套技术参考指南。</p>
<p>但是，实际上，Java对于锁的实现与运用远远不止这些，还有相位器(Phaser)和交换器(Exchanger),以及在Java JDK1.8版本之前并发容器ConcurrentHashMap中使用的分段锁(Segment)。</p>
<p>不论是何种实现和应用，在Java并发编程领域来讲，都是围绕线程安全问题的角度去考虑的，只是针对于各种各样的业务场景做的具体的实现。</p>
<p>一定意义上来讲，对线程加锁只是并发编程的实现方式之一，相对于实际应用来说，Java领域中的锁都只是一种单一应用的锁，只是给我们掌握Java并发编程提供一种思想没，三言两语也不可能详尽。</p>
<p>到此为止，这算是对于Java领域中并发锁的最终章，文中表述均为个人看法和个人理解，如有不到之处，忘请谅解也请给予批评指正。</p>
]]></content>
    <category term="Java"/>
    <published>2024-01-29T08:06:37.000Z</published>
  </entry>
  <entry>
    <title type="text">JDK源码中用到的23种设计模式</title>
    <id>https://ujava.cn/java/jdkdesign.html</id>
    <link href="https://ujava.cn/java/jdkdesign.html"/>
    <updated>2024-01-25T01:31:49.000Z</updated>
    <summary type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F">创建模式</a>
<ul>
<li><a href="#singleton%E5%8D%95%E4%BE%8B">Singleton(单例)</a></li>
<li><a href="#abstract-factory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">Abstract factory(抽象工厂)</a></li>
<li><a href="#factory%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">Factory(工厂方法)</a></li>
<li><a href="#builder%E5%BB%BA%E9%80%A0%E8%80%85">Builder(建造者)</a></li>
<li><a href="#prototype%E5%8E%9F%E5%9E%8B">Prototype(原型)</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F">结构模式</a>
<ul>
<li><a href="#adapter%E9%80%82%E9%85%8D%E5%99%A8">Adapter(适配器)</a></li>
<li><a href="#composite%E7%BB%84%E5%90%88">Composite(组合)</a></li>
<li><a href="#decorator%E8%A3%85%E9%A5%B0%E5%99%A8">Decorator(装饰器)</a></li>
<li><a href="#facade%E9%97%A8%E9%9D%A2">Facade(门面)</a></li>
<li><a href="#flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">Flyweight(享元模式)</a></li>
<li><a href="#proxy%E4%BB%A3%E7%90%86">Proxy(代理)</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F">行为模式</a>
<ul>
<li><a href="#chain-of-responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE">Chain of Responsibility(责任链)</a></li>
<li><a href="#command%E5%91%BD%E4%BB%A4">Command(命令)</a></li>
<li><a href="#interpreter%E8%A7%A3%E9%87%8A%E5%99%A8">Interpreter(解释器)</a></li>
<li><a href="#iterator%E8%BF%AD%E4%BB%A3%E5%99%A8">Iterator(迭代器)</a></li>
<li><a href="#mediator%E4%B8%AD%E4%BB%8B">Mediator(中介)</a></li>
<li><a href="#memento%E5%BF%AB%E7%85%A7-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">Memento(快照-备忘录模式)</a></li>
<li><a href="#observer%E8%A7%82%E5%AF%9F%E8%80%85">Observer(观察者)</a></li>
<li><a href="#state%E7%8A%B6%E6%80%81">State(状态)</a></li>
<li><a href="#strategy%E7%AD%96%E7%95%A5">Strategy(策略)</a></li>
<li><a href="#template%E6%A8%A1%E6%9D%BF">Template(模板)</a></li>
<li><a href="#visitor%E8%AE%BF%E9%97%AE%E8%80%85">Visitor(访问者)</a></li>
</ul>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F">创建模式</a>
<ul>
<li><a href="#singleton%E5%8D%95%E4%BE%8B">Singleton(单例)</a></li>
<li><a href="#abstract-factory%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">Abstract factory(抽象工厂)</a></li>
<li><a href="#factory%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">Factory(工厂方法)</a></li>
<li><a href="#builder%E5%BB%BA%E9%80%A0%E8%80%85">Builder(建造者)</a></li>
<li><a href="#prototype%E5%8E%9F%E5%9E%8B">Prototype(原型)</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F">结构模式</a>
<ul>
<li><a href="#adapter%E9%80%82%E9%85%8D%E5%99%A8">Adapter(适配器)</a></li>
<li><a href="#composite%E7%BB%84%E5%90%88">Composite(组合)</a></li>
<li><a href="#decorator%E8%A3%85%E9%A5%B0%E5%99%A8">Decorator(装饰器)</a></li>
<li><a href="#facade%E9%97%A8%E9%9D%A2">Facade(门面)</a></li>
<li><a href="#flyweight%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">Flyweight(享元模式)</a></li>
<li><a href="#proxy%E4%BB%A3%E7%90%86">Proxy(代理)</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F">行为模式</a>
<ul>
<li><a href="#chain-of-responsibility%E8%B4%A3%E4%BB%BB%E9%93%BE">Chain of Responsibility(责任链)</a></li>
<li><a href="#command%E5%91%BD%E4%BB%A4">Command(命令)</a></li>
<li><a href="#interpreter%E8%A7%A3%E9%87%8A%E5%99%A8">Interpreter(解释器)</a></li>
<li><a href="#iterator%E8%BF%AD%E4%BB%A3%E5%99%A8">Iterator(迭代器)</a></li>
<li><a href="#mediator%E4%B8%AD%E4%BB%8B">Mediator(中介)</a></li>
<li><a href="#memento%E5%BF%AB%E7%85%A7-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F">Memento(快照-备忘录模式)</a></li>
<li><a href="#observer%E8%A7%82%E5%AF%9F%E8%80%85">Observer(观察者)</a></li>
<li><a href="#state%E7%8A%B6%E6%80%81">State(状态)</a></li>
<li><a href="#strategy%E7%AD%96%E7%95%A5">Strategy(策略)</a></li>
<li><a href="#template%E6%A8%A1%E6%9D%BF">Template(模板)</a></li>
<li><a href="#visitor%E8%AE%BF%E9%97%AE%E8%80%85">Visitor(访问者)</a></li>
</ul>
</li>
</ul>
<!-- TOC -->
<h1> 创建模式</h1>
<h2> Singleton(单例)</h2>
<p>只允许一个实例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Abstract factory(抽象工厂)</h2>
<p>创建一组有关联的对象实例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Factory(工厂方法)</h2>
<p>按照需求返回一个类型的实例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Builder(建造者)</h2>
<p>主要用来简化一个复杂对象的创建。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Prototype(原型)</h2>
<p>使用自己的实例创建另外一个实例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 结构模式</h1>
<h2> Adapter(适配器)</h2>
<p>可通过创建方法识别采用不同抽象/接口类型的实例，并返回自己/抽象/接口类型的实现，其装饰/覆盖给定实例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Composite(组合)</h2>
<p>让使用者将单独对象和组合对象混用。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Decorator(装饰器)</h2>
<p>为一个对象动态地加上一系列动作，而不需要因为这些动作的不同产生大量的继承类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Facade(门面)</h2>
<p>一个简单的接口包装一组组件、接口、抽象或者子系统。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Flyweight(享元模式)</h2>
<p>使用缓存来加速大量小对象的访问时间。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Proxy(代理)</h2>
<p>用一个简单的对象代替一个复杂的对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1> 行为模式</h1>
<h2> Chain of Responsibility(责任链)</h2>
<p>一个对象在一个链接传递直到被处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Command(命令)</h2>
<p>将一系列命令封装成在一个类中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Interpreter(解释器)</h2>
<p>定义语言的文法，并且建立一个解释器来解释该语言中的句子。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Iterator(迭代器)</h2>
<p>对象遍历。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mediator(中介)</h2>
<p>用一个中介对象来封装一系列关于对象交互行为。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Memento(快照-备忘录模式)</h2>
<p>保存另外一个对象内部状态拷贝的对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Observer(观察者)</h2>
<p>事件监听器。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> State(状态)</h2>
<p>不同的状态，不同的行为；或者说每个状态有相应的行为。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Strategy(策略)</h2>
<p>定义一系列算法，把这些算法一个一个封装成单独的类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Template(模板)</h2>
<p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Visitor(访问者)</h2>
<p>作用于某个对象群中各个对象的操作，它可以使你在不改变这些对象本身的情况下，定义作用于这些对象的新操作。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="Java"/>
    <published>2024-01-25T00:56:50.000Z</published>
  </entry>
  <entry>
    <title type="text">Java核心包结构设计思想</title>
    <id>https://ujava.cn/java/package.html</id>
    <link href="https://ujava.cn/java/package.html"/>
    <updated>2024-01-24T03:14:02.000Z</updated>
    <summary type="html"><![CDATA[<p>在研读 JDK 源码之前，先了解 JDK 几个核心包的设计思想，将有助于我们理解当初的设计者们的意图，让我们更能体会到设计者的良苦用心。</p>
<h2> 1 java.lang 语言包</h2>
<p>提供利用 Java 编程语言进行程序设计的基础类。最重要的类是 Object（类层次结构的根）和 Class（其实例表示正在运行的应用程序中的类）。</p>
<p>把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float 和 Double 就是用于这个目的。例如，一个 Double 类型的对象包含了一个类型为 double 的字段，这表示如果引用某个值，则可以将该值存储在引用类型的变量中。这些类还提供了大量用于转换基值的方法，并支持一些标准方法，比如 equals 和 hashCode。Void 类是一个非实例化的类，它保持一个对表示基本类型 void 的 Class 对象的引用。</p>]]></summary>
    <content type="html"><![CDATA[<p>在研读 JDK 源码之前，先了解 JDK 几个核心包的设计思想，将有助于我们理解当初的设计者们的意图，让我们更能体会到设计者的良苦用心。</p>
<h2> 1 java.lang 语言包</h2>
<p>提供利用 Java 编程语言进行程序设计的基础类。最重要的类是 Object（类层次结构的根）和 Class（其实例表示正在运行的应用程序中的类）。</p>
<p>把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float 和 Double 就是用于这个目的。例如，一个 Double 类型的对象包含了一个类型为 double 的字段，这表示如果引用某个值，则可以将该值存储在引用类型的变量中。这些类还提供了大量用于转换基值的方法，并支持一些标准方法，比如 equals 和 hashCode。Void 类是一个非实例化的类，它保持一个对表示基本类型 void 的 Class 对象的引用。</p>
<p>类 Math 提供了常用的数学函数，比如正弦、余弦和平方根。类似地，类 String 和 StringBuffer 提供了常用的字符串操作。</p>
<p>类 ClassLoader、Process、Runtime、SecurityManager 和 System 提供了管理类的动态加载、外部进程创建、主机环境查询（比如时间）和安全策略实施等“系统操作”。</p>
<p>类 Throwable 包含了可能由 throw 语句抛出的对象。Throwable 的子类表示错误和异常。</p>
<p><strong>字符编码</strong></p>
<p>java.nio.charset.Charset 类的规范描述了字符编码的命名约定，以及每个 Java 平台实现必须支持的标准编码集。</p>
<h2> 2 java.util</h2>
<p><strong>简介</strong></p>
<p>包含 collection 框架、遗留的 collection 类、事件模型、日期和时间工具、国际化和各种实用的工具类（字符串标记生成器、随机数生成器和位数组）。</p>
<p>限于篇幅和重要性，我们这里只讨论最常用的 collection 容器类库的设计规划。</p>
<p>Java平台包括一个集合框架。集合是代表一组对象的对象（例如经典的Vector类）。集合框架是用于表示和操作集合的统一体系结构，使集合可以独立于实现细节进行操作。</p>
<p>集合框架的主要优点是：</p>
<ul>
<li>通过提供数据结构和算法来减少编程工作，因此不必自己实现它们</li>
<li>通过提供数据结构和算法的高性能实现来提高性能。因为每个接口的各种实现都是可互换的，所以可以通过切换实现来调整程序</li>
<li>通过建立公共语言来回传递集合，从而在不相关的API之间提供互操作性</li>
<li>通过要求您学习多个临时集合API，减少了学习API所需的工作量</li>
<li>通过不需要生成临时集合API，减少了设计和实现API所需的工作量</li>
<li>通过为集合和用于操作集合的算法提供标准接口，促进软件重用</li>
</ul>
<p>集合框架包括：</p>
<ul>
<li>Collection接口。表示不同类型的集合，例如set，list和map。这些接口构成了框架的基础</li>
<li>通用实现。集合接口的主要实现</li>
<li>旧版实现。改造了早期版本的Vector和Hashtable的收集类，以实现集合接口</li>
<li>特殊用途的实现。设计用于特殊情况的实现。这些实现显示非标准的性能特征，使用限制或行为</li>
<li>并发实现。专为高度并发使用而设计的实现，下一节具体描述</li>
<li>包装器实现。向其他实现中添加功能，例如同步</li>
<li>便利的实现。集合接口的高性能“微型实现”</li>
<li>抽象实现。集合接口的部分实现可简化自定义实现</li>
<li>算法。对集合执行有用功能的静态方法，例如对列表进行排序</li>
<li>基础设施。为集合接口提供基本支持的接口</li>
<li>数组实用程序。原始类型和引用对象数组的实用程序函数。严格来讲，它不是集合框架的一部分，而是与集合框架同时添加到Java平台，并且依赖于某些相同的基础结构。</li>
</ul>
<p><strong>集合接口</strong></p>
<p>分为两组。最基本的接口java.util.Collection具有以下子类或接口：<br>
</p>
<p>其他集合接口基于java.util.Map，而不是真实的集合。但是，这些接口包含集合视图操作，使它们可以作为集合进行操作。map具有以下子类：<br>
</p>
<p>集合接口中的许多修改方法都标记为可选。允许实现不执行这些操作中的一项或多项，如果尝试执行，则会抛出运行时异常（UnsupportedOperationException）。每个实现的文档必须指定支持哪些可选操作。引入了一些术语以帮助该规范：</p>
<ul>
<li>
<p>不支持修改操作（例如添加，删除和清除）的集合称为unmodifiable。非不可修改的集合是modifiable</p>
</li>
<li>
<p>另外保证不可见Collection对象中的任何更改的集合称为immutable。非不可更改的集合是mutable</p>
</li>
<li>
<p>即使元素可以更改，也要保证其大小保持不变的列表称为 fixed-size。非固定大小的列表称为variable-size。</p>
</li>
<li>
<p>支持快速（通常为固定时间）索引元素访问的列表称为random access列表。不支持快速索引元素访问的列表称为sequential access列表。 RandomAccess标记接口使列表能够公布它们支持随机访问的事实。这使得通用算法在应用于随机或顺序访问列表时，可以更改其行为以提供良好的性能。<br>
一些实现限制了可以存储哪些元素（或在Maps中，键和值）。可能的限制包括要求元素：</p>
</li>
<li>
<p>属于特定类型</p>
</li>
<li>
<p>不为空</p>
</li>
<li>
<p>服从一些任意谓词<br>
尝试添加违反实现限制的元素会导致运行时异常，通常是ClassCastException，IllegalArgumentException或NullPointerException。尝试删除或测试是否存在违反实现限制的元素会导致异常。一些受限制的集合允许这种用法。</p>
</li>
</ul>
<p><strong>集合实现</strong></p>
<p>实现collection接口的类通常以Implementation-style Interface的形式来命名。下表总结了通用实现：<br>
</p>
<p>通用实现支持集合接口中的所有可选操作，并且对它们可能包含的元素没有限制。它们是不同步的，但是Collections类包含称为同步包装器的静态工厂，可用于将同步添加到许多未同步的集合中。所有新的实现都有fail-fast迭代器，该迭代器检测无效的并发修改，并且快速而干净地失败（而不是行为异常）。</p>
<p>AbstractCollection，AbstractSet，AbstractList，AbstractSequentialList和AbstractMap类提供了核心集合接口的基本实现，以最大程度地减少实现它们所需的工作量。这些类的API文档精确地描述了每种方法的实现方式，因此，在特定实现的基本操作得以执行的情况下，实现者知道必须重写哪些方法。</p>
<p><strong>并发容器</strong></p>
<p>使用来自多个线程的集合的应用程序必须经过仔细地编程。通常，这称为并发编程。 Java平台包括对并发编程的广泛支持。</p>
<p>集合是如此频繁地使用，以至于各种并发友好接口和集合的实现都包含在API中。这些类型超出了前面讨论的同步包装程序的范围，可提供并发编程中经常需要的功能。</p>
<p>这些并发感知接口可用：<br>
</p>
<p>可以使用以下并发感知实现类。</p>
<figure><figcaption>img_4.png</figcaption></figure>
<p><strong>设计目标</strong></p>
<p>主要设计目标是生产一种尺寸更小且更重要的是“概念重量”的API。至关重要的是，新功能与当前的Java程序员似乎并没有太大区别。它必须增加现有设施，而不是更换它们。同时，新的API必须足够强大才能提供先前描述的所有优点。</p>
<p>为了使核心接口的数量保持较小，接口不会尝试捕获诸如可变性，可修改性和可缩放性之类的细微差别。相反，核心接口中的某些调用是可选的，从而使实现可以引发UnsupportedOperationException来指示它们不支持指定的可选操作。集合实现者必须清楚地记录实现支持哪些可选操作。</p>
<p>为了使每个核心接口中的方法数量保持较小，接口仅在满足以下任一条件时才包含方法：</p>
<ul>
<li>这是真正的基本操作：可以合理定义其他基本操作的基本操作</li>
<li>有一个令人信服的性能原因，为什么重要的实现要覆盖它</li>
</ul>
<p>至关重要的是，所有合理的馆藏表现形式必须能够良好地互操作。这包括数组，如果不更改语言就不能直接实现Collection接口。因此，该框架包括以下方法：使集合能够移动到数组中，将数组视为集合，将map视为集合。</p>
<h2> 3 java.util.concurrent</h2>
<p>从JDK1.5版本开始提供：在并发编程中很常用的实用工具类。该包涵盖几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。</p>
<p>下面简要描述主要的组件。</p>
<h3> 3.1 执行器（Executors）</h3>
<p><strong>接口</strong></p>
<p>Executor 是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。</p>
<p>根据所使用的具体 Executor 类的不同，任务们可能在新创建的线程中、已有的任务执行线程中或者调用 execute() 的线程中执行，并且可能顺序或并发执行。</p>
<ul>
<li>ExecutorService 提供了多个完整的异步任务执行框架。</li>
</ul>
<figure><figcaption>img_5.png</figcaption></figure>
<p>ExecutorService 管理任务的排队和安排，并允许受控的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。</p>
<p>Future 返回函数的结果，允许确定执行是否完成，并提供取消任务执行的方法。</p>
<p>RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。</p>
<p><strong>实现</strong></p>
<p>类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体实现类 FutureTask，它提供了 Future 的常见可扩展实现，以及 ExecutorCompletionService 有助于协调对异步任务组的处理。</p>
<p>ForkJoinPool类提供了一个Executor，主要用于处理ForkJoinTask及其子类的实例。这些类使用工作窃取调度程序，该任务调度程序可满足符合计算密集型并行处理中经常存在的限制的任务的高吞吐量。</p>
<h3> 3.2 队列</h3>
<p>ConcurrentLinkedQueue 类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。ConcurrentLinkedDeque类与此类似，但是还支持Deque接口。</p>
<p>java.util.concurrent 包中的五个实现都支持扩展的 BlockingQueue 接口。该接口定义了 put 和 take 的阻塞版本：<br>
</p>
<p>这些不同的类覆盖了生产者-消费者、消息传递、任务并行执行和相关并发设计的大多数常见模型的上下文。</p>
<p>扩展接口TransferQueue及其实现LinkedTransferQueue引入了同步的传输方法（以及相关功能），生产者可以选择阻塞等待其消费者。</p>
<p>BlockingDeque 接口继承了 BlockingQueue，以支持 FIFO 和 LIFO（基于栈）操作。LinkedBlockingDeque 类就提供了这样一个实现。</p>
<h3> 3.3 超时</h3>
<p>TimeUnit 类为指定和控制基于超时的操作提供了多层粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，都包含了基于超时机制的操作。</p>
<p>在使用超时的所有场景中，超时规定了在表明已超时前，该方法应等待的最少时间。超时后，实现类们会“尽力”检测超时。当然了，在检测到超时和超时后再次真正地执行线程之间可能还要经过一段不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。</p>
<h3> 3.4 同步器</h3>
<p>五个类可辅助实现常见的专用同步语法。</p>
<ul>
<li>Semaphore 是一个经典的并发工具</li>
<li>CountDownLatch 是一个非常简单但又常用的工具，在持有给定数目的信号、事件或条件前一直阻塞</li>
<li>CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用</li>
<li>Phaser 提供了更灵活的屏障形式，可用于控制多个线程之间的分阶段计算。</li>
<li>Exchanger 允许两个线程在一个会合点交换对象，它在多流水线设计中是有用的</li>
</ul>
<h3> 3.5 并发容器</h3>
<p>除队列外，此包还提供了设计用于多线程上下文中的容器实现：</p>
<figure><figcaption>img_7.png</figcaption></figure>
<p>当期望许多线程访问同一个给定容器时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读请求数和遍历请求远大于对list的更新时，CopyOnWriteArrayList 优于同步的 ArrayList。</p>
<p>此包中与某些类一起使用的 “Concurrent” 前缀是一种速记，暗示着与类似的“同步化”的类有所不同。例如Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步化的，但 ConcurrentHashMap 则是“并发的（Concurrent）”。并发容器是线程安全的，但不受单个独占锁的管理。在 ConcurrentHashMap 这一特定场景下，它可以安全地允许任意次数的并发读，以及数目可调的并发写。适用场景如下：</p>
<ul>
<li>需要通过单个锁防止对容器的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性</li>
<li>在期望多线程访问公共的容器的其他情况中，通常“concurrent”版本要更好</li>
<li>当容器是未共享的，或者仅持有其他锁时容器才可访问时，非同步的普通容器则要更好。</li>
</ul>
<p>大多数并发容器的实现（包括大多数队列）与常规的 java.util 包中的约定也不同，因为它们的迭代器Iterators和Spliterators提供了弱一致的，而不是fast-fail的遍历：</p>
<ul>
<li>他们可能会与其他操作并发进行</li>
<li>他们永远不会抛ConcurrentModificationException</li>
<li>它们被保证可以遍历在构造时就已经存在的元素恰好一次，并且可以（但不保证）反映出构造后的任何修改。</li>
</ul>
<h3> 3.6 内存一致性属性</h3>
<ul>
<li>
<p>Java语言规范的第 17 章定义了内存操作（例如对共享变量的读写）的 happens-before （先行发生，以下简称 HB）关系<br>
<br>
只有写操作HB读操作时，才保证一个线程写结果对另一个线程的读是可见的。synchronized 和 volatile 构造以及Thread.start() 和 Thread.join() 方法可以形成HB关系。尤其是：</p>
</li>
<li>
<p>线程中，按照程序的顺序，前面的操作先行发生于后面的操作</p>
</li>
<li>
<p>监视器锁上的解锁（退出 synchronized 块或方法）HB同一监视器锁上后续（时间概念上的）的加锁（进入synchronized 块或方法）。并且因为 happen-before 关系是可传递的，所以解锁之前的线程的所有操作 happen-before 加锁后的所有操作</p>
</li>
<li>
<p>对某volatile字段的写操作HB每个后续（时间上的先后）对相同字段的读。volatile 字段的读写与进入和退出监视器具有相似的内存一致性效果，但并不需要互斥锁</p>
</li>
<li>
<p>在线程对象上调用start()方法HB该启动了的线程中的任意动作</p>
</li>
<li>
<p>线程中的所有操作HB从该线程上的 join 成功返回的任何其他线程</p>
</li>
</ul>
<p>java.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：</p>
<ul>
<li>线程中将一个对象放入任何并发容器之前的操作 HB 从另一线程中的容器访问或移除该元素的后续操作</li>
<li>线程中向 Executor 提交 Runnable 之前的操作 HB 其执行开始。同样适用于向 ExecutorService 提交 Callables</li>
<li>异步计算（由 Future 接口表示）所采取的操作  HB 通过另一线程中 Future.get() 获取结果的后续的操作</li>
<li>“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。</li>
<li>对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 HB 另一线程中对应 exchange() 后续的操作。</li>
</ul>
<h2> 4 java.util.concurrent.locks</h2>
<p>该包的接口和类提供了用于锁和等待条件的框架，这些条件不同于内置的同步和监视器。该框架允许使用锁和条件来实现更大的灵活性，但以更复杂的语法为代价。</p>
<p>Lock 接口支持那些语义不同（重入、公平等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现为 ReentrantLock。</p>
<p>ReadWriteLock 接口以类似方式定义了一些读线程可以共享而写线程独占的锁。此包只提供了一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。</p>
<p>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，一个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p>
<p>AbstractQueuedSynchronizer 类是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器。 AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。LockSupport 类提供了更低级别的阻塞和解除阻塞支持，这对那些实现自己的定制锁的开发人员很有用。</p>
<h2> 5 <a href="http://java.io" target="_blank" rel="noopener noreferrer">java.io</a></h2>
<p>通过数据流、序列化和文件系统提供系统输入和输出，<a href="http://Java.io" target="_blank" rel="noopener noreferrer">Java.io</a> 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入的数据源和输出的目标对象。</p>
<p>除非另有说明，否则向此包的任何类或接口中的构造方法或方法传递 null 参数时，都将抛出 NullPointerException。</p>
<p>流可以理解为数据的序列：</p>
<ul>
<li>输入流，从一个源读数据</li>
<li>输出流，向一个目标写数据<br>
流支持很多种格式，比如：基本类型、对象、数组等。下图展示了该包的内容从数据源、操作目标等角度可大致分类如下：</li>
</ul>
<figure><figcaption>img_9.png</figcaption></figure>
]]></content>
    <category term="Java"/>
    <published>2024-01-24T03:14:02.000Z</published>
  </entry>
  <entry>
    <title type="text">Java值传递</title>
    <id>https://ujava.cn/java/why-there-only-value-passing-in-java.html</id>
    <link href="https://ujava.cn/java/why-there-only-value-passing-in-java.html"/>
    <updated>2024-01-24T03:14:02.000Z</updated>
    <summary type="html"><![CDATA[<p>开始之前，我们先来搞懂下面这两个概念：</p>
<ul>
<li>形参&amp;实参</li>
<li>值传递&amp;引用传递</li>
</ul>
<h2> 形参&amp;实参</h2>
<p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参（实际参数，Arguments）</strong>：用于传递给函数/方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数，Parameters）</strong>：用于定义函数/方法，接收实参，不需要有确定的值。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>开始之前，我们先来搞懂下面这两个概念：</p>
<ul>
<li>形参&amp;实参</li>
<li>值传递&amp;引用传递</li>
</ul>
<h2> 形参&amp;实参</h2>
<p>方法的定义可能会用到 <strong>参数</strong>（有参的方法），参数在程序语言中分为：</p>
<ul>
<li><strong>实参（实际参数，Arguments）</strong>：用于传递给函数/方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数，Parameters）</strong>：用于定义函数/方法，接收实参，不需要有确定的值。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 值传递&amp;引用传递</h2>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong>：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2> 为什么 Java 只有值传递？</h2>
<p><strong>为什么说 Java 只有值传递呢？</strong> 不需要太多废话，我通过 3 个例子来给大家证明。</p>
<h3> 案例 1：传递基本类型参数</h3>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p>
<p>在 <code>swap()</code> 方法中，<code>a</code>、<code>b</code> 的值进行交换，并不会影响到 <code>num1</code>、<code>num2</code>。因为，<code>a</code>、<code>b</code> 的值，只是从 <code>num1</code>、<code>num2</code> 的复制过来的。也就是说，a、b 相当于 <code>num1</code>、<code>num2</code> 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例 2。</p>
<h3> 案例 2：传递引用类型参数 1</h3>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p>
<p>看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。</p>
<p>实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！</p>
<p>也就是说 <code>change</code> 方法的参数拷贝的是 <code>arr</code> （实参）的地址，因此，它和 <code>arr</code> 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。</p>
<p>为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！</p>
<h3> 案例 3：传递引用类型参数 2</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：</p>
<p>怎么回事？？？两个引用类型的形参互换并没有影响实参啊！</p>
<p><code>swap</code> 方法的参数 <code>person1</code> 和 <code>person2</code> 只是拷贝的实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 的地址。因此， <code>person1</code> 和 <code>person2</code> 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 <code>xiaoZhang</code> 和 <code>xiaoLi</code> 。</p>
<h2> 引用传递是怎么样的？</h2>
<p>看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。<br>
但是，引用传递到底长什么样呢？下面以 <code>C++</code> 的代码为例，让你看一下引用传递的庐山真面目。</p>
<div class="language-C++ line-numbers-mode" data-ext="C++"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析：可以看到，在 <code>incr</code> 函数中对形参的修改，可以影响到实参的值。要注意：这里的 <code>incr</code> 形参的数据类型用的是 <code>int&amp;</code> 才为引用传递，如果是用 <code>int</code> 的话还是值传递哦！</p>
<h2> 为什么 Java 不引入引用传递呢？</h2>
<p>引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？</p>
<p><strong>注意：以下为个人观点看法，并非来自于 Java 官方：</strong></p>
<ol>
<li>出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。</li>
<li>Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。</li>
</ol>
<h2> 总结</h2>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong>：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
]]></content>
    <category term="Java"/>
    <published>2024-01-24T01:45:54.000Z</published>
  </entry>
  <entry>
    <title type="text">几种常见web容器</title>
    <id>https://ujava.cn/highfreq/container.html</id>
    <link href="https://ujava.cn/highfreq/container.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>应用服务器：tomcat</p>
<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>
<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>
<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>
<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish<br>
v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5<br>
平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations<br>
1.0、StAX<br>
1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>应用服务器：tomcat</p>
<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>
<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>
<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>
<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish<br>
v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5<br>
平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations<br>
1.0、StAX<br>
1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>
<h2> webSphere</h2>
<p>WebSphere是 IBM 的集成软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web<br>
应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的集成软件。</p>
<h2> JBoss</h2>
<p>JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3.0的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。2006年,Jboss公司被Redhat公司收购。</p>
<h2> Tomcat</h2>
<p>Tomcat是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun<br>
的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5 支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat<br>
技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>JBoss与Tomcat的是完全开源的</p>
<p>WebLogic与WebSphere都是对业内多种标准的全面支持，包括EJB、JSB、JMS、JDBC、XML和WML，使Web应用系统的实施更为简单，并且保护了投资，同时也使基于标准的解决方案的开发更加简便。</p>
<h4> 扩展性的不同：</h4>
<p>WebLogic和WebSphere都是以其高扩展的架构体系闻名于业内，包括客户机连接的共享、资源 pooling以及动态网页和EJB组件群集。</p>
<h4> 应用范围的区别：</h4>
<p>Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<p>WebLogic和WebSphere是商业软件，功能齐全强大，主要应用于大型企业的大型项目。</p>
<p>JBOSS 主要应用于EJB服务的中小型公司。</p>
<h4> JBoss还具有如下六大优点：</h4>
<p>1、JBoss是免费的，开放源代码J2EE的实现，它通过LGPL许可证进行发布。</p>
<p>2、JBoss需要的内存和硬盘空间比较小。</p>
<p>3、安装非常简单。先解压缩JBoss打包文件再配置一些环境变量就可以了。</p>
<p>4、JBoss能够"热部署"，部署BEAN只是简单拷贝BEAN的JAR文件到部署路径下就可以了。如果没有加载就加载它；如果已经加载了就卸载掉，然后LOAD这个新的。</p>
<p>5、JBoss与Web服务器在同一个Java虚拟机中运行，Servlet调用EJB不经过网络，从而大大提高运行效率，提升安全性能。</p>
<p>6、用户可以直接实施J2EE-EAR，而不是以前分别实施EJB-JAR和Web-WAR，非常方便。</p>
<p>JBoss的安装和配置可以直接拷贝使用，但是要改动 %JBoss-HOME%\bin\run.bat里JAVA-HOME的设置，改成本机JDK的目录。运行run.bat来启动JBoss</p>
<h2> Weblogic</h2>
<p>WebLogic是美国bea公司出品的一个application<br>
server确切的说是一个基于j2ee架构的中间件，webserver是用来构建网站的必要软件用来解析发布网页等功能，它是用纯java开发的。weblogic本来不是由bea发明的，是它从别人手中买过来，然后再加工扩展。目前weblogic在世界application<br>
server市场上占有最大的份额，其他还有象IBM的websphere，免费的tomcat、resin等中间件。</p>
<p>BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java<br>
Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<p>BEA WebLogic Server拥有处理关键Web应用系统问题所需的性能 、可扩展性和高可用性。</p>
<p>与BEA WebLogic Commerce ServerTM配合使用， BEA WebLogic Server可为部署适应性个性化电子商务应用系统提供完善的解决方案。</p>
<p>BEA WebLogic Server具有开发和部署关键任务电子商务Web应用系统 所需的多种特色和优势</p>
<p>WebLogic: WebLogic<br>
是一套基于JAVA功能强大的电子商务套件，提供了许多功能强大的中间件以方便编程人员编写的JSP、SERVLET等电子商务应用，可以为企业提供一个完整的商务应用解决方案。不适合开发阶段，太慢了，适合于运行环境（收费）。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-29T11:50:17.000Z</published>
  </entry>
  <entry>
    <title type="text">系统总体结构设计</title>
    <id>https://ujava.cn/highfreq/overall.html</id>
    <link href="https://ujava.cn/highfreq/overall.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>
<h2> 一、系统设计的任务</h2>
<ol>
<li>系统设计的概念</li>
</ol>
<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>
<h2> 一、系统设计的任务</h2>
<ol>
<li>系统设计的概念</li>
</ol>
<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>
<p>系统设计是开发人员进行的工作，他们将系统设计阶段得到的目标系统的逻辑模型转换为目标系统的物理模型，该阶段得到工作成果――系统设计说明书是下一个阶段系统实施的工作依据。</p>
<ol start="2">
<li>系统设计的主要内容</li>
</ol>
<p>系统设计的主要任务是进行总体设计和详细设计。下面分别说明它们的具体内容。</p>
<p>(1) 总体设计</p>
<p>总体设计包括系统模块结构设计和计算机物理系统的配置方案设计。</p>
<ol>
<li>系统模块结构设计</li>
</ol>
<p>系统模块结构设计的任务是划分子系统，然后确定子系统的模块结构，并画出模块结构图。在这个过程中必须考虑以下几个问题：</p>
<p>如何将一个系统划分成多个子系统；</p>
<p>每个子系统如何划分成多个模块；</p>
<p>如何确定子系统之间、模块之间传送的数据及其调用关系；</p>
<p>如何评价并改进模块结构的质量。</p>
<ol start="2">
<li>计算机物理系统配置方案设计</li>
</ol>
<p>在进行总体设计时，还要进行计算机物理系统具体配置方案的设计，要解决计算机软硬件系统的配置、通信网络系统的配置、机房设备的配置等问题。计算机物理系统具体配置方案要经过用户单位和领导部门的同意才可进行实施。</p>
<p>开发管理信息系统的大量经验教训说明，选择计算机软硬件设备不能光看广告或资料介绍，必须进行充分的调查研究，最好应向使用过该软硬件设备的单位了解运行情况及优缺点，并征求有关专家的意见，然后进行论证，最后写出计算机物理系统配置方案报告。</p>
<p>从我国的实际情况看，不少单位是先买计算机然后决定开发。这种不科学的、盲目的做法是不可取的，它会造成极大浪费。因为，计算机更新换代是非常快的，就是在开发初期和在开发的中后期系统实施阶段购买计算机设备，价格差别就会很大。因此，在开发管理信息系统过程中应在系统设计的总体设计阶段才具体设计计算机物理系统的配置方案。</p>
<p>(2) 详细设计</p>
<p>在总体设计基础上，第二步进行的是详细设计，主要有处理过程设计以确定每个模块内部的详细执行过程，包括局部数据组织、控制流、每一步的具体加工要求等，一般来说，处理过程模块详细设计的难度已不太大，关键是用一种合适的方式来描述每个模块的执行过程，常用的有流程图、问题分析图、IPO图和过程设计语言等；除了处理过程设计，还有代码设计、界面设计、数据库设计、输入输出设计等。</p>
<p>(3) 编写系统设计说明书</p>
<p>系统设计阶段的结果是系统设计说明书，它主要由模块结构图、模块说明书和其它详细设计的内容组成。</p>
<h2> 系统设计的方法与工具</h2>
<p>系统设计的工作复杂又细致，总体设计阶段需要进行系统模块结构设计，要将一个大系统分解成不同层次、多个模块组成的系统，在详细设计阶段要在模块结构设计的基础上，给出每个模块实现方法的细节，并对模块的输入、输出和处理过程作详细描述，以便在系统实施阶段进行程序设计时可以把这个描述直接“翻译”成用某种程序设计语言书写的程序。系统设计在技术上有相当的难度，为此需要有一定的设计方法和设计工具来指导。70年代以来，出现了多种设计方法，其中结构化设计方法是较为典型的方法，本章将对该设计方法进行论述并介绍几个常用的设计工具。</p>
<h2> 一、结构化设计的方法</h2>
<p>结构化设计（STRUCTURED DESIGN, 简称SD)<br>
方法是使用最广的一种设计方法，由美国IBM公司的W·STEVENS、G·MYERS和·CONSTANTINE等人提出。该方法适合于软件系统的总体设计和详细设计，特别是将一个复杂的系统转换成模块化结构系统，该方法具有它的优势。在使用过程中可将结构化设计方法与结构化分析（SA)<br>
方法及编程阶段的结构化程序设计方法(SP)前后衔接起来，SD方法具有以下特点：</p>
<p>1．相对独立、功能单一的模块结构</p>
<p>结构化设计的基本思想是将系统设计成由多个相对独立、功能单一的模块组成的结构。由于模块之间相对独立，每一模块就可以单独地被理解、编写、测试、排错和修改,从而有效地防止错误在模块之间扩散蔓延，提高了系统的质量(<br>
可维护性、可靠性等)。因此，大大简化了系统研制开发的工作。</p>
<p>2．“块内联系大、块间联系小”的模块性能标准</p>
<p>“模块内部联系要大，模块之间联系要小”，这是结构化设计中衡量模块“相对独立”性能的标准。事实上，块内联系和块间联系是同一件事的两个方面。系统中各组成成分之间是有联系的，若把联系密切的成分组织在同一模块中，块内联系高了，块间联系自然就少了。反之，若把密切相关的一些组成成分分散在各个模块中，势必造成很高的块间联系，这将影响系统的可维护性。所以，在系统设计过程中一定要以结构化设计的模块性能标准为指导。</p>
<p>3．采用模块结构图的描述方式</p>
<p>结构化设计方法使用的描述方式是模块结构图。</p>
<h2> 系统模块结构设计</h2>
<p>总体设计的另外一个主要内容是合理地进行系统模块结构的分析和定义，将一个复杂的系统设计转为若干个子系统和一系列基本模块的设计，并通过模块结构图把分解的子系统和一个个模块按层次结构联系起来。下面来介绍如何进行模块的分解、如何从数据流图导出模块结构图以及模块结构图的改进。</p>
<h4> 一、模块分解的原则和依据</h4>
<p>系统逻辑模型中数据流图中的模块是逻辑处理模块，模型中没有说明模块的物理构成和实现途径，同时也看不出模块的层次分解关系，为此在系统结构设计中要将数据流图上的各个逻辑处理模块进一步分解，用模块结构图确定系统的层次结构关系，并将系统的逻辑模型转变为物理模型。</p>
<ol>
<li>“耦合小，内聚大”的基本原则</li>
</ol>
<p>在结构化设计中，采用自顶向下，逐步细化的方法将系统分解成为一些相对独立、功能单一的模块。如何度量模块之间的独立性呢？</p>
<p>在一个管理信息系统中，系统的各组成部分之间总是存在着各种联系的，将系统或子系统划分成若干模块，则一个模块内部的联系就是块内联系，而穿越模块边界的联系就是块间联系。由于模块之间的互相联系越多，模块的独立性就越少，因此，引入模块耦合和内聚的概念。</p>
<p>耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。</p>
<p>内聚表示模块内部各成分之间的联系程度。</p>
<p>一般说来，在系统中各模块的内聚越大，则模块间的耦合越小。但这种关系并不是绝对的。耦合小使得模块间尽可能相对独立，从而各模块可以单独开发和维护。内聚大使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚。</p>
<ol start="2">
<li>对子系统或模块进行划分的依据</li>
</ol>
<p>一个合理的子系统或模块划分，应该是内部联系强，子系统或模块间尽可能独立，接口明确、简单，尽量适应用户的组织体系，有适当的共用性。也就是上面所说的“耦合小，内聚大”。按照结构化设计的思想，对模块或子系统进行划分的依据通常有以下几种：</p>
<p>(1)按逻辑划分，把相类似的处理逻辑功能放在一个子系统或模块里。例如，把“对所有业务输入数据进行编辑”的功能放在一个子系统或模块里。那么不管是库存、还是财务，只要有业务输入数据都由这个子系统或模块来校错、编辑。</p>
<p>(2)按时间划分，把要在同一时间段执行的各种处理结合成一个子系统或模块。</p>
<p>(3)按过程划分，即按工作流程划分。从控制流程的角度看，同一子系统或模块的许多功能都应该是相关的。</p>
<p>(4)按通信划分，把相互需要较多通讯的处理结合成一个子系统或模块。这样可减少子系统间或模块间的通讯，使接口简单。</p>
<p>(5)按职能划分，即按管理的功能。例如，财务、物资、销售子系统，或输入记帐凭证、计算机优解子系统或模块等等。</p>
<p>一般来说，按职能划分子系统，按逻辑划分模块的方式是比较合理和方便的</p>
<h2> 详细设计</h2>
<p>进行了系统的总体设计后即可在此基础上进行系统的详细设计了，即各种输入、输出、处理和数据存储等的详细设计。下面分别介绍详细设计的内容。</p>
<h4> 一、代码设计</h4>
<p>代码是用来表示事物名称、属性和状态等的符号。在管理信息系统中，代码是人和机器的共同语言，是系统进行信息分类、校对、统计和检索的依据。代码设计就是要设计出一套能为系统各部门公用的、优化的代码系统，这是实现计算机管理的一个前提条件。</p>
<ol>
<li>代码设计的原则</li>
</ol>
<p>代码设计是一项重要的工作，合理的编码结构是使管理信息系统具有生命力的重要因素。设计代码的基本原则是：</p>
<p>(1) 具备唯一确定性。每一个代码都仅代表唯一的实体或属性。</p>
<p>(2) 标准化与通用性。凡国家和主管部门对某些信息分类和代码有统一规定和要求的，则应采用标准形式的代码，以使其通用化。</p>
<p>(3) 可扩充且易修改。要考虑今后的发展，为增加新代码留有余地。当某个代码在条件或代表的实体改变时，容易进行变更。</p>
<p>(4) 短小精悍即选择最小值代码。代码的长度会影响所占据的内存空间、处理速度以及输入时的出错概率，因此要尽量短小。</p>
<p>(5) 具有规律性、便于编码和识别。代码应具有逻辑性强，直观性好的特点，便于用户识别和记忆。</p>
<ol start="2">
<li>分类方法</li>
</ol>
<p>目前最常用的分类方案有两种，一种是线分类方法，一种是面分类方法。在实际应用中根据具体情况各有其不同的用途。</p>
<p>线分类方法：首先给定母项，然后下分若干子项，由对象的母项分大集合，由大集合确定小集合，最后落实到具体对象</p>
<p>特点：结构清晰，容易识别和记忆，易查找；适应于手工系统；</p>
<p>缺点：结构不灵活，柔性差。</p>
<p>线分类时要掌握两个原则：唯一性和不交叉性。</p>
<p>例：公司生产组织结构。</p>
<p>面分类方法：它主要从面的角度来考虑分类</p>
<p>面分类的特点：</p>
<p>柔性好，面上的增、删、改很容易；</p>
<p>可实现按任意组配面的信息检索，对机器处理有良好的适应性；</p>
<p>缺点是不易直观识别，不便于记忆。</p>
<p>系统设计报告</p>
<p>系统设计阶段的成果是系统设计报告， 其主要是各种设计方案和设计图表，它是下一步系统实现的基础。</p>
<h4> 一、系统设计的成果</h4>
<p>系统设计阶段的成果归纳起来一般有 (点击这里观看“各开发环节之间的关系”动画演示)：</p>
<p>1.系统总体结构图（包括总体结构图，子系统结构图，计算机流程图等）。</p>
<p>2.系统设备配置图（系统设备配置图： 主要是计算机系统图，设备在各生产岗位的分布图，主机、网络、终端联系图等）。</p>
<p>3.系统分布编码方案（分类方案、编码系统）。</p>
<p>4.数据库结构图（DB的结构，主要指表与表之间的结构，表内部结构（字段、域、数据字典等）。</p>
<p>5.HIPO图（层次化模块控制图、IPO图等等）。</p>
<p>6.系统详细设计方案说明书。</p>
<h2> 二、系统设计说明书的组成</h2>
<ol>
<li>引言</li>
</ol>
<p>(1) 摘要 系统的目标名称和功能等的说明</p>
<p>(2) 背景</p>
<ul>
<li>项目开发者</li>
<li>用户</li>
<li>本项目和其它系统或机构的关系和联系</li>
</ul>
<p>(3) 系统环境与限制</p>
<ul>
<li>硬件、软件和运行环境方面的限制</li>
<li>保密和安全的限制</li>
<li>有关系统软件文本</li>
<li>有关网络协议标准文本</li>
</ul>
<p>(4) 参考资料和专门术语说明</p>
<h2> 2.系统设计方案</h2>
<p>(1) 模块设计</p>
<ul>
<li>系统的模块结构图</li>
<li>各个模块的IPO图(包括各模块的名称、功能、调用关系、局部数据项和详细的算法说明等)</li>
</ul>
<p>(2) 代码设计</p>
<p>各类代码的类型、名称、功能、使用范围和使用要求等的设计说明书</p>
<p>(3) 输入设计</p>
<p>输入项目</p>
<p>输入人员(指出所要求的输入操作人员的水平与技术专长，说明与输入数据有关的接口软件及其来源)</p>
<p>主要功能要求(从满足正确、迅速、简单、经济、方便使用者等方面达到要求的说明)</p>
<p>输入校验(关于各类输入数据的校验方法的说明)</p>
<p>(4) 输出设计</p>
<p>输出项目</p>
<p>输出接受者</p>
<p>输出要求(所用设备介质、输出格式、数值范围和精度要求等)</p>
<p>(5) 文件(数据库)设计说明</p>
<p>概述(目标、主要功能)</p>
<p>需求规定(精度、有效性、时间要求及其它专门要求)</p>
<p>运行环境要求(设备支撑软件，安全保密等要求)</p>
<p>逻辑结构设计(有关文件及其记录、数据项的标识、定义、长度和它们之间的关系)</p>
<p>物理结构设计(有关文件的存贮要求、访问方法、存贮单位、设计考虑和保密处理等)</p>
<p>(6) 模型库和方法库设计(本系统所选用的数学模型和方法以及简要说明)</p>
<p>(7) 安全保密设计</p>
<p>(8) 物理系统配置方案报告</p>
<p>硬件配置设计</p>
<p>通信与网络配置设计</p>
<p>软件配置设计</p>
<p>机房配置设计</p>
<p>(9) 系统实施方案及说明</p>
<p>实施方案</p>
<p>实施计划(包括工作任务的分解、进度安排和经费预算)</p>
<p>实施方案的审批(说明经过审批的实施方案概况和审批人员的姓名)</p>
<p>3.案例</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>模块名称</th>
<th>主要用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>无线寻呼管理信息系统-系统设计说明书</td>
<td>研究开发5-10万用户寻呼机管理信息系统，它可以进行普通寻呼服务；漫游寻呼服务；群呼服务；试机服务；定时服务；系统管理；运行管理。</td>
</tr>
<tr>
<td>2</td>
<td>库存管理系统-系统设计说明书</td>
<td>研发库存控制系统的主要目的:1）为顾客订货提供更好的服务；2）控制库存水平；3）决定向厂家订货的时间和批量。</td>
</tr>
<tr>
<td>3</td>
<td>百货商店业务管理信息系统-系统设计</td>
<td>实现登记、整理数据，处理核对顾客订货单；向经理提供各种业务统计报表；提供各级查询；销售、采购、会计各部门的业务数据处理实现自动化。</td>
</tr>
<tr>
<td>4</td>
<td>铁道财务会计管理信息系统-系统设计</td>
<td>运用系统的方法以计算机和现代通信技术为基本信息处理手段和工具的，能为全国铁道财务会计核算、管理、决策提供信息服务的人—机系统。</td>
</tr>
<tr>
<td>5</td>
<td>高校选课辅助决策</td>
<td>本选课系统能够使学生在INTERNET上自主、便捷、准确地进行全校性课程选择的一种软件。学生在选择选修课前，可以上网进行查询，当学生输入其学号与密码后，系统便调出其所有相关信息，包括已修课程、已修课程的成绩、专业培养计划、全校性可选课程，系统进行综合分析后，得到一些可行的方案，供选课学生参考，并提出合理建议。</td>
</tr>
<tr>
<td>6</td>
<td>条形材料选材优化</td>
<td>要制造器件,必须先制造一定的零件,而这些零件又由某种原材料截取而得到。例如：用某一种条形材料锯成数种需要的零件，求最少的用料数量。使用运筹学线性规划的思想和解决方法。</td>
</tr>
</tbody>
</table>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-23T10:50:49.000Z</published>
  </entry>
  <entry>
    <title type="text">设计注意事项一</title>
    <id>https://ujava.cn/highfreq/attention1.html</id>
    <link href="https://ujava.cn/highfreq/attention1.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> 架构的本质</h2>
<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>
<p>分为三部分：</p>
<ul>
<li>整体：部分的组成，强调合力。</li>
<li>规则：强调部分之前有关联关系，有规则，有约束。</li>
<li>通信：强调部分之间有往来，有交互。</li>
</ul>
<figure><figcaption>img_18.png</figcaption></figure>
<h2> 架构的分类</h2>
<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> 架构的本质</h2>
<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>
<p>分为三部分：</p>
<ul>
<li>整体：部分的组成，强调合力。</li>
<li>规则：强调部分之前有关联关系，有规则，有约束。</li>
<li>通信：强调部分之间有往来，有交互。</li>
</ul>
<figure><figcaption>img_18.png</figcaption></figure>
<h2> 架构的分类</h2>
<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>
<h2> 业务架构</h2>
<p>业务架构是指企业或机构的业务逻辑、流程、组织结构等方面的设计。它着重于企业业务运营的需求和目标，将业务需求转化为技术解决方案。业务架构的设计需要考虑企业的战略规划、组织结构、业务流程、客户需求等多个方面。</p>
<p>例如：一个银行的业务架构设计需要考虑银行的基本业务逻辑、流程和组织结构，如存款、贷款、投资、支付等，以及银行的安全性、可靠性和效率等方面的需求。</p>
<h2> 应用架构</h2>
<p>应用架构是指企业或机构的信息系统中的应用程序、系统、服务等方面的设计。它着重于解决企业业务运营中的具体问题，将业务需求转化为具体的应用程序。应用架构的设计需要考虑企业的业务需求、用户体验、系统性能、安全风险等多个方面。</p>
<p>例如：一个电商网站的应用架构设计需要考虑用户购物、订单管理、库存管理、支付等多个应用程序的设计，以及这些应用程序之间的交互和集成。</p>
<h2> 技术架构</h2>
<p>技术架构是指企业或机构的信息系统中的技术实现、系统架构、软件设计等方面的设计。它着重于解决企业业务运营中的技术问题，如系统的稳定性、可扩展性、可维护性等。</p>
<p>例如：一个电商网站的技术架构设计需要考虑系统的负载均衡、容错容灾、CDN缓存、自动化部署等多个方面的技术实现。</p>
<h2> 数据架构</h2>
<p>数据架构是指企业或机构的信息系统中的数据存储、数据处理、数据安全等方面的设计。它着重于解决企业业务运营中的数据问题，如数据的一致性、完整性、安全性等。</p>
<p>例如：一个电商网站的数据架构设计需要考虑数据的分层存储、数据备份和恢复、数据加密和权限管理等多个方面的设计，以确保数据的安全和可靠性。</p>
<h2> 架构设计要考虑的因素</h2>
<p>架构设计过程中我们要考虑的因素，整体可以分为两大类，一类是功能性因素，一类是非功能性因素。</p>
<h2> 功能性因素</h2>
<p>无论什么架构设计，我们首先是要考虑必须满足我们的业务需求，否则我们的设计都是空中楼阁。功能需求会直接决定我们的业务架构设计。所以我们的架构必须完整性地，正确地对业务实现支撑。</p>
<h2> 非功能性因素</h2>
<p>满足了功能性因素以后，我们就得要考虑怎么能够稳定地，可靠地，可持续性地支持我们的业务功能，比如性能，可靠性，扩展性，兼容性等等。</p>
<ul>
<li>可靠性
<ul>
<li>为了更好的服务于功能，我们需要确保架构能够稳定、高效的运行。不会时不时的出现服务崩溃或者不可用的情况。</li>
</ul>
</li>
<li>可用性
<ul>
<li>同样的，服务对外要始终处于可用的状态，即使单个服务实例出现问题，我们依然可以正常的对外提供服务。</li>
</ul>
</li>
<li>扩展性
<ul>
<li>功能性需求不是一层不变的，尤其在当今盛行敏捷的时代，需求不是一次性提出的。我们需要对系统、服务的整体能力有全面的定位和把控。这就需要我们的架构在新的需求出现的时候，可以方便的进行扩展支持。</li>
</ul>
</li>
<li>治理能力
<ul>
<li>好的架构一定是方便运营、管理和监控的。甚至微观到工程管理，代码一定是易于维护、扩展、协同的。</li>
</ul>
</li>
<li>响应性能
<ul>
<li>一般的，功能性需求都会对性能有一定的预期。这个业务要我们在架构上做很多工作，比如读写分离、缓存、异步等等的介入，以满足整体架构的响应能力。</li>
</ul>
</li>
</ul>
<figure><figcaption>img_19.png</figcaption></figure>
<h2> 设计原则</h2>
<ul>
<li>价值为王：系统架构设计应该以实现业务价值为目标，始终关注用户需求和业务场景，确保设计出的系统能够满足用户需求和业务场景，为企业创造价值。</li>
<li>以终为始：在进行系统架构设计时，需要明确系统的目标和愿景，并以此为起点，进行设计和实现。以确保系统的设计和实现都是为了实现业务价值，满足用户需求。</li>
<li>分治原则：将系统划分为多个子系统或模块，每个子系统或模块都可以独立地进行开发、测试、部署和维护。这样可以降低系统的复杂度，提高系统的可维护性和可扩展性。</li>
<li>服务自治：每个服务都应该具备独立的能力，能够独立地进行开发、测试、部署和维护。这样可以提高服务的可用性和可靠性，降低系统的耦合度。</li>
<li>拥抱变化：系统架构设计应该能够适应业务需求的变化和市场的变化，具备快速响应和灵活应变的能力。</li>
<li>系统安全性：系统架构设计应该充分考虑系统的安全性，包括数据安全、应用安全、系统安全等方面，确保系统的安全性和稳定性。</li>
<li>不作不死：系统架构设计应该遵循“最小化变更范围”原则，避免过度设计和复杂度的出现，从而提高系统的可维护性和可扩展性。</li>
</ul>
<h2> 常见的架构设计方案</h2>
<p>之前比较流行的是MVC，MVC有很多的优点，但是缺点也不少：</p>
<ul>
<li>视图与控制器的连接过紧，视图如果不依赖控制器，那么它的应用就会十分有限，这妨碍了他们的独立。</li>
<li>模型对视图数据的访问效率较低，工作量大，并且有一些高级的界面工具或构造器不支持MVC框架。</li>
<li>MVC架构使得我们面向视图开发，但是视图的变化是不可控的，容易受到用户主观的影响。同时复杂系统必然存在纷繁复杂的依赖，依赖不可能存在于视图，最终表现为接口依赖。</li>
</ul>
<p>所以现在比较流行如下几种方案：</p>
<figure><figcaption>img_20.png</figcaption></figure>
<h2> 领域驱动架构</h2>
<p>领域驱动设计是通过将软件实现与核心业务概念的演进紧密相连，从而实现复杂需求的软件开发方法。</p>
<p>领域驱动设计包括三要素：</p>
<ul>
<li>专业知识：就是前期在与客户沟通需求过程中，学习到的关于业务方面的知识。 这类知识并不仅仅只是对需求的理解，更多的要思考业务需求实际要解决的是什么问题。</li>
<li>抽象能力：一般指发现核心业务对象，简化问题空间的能力。</li>
<li>细分问题：把业务问题细化为更小更容易处理的子问题。<br>
领域驱动设计，使得我们不再用数据进行驱动，而是使用领域进行驱动。遇到问题，我们先进行领域上的划分和拆解。这个问题属于哪个问题域，或者需要拆解到哪些问题域里面去，然后再通过领域的组合以及依赖，完成最终问题的解决。</li>
</ul>
<h2> 微服务架构</h2>
<p>微服务架构是一种软件开发架构，它将应用程序拆分成小型、独立的微服务，每个微服务都有自己的功能集，并运行在其独立的进程中。</p>
<p>微服务架构有以下优点：</p>
<ul>
<li>开发人员可以只关注整个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化。</li>
<li>有利于各层逻辑的复用，如PetShop可经过简单的配置实现Sqlserver和Oracle之间的转换。</li>
<li>扩展性强，不同层负责不同的层面，有利于系统的扩展和维护。</li>
<li>安全性高，用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。</li>
<li>项目结构更清楚，分工更明确，有利于后期的维护和升级。</li>
</ul>
<h2> 云原生架构</h2>
<figure><figcaption>img_21.png</figcaption></figure>
<p>云原生架构是一种创新的软件开发方法，专为充分利用云计算模型而设计。</p>
<p>云原生架构通过结合使用云计算和各种云服务来创建具有更大可扩展性的可定制模块化基础架构，从而提高了团队的效率，生产力和协作能力。</p>
<p>云原生架构的核心原则：</p>
<ul>
<li>云原生架构是一种设计方法，利用AWS等EC2，S3，Lambda等云服务来支持动态，敏捷的应用程序开发技术，这些技术采用模块化方法通过一套基于云的套件来构建，运行和更新软件微服务与整体应用程序基础架构。</li>
<li>微服务和容器化通过简化云提供商之间的转移或独立地以不同的语言或框架部署服务而没有冲突或停机的情况，从而支持云本机应用程序的敏捷性和动态性。</li>
<li>将微服务架构集成到应用程序开发中可支持协作，效率和生产力，因为DevOps团队能够同时独立处理应用程序的不同组件或实现新功能而又不牺牲稳定性。</li>
</ul>
<h2> DevOps架构</h2>
<figure><figcaption>img_22.png</figcaption></figure>
<p>DevOps架构，它旨在加强软件产品开发与交付过程中的协作、自动化、持续性和监控等方面，以实现更高效、更迅速和更可靠的软件交付。</p>
<p>DevOps通常包括以下核心组成部分：</p>
<ul>
<li>持续集成：将代码频繁地集成到一个共享的代码库中，并对代码进行自动化测试，以确保代码质量和稳定性，并及时发现和解决错误。</li>
<li>持续交付：通过自动化测试、构建、部署和运行环节，实现快速、可靠和可重复的软件发布，从而减少手动操作和人工干预带来的错误和风险。</li>
<li>自动化运维：将基础设施的管理、配置和维护工作自动化，并将其作为代码、脚本或配置文件存储在版本控制系统中，以便快速搭建、复制和修改环境。</li>
<li>容器化技术：使用容器化技术（如Docker）将应用程序和其依赖项打包成独立的、可移植的容器，在不同的环境中快速部署和运行。</li>
<li>监控和日志分析：通过对软件运行时数据进行采集、储存、分析和可视化，监控系统状态、性能和安全等方面的指标，并及时发现和修复问题。</li>
</ul>
<h2> 大数据架构</h2>
<figure><figcaption>img_23.png</figcaption></figure>
<p>大数据架构是一种面向海量数据、高并发、高可靠、高性能的计算和存储系统架构，用于管理和处理大规模的结构化、半结构化和非结构化数据。它具有以下几个特点：</p>
<ul>
<li>高可扩展性：大数据架构应该能够轻松地扩展到海量数据和高并发请求下。</li>
<li>高容错性：大数据架构应该在硬件、网络和软件故障等异常情况下保证系统稳定性。</li>
<li>实时计算：大数据架构需要支持实时计算和流式处理，以满足复杂的业务场景。</li>
<li>数据安全：大数据架构需要保证数据的机密性、完整性和可用性，避免数据泄露和损坏。</li>
<li>成本效益：大数据架构应该充分考虑成本问题，尽可能利用开源技术和云平台来降低系统运维和资源开销。<br>
比如常见的大数据架构包括<code>Hadoop、Spark、Storm、Kafka</code><br>
等开源软件，它们可以被组合在一起形成一个完整的数据处理流水线。例如，Hadoop可以提供分布式文件系统HDFS和MapReduce计算模型，Spark可以提供内存计算和机器学习功能，Storm可以提供实时数据处理功能，Kafka可以提供高可靠的消息队列服务。使用这些开源软件和云平台，企业可以构建出适合自己场景的大数据处理系统，提升自身的业务竞争力。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T11:45:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计注意事项二</title>
    <id>https://ujava.cn/highfreq/attention2.html</id>
    <link href="https://ujava.cn/highfreq/attention2.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> 一.设计原则</h2>
<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>示例：</p>
<ul>
<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>
<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>
<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> 一.设计原则</h2>
<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>示例：</p>
<ul>
<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>
<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>
<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>
</ul>
<h4> 1.合适原则</h4>
<blockquote>
<p>合适优于业界领先。</p>
</blockquote>
<p>在进行架构设计的同时，需要考虑自身业务，而不是一味的去参照业界顶尖的规模，如：QQ、微信、淘宝架构。真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>
<h4> 2.简单原则</h4>
<blockquote>
<p>简单优于复杂。</p>
</blockquote>
<p>软件架构设计是一门技术活，当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>
<p>软件复杂度的体现，主要有以下两个方面：</p>
<p>结构的复杂性<br>
– 组成复杂系统的组件数量更多；<br>
– 组件之间的关系也更加复杂。</p>
<p>其问题主要有：</p>
<ul>
<li>（1）组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li>
<li>（2）某个组件改动，会影响关联的所有组件。</li>
<li>（3）定位一个复杂系统中的问题总是比简单系统更加困难。</li>
</ul>
<h4> 逻辑的复杂性</h4>
<p>逻辑的复杂性来源于一个组件集中了太多的功能，修改协作困难；并且，其中某些业务还可能使用了一些复杂的算法，导致难以理解、修改困难。</p>
<p>一个组件集中了太多功能，就会表现出一些逻辑复杂性的特征，为了解决这个问题，一般的手段是进行组件的拆分，但随着组件的细化，又会引入结构复杂性的一些特征，所以，在做结构设计的时候，需要权衡这两者。</p>
<h4> 3.演化原则</h4>
<blockquote>
<p>演化优于一步到位。</p>
</blockquote>
<p>维基百科对“软件架构”的定义如下：</p>
<blockquote>
<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>
</blockquote>
<p>这个定义中，将建筑和软件架构做了一个比较，但是，两者之间是有一个本质区别的：对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。<br>
也就是说，软件架构的本质是：软件架构需要根据业务发展不断变化，所以，我们在做软件架构设计的时候，不要试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>
<p>架构设计的过程基本上可以总结为下面三个历程：</p>
<ul>
<li>首先，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。--<br>
小重构</li>
<li>最后，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。--<br>
大重构</li>
</ul>
<p>我们在做架构设计的时候，切勿贪大求全，或者盲目的照搬大公司的做法，而是要牢记软件架构的本质（软件架构需要根据业务发展不断变化）。认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T11:45:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计实践经验</title>
    <id>https://ujava.cn/highfreq/experience.html</id>
    <link href="https://ujava.cn/highfreq/experience.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<ul>
<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>
<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>
<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>
<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>
<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>
OAuth2.0 协议来实现多渠道认证。
<ul>
<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>
<li>合并登录方式 登录方式以手机号为中心 合并。</li>
<li>渠道分组，按渠道分组分区分服。</li>
</ul>
</li>
<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>
<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>
<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>
<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>
<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>
<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>
<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>
<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>
例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<ul>
<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>
<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>
<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>
<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>
<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>
OAuth2.0 协议来实现多渠道认证。
<ul>
<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>
<li>合并登录方式 登录方式以手机号为中心 合并。</li>
<li>渠道分组，按渠道分组分区分服。</li>
</ul>
</li>
<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>
<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>
<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>
<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>
<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>
<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>
<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>
<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>
例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个操作相对比较耗费性能，要谨慎操作。在数据量超千万的表中进行释放，一定要保证cpu核数至少大于等于2。因为这时候会占用1core的资源全部用来处理。时长可能超过5min。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T11:18:05.000Z</published>
  </entry>
  <entry>
    <title type="text">一致性Hash算法</title>
    <id>https://ujava.cn/highfreq/hash.html</id>
    <link href="https://ujava.cn/highfreq/hash.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>
<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>
<h2> 产生背景</h2>
<p>考虑这么一种场景：</p>
<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>
<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>
<h2> 产生背景</h2>
<p>考虑这么一种场景：</p>
<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>
<p>我们可能首先想到的方案是：取模算法hash（key）% N，即：对 key 进行 hash 运算后取模，N 是机器的数量；</p>
<p>这样，对 key 进行 hash 后的结果对 3 取模，得到的结果一定是 0、1 或者 2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题；</p>
<figure><figcaption>img_7.png</figcaption></figure>
<p>取模算法虽然使用简单，但对机器数量取模，在集群扩容和收缩时却有一定的局限性：因为在生产环境中根据业务量的大小，调整服务器数量是常有的事；</p>
<p>而服务器数量 N 发生变化后hash（key）% N计算的结果也会随之变化！</p>
<figure><figcaption>img_8.png</figcaption></figure>
<p>比如：一个服务器节点挂了，计算公式从hash（key）% 3变成了hash（key）% 2，结果会发生变化，此时想要访问一个 key，这个 key 的缓存位置大概率会发生改变，那么之前缓存 key 的数据也会失去作用与意义；</p>
<p>大量缓存在同一时间失效，造成缓存的雪崩，进而导致整个缓存系统的不可用，这基本上是不能接受的；</p>
<p>为了解决优化上述情况，一致性 hash 算法应运而生~</p>
<h2> 什么是一致性哈希算法</h2>
<p>一致性哈希算法是一种用于分布式系统中的数据分片和负载均衡的算法。它将整个哈希空间划分为一个环，并且每个节点在这个环上都有一个对应的位置。当需要读写某个数据时，先将其进行哈希运算得到一个哈希值，然后根据这个哈希值在环上找到对应的节点，从而实现数据的定位。</p>
<p>一致性哈希算法的优点在于：当新增或删除节点时，只会影响到环上的一小部分节点，因此不会像传统的哈希算法那样造成大量的数据迁移和重新分片。同时，由于节点数较多，请求可以被更好地平均分配，从而实现了负载均衡的效果。</p>
<p>另外，一致性哈希算法还可以通过增加虚拟节点来解决节点不均衡的问题，从而进一步提高负载均衡的效果。</p>
<h2> 一致性哈希算法原理</h2>
<p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系；</p>
<p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题；</p>
<p>一致性 hash 算法本质上也是一种取模算法；</p>
<p>不过，不同于上边按服务器数量取模，一致性 hash 是对固定值 2^32 取模；</p>
<p>IPv4 的地址是 4 组 8 位 2 进制数组成，所以用 2^32 可以保证每个 IP 地址会有唯一的映射；</p>
<ol>
<li>hash 环<br>
我们可以将这2^32个值抽象成一个圆环 ⭕️，圆环的正上方的点代表 0，顺时针排列，以此类推：1、2、3…直到2^32-1，而这个由 2 的 32 次方个点组成的圆环统称为hash环；</li>
</ol>
<figure><figcaption>img_9.png</figcaption></figure>
<ol start="2">
<li>服务器映射到 hash 环<br>
在对服务器进行映射时，使用hash（服务器ip）% 2^32，即：</li>
</ol>
<p>使用服务器 IP 地址进行 hash 计算，用哈希后的结果对2^32取模，结果一定是一个 0 到2^32-1之间的整数；</p>
<p>而这个整数映射在 hash 环上的位置代表了一个服务器，依次将node0、node1、node2三个缓存服务器映射到 hash 环上；</p>
<figure><figcaption>img_10.png</figcaption></figure>
<ol start="3">
<li>对象 key 映射到服务器<br>
在对对应的 Key 映射到具体的服务器时，需要首先计算 Key 的 Hash 值：hash（key）% 2^32；</li>
</ol>
<p>注：此处的 Hash 函数可以和之前计算服务器映射至 Hash 环的函数不同，只要保证取值范围和 Hash 环的范围相同即可（即：2^32）；</p>
<p>将 Key 映射至服务器遵循下面的逻辑：</p>
<p>从缓存对象 key 的位置开始，沿顺时针方向遇到的第一个服务器，便是当前对象将要缓存到的服务器；</p>
<p>假设我们有 “semlinker”、“kakuqo”、“lolo”、“fer” 四个对象，分别简写为 o1、o2、o3 和 o4；</p>
<p>首先，使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p>
<figure><figcaption>img_11.png</figcaption></figure>
<p>图中对象的映射关系如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时 3 台缓存服务器，分别为 CS1、CS2 和 CS3：</p>
<figure><figcaption>img_12.png</figcaption></figure>
<p>则可知，各对象和服务器的映射关系如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即：</p>
<figure><figcaption>img_13.png</figcaption></figure>
<p>以上便是一致性 Hash 的工作原理；</p>
<blockquote>
<p>可以看到，一致性 Hash 就是：将原本单个点的 Hash 映射，转变为了在一个环上的某个片段上的映射！</p>
</blockquote>
<h2> 服务器扩缩容场景</h2>
<ol>
<li>服务器减少</li>
</ol>
<p>假设 CS3 服务器出现故障导致服务下线，这时原本存储于 CS3 服务器的对象 o4，需要被重新分配至 CS2 服务器，其它对象仍存储在原有的机器上：</p>
<figure><figcaption>img_14.png</figcaption></figure>
<p>此时受影响的数据只有 CS2 和 CS3 服务器之间的部分数据！</p>
<ol start="2">
<li>服务器增加</li>
</ol>
<p>假如业务量激增，我们需要增加一台服务器 CS4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p>
<figure><figcaption>img_15.png</figcaption></figure>
<p>此时，只有 t1 和 t2 服务器之间的部分对象需要重新分配；</p>
<p>在以上示例中只有 o3 对象需要重新分配，即它被重新到 CS4 服务器；</p>
<p>在前面我们已经说过：如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配！</p>
<h2> 数据偏斜&amp;服务器性能平衡问题</h2>
<ol>
<li>引出问题</li>
</ol>
<p>在上面给出的例子中，各个服务器几乎是平均被均摊到 Hash 环上；</p>
<p>但是在实际场景中很难选取到一个 Hash 函数这么完美的将各个服务器散列到 Hash 环上；</p>
<p>此时，在服务器节点数量太少的情况下，很容易因为节点分布不均匀而造成数据倾斜问题；</p>
<p>如下图被缓存的对象大部分缓存在node-4服务器上，导致其他节点资源浪费，系统压力大部分集中在node-4节点上，这样的集群是非常不健康的：</p>
<figure><figcaption>img_16.png</figcaption></figure>
<p>同时，还有另一个问题：</p>
<p>在上面新增服务器 CS4 时，CS4 只分担了 CS1 服务器的负载，服务器 CS2 和 CS3 并没有因为 CS4 服务器的加入而减少负载压力；如果 CS4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的；</p>
<ol start="2">
<li>虚拟节点</li>
</ol>
<p>针对上面的问题，我们可以通过：引入虚拟节点来解决负载不均衡的问题：</p>
<p>即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器；</p>
<p>如下图所示：</p>
<figure><figcaption>img_17.png</figcaption></figure>
<p>在图中：o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示实际的物理服务器；</p>
<ol start="3">
<li>虚拟节点的计算</li>
</ol>
<p>虚拟节点的 hash 计算通常可以采用：对应节点的 IP 地址加数字编号后缀 hash（10.24.23.227#1) 的方式；</p>
<p>举个例子，node-1 节点 IP 为 10.24.23.227，正常计算node-1的 hash 值：</p>
<ul>
<li>
<p>hash（10.24.23.227#1）% 2^32<br>
假设我们给 node-1 设置三个虚拟节点，node-1#1、node-1#2、node-1#3，对它们进行 hash 后取模：</p>
</li>
<li>
<p>hash（10.24.23.227#1）% 2^32</p>
</li>
<li>
<p>hash（10.24.23.227#2）% 2^32</p>
</li>
<li>
<p>hash（10.24.23.227#3）% 2^32</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>分配的虚拟节点个数越多，映射在 hash 环上才会越趋于均匀，节点太少的话很难看出效果；</li>
<li>引入虚拟节点的同时也增加了新的问题，要做虚拟节点和真实节点间的映射，对象key-&gt;虚拟节点-&gt;实际节点之间的转换；</li>
</ul>
<h2> 使用场景</h2>
<p>一致性 hash 在分布式系统中应该是实现负载均衡的首选算法，它的实现比较灵活，既可以在客户端实现，也可以在中间件上实现，比如日常使用较多的缓存中间件memcached和redis集群都有用到它；</p>
<p>memcached 的集群比较特殊，严格来说它只能算是伪集群，因为它的服务器之间不能通信，请求的分发路由完全靠客户端来的计算出缓存对象应该落在哪个服务器上，而它的路由算法用的就是一致性 hash；</p>
<p>还有 redis 集群中 hash 槽的概念，虽然实现不尽相同，但思想万变不离其宗，看完本篇的一致性 hash，你再去理解 redis 槽位就轻松多了；</p>
<p>其它的应用场景还有很多：</p>
<ul>
<li>RPC框架Dubbo用来选择服务提供者</li>
<li>分布式关系数据库分库分表：数据与节点的映射关系</li>
<li>LVS负载均衡调度器</li>
<li>……</li>
</ul>
<h2> 小结</h2>
<p>一致性哈希是一种用于分布式系统中数据负载均衡的算法。在分布式系统中，多个服务器节点需要负责处理不同的请求，但由于每个请求的负载大小不同，因此会导致服务器节点的负载不平衡，一些节点可能会过度负载，而另一些节点则占用较少的资源。这就需要一种算法来平衡各个节点之间的负载。</p>
<p>一致性哈希算法通过将服务器节点和请求都映射到一个固定的哈希环上，使得每个请求可以被映射到一个特定的服务器节点上。同时，在哈希环上沿顺时针方向查找离该请求最近的服务器节点，并将该请求路由到该节点上，从而实现了负载均衡。一致性哈希算法还支持添加或删除服务器节点，同时保持大部分请求仍然能够映射到原来的节点上，以避免数据迁移带来的复杂性和成本。</p>
<p>总之，一致性哈希算法可以提高分布式系统的可扩展性和可靠性，减少系统崩溃等问题的风险，从而更好地满足大规模应用所需的高吞吐量和低延迟要求。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T10:57:00.000Z</published>
  </entry>
  <entry>
    <title type="text">系统设计原则</title>
    <id>https://ujava.cn/highfreq/design.html</id>
    <link href="https://ujava.cn/highfreq/design.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>
<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>
<p>在设计系统时，应该多思考墨菲定律:</p>
<ul>
<li>任何事情都没有表面看起来那么简单</li>
<li>所有的事情都会比你预计的时间长</li>
<li>可能会出错的事一定会出错</li>
<li>如果你担心某种情况发生，那么它就更有可能发生</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>
<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>
<p>在设计系统时，应该多思考墨菲定律:</p>
<ul>
<li>任何事情都没有表面看起来那么简单</li>
<li>所有的事情都会比你预计的时间长</li>
<li>可能会出错的事一定会出错</li>
<li>如果你担心某种情况发生，那么它就更有可能发生</li>
</ul>
<p>在系统划分时，也要思考康威定律:</p>
<ul>
<li>系统架构是公司组织架构的反映</li>
<li>应该按照业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚/低耦合，减少沟通成本</li>
<li>如果沟通出现问题，那么就应该考虑进行系统和组织架构的调整</li>
<li>在合适时机进行系统拆分，不要一开始就把系统/服务拆得非常细，虽然闭环，但是每个人维护的系统多，维护成本高该处使用的url网络请求的数据。</li>
</ul>
<h2> 一、系统的技术设计原则</h2>
<h3> 1.1.高并发原则</h3>
<h4> 1.1.1.无状态</h4>
<p>如果设计的是无状态的，那么应用比较容易进行水平扩展。</p>
<p>实际生产环境可能是这样的：应用无状态，配置文件有状态。比如，不同的机房需要读取不同的数据源，此时，就需要通过配置文件或配置中心指定。比如后台系统使用session共享机制保证分布式部署。</p>
<h4> 1.1.2.拆分</h4>
<p>在系统设计时，要考虑到系统是否做拆分。如果资源有限，并且用户并没有那么多，可以做一个大而全的系统。</p>
<p>而高并发的应用，通常是要做拆分的。拆分可以依据多个维度：</p>
<ul>
<li>系统维度 ：如订单、库存、商品系统等</li>
<li>功能维度 ：如，对登录系统再拆分，划分为 ：验证码登录、微信登录、密码登录等功能。</li>
<li>读写维度 ：针对读写再做分离，读服务可以使用缓存、写服务使用分库分表。</li>
</ul>
<h4> 1.1.3.服务化</h4>
<p>首先判断单点服务是否可以满足。如果不能满足，集群可以吗？使用Nginx做负载均衡是否可以解决？</p>
<p>服务越来越多，是否要使用服务自动注册与发现？某些服务访问量太大，导致整个系统不可用，要不要上服务降级和限流？哪些是主要服务？</p>
<h4> 1.1.4.消息队列</h4>
<p>消息队列的作用有三个 ：削峰、解耦、异步。</p>
<p>使用消息队列可以实现服务解耦（一对多消费）、异步处理、流量削峰/缓冲等。但是订阅者太多，那么订阅单个消息队列就会成为瓶颈，此时需要考虑对消息队列进行多个镜像复制。</p>
<p>使用消息队列时，需要注意消息丢失、重复接收的场景。这对于不能容忍生产失败的业务场景来说，一定要做好后续的数据处理工作，比如持久化数据同时要增加日志、报警等，或者在生产失败后发送http请求来保证成功。还有消息重复问题，特别是一些分布式消息队列，出于对性能和开销的考虑，在一些场景下会发送消息重复接收，需要在代码层面进行防重处理。</p>
<h4> 1.1.5.缓存</h4>
<p>缓存对读服务来说，是扛流量的必选技术。不同的场景缓存不同的信息，以解决不同的问题：</p>
<ul>
<li>浏览器端缓存</li>
<li>客户端缓存</li>
<li>CDN缓存</li>
<li>接入层缓存: 使用Nginx做一层缓存</li>
<li>应用层缓存</li>
<li>分布式缓存</li>
<li>异步与并发:某些资源实时性没那么高，可以考虑使用异步加载，如用户评价、商品打分这种。获取多个资源时，采用并发的方式获取，可以大大的加快访问速度。</li>
</ul>
<h4> 1.1.6.数据异构</h4>
<p>所谓数据异构，是把数据按需（数据结构、存取方式、存取形式）异地构建存储。比如将mysql里面的数据缓存到redis里面去，就是一种数据异构的方式。</p>
<p>分库分表中有一个最为常见的场景，为了提升数据库的查询能力，我们都会对数据库做分库分表操作。比如订单库，开始的时候是按照订单ID维度去分库分表，那么后来的业务需求按照商家维度去查询。相同的数据需要做多种异构可以使用MQ机制接收数据的变更，然后存储到合适的存储引擎，如订单id纬度的分库分表、商家纬度的分库分表、用户纬度的分库分表、redis、Elasticsearch等。</p>
<p>另外，还需要考虑对历史订单数据进行归档处理，以提升服务的性能和稳定性。而有些数据异构的意义不大，如库存架构，可以考虑异步加载，或者合并并发请求。</p>
<p>总结起来大概有以下几种场景：</p>
<ul>
<li>
<p>数据库镜像</p>
</li>
<li>
<p>数据库实时备份</p>
</li>
<li>
<p>多级索引</p>
</li>
<li>
<p>search build（比如分库分表后的多维度数据查询）</p>
</li>
<li>
<p>业务cache刷新</p>
</li>
<li>
<p>价格、库存变化等重要业务消息<br>
常见的异构方式：</p>
</li>
<li>
<p>完全克隆。做数据备份。将数据库A，全部拷贝一份到数据库B，这样的使用场景是离线统计跑任务脚本的时候可以。缺点也很突出，不适用于持续增长的数据。</p>
</li>
<li>
<p>binlog方式。比如使用比较广泛的canal是基于mysql数据库binlog的增量订阅和消费组件。订阅mysql的binlog日志，消费这些日志做主从同步、缓存更新。</p>
</li>
<li>
<p>MQ方式。业务数据写入DB的同时，也发送MQ一份，也就是业务里面实现双写，消费MQ的数据做各种异构处理。这种方式比较简单，但也很难保证数据一致性，对简单的业务场景可以采用这种方式。</p>
</li>
</ul>
<h3> 1.2.高可用原则</h3>
<h4> 1.2.1.降级</h4>
<p>对于一个高可用服务，很重要的一个设计就是降级开关，提前写好降级逻辑。</p>
<p>可以手动降级，也可以自动降级。自动降级触发的条件可以使用：超时的请求数超过阈值、异常的请求数超过阈值时。阈值具体设置为多少，通过压测初步确认，上线观察后，再次调整。</p>
<p>降级的手段：停止读数据库、准确结果转为近似结果、使用静态结果、同步转异步、功能裁剪、禁止写（高峰期减少不必要的写）、分用户降级、工作量证明POW(<br>
验证码、数学题、拼图、滑块)。</p>
<p>主要依据如下思路：</p>
<ul>
<li>开关集中化管理：通过推送机制把开关推送到各个应用。</li>
<li>可降级的多级读服务：可以指定服务调用降级为只读本地缓存、只读分布式缓存、只读默认数据。</li>
<li>开关前置化: 如架构是Nginx—&gt;Apache，可以将开关前置到Nginx接入层，在Nginx层做开关，请求流量汇源后端应用或者只是一小部分流量回源</li>
<li>业务降级：当高并发流量来袭，保证核心业务是正常的，并保障数据最终一致性即可。这样就把一些同步调用改成异步调用，优先处理高优先级数据或特殊特征的数据，合理分配进入系统的流量，以保障系统可用。</li>
</ul>
<h4> 1.2.2.限流</h4>
<p>当监控发现外部流量超过阈值或内部资源使用达到阈值（通过压测、上线观察、调整）时，告知各系统限流打开。</p>
<p>限流的目的是防止恶意请求流量，或者防止流量超出系统峰值。思路如下：</p>
<ul>
<li>
<p>基于请求的限流：</p>
<ul>
<li>限制请求总量。如腾讯会议最多500人。</li>
<li>限制时间量。如一个时间窗口内最多接受100个请求。</li>
</ul>
</li>
<li>
<p>基于关键资源的限流：</p>
<ul>
<li>统计连接数、线程数、cup等硬件参数。难点是如何确定哪些是关键资源、阈值是多少。</li>
<li>使用池化技术：线程池、连接池；使用队列排队；</li>
</ul>
</li>
</ul>
<p>相关限流的算法：</p>
<ul>
<li>滑动时间窗口：有突刺</li>
<li>漏桶: 请求进入队列的速度不受限制，但是超过队列的大小就拒绝，请求出队列的速度固定。请求会匀速出队列。</li>
<li>令牌桶：系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。有突刺。<br>
有些大流量是正常的用户，这种是要临时的水平扩容。</li>
</ul>
<p>原则是限制流量穿透到后端薄弱的应用层</p>
<h4> 1.2.3.熔断</h4>
<p>熔断发生的三个必要条件，缺一不可，必须全部满足才能开启 hystrix 的熔断功能：</p>
<ul>
<li>
<p>有一个统计的时间周期，滚动窗口；如1000毫秒</p>
</li>
<li>
<p>请求次数必须达到一定数量；如20次</p>
</li>
<li>
<p>失败率达到阈值；如50%<br>
熔断器的三个状态：</p>
</li>
<li>
<p>关闭状态。关闭状态时用户请求是可以到达服务提供方的。</p>
</li>
<li>
<p>开启状态。开启状态时用户请求是不能到达服务提供方的，直接会走降级方法。</p>
</li>
<li></li>
</ul>
<p>半开状态。当熔断器开启时，过一段时间后，熔断器就会由开启状态变成半开状态。半开状态的熔断器是可以接受用户请求并把请求传递给服务提供方的，这时候如果远程调用返回成功，那么熔断器就会有半开状态变成关闭状态，反之，如果调用失败，熔断器就会有半开状态变成开启状态。<br>
Hystrix功能建议在并发比较高的方法上使用，并不是所有方法都得使用的。</p>
<p>Sentinel的熔断策略是根据响应时间，响应时间超过阈值，熔断开关打开。</p>
<h4> 1.2.4.恢复</h4>
<p>撤出限流、消除降级、关闭熔断</p>
<p>熔断使用半开状态，完成吞吐量爬升、缓存预热。</p>
<p>灰度发布，限流阈值逐步提升。</p>
<h4> 1.2.5.隔离</h4>
<ul>
<li>数据隔离：数据按照重要性排序、分库</li>
<li>机器隔离：给重要的用户单独配置服务器，用用户标识去路由</li>
<li>线程池隔离：线程池分配。hystrix</li>
<li>信号量隔离：计数器。hystrix</li>
<li>集群隔离：服务分组（注册中心）、秒杀</li>
<li>机房隔离：3个服务。局域网IP、路由。</li>
<li>读写隔离：主从</li>
<li>动静隔离：识别静态资源。nginx CDN</li>
<li>爬虫隔离：对IP的访问频率</li>
<li>冷热隔离：秒杀、抢购。读：缓存；写：缓存+队列</li>
</ul>
<h4> 1.2.6.异地多活</h4>
<p>异地机房部署相同的服务，同时对外提供服务（不是备份）。防止因为停电、火灾、水灾、地震、战争等问题导致服务不可用。</p>
<p>异地多活通常考虑RTT(round trip time):网络请求一个来回消耗的传输时间。光纤光速计算 300000 KM/s，两个机房如果一个在上海，一个在新疆，隔5000KM，<br>
rtt = 300000 / 5000 * 2 = 120毫秒的往返时延。</p>
<p>多活要求：</p>
<ul>
<li>
<p>请求任何一个节点，都能正常响应</p>
</li>
<li>
<p>某些系统故障，用户访问其他系统也能访问<br>
分类：</p>
</li>
<li>
<p>同城异区：距离较近，可以防止停电、机房起火</p>
</li>
<li>
<p>跨域异地：距离较近，可以防止停电、机房起火、火灾、水灾、地震。</p>
</li>
<li>
<p>跨国异地（隔离）：延迟，已经无法让系统提供服务了。通常在异国开展业务，数据和服务就放在异国，和国内数据是隔离的。<br>
异地多活容易出现数据不一致问题，要保证核心业务的多活。如用户系统有注册、登陆、修改用户信息等功能，保证正常注册、登陆多活，修改用户信息可以根据时间合并数据。</p>
</li>
</ul>
<h4> 1.2.7.可回滚</h4>
<p>灰度发布。版本化机制，当程序出错时，回滚到上一个版本。</p>
<h2> 二、业务设计原则</h2>
<h3> 2.1.防重、幂等</h3>
<p>重复提交业务，消息中间件重复消费消息。使用分布式锁、数据库唯一键等保证。</p>
<h3> 2.2.模块复用</h3>
<p>相同的功能只开发一次，模块化。不要到处拷贝相同的代码。</p>
<h3> 2.3.可追溯</h3>
<p>可以快速追踪到问题涉及的这个数据链路，快速定位问题。traceId</p>
<h3> 2.4.反馈原则</h3>
<p>给出精确友好的结果反馈。如http接口调用异常时尽量给出精确的异常原因，降低内外部沟通成本。</p>
<h3> 2.5.流程可定义</h3>
<p>相关工作有明确的流程规范</p>
<h3> 2.6.系统审批化</h3>
<p>系统变更需要审批</p>
<h3> 2.7.文档和注释</h3>
<p>完善文档和注释</p>
<h3> 2.8.备份</h3>
<ul>
<li>代码备份：git、分支</li>
<li>数据备份：运维备份，操作记录备份。</li>
<li>人员备份：不因个人离职导致项目停滞。</li>
</ul>
<h3> 2.9.规范</h3>
<p>制定规范，定期review。</p>
<h2> 三、系统性能常见指标</h2>
<h3> 3.1.响应时间（Response time）</h3>
<p>响应时间就是用户感受软件系统为其服务所耗费的时间，对于网站系统来说，响应时间就是从点击了一个页面计时开始，到这个页面完全在浏览器里展现计时结束的这一段时间间隔，看起来很简单，但其实在这段响应时间内，软件系统在幕后经过了一系列的处理工作，贯穿了整个系统节点。</p>
<p>根据“管辖区域”不同，响应时间可以细分为：</p>
<ul>
<li>服务器端响应时间这个时间指的是服务器完成交易请求执行的时间，不包括客户端到服务器端的反应（请求和耗费在网络上的通信时间），这个服务器端响应时间可以度量服务器的处理能力。</li>
<li>网络响应时间，这是网络硬件传输交易请求和交易结果所耗费的时间。</li>
<li>客户端响应时间，这是客户端在构建请求和展现交易结果时所耗费的时间，对于普通的瘦客户端Web应用来说，这个时间很短，通常可以忽略不计；但是对于胖客户端Web应用来说，比如Java<br>
applet、AJAX，由于客户端内嵌了大量的逻辑处理，耗费的时间有可能很长，从而成为系统的瓶颈，这是要注意的一个地方。<br>
那么客户感受的响应时间其实是等于客户端响应时间+服务器端响应时间+网络响应时间。细分的目的是为了方便定位性能瓶颈出现在哪个节点上。</li>
</ul>
<h3> 3.2.吞吐量（Throughput）</h3>
<p>吞吐量是我们常见的一个软件性能指标，对于软件系统来说，“吞”进去的是请求，“吐”出来的是结果，而吞吐量反映的就是软件系统的“饭量”，也就是系统的处理能力，具体说来，就是指软件系统在每单位时间内能处理多少个事务/请求/单位数据等。但它的定义比较灵活，在不同的场景下有不同的诠释，比如数据库的吞吐量指的是单位时间内，不同SQL语句的执行数量；而网络的吞吐量指的是单位时间内在网络上传输的数据流量。吞吐量的大小由负载（如用户的数量）或行为方式来决定。举个例子，下载文件比浏览网页需要更高的网络吞吐量。</p>
<h3> 3.3.资源使用率（Resource utilization）</h3>
<p>常见的资源有：CPU占用率、内存使用率、磁盘I/O、网络I/O。</p>
<h3> 3.4.点击数（Hits per second）</h3>
<p>点击数是衡量Web Server处理能力的一个很有用的指标。需要明确的是：点击数不是我们通常理解的用户鼠标点击次数，而是按照客户端向Web<br>
Server发起了多少次http请求计算的，一次鼠标可能触发多个http请求，这需要结合具体的Web系统实现来计算。</p>
<h3> 3.3.并发用户数（Concurrent users）</h3>
<p>并发用户数用来度量服务器并发容量和同步协调能力。在客户端指一批用户同时执行一个操作。并发数反映了软件系统的并发处理能力，和吞吐量不同的是，它大多是占用套接字、句柄等操作系统资源。</p>
<p>另外，度量软件系统的性能指标还有系统恢复时间等，其实凡是用户有关资源和时间的要求都可以被视作性能指标，都可以作为软件系统的度量，而性能测试就是为了验证这些性能指标是否被满足。</p>
<h2> 四、总结</h2>
<p>一个系统的设计，不仅需要考虑实现业务功能，还要保证系统高并发、高可用等。在系统容量规划（流量、容量等）、SLA制定（吞吐量、响应时间、可用性、降级方案等）、压测方案（线上、test等）、监控报警（机器负载、响应时间、可用率等）、应急预案（容灾、降级、限流、隔离、切流量、可回滚）等方面，也要有一些原则来进行设计。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T10:34:42.000Z</published>
  </entry>
  <entry>
    <title type="text">设计时可使用的工具</title>
    <id>https://ujava.cn/highfreq/tool.html</id>
    <link href="https://ujava.cn/highfreq/tool.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> JUnit test</h2>
<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>
<h2> EclEmma</h2>
<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>
<h2> Checkstyle</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> JUnit test</h2>
<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>
<h2> EclEmma</h2>
<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>
<h2> Checkstyle</h2>
<p>Checkstyle是一个静态代码分析工具，用于帮助开发团队遵循一致的编码规范。它可以检查代码中的格式错误、命名约定、代码风格和其他潜在的问题，并生成相应的报告。通过使用Checkstyle，团队可以提高代码质量、可读性和可维护性。</p>
<h2> SpotBugs</h2>
<p>SpotBugs是一个静态代码分析工具，用于检测Java程序中的潜在缺陷和错误。它可以发现常见的编程错误、空指针引用、资源泄漏、线程安全问题等。SpotBugs提供了详细的报告和建议，帮助开发人员改进代码质量和可靠性。</p>
<h2> VisualVM</h2>
<p>VisualVM是一个功能强大的Java虚拟机（JVM）监视和性能分析工具。它可以显示应用程序的内存使用情况、线程活动、垃圾收集行为等，并提供实时的性能监控和分析。VisualVM还支持插件和扩展，可以与其他工具集成以提供更丰富的功能。</p>
<h2> Git</h2>
<p>版本控制系统，用于管理和跟踪源代码的变更。可以查看历史提交记录、分支、合并代码等。</p>
<h2> Eclipse Memory Analyzer</h2>
<p>Eclipse Memory Analyzer (MAT) 是一个用于分析 Java<br>
应用程序的内存使用情况的工具。它可以通过分析堆转储文件（例如通过jmap生成的文件）来查找内存泄漏、大对象、过多的对象等问题，而无需执行正在开发的软件代码。MAT提供了强大的内存分析功能，可以帮助开发人员定位和解决内存相关的问题。</p>
<h2> JMap</h2>
<p>jmap是Java虚拟机（JVM）的一个诊断工具，它可以生成Java堆转储文件，其中包含了Java应用程序在运行时的内存使用情况。通过使用jmap生成堆转储文件，可以将其提供给Eclipse<br>
Memory Analyzer（MAT）等工具进行进一步的分析，而无需执行正在开发的软件代码。</p>
<h2> Jenkins</h2>
<p>jenkins：一个开源的持续集成和交付工具，可自动构建、测试和部署软件项目。它可以设置为监控代码库的变更，并在发生变更时触发自动构建和测试过程。</p>
<h2> 自动化测试架构</h2>
<h4> TestNG + Mocktio</h4>
<p>JUnit是Java单元测试的一站式解决方案，它把测试驱动的开发思想介绍给了Java开发人员，并教会他们如何有效地编写单元测试。但是在过去的几年中，JUnit的改进并不大，所以为当前复杂的环境编写测试任务已经变得越来越困难，即JUnit必须与其他一些补充性测试框架集成起来。TestNG是一个测试Java应用程序的新框架，功能十分强大。</p>
<p>EasyMock和Mockito可以极大地简化单元测试的编写过程，因而被许多程序员应用在日常工作中。这两个工具无法实现对静态函数、构造函数、私有函数、Final函数和系统函数的模拟，而这些函数在大型系统中必不可少。</p>
<h4> JUnit + JMock</h4>
<p>单元测试一般只测试某一个功能，但是由于类之间的耦合，往往难以把功能隔离开来。例如，想要测试某个业务逻辑处理数据的功能，但是数据是从Database取回的，这就涉及DAO层的类调用。但是很多时候，你不想让单元测试函数去访问数据库（，而是希望有一个假的DAO类刚好可以返回你需要的测试数据。此时即可使用Mock，它的作用是在单元测试里模拟类的行为和状态。</p>
<p>JMock与Mocktio都是提供Mock功能的框架。</p>
<h2> 自动化持续集成部署架构</h2>
<h4> Git/SVN + Jenkins</h4>
<p>Git和SVN都是版本控制器。Git是分布式管理的版本控制器，通常被用于分布式模式，也就是说，每个开发人员从中心版本库或服务器上检出代码后都会在自己的机器上克隆一个与中心版本库一模一样的本地版本库。而SVN是集中式管理的版本控制器。</p>
<p>Jenkins是一个开源的、提供友好操作界面的持续集成工具，主要用于持续、自动地构建或测试软件项目、监控外部任务的运行。Jenkins是用Java语言编写的，既可以在Tomcat等流行的Servlet容器中运行，也可以独立运行。Jenkins通常与版本管理工具（SCM）和构建工具结合使用。</p>
<p>常用的版本控制工具有SVN和Git等，常用的构建工具有Maven、Ant和Gradle等。</p>
<p>Jenkins涉及持续集成（Continuous Integration，CI）和持续交付（Continuous Delivery，CD）。持续集成强调开发人员在提交新代码之后，立刻进行构建和（单元）测试。根据测试结果，确定新代码和原有代码能否正确地集成在一起。持续交付是在持续集成的基础上，将集成后的代码部署到类生产环境中。</p>
<p>Jenkins可以把FTP、SVN或Git中存储的Java程序持续构建到生产与测试环境中。也就是说，在微服务分布式环境下，不需要每次更新都在各个服务器上上传代码。一个项目的服务器越多，Jenkins的优势越明显。与Jenkins类似的软件有Travis CI等，不再赘述。</p>
<h4> Puppet</h4>
<p>Puppet是Linux、UNIX和Windows操作系统的自动管理引擎，它根据集中式规范执行管理任务（例如，添加用户、安装软件包和更新服务器配置等）。Puppet的简单陈述规范语言的能力提供了强大的代理服务，制定了主机之间的相似之处，同时使它们能够提供尽可能具体的、必要的管理内容，它依赖的先决条件和对象之间的关系清楚且明确。</p>
<p>Puppet主要解决的是环境部署的难点，例如，需要给50台服务器安装JDK，或者给10台服务器的MongoDB升级版本。如果在升级过程中出现意外的Bug和错误，此时就可以通过Puppet编写相关配置文件，一键安装到所有服务器上。与Puppet类似的软件有Homebrew等。</p>
<h2> 高并发架构</h2>
<h4> FreeMaker/Thymeleaf + FastDFS</h4>
<p>页面静态化指将部分前端需要经常请求的内容，通过页面静态化引擎转换成独立的HTML页面进行缓存。也就是说，不再需要请求后端代码，即可直接返回独立的HTML页面，减轻后端的压力。例如，在某小说网站中如果对某本热门小说的每一章内容都去请求后端，则服务器和数据库的压力会过大，通过页面静态化技术，可以把该热门小说的每一章内容都制作成独立的HTML页面，当返回该页面时，服务器承受的压力几乎可以忽略不计。除小说网站外，门户网站、新闻网站、博客网站和视频网站都可以通过这样的技术进行架构。</p>
<p>FreeMaker/Thymeleaf + FastDFS是一种页面静态化+文件管理系统的高并发架构，多用于视频、电商、小说等网站。这里的FastDFS也可以换成其他软件，其目的是减少对数据库的读取，将静态化页面存储在某存储引擎或文件管理系统中。</p>
<p>传统SSM项目架构在上传静态文件时通常上传至SSM项目服务器的本地，无法针对存储进行加卷之类的扩展性操作，因而FastDFS应运而生。FastDFS是专门为了管理静态文件制作的独立运行的应用程序，静态文件可能包含图片、GIF、TXT等。</p>
<p>在Spring Boot + FastDFS + Thymeleaf架构中，FastDFS主要负责保存Thymeleaf生成的静态文件，并提供给Spring Boot进行读写操作。这是一种很常见的以空间换时间的架构模式。当文件管理系统中的数据量过大时，可以进行定时删除操作，极大地减少对MySQL的访问量。</p>
<p>当然，电商网站用Elasticsearch引擎或MongoDB缓存的也非常多，方便在读取页面时返回不同的数据，减少对MySQL数据库的访问量。页面静态化+文件管理系统的架构更加细致，返回速度更快，压力更小。</p>
<p>下面用一个简单的例子介绍Spring Boot + FastDFS + Thymeleaf架构的业务流程。假设前端需要请求一页新闻，首先，请求Redis查看缓存中是否包含Thymeleaf生成的静态页面标识。若没有，则通过MySQL请求静态页面标识。其次，在拿到静态页面标识后，即可通过FastDFS请求到HTML静态页面，并直接将其返回给前端进行处理。另外，管理员或定时任务可以定时修改FastDFS中的新闻（相当于更新FastDFS中的缓存）。</p>
<p>如果不使用该架构，仍假设前端需要请求一页一万字的新闻，则先在Redis中查询是否包含这一万字的新闻。若没有，再在MySQL中查询一万字的String字符串，转化速度极慢。这种架构相当于将大量的字符都缓存了起来 ， 减 少 了 后 端 的 压 力 。 但 是 将 N 篇 一 万 字 的 新 闻 都 缓 存 在 Redis 或Elasticsearch中并不是好的选择。</p>
<h4> Spring Boot +Netty+ gRpc + Protobuf</h4>
<p>Spring Boot + Netty + gRPC +Protobuf是一种多语言多协议的集成架构，多用于金融、医疗等网站。</p>
<p>Protobuf是一个与平台和语言无关，可扩展且轻便高效的序列化数据结构协议，可用于网络通信和数据存储。Protobuf像XML和JSON一样，可以让由不同语言编写并在不同平台上运行的应用程序交换数据。例如，用Go语言编写的发送程序可以在Protobuf中对用Go语言编写的销售订单数据进行编码，然后用Java语言编写的接收方对它进行解码，以获取所接收订单数据的Java表示方式。Protobuf传输的是二进制数据。Protobuf和其他编码系统对结构化数据进行序列化和反序列化。</p>
<p>远程过程调用（Remote Procedure Call，RPC）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，而且遵从C/S模型。在使用时，客户端调用服务器端提供的接口就像调用本地的函数一样。</p>
<p>gRPC是Google公司针对远程过程调用提供的一种实现框架，通过gRPC框架配合ProtoBuf序列化传输协议，可以使数据如同本地调用一样轻松跨语言传输。例如，对于一些特定内容，若C++性能比Java性能更加优秀，则可以使用C++代码编写，之后再通过gRPC+ Protobuf架构让Java代码直接调用。</p>
<h4> Spring Batch + Quartz + Kettle</h4>
<p>Spring Batch是Spring全家桶的一个组件，是一个批处理应用框架。它不是调度框架，但需要和调度框架合作来构建并完成批处理任务。它只关注批处理任务相关的问题，如事务、并发、监控、执行等，并不提供相应的调度功能。如果需要使用调度框架，则可以使用Quartz、Tivoli、Control-M、Cron等企业级调度框架。Spring Batch擅长数据迁移、数据同步、数据批处理等工作。</p>
<p>Quartz是OpenSymphony开源组织在Job Scheduling领域的又一个开源项目，它既可以与J2EE和J2SE应用程序相结合，也可以单独使用。Quartz可以用来创建简单的或者可以运行上万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p>
<p>Spring Batch + Quartz通常与Kettle、MySQL一起使用。Kettle是一款国外开源的ETL（Extract-Transform-Load）数据仓库技术工具，可以在Window、Linux、UNIX操作系统上运行，数据抽取高效稳定。Spring Batch +Quartz可将多个数据源的数据统一置入数据仓库中，由数据仓库导出各种所需要的数据。例如，原本的数据为用户表、购物车表和商品表，经数据仓库处理之后，可直接返回所需要的数据格式，而非多个表或多个值。除此之外，Kettle包含界面化导出Excel的功能，可以由非技术类人员导出相关数据。</p>
<h2> 响应式编程架构</h2>
<p>响应式编程（Reactive Programming）是一种面向数据流和变化传播的范式，可以在编程语言中很方便地表达静态或动态的数据流，相关的计算模型会自动将变化的值通过数据流进行传播。例如，c=a+b表示将a+b表达式的结果赋给c。在传统编程中，改变a或b的值不会影响c；但在响应式编程中，c的值会随着a或b值的变化而变化。</p>
<p>Reactor是一个基于JVM之上的异步应用框架。为Java、Groovy和其他JVM语言提供构建基于事件和数据驱动应用的抽象库。Reactor的性能相当高，在最新的硬件平台上，使用无堵塞分发器每秒可以处理1500万个事件。</p>
<p>Reactor框架是Spring之前的项目，实现了Reactive Programming思想，符合Reactive Streams规范。。Spring WebFlux是在Ractor框架基础上实现的响应式Web框架，完全无阻塞，支持Reactive Streams背压，并且可以在Netty、Undertow和Servlet 3.1+等服务器上运行。</p>
<p>Spring WebFlux的功能较多，下面通过代码展示部分功能：<br>
<br>
</p>
<p>此时分别调用controller1接口与controller2接口，后台日志输出如下所示：<br>
</p>
<h2> 负载均衡架构</h2>
<p>负载均衡的含义是通过多台服务器共同承载压力。例如，一个HTTP请求通过Nginx中间件转发给多台Tomcat的架构形式即为负载均衡架构。</p>
<p>负载均衡架构有多种表现形式，如下所示：</p>
<ul>
<li>服务器端静态反向代理负载均衡架构：Keepalived + Nginx + Java。该架构被负载的实际地址是在配置文件中直接编写的IP地址与端口。该架构形式无法在正在运行的过程中进行修改。</li>
<li>服务器端动态反向代理负载均衡架构：Nginx + UpSync + Consul +Java。该架构被负载的实际地址是通过Consul注册中心记录的。Nginx会通过UpSync插件获得到实际地址并进行负载均衡。该架构形式可以在系统正常运行时更新Java程序的节点。</li>
<li>客 户 端 负 载 均 衡 架 构 Spring Cloud + Consul + Spring BootRibbon。在该架构中，当Java1程序请求Java2程序时，Java1程序会通过Consul获取Java2程序的节点信息，若Java2程序在Consul中注册了N个节点，则Java1程序在获得所有Java2程序的节点信息之后，会通过算法请求Java2程序的其中一个节点，即以客户端请求直接进行分发的方式达到负载均衡的目的</li>
<li>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，以便将客户端的访问引导到不同的服务器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。这种负载均衡技术通常由云服务商提供。与DNS负载均衡类似的是CDN负载均衡，不再赘述。</li>
<li>硬件负载均衡技术：通常由硬件直接进行数据与请求分发，达到负载均衡的结果。市场上常见的硬件有NetScaler和Radware等。</li>
<li>协议性负载均衡架构。例如，通过HTTP协议的重定向功能进行负载均衡，或通过自研协议进行负载均衡。</li>
<li>混合型负载均衡架构。使用多种负载均衡架构的混合架构，不同的应用程序可以采用不同的负载均衡架构。</li>
</ul>
<h2> 监控工具与监控架构</h2>
<h4> 性能监控设计</h4>
<p>性能监控通常指监控Linux服务器的CPU、内存、I/O、硬盘、应用程序接口耗时等，常见的性能监控架构如下所示：</p>
<ul>
<li>Telegraf + InfluxDB + Chronograf + Kapacitor架构。</li>
<li>Prometheus + Grafana架构。</li>
<li>Elasticsearch + Logstash + Kibana + Filebeat架构。</li>
<li>Zabbix + Grafana架构。<br>
在Telegraf + InfluxDB + Chronograf + Kapacitor架构（简称TICK架构）中，InfluxDB为时序数据库，负责数据存储；Telegraf为独立运行的采集软件，负责数据采集；Chronograf负责数据可视化；Kapacitor负责告警、预警。Telegraf从Linux系统或相关文件中获取数据，通过HTTP接口传到InfluxDB数据库中，Chronograf会定时从InfluxDB数据库中获取相关数据并进行展示。</li>
</ul>
<p>TICK架构可转换成Telegraf + InfluxDB + Grafana架构（简称TIG架构），其中，Grafana提供数据可视化与报警、预警功能。TICK架构也可转换成Prometheus + Grafana架构（简称PG架构），即由Prometheus负责数据的采集与存储。</p>
<p>在 Elasticsearch + Logstash + Kibana 架 构 （ 简 称 ELK 架 构 ） 中 ，Logstash负责数据的采集，Elasticsearch负责数据的存储，Kibana负责数据的展示。当Logstash在大型项目中采集能力不足时，偶尔会增加Filebeat来采集数据，之后通过Logstash管道传输给Elasticsearch。</p>
<p>ELK架构与TICK架构、TIG架构和PG架构的相似之处在于各个角色的划分几乎相同，并且都可以采集CPU、内存等信息，与TICK架构、TIG架构和PG架构相比，ELK架构更着重于采集不同类型的数据，具有更丰富的生态，不过在构建一些监控图表时，较为费时费力。TICK架构、TIG架构和PG架构的监控图表更加美观，搭建与报警也更加简便，所以业内通常采用TICK架构和TIG架构作为性能监控设计，采集CPU、内存、硬盘等相关信息；采用ELK架构作为业务监控设计，采集程序日志、Nginx日志、接口请求等相关信息。采用TICK架构、TIG架构作为性能监控设计主要。采用PG架构采集MySQL相关的信息。</p>
<p>Zabbix与上面的软件都不同，它是一套自我完善的监控软件，也就是说，只使用Zabbix，也可以完成对CPU、内存等相关信息的监控。Zabbix是一个基于Web界面的提供分布式系统监视和网络监视功能的企业级的开源解决方案。Zabbix能控各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制，以便让系统管理员快速定位并解决存在的问题。</p>
<p>Zabbix由两部分组成，zabbix server与可选组件zabbix agent。zabbixserver可以通过SNMP、zabbix agent、ping、端口监视等实现对远程服务器或网络状态的监控、数据收集等功能，它可以运行在Linux、Solaris、OS X等平台上。</p>
<p>Zabbix自带图表功能，但图表并不美观，所以通常结合Grafana使用。</p>
<h2> 全链路监控</h2>
<p>Pinpoint是一款全链路分析工具，提供了无侵入式的调用链监控和方法执行详情查看、应用状态信息监控等功能，与另一款开源的全链路分析工具Zipkin类似。与Zipkin相比，Pinpoint提供了无侵入式等特性，支持的功能较为丰富，可以帮助分析系统的总体结构，以及分布式应用程序组件之间是如何进行数据互联的。</p>
<p>服务拓扑图：对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的详细信息，比如当前节点状态、请求数量等</p>
<p>实时活跃线程图：监控应用内活跃线程的执行情况，可以直观地了解应用的线程执行性能。请求响应散点图：以时间维度进行请求计数和响应时间的展示，通过拖动图表可以选择对应的请求，查看执行的详细情况。</p>
<p>请求调用栈查看：对分布式环境中的每个请求都提供了代码维度的可见性，可以在页面中查看请求针对代码维度的执行详情，帮助查找请求的瓶颈和故障原因。</p>
<p>应用状态、机器状态检查：查看相关应用程序的其他详细信息，比如CPU的使用情况、内存状态、垃圾收集状态、TPS和JVM信息等参数。</p>
<p>与Pinpoint类似的还有Zorka和Scouter等。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-17T10:18:13.000Z</published>
  </entry>
  <entry>
    <title type="text">影响项目的要素及经验总结</title>
    <id>https://ujava.cn/highfreq/effect.html</id>
    <link href="https://ujava.cn/highfreq/effect.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>项目失败的因素主要分为以下几类</p>
<h2> 技术原因</h2>
<p>1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足；</p>
<p>2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善；</p>
<p>3、为非技术问题提供了技术解决方案，没有认真思考问题的本质；</p>
<p>4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性；</p>
<p>5、在开发生命周期过程中没有充分利用工具；</p>
<p>6、以技术为导向进行开发，而不是需求导向；</p>
<h2> 人为因素</h2>
<p>1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>项目失败的因素主要分为以下几类</p>
<h2> 技术原因</h2>
<p>1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足；</p>
<p>2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善；</p>
<p>3、为非技术问题提供了技术解决方案，没有认真思考问题的本质；</p>
<p>4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性；</p>
<p>5、在开发生命周期过程中没有充分利用工具；</p>
<p>6、以技术为导向进行开发，而不是需求导向；</p>
<h2> 人为因素</h2>
<p>1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；</p>
<p>2、缺少领导，团队内部多头领导；</p>
<p>3、没有敬业精神的项目团队；</p>
<p>4、功能不全的项目团队，人员配比缺失；</p>
<p>5、管理第三方的因素，如技术外包的项目；</p>
<p>6、缺少一个项目精英，如专职的项目经理；</p>
<p>7、缺少项目所有权；</p>
<p>8、相关人员冲突，指人员配比失衡；</p>
<p>9、拒绝变更，无法面对需求的变化；</p>
<p>10、不友好的组织文化；</p>
<p>11、经验不足的项目经理；</p>
<p>12、缺少商业理由，项目的价值较低；</p>
<p>13、不清晰或模棱两可的优先级；</p>
<p>14、缺少培训，项目执行过程中状况百出；</p>
<p>15、相关人员动机不一致，缺乏向心力；</p>
<h2> 过程管理因素</h2>
<p>1、 缺少项目管理方法体系；</p>
<p>2、 缺少系统开发方法体系；</p>
<p>3、缺少收益管理方法体系；</p>
<p>4、缺少质量管理方法体系；</p>
<p>5、未能确定和转移项目风险；</p>
<p>6、未能管理好需求；</p>
<p>7、过长的项目时间表；</p>
<p>8、测试覆盖不足；</p>
<p>9、计算机化的”爆炸“方法</p>
<p>从失败中吸取教训是不断改进过程的重要组成部分，下面罗列一些主要的经验教训。</p>
<h2> 管理用户预期</h2>
<p>即项目人员要从一开始就明白需要交付什么以及不要交付什么，要在项目中确定用户的需求和建立尽可能清晰的所有权。即使在最好的情况下，用户以前收到的信息也是有限的。通常情况下，我们很难确定能够提供反馈信息的合适用户。在项目一开始就需要确定主要的用户需求，并且为主要用户提供时间，以便他们确定所有的需求，同时他们也有责任提供和验证信息并投入相应的资源。</p>
<h2> 项目规格说明书中必须考虑价值和用户需求</h2>
<p>第一，项目是因为可确定且可测量的用户需求而产生并发展的。在项目初期确定的清晰目标将随着项目的进展而逐渐变得模糊，这是交付期限过长的项目所共有的特点。因此在项目开始之前，需要确定最终用户，以便在项目的设计和开发过程中充分考虑到他们的需求，同时用户也有责任而且需要采取相应的行动来帮助项目获得成功，这一点非常重要。用户需求构成了项目分析和设计阶段中一个至关重要的环节。需求确定后，就要为这些需求确定基线，并将它们引入到项目管理系统中，同时使用变更控制对其进行管理。如果这些需求出现了变更或添加了新需求，则需要对项目进行影响分析，并对项目计划进行相应的修正。</p>
<p>第二，项目规格说明书必须关注项目价值而不是技术解决方案。因此，即使从技术上讲已经存在明确的解决方案，但在进行项目评审时仍需将重点放在与项目价值相关的方面。</p>
<h2> 在确定资源前测量和评估项目的规模和复杂度（重视实现性）</h2>
<p>技术力量的发展带来了一个不好的后果，就是让我们相信，许多以前不可能实现的目标如今不但可以实现了，而且可以轻而易举地实现。有时候这种想法在项目的早期阶段通常表现为对项目的潜在收益过分夸大、过于庞大的项目范围定义以及过分乐观却相当危险且不够详细的项目规划。项目的规模和复杂度是项目成功与否的一个决定性因素，因此我们需要明确确定的是</p>
<p>a、提议的项目进度表是否现实可行；</p>
<p>b、项目的需求案例是否可行；</p>
<p>c、解决方案在技术上是否可行；</p>
<h2> 新技术的引入必须安排相应的培训</h2>
<p>新技术或者一些开源工具会给项目带来的不少影响，容易导致有关程序员角色和责任的不明确。因此在项目计划中纳入培训成本和时间进度以确保员工知道如何使用和维护系统是至关重要的。没有合理的培训就是永远不可能实现软件投资的全部潜在收益。更重要的是，缺少培训可能会为项目带来实现风险和运作风险，这些风险可能会最终威胁项目的长期可用性。</p>
<h2> 清晰可见的项目管理结构</h2>
<p>在管理结构中必须存在定义清楚的角色、责任和义务，明确各个项目成员自身所处的角色及相应的职责。在项目的开始阶段就应该确定正式的组织结构以及与高级管理层交流的途径，同时在项目的整个过程中予以保持。</p>
<h2> 处理好人员问题</h2>
<p>人才永远是项目成功的最重要因素。人员开发计划必须与组织中的项目管理框架同步进行，从而提供培训、业绩评估、分派工作和职位晋升相关的机制。谁都希望项目团队里都是高度主动性和熟练技能的员工，但现实往往很残酷，如果应届生较多的话，还是早点安排老员工带一下，这样能尽快的上手。</p>
<h2> 接受风险，但要严格管理风险</h2>
<p>项目的成功实现需要有有效的风险管理所支持的创造性思维。要及时对一些影响项目进度的功能模块进行调查并重新进行风险分析工作以及后续的风险管理工作，从而对需求进行重新评估并相应的调整计划。</p>
<p>项目管理是一门学问，需要一定时间的工作经验积累，并不是去考个PMP回来就能当项目经理的，真正注重的还是实践，照搬理论那一套的话，很多公司内部的现状都不足以支撑PMP所要求的完善体系，大型公司可以试下。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-15T09:28:58.000Z</published>
  </entry>
  <entry>
    <title type="text">概要设计和详细设计</title>
    <id>https://ujava.cn/highfreq/summary.html</id>
    <link href="https://ujava.cn/highfreq/summary.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概要设计和详细设计</h2>
<p>在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？</p>
<p>一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。<br>
结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。</p>
<p>这样一来，设计可以明显地划分成两个阶段：</p>
<ul>
<li>概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。</li>
<li>详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 概要设计和详细设计</h2>
<p>在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？</p>
<p>一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。<br>
结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。</p>
<p>这样一来，设计可以明显地划分成两个阶段：</p>
<ul>
<li>概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。</li>
<li>详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。</li>
</ul>
<h2> 一、概要设计阶段</h2>
<p>在这个阶段，设计者会大致考虑并照顾模块的内部实现，但不过多纠缠于此。主要集中于划分模块、分配任务、定义调用关系。模块间的接口与传参在这个阶段要定得<br>
十分细致明确，应编写严谨的数据字典，避免后续设计产生不解或误解。概要设计一般不是一次就能做到位，而是反复地进行结构调整。典型的调整是合并功能重复的模块，或者进一步分解出可以复用的模块。在概要设计阶段，应最大限度地提取可以重用的模块，建立合理的结构体系，节省后续环节的工作量。</p>
<p>概要设计文档最重要的部分是分层数据流图、结构图、数据字典以及相应的文字说明等。以概要设计文档为依据，各个模块的详细设计就可以并行展开了。</p>
<h2> 二、详细设计阶段</h2>
<ul>
<li>在这个阶段，各个模块可以分给不同的人去并行设计。在详细设计阶段，设计者的工作对象是一个模块，根据概要设计赋予的局部任务和对外接口，设计并表达出模块的算法、流程、状态转换等内容。这里要注意，如果发现有结构调整（如分解出子模块等）的必要，必须返回到概要设计阶段，将调整反应到概要设计文档中，而不能就地解决，不打招呼。</li>
<li>详细设计文档最重要的部分是模块的流程图、状态图、局部变量及相应的文字说明等。一个模块一篇详细设计文档。</li>
<li>概要设计文档相当于机械设计中的装配图，而详细设计文档相当于机械设计中的零件图。文档的编排、装订方式也可以参考机械图纸的方法。</li>
<li>概要设计中较顶层的部分便是所谓的方案。方案文档的作用是在宏观的角度上保持设计的合理性。</li>
</ul>
<p>有的项目采用面向对象的分析、设计方法。可能在概要设计、详细设计的分工上疑问更多。其实，面向对象的分析、设计方法并没有强调结构化方法那样的阶段性，因此一般不引入概要、详细设计的概念。如果按照公司的文档体系，非要有这种分工的话，可以将包的划分、类及对象间的关系、类的对外属性、方法及协作设计看做</p>
<ul>
<li>概要设计；类属性、方法的内部实现看做详细设计。</li>
<li>需求分析--产生软件功能规格说明书,需要确定用户对软件的需求,要作到明确、无歧义。不涉及具体实现方法。用户能看得明白，开发人员也可据此进行下面的工作（概要设计）。</li>
<li>概要设计--产生软件概要设计说明书，说明系统模块划分、选择的技术路线等，整体说明软件的实现思路。并且需要指出关键技术难点等。</li>
<li>详细设计--产生软件详细设计说明书，对概要设计的进一步细化，一般由各部分的担当人员依据概要设计分别完成，然后在集成，是具体的实现细节。理论上要求可以照此编码。</li>
</ul>
<h2> 三、概要设计和详细设计的区别与联系</h2>
<ul>
<li>概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。</li>
<li>详细设计阶段就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。</li>
<li>概要设计阶段通常得到软件结构图，详细设计阶段常用的描述方式有：流程图、N-S图、PAD图、伪代码等。</li>
<li>软件设计采用自顶向下、逐次功能展开的设计方法，首先完成总体设计，然后完成各有机组成部分的设计。根据工作性质和内容的不同，软件设计分为概要设计和详细设计。概要设计实现软件的总体设计、模块划分、用户界面设计、数据库设计等等；详细设计则根据概要设计所做的模块划分，实现各模块的算法设计，实现用户界面设计、数据结构设计的细化，等等。</li>
<li>概要设计是详细设计的基础，必须在详细设计之前完成，概要设计经复查确认后才可以开始详细设计。概要设计，必须完成概要设计文档，包括系统的总体设计文档、以及各个模块的概要设计文档。每个模块的设计文档都应该独立成册。</li>
<li>详细设计必须遵循概要设计来进行。详细设计方案的更改，不得影响到概要设计方案；如果需要更改概要设计，必须经过项目经理的同意。详细设计，应该完成详细设计文档，主要是模块的详细设计方案说明。和概要设计一样，每个模块的详细设计文档都应该独立成册。</li>
<li>概要设计里面的数据库设计应该重点在描述数据关系上，说明数据的来龙去脉，在这里应该结合我们的一下结果数据，说明这些结果数据的源点，我们这样设计的目的和原因。详细设计里的数据库设计就应该是一份完善的数据结构文档，就是一个包括类型、命名、精度、字段说明、表说明等内容的数据字典。</li>
<li>概要设计里的功能应该是重点在功能描述，对需求的解释和整合，整体划分功能模块，并对各功能模块进行详细的图文描述，应该让读者大致了解系统作完后大体的结构和操作模式。详细设计则是重点在描述系统的实现方式，各模块详细说明实现功能所需的类及具体的方法函数，包括涉及到的sql语句等。</li>
</ul>
<h2> 四、软件设计的过程</h2>
<p>1、制定规范</p>
<p>在软件开发组设计标准，规定编码的信息格式，命名规则</p>
<p>2、软件系统结构的总体设计</p>
<p>基于功能层次，划分模块，采用抽象、分层、模块分解</p>
<p>3、处理方式设计</p>
<p>确定为实现功能的需求所必须的算法，评估算法的性能。</p>
<p>4、数据结构设计</p>
<p>确定数据的模式，子模式，安全性，整体性，输入输出文件的结构和模式</p>
<p>5、可靠性设计（质量设计）</p>
<p>运行期间为了使用要求，保证可靠的运行</p>
<p>6、编写概要设计阶段的文档</p>
<p>概要设计说明书，数据库的说明书，进一步完善用户手册，制定初步的测试计划</p>
<p>7、概要设计评审</p>
<p>概要设计说明书，评审的要点：可追溯性、接口、</p>
<p>模块的内部，高内聚、低耦合</p>
<p>模块的作用于是否在控制范围内，实用性，技术清晰性</p>
<p>其他的选择方案，</p>
<p>8、详细设计阶段</p>
<p>确定软件各个组成部分的算法，</p>
<p>选定某种过程的表达形式，</p>
<p>进行详细设计的评审，</p>
<h2> 五、软件设计的基础</h2>
<p>自定下下，逐步细化</p>
<p>将软件的体系结构按自定向下方式，对各个层次的过程细节和数据细节逐层细化</p>
<p>软件结构</p>
<p>软件的结构包括两部分。程序的模块结构和数据的结构。</p>
<p>程序结构</p>
<p>树状结构、网状结构、</p>
<p>结构图</p>
<p>反应程序中模块中模块之间的层次调用关系和联系</p>
<p>模块</p>
<p>模块的调用关系和接口</p>
<p>模块之间的信息传递</p>
<p>表示模块A有条件地调用另一个模块</p>
<p>模块化</p>
<p>能够把一个大而复杂的软件系统划分成易于理解的比较单纯的模块结构。</p>
<p>抽象化</p>
<p>软件系统进行模块设计时，可以有不同的抽象层次。</p>
<p>功能抽象：</p>
<p>抽象层次1（高层次的抽象）：用问题所处环境的术语来描述这个软件。</p>
<p>抽象层次2：任务需求的描述。</p>
<p>抽象层次3：程序过程表示。</p>
<p>数据抽象：在不同层次上描述数据对象的细节，定义与该数据对象相关的操作。</p>
<p>模块独立性：</p>
<p>模块：一般具有如下三个基本属性：功能、逻辑、状态、模块的独立性、采用耦合和内聚</p>
<h2> 六、概要设计说明书：</h2>
<p>1、引言</p>
<p>1.1编写目的</p>
<p>1.2项目背景</p>
<p>1.3定义</p>
<p>1.4参考资料</p>
<p>2、任务概述</p>
<p>2.1目标</p>
<p>2.2运行环境</p>
<p>2.3需求概述</p>
<p>2.4条件与限制</p>
<p>3、总体设计</p>
<p>3.1处理流程</p>
<p>3.2总体结构和模块外部设计</p>
<p>3.3功能分配</p>
<p>4、接口设计</p>
<p>4.1外部接口</p>
<p>4.2内部接口</p>
<p>5、数据结构设计</p>
<p>5.1逻辑结构设计</p>
<p>5.2物理结构设计</p>
<p>5.3数据结构与程序的关系</p>
<p>6、运行设计</p>
<p>6.1运行模块的组合</p>
<p>6.2运行控制</p>
<p>6.3运行时间</p>
<p>7、出错处理设计</p>
<p>7.1出错输出信息</p>
<p>7.2出错处理对策</p>
<p>8、安全保密设计</p>
<p>9、维护设计</p>
<h2> 详细设计说明书</h2>
<p>1、引言</p>
<p>1.1编写目的</p>
<p>1.2项目背景</p>
<p>1.3定义</p>
<p>1.4参考资料</p>
<p>2、总体设计</p>
<p>2.1需求概述</p>
<p>2.2软件结构</p>
<p>3、程序描述</p>
<p>3.1功能</p>
<p>3.2性能</p>
<p>3.3输入项目</p>
<p>3.4输出项目</p>
<p>3.5算法</p>
<p>3.6程序逻辑</p>
<p>3.7接口</p>
<p>3.8存储分配</p>
<p>3.9限制条件</p>
<p>3.10测试要点</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-15T09:23:27.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:六大设计原则</title>
    <id>https://ujava.cn/principle/theory.html</id>
    <link href="https://ujava.cn/principle/theory.html"/>
    <updated>2023-11-15T09:09:37.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> 一、单一职责原则</h2>
<p>单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。</p>
<p>单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。</p>
<p>单一职责原则的好处：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> 一、单一职责原则</h2>
<p>单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。</p>
<p>单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。</p>
<p>单一职责原则的好处：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<p>注意： 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p>
<p>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>
<h2> 二、里氏替换原则</h2>
<p>里氏替换原则（Liskov Substitution Principle，LSP），有两种定义：</p>
<ul>
<li>
<p>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P<br>
defined in terms of T ,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p>
</li>
<li>
<p>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes<br>
without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>
</li>
<li>
<p>第二个定义是最清晰明确的，通俗点讲，只要父类出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必就能适应。</p>
</li>
</ul>
<p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义：</p>
<ul>
<li>子类必须完全实现父类的方法；
<ul>
<li>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则；</li>
<li>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</li>
</ul>
</li>
<li>子类可以有自己的个性；</li>
<li>覆盖或实现父类的方法时输入参数可以被放大；
<ul>
<li>如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴；</li>
<li>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</li>
</ul>
</li>
<li>覆写或实现父类的方法时输出结果可以被缩小。
<ul>
<li>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。</li>
</ul>
</li>
</ul>
<p>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续执行。</p>
<h2> 三、依赖倒置原则</h2>
<p>依赖倒置原则（Dependence Inversion Principle,DIP）,原始定义是：High level modules should not depend upon low level<br>
modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon<br>
abstractions.</p>
<p>包含三层含义：</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。</li>
</ul>
<p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。依赖倒置原则在Java语言中的表现就是：</p>
<p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p>
<p>接口或抽象类不依赖于实现类；</p>
<p>实现类依赖接口或抽象类。 更加精简的定义就是“面向接口编程”--OOD（Object-Oriented Design，面向对象设计）的精髓之一。</p>
<p>依赖的三种写法：</p>
<p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D。。。。。。生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p>
<p>对象的依赖关系有三种方式来传递：</p>
<ul>
<li>
<p>构造函数传递依赖对象 --- 在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。</p>
</li>
<li>
<p>Setter方法传递依赖对象 --- 在抽象中设置Setter方法声明依赖关系，依照注入的说法，这是Setter依赖注入。</p>
</li>
<li>
<p>在接口的方法中声明依赖对象，这种方式也叫做接口注入。<br>
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的规则就可以：</p>
</li>
<li>
<p>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备； --- 这是依赖倒置的基本要求，接口或抽象类都是属于抽象的，有了抽象才可能依赖倒置。</p>
</li>
<li>
<p>变量的表面类型尽量是接口或者是抽象类；</p>
</li>
<li>
<p>任何类都不应该从具体类派生；</p>
</li>
<li>
<p>尽量不要覆写基类的方法； --- 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。</p>
</li>
<li>
<p>结合里氏替换原则使用。 --- 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</p>
</li>
</ul>
<h2> 四、接口隔离原则</h2>
<p>接口分为两种：</p>
<ul>
<li>
<p>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的食物的描述，这是一种接口。</p>
</li>
<li>
<p>类接口（Class Interface），Java中经常使用的interface关键字定义的接口；</p>
</li>
<li>
<p>Clients should not be forced to depend upon interfaces that they don‘t use。（客户端不应该依赖它不需要的接口。）</p>
</li>
<li>
<p>The dependency of one class to another one should depend on the smallest possible interface。（类间的依赖关系应该建立在最小的接口上。）<br>
接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p>
</li>
<li>
<p>接口要尽量小； --- 这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。</p>
</li>
<li>
<p>接口要高内聚； --- 高内聚就是提高接口、类、模块的处理能力，减少对外的交互。在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也越有利于降低成本。</p>
</li>
<li>
<p>定制服务； ---  一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务。定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。</p>
</li>
<li>
<p>接口设计是有限度的。 --- 接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断？根据经验和常识判断，没有一个固话或可测量的标准。</p>
</li>
</ul>
<p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：</p>
<ul>
<li>一个接口只服务于一个模块或业务逻辑；</li>
<li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</li>
<li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</li>
<li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</li>
</ul>
<h2> 五、迪米特法则</h2>
<p>迪米特法则（Law of Demeter ，LoD）也称为最少知识原则（Least Knowledge<br>
Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>
<p>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义：</p>
<ul>
<li>只和朋友交流 --- 迪米特法则还有一个英文解释是：Only talk to your immedate<br>
friends（只与直接的朋友通信。）什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。注意：一个类只和朋友交流，不与陌生类交流，不要出现getA()<br>
.getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点后面返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK<br>
API提供的类除外。</li>
<li>朋友间也是有距离的 --- 一个类公开的public属性或方法越多，修改时涉及的面积越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected<br>
等访问权限，是否可以加上final关键字等。<br>
注意：迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</li>
<li>是自己的就是自己的 --- 如果一个方法放在本类中，即不增加类间的关系，也对本类不产生负面影响，就放置在本类中。</li>
<li>谨慎使用Serializable</li>
</ul>
<p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。</p>
<p>迪米特法则要求类间解耦，但解耦是有限度的，除非是计算机的最小单元——二进制的0和1。那才是完全解耦，在实际的项目中，需要适度地考虑这个原则，别为了套用原则而做项目。原则只是供参考，如果违背了这个原则，项目也未必会失败，这就需要大家在采用原则时反复度量，不遵循是不对的，严格执行就是“过犹不及”。</p>
<h2> 六、开放封闭原则</h2>
<p>开放封闭原则的定义：Software entities like classes, modules and functions should be open for extension but closed for<br>
modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）其含义是说一个软件实体应该通过扩展来实现变化。软实体包括以下几个部分：</p>
<ul>
<li>项目或软件产品中按照一定的逻辑规则划分的模块；</li>
<li>抽象和类；</li>
<li>方法。</li>
</ul>
<p>一个软件产品只要在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。开放封闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。</p>
<p>开放封闭原则对扩展开放，对修改封闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。我们可以把变化归纳以下三种类型：</p>
<ul>
<li>逻辑变化； -- 只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是 a<em>b+c ，现在需要修改为 a</em>b*c ，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖关系都按照相同的逻辑处理。</li>
<li>子模块变化； --- 一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层次模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的。</li>
<li>可见视图变化 --- 可见视图是提供给客户使用的界面，如JSP程序、Swing界面等，该部分的变化一般会引起连锁反应（特别是在国内做项目，做欧美的外包项目一般不会影响太大）。如果仅仅是界面上按钮、文字的重新排列倒是简单，最司空见惯的是业务耦合变化，什么意思？一个展示数据的列表，按照原有的需求是6列，突然有一天要增加1列，而且这一列要跨N张表，处理M个逻辑才能展现出来，这样的变化是比较恐怖的，但还是可以通过扩展来完成变化，这就要看我们原有的设计是否灵活。</li>
</ul>
<p><strong>为什么要采用开放封闭原则</strong>：</p>
<p>每个事物的诞生都有它存在的必要性，存在即合理，那开闭原则的存在也是合理的，为什么这么说呢？</p>
<p>首先，开闭原则是那么地著名，只要是做面向对象编程的，甭管是什么语言，Java也好，C++也好，或者是Smalltalk，在开发时都会提及开闭原则。</p>
<p>其次，开闭原则是最基础的一个原则，前面介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。换一个角度理解，依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类，开闭原则在面向对象设计领域中的地位就类似于牛顿第一定律在力学、勾股定律在几何学、质能方程在狭义相对论中的地位，其地位无人能及。</p>
<p>最后，开闭原则是非常重要的，可通过以下几个方面来理解其重要性。</p>
<p>1、开闭原则对测试的影响</p>
<p>所有已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经过“千锤百炼”的测试过程，不仅保证逻辑是正确的，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码（Poisonous<br>
Code）”，因此有变化提出时，我们就需要考虑一下，原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试，现在虽然在大力提倡自动化测试工具，但是仍然代替不了人工的测试工作。</p>
<p>2、 开闭原则可以提高复用性</p>
<p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什么要复用呢？减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码，然后发出对开发人员“极度失望”的感概。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。</p>
<p>3、开闭原则可以提高可维护性</p>
<p>一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂代码原有的代码，然后再修改，是一件很痛苦的事情，不要让他在原有的代码海洋里游戈完毕后再修改，那是对维护人员的一种折磨和摧残。</p>
<p>4、面向对象开发的要求</p>
<p>万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。</p>
<p><strong>如何使用开闭原则</strong></p>
<p>1、抽象约束</p>
<p>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。</p>
<p>2、元数据（metadata）控制模块行为</p>
<p>编程时使用元数据来控制程序的行为，减少重复开发。用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据中库中获得。</p>
<p>3、制定项目章程</p>
<p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。相信大家都做过项目，会发现一个项目会产生非常多的配置文件。以SSH项目开发为例，一个项目中Bean配置文件就非常多，管理非常麻烦。如果需要扩展，就需要增加子类，并修改SpringContext文件。然而，如果你在项目中指定这样一个章程：所有的Bean都自动注入，使用Annotation进行装配，进行扩展时，甚至只用写一个类，然后由持久层生成对象，其他的都不需要修改，这就需要项目内约束，每个项目成员都必须遵守，该方法需要一个团队有较高的自觉性，需要一个较长时间的磨合，一旦项目成员都熟悉这样的规则，比通过接口或抽象类进行的约束效率更高，而且扩展性一点也没有减少。</p>
<p>4、封装变化</p>
<p>对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protected<br>
variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装，23个设计模式都是从各个不同的角度对变化进行封装的，我们会在各个模式中逐步讲解。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-15T09:09:37.000Z</published>
  </entry>
  <entry>
    <title type="text">设计考量</title>
    <id>https://ujava.cn/highfreq/consider.html</id>
    <link href="https://ujava.cn/highfreq/consider.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> 1、系统拆分</h2>
<p>有句古话 “牵一发而动全身”。</p>
<p>面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。</p>
<p>万物相通，回到我们的软件架构。</p>
<p>早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。</p>
<p>“鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。</p>
<p>因此，系统拆分 成了更多人的选择。</p>
<p>慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> 1、系统拆分</h2>
<p>有句古话 “牵一发而动全身”。</p>
<p>面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。</p>
<p>万物相通，回到我们的软件架构。</p>
<p>早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。</p>
<p>“鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。</p>
<p>因此，系统拆分 成了更多人的选择。</p>
<p>慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。</p>
<h2> 2、解耦</h2>
<p>软件开发有个重要原则“高内聚、低耦合”。</p>
<p>小到接口抽象、MVC 分层，大到 SOLID 原则、23种设计模式。核心都是降低不同模块间的耦合度，避免一处错误改动影响到整个系统。</p>
<p>就以开闭原则为例，对扩展是开放的，对修改是关闭的。随着业务功能迭代，如何做到每次改动不对原来的旧代码产生影响。</p>
<p>高内聚，低耦合方案（解耦方案）：</p>
<p>动态代理技术，通过对字节码进行增强，在方法调用的时候进行拦截，以便于在方法调用前后，增加我们需要的额外处理逻辑。</p>
<p>事件机制，通过发布订阅模式，新增的需求，只需要订阅对应的事件通知，针对性消费即可。不会对原来的代码侵入性修改，是不是会好很多。</p>
<p>队列，将消息丢往队列，消费者消费消息，提高可扩展性，性能</p>
<h2> 3、异步</h2>
<p>同步指一个进程在执行请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</p>
<p>效率会大大降低，聪明的人想到了 异步 方式。</p>
<p>如果是非实时响应的动作可以采用异步来完成，线程不需要一直等待，而是继续执行后面的逻辑。</p>
<p>如：线程池（ThreadPoolExecutor）、规则推送、消息队列 等都是这个原理</p>
<p>比如一个用户在淘宝下了一笔购物订单，关心的是订单是否创建成功，能否进行后续的付款流程</p>
<p>至于其他业务动作，如短信通知、邮件通知、生成订单快照、创建超时任务记录，这些非核心动作用户并不是特别关心。</p>
<p>我们可以采用消息队列的发布/订阅 机制，数据库插入订单记录后，发布一条消息到 MQ，然后就可以告知用户下单成功。</p>
<p>其他事情，由不同的 Task 任务订阅消息异步处理，彼此间互不干扰。</p>
<h2> 4、重试</h2>
<p>重试主要是体现在远程的RPC调用，受 网络抖动、线程资源阻塞 等因素影响，请求无法及时响应。</p>
<p>为了提升用户体验，调用方可以通过 重试 方式再次发送请求，尝试获取结果。比过：浏览器的 F5 刷新机制就是类似道理。</p>
<p>接口重试是一把双刃剑，虽然客户端收到了响应超时结果，但是我们无法确定，服务端是否已经执行完成。如果盲目地重试，可能会带来严重后果。比如：银行转账。</p>
<p>重试通常跟幂等组合使用，如果一个接口支持了 幂等，那你就可以随便重试</p>
<p>1、幂等性概念</p>
<p>顾名思义，所谓幂等就是对于数据的操作不论多少次，但始终操作的结果是一致的。也就是说，无论相同的查询操作多少次，得到结果始终只是一次的结果和影响。</p>
<p><strong>保证幂等方案</strong></p>
<h4> 1、查询操作：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作；</h4>
<h4> 2、删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；</h4>
<h4> 3、唯一索引：防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；</h4>
<h4> 4、token机制（防止重复提交）</h4>
<p>方式一：</p>
<p>原理上通过session token来实现的(也可以通过redis来实现)<br>
。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。</p>
<p>服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p>
<p>方式二：</p>
<p>调用方在调用接口时候先向后端请求一个全局ID（Token），请求的时候携带全局ID一起请求，后端需要用这个Token作为Key，用户信息作为Value到Redis中进行键值内容校验，如果Key存在且Value匹配就执行删除命令，然后执行后面的业务逻辑。如果不存在对应的Key或者Value不匹配就返回执行错误的信息。</p>
<p><br>
方式三：</p>
<p>请求每次访问时候，会记录当前请求相同参数，url的信息，访问时间，到期时间等放入redis，定义一个一定时间内防止重复处理的时间间隔，如果下次请求来的时候，通过url，参数等信息获取redis中的请求信息，如果redis中记录的访问时间小于上次请求时间+固定的时间间隔，就不允许访问。</p>
<h4> 5、乐观锁</h4>
<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：<br>
</p>
<h4> 6、分布式锁</h4>
<p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(<br>
redis或zookeeper)<br>
，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(<br>
用户ID+后缀等)<br>
获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(<br>
分布式锁要第三方系统提供)；</p>
<h4> 7、select + insert</h4>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；</p>
<h4> 8、状态机幂等</h4>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)<br>
，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>
<h4> 9、对外提供接口的api如何保证幂等</h4>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(<br>
并发时，只能处理一个请求) 。</p>
<p>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
<h2> 5、补偿</h2>
<p>我们知道不是所有的请求都能收到成功响应。除了上面的 重试 机制外，我们还可以采用补偿玩法，实现数据最终一致性。</p>
<p>业务补偿根据处理的方向分为两部分：</p>
<ul>
<li>正向。多个操作构成一个分布式事务，如果部分成功、部分失败，我们会通过最大努力机制将失败的任务推进到成功状态</li>
<li>逆向。同上道理，我们也可以采用反向操作，将部分成功任务恢复到初始状态</li>
</ul>
<p>注意：补偿操作有个重要前提，业务能接受短时间内的数据不一致。</p>
<p>补偿有很多的实现方式：</p>
<p>1、本地建表方式，存储相关数据，然后通过定时任务扫描提取，并借助反射机制触发执行</p>
<p>2、也可以采用简单的消息中间件，构建业务消息体，由下游的的消费任务执行。如果失败，可以借助MQ的重试机制，多次重试</p>
<h2> 6、备份</h2>
<p>任何服务器都有宕机的可能性，一旦存储了数据，带上状态，如果发生故障，数据丢失，后果是我们无法承受的。</p>
<p>所以，容灾备份也就变成了互联网的基本能力。</p>
<p>那如何备份，不同的框架有不用的玩法。我们以 Redis 为例：</p>
<p>Redis 借助 RDB 和 AOF 来实现两台服务器间的数据同步</p>
<ul>
<li>RDB，全量数据同步</li>
<li>AOF，增量数据同步，回放日志</li>
</ul>
<p>一旦主节点挂了怎么办？</p>
<p>这里引入哨兵机制。哨兵机制可以实现主从库的自动切换，有效解决了故障转移。整个过程分为三个阶段：监控、选主、通知。</p>
<p>除了 Redis 中间件外，其他常见的 MySQL、Kafka 消息中间件、HBase 、ES 等 ，凡是涉及到数据存储的介质，都有备份机制，一旦主节点挂了，会启用备份节点，保证数据不会丢失。</p>
<h2> 7、多活策略</h2>
<p>虽然有了上面的备份策略，那是不是就万事大吉呢？</p>
<p>在一些极端情况，如：机房断电、机房火灾、地震、山洪等不可抗力因素，所有的服务器都可能出现故障，无法对外提供服务，导致整体业务瘫痪。</p>
<p>为了降低风险，保证服务的24小时可用性，我们会采用 多活策略。</p>
<p>常见的多活方案有，同城双活、两地三中心、三地五中心、异地双活、异地多活</p>
<p>不同的方案技术要求、建设成本、运维成本也都不一样。</p>
<p>多活的技术方案复杂，需要考虑的问题点也非常多，这里只是抛砖引玉就不过多展开</p>
<h2> 8、隔离</h2>
<p>隔离属于物理层面的分割，将若干的系统低耦合设计，独立部署，从物理上隔开。</p>
<p>每个子系统有自己独立的代码库，独立开发，独立发布。一旦出现故障，也不会相互干扰。当然如果不同子系统间有相互依赖，这种情况比较特殊，需要有默认值或者异常特殊处理，这属于业务层面解决方案。</p>
<p>隔离属于分布式技术的衍生产物，我们最常见的微服务解决方案。</p>
<p>将一个大型的复杂系统拆分成若干个微服务系统，这些微服务子系统通常由不同的团队开发、维护，独立部署，服务之间通过 RPC 远程调用。</p>
<p>隔离使得系统间边界更加清晰，故障可以更加隔离开来，问题的发现与解决也更加快速，系统的可用性也更高。</p>
<h2> 9、限流</h2>
<p>高并发系统，如果遇到流量洪峰，超过了当前系统的承载能力。我们要怎么办？</p>
<p>一种方案，照单全收，CPU、内存、Load负载飚的很高，最后处理不过来，所有请求都超时无法正常响应。</p>
<p>另一种解决方案，“舍得，有舍有得”，多余的流量我们直接丢弃。</p>
<p>限流定义：</p>
<p>限制到达系统的并发请求数量，保证系统能够正常响应部分用户请求，而对于超过限制的流量，则通过拒绝服务的方式保证整体系统的可用性。</p>
<p>根据作用范围：限流分为单机版限流、分布式限流</p>
<p>1、单机版限流</p>
<p>主要借助于本机内存来实现计数器，比如通过AtomicLong#incrementAndGet()，但是要注意之前不用的key定期做清理，释放内存。</p>
<p>纯内存实现，无需和其他节点统计汇总，性能最高。但是优点也是缺点，无法做到全局统一化的限流。</p>
<p>2、分布式限流</p>
<p>单机版限流仅能保护自身节点，但无法保护应用依赖的各种服务，并且在进行节点扩容、缩容时也无法准确控制整个服务的请求限制。而分布式限流，以集群为维度，可以方便的控制这个集群的请求限制，从而保护下游依赖的各种服务资源。</p>
<p>限流支持多个维度：</p>
<ul>
<li>整个系统一定时间内（比如每分钟）处理多少请求</li>
<li>单个接口一定时间内处理多少流量</li>
<li>单个IP、城市、渠道、设备id、用户id等在一定时间内发送的请求数</li>
<li>如果是开放平台，则为每个appkey设置独立的访问速率规则</li>
</ul>
<p>常见的限流算法：</p>
<ul>
<li>计数器限流(固定窗口限流)</li>
<li>滑动窗口限流</li>
<li>漏桶限流</li>
<li>令牌桶限流</li>
</ul>
<h2> 10、熔断</h2>
<p>熔断，其实是对调用链路中某个资源出现不稳定状态时（如：调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p>
<p>熔断的主要方式是使用断路器阻断对故障服务器的调用</p>
<p>断路器有三种状态，关闭、打开、半打开。</p>
<ul>
<li>1、关闭（Closed）状态：在这个状态下，请求都会被转发给后端服务。同时会记录请求失败的次数，当请求失败次数在一段时间超过一定次数就会进入打开状态。</li>
<li>2、打开（Open）状态：在这个状态下，熔断器会直接拒绝请求，返回错误，而不去调用后端服务。同时，会有一个定时器，时间到的时候会变成半打开状态。目的是假设服务会在一段时间内恢复正常。</li>
<li>3、半打开（Half Open）状态：在这个状态下，熔断器会尝试把部分请求转发给后端服务，目的是为了探测后端服务是否恢复。如果请求失败会进入打开状态，成功情况下会进入关闭状态，同时重置计数。</li>
</ul>
<h2> 11、降级</h2>
<p>降级是系统保护的一种重要手段。</p>
<p>正如 “好钢用在刀刃上”，为了使有限资源发挥最大价值，我们会临时关闭一些非核心功能，减轻系统压力，并将有限资源留给核心业务。</p>
<p>比如电商大促，业务在峰值时刻，系统抵挡不住全部的流量时，系统的负载、CPU<br>
的使用率都超过了预警水位，可以对一些非核心的功能进行降级，降低系统压力，比如把商品评价、成交记录等功能临时关掉。弃车保帅，保证<br>
创建订单、订单支付 等核心功能的正常使用。</p>
<p>当然，不同业务、不同公司，处理方式也各不相同，需要结合实际场景，和业务方同学一块讨论，最后达成一个统一认可的降级方案。</p>
<p>总结下来：降级是通过暂时关闭某些非核心服务或者组件从而保护核心系统的可用性。</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-15T08:17:57.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:UML图</title>
    <id>https://ujava.cn/principle/uml.html</id>
    <link href="https://ujava.cn/principle/uml.html"/>
    <updated>2023-11-15T07:37:56.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。</p>
<p>软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有<br>
7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>
<p>在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。</p>
<p>软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有<br>
7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>
<p>在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。</p>
<p>下面我们将探讨如何绘制这 7 种模型图，以及如何在不同阶段使用这些模型来生成相应的设计文档。</p>
<h2> 类图</h2>
<p>类图是软件设计中使用最广泛的 UML 图形之一，用来描述类的特性以及类之间的静态关系。在一个类图中，每个类都由三个部分组成：类名、属性列表和方法列表。</p>
<p>除了描述类的基本特征，类图还用来表示类之间的关系，其中包括六种静态关系：</p>
<p>关联（Association）：表示一个类对象与另一个类对象之间的关系，比如订单与客户之间的关系。</p>
<p>依赖（Dependency）：表示一个类对另一个类的使用或调用，比如客户下订单时需要使用订单类。</p>
<p>组合（Composition）：表示一种包含关系，表示一个类对象包含另一个类对象，比如一个订单包含多个商品。</p>
<p>聚合（Aggregation）：也表示一种包含关系，但是聚合关系中包含的类对象可以被多个类共享，比如一个学校包含多个班级。</p>
<p>继承（Inheritance）：表示一个类继承自另一个类，可以从父类中继承属性和方法，并且可以添加新的属性和方法。</p>
<p>泛化（Generalization）：与继承关系相似，但泛化关系可以用来表示更抽象的关系，比如多个类都实现了一个接口。</p>
<p>通过绘制类图，我们可以清晰地描述一个软件系统中的类及其之间的关系，帮助开发人员更好地理解软件系统的结构和功能。</p>
<p>在UML工具中把相关的一组类及其关系用一张图画出来，就是类图。</p>
<p><br>
如上图所示，描述的就是一个典型的责任链模式的实现类图。</p>
<p>类图主要是在 详细设计<br>
阶段画，一旦类图设计完成，开发工程师可以根据类图来实现代码。只要类方法的逻辑不是太复杂，不同工程师实现的代码几乎是一样的，这有利于保证软件的规范和统一性。在实际应用中，通常不需要画出所有类的类图，只需要画出核心、代表性、技术难度较高的类图即可。</p>
<p><br>
除了在详细设计阶段绘制类图外，还可以在需求分析阶段使用类图来表示关键领域模型对象。在这个阶段中，我们不要将注意力集中在属性或行为上，而应该专注于识别领域对象及其之间的关系。因此，可以使用简化的类图来描述，只需要绘制类的名称和它们之间的关系即可。</p>
<p>如上所示描述的是在需求分析阶段挖掘出SIM卡、运营商、手机、手机厂商等模型对象之间的关系。</p>
<h2> 序列图</h2>
<p>类图之外，另一种常用的图形是序列图。</p>
<p>类图描述类之间的静态关系，而序列图用于描述参与者之间的动态调用关系。每个参与者都有一条垂直向下的生命线，该生命线用虚线表示。参与者之间的消息按照从上到下的顺序表示它们的调用顺序关系，这就是序列图这个词的来源。每个生命线都有一个激活条，它是图中的细长矩形条，只有在参与者活动时才是激活的。</p>
<figure><figcaption>3.png</figcaption></figure>
<p>通常使用序列图表示对象之间的交互，这些对象可以是类对象，也可以是更大的参与者，如组件、服务器、子系统等。总之，只要涉及到不同参与者之间的交互，都可以使用序列图，比如下面这张图就是业务分析阶段，系统建设后完成后的业务流程。</p>
<figure><figcaption>4.png</figcaption></figure>
<p>记住，在软件设计的不同阶段都可以使用序列图。</p>
<h2> 组件图</h2>
<p>组件是比类更大粒度的设计元素，通常一个组件中包含多个类。组件图有时与包图的用途相似，通常用于描述物理组件，如JAR、DLL等。在实践中，我们更多地使用组件图进行模块设计。</p>
<figure><figcaption>5.png</figcaption></figure>
<p>组件图描述组件之间的静态关系，主要是依赖关系。如果想要描述组件之间的动态调用关系，可以使用组件序列图，以组件作为参与者，描述组件之间的消息调用关系。</p>
<p>由于组件的粒度较大，通常用于描述和设计软件的模块及其之间的关系。因此，在设计的早期阶段就需要画出组件图，一般用于架构设计阶段。</p>
<h2> 部署图</h2>
<p>部署图描述的是软件系统最终的物理部署情况，包括需要部署的服务器数量、关键组件的部署位置等。它是软件系统最终呈现的物理蓝图，能够让客户、老板和工程师清晰地了解系统的最终运行状态，以及与现有系统和第三方服务器的关系。通过部署图，可以预估服务器和第三方软件的采购成本。</p>
<p>因此，部署图是整个软件设计模型中相当宏观的一种图，需要在设计早期就绘制。各方可以根据部署图讨论是否认可该方案，只有对部署图达成共识，才能继续后面的细节设计。部署图主要用于架构设计阶段，并且与组件图要彼此呼应。<br>
</p>
<h2> 用例图</h2>
<p>用例图分为业务用例和系统用例，业务用例图主要体现在 业务分析阶段， 描述一个承建系统的组织对外提供的能力，系统用例体现在需求分析阶段描述系统对外提供的能力。</p>
<figure><figcaption>7.png</figcaption></figure>
<p>这张图中，左边是业务用例图，右边是系统用例图。虽然它们的画法相似，但它们本质上有很大的区别，具体可以查看我之前写的这篇文章。</p>
<p>图中的人形元素称为角色，角色可以是人也可以是其他系统。由于系统的功能可能很复杂，用例图可能仅包含其中的一小部分功能，这些功能被画在一个矩形框内，这个矩形框是用例边界。矩形框里面的椭圆表示单个功能，它们可以相互依赖或需要扩展。因为用例图中的功能描述相对简单，所以通常需要配以文字说明以形成需求文档。</p>
<h2> 状态图</h2>
<p>状态图用来展现单个对象生命周期中的状态变迁。</p>
<p>在业务系统中，许多重要的领域对象都有相当复杂的状态变化，比如订单，它们可以有待付款、待审核、待发货、待收货、交易关闭和交易完成等各种状态。</p>
<p>这些状态变化可以在用例图中用文本形式描述，并随着各个用户的不同操作而改变。但是，使用这种方法描述状态时，状态会分散到不同的地方，这样可能会导致开发错误以及产品经理在设计时的困惑。</p>
<p>采用UML状态图可以有效地解决这些问题，因为它可以在一张图表中展示对象的整个生命周期以及各个状态和变迁之间的关系。比如下面的图表展示了一个订单从创建到交易完成的状态变化。</p>
<figure><figcaption>8.png</figcaption></figure>
<p>状态图要在需求分析阶段画，描述状态变迁的逻辑关系，在详细设计阶段也要画，这个时候，状态要用枚举值表示，以指导具体的开发。</p>
<h2> 活动图</h2>
<p>活动图常用于描述系统或业务流程中的动态行为。它可以清晰地展现从一个活动到另一个活动的控制流，描绘出系统或业务流程的逻辑和流程，让开发人员更好地了解整个系统的运作方式。</p>
<p>在活动图中，实心圆表示流程的开始，空心圆表示流程的结束，圆角矩形表示活动，菱形表示分支判断。这些符号的使用能够使活动图更加规范化和可读性，有助于提高系统开发的效率和质量。</p>
<figure><figcaption>9.png</figcaption></figure>
<p>此外，活动图引入了一个重要的概念——泳道。活动图可以根据活动的范围，将活动根据领域、系统和角色等划分到不同的泳道中，使流程边界更加清晰。</p>
<p>流程图也比较有普适性，可以在需求分析阶段描述业务流程，也可以在架构设计阶段描述子系统和组件的交互，还可以在详细设计阶段描述一个类方法内部的计算流程。</p>
<p>使用合适的 UML 模型构建一个设计文档<br>
UML 模型图本身并不难掌握，但如何在正确的场合下用适当的 UML 模型表达设计意图，形成一套清晰且详细的软件模型，并在团队内外达成共识的设计文档则需要注意。</p>
<p>根据软件设计不同阶段的需要，我们可以使用不同的模型图进行建模。</p>
<p>在需求分析阶段，我们可以使用用例图、活动图、时序图和简化的类图进行领域模型抽象和关系描述。</p>
<p>在架构设计阶段，通过组件图、组件时序图和部署图描述系统物理蓝图和模块关系。</p>
<p>在详细设计阶段，主要侧重于类图和类的时序图，而对于复杂的方法逻辑，可以使用方法的活动图进行描述。</p>
<h2> 小结</h2>
<p>掌握类图、时序图、组件图、部署图、用例图、状态图、活动图这七种UML模型图，根据实际场景，在需求分析、架构设计和详细设计阶段选择并巧妙应用对应的模型图，有助于有效地进行软件建模和系统设计，成为一个掌控大局、指导技术团队的优秀架构师。</p>
<p>要注意模型图的规范和注释，遵循命名规范，对模型元素进行命名，注释模型元素的关系和属性等，简洁明了。此外，UML模型图只是设计文档的一部分，需要与其他文档相结合，如需求文档、设计文档、测试文档等，形成一个完整的设计文档，指导软件开发。</p>
<p>对于画UML的工具，有收费的专业软件设计工具像EA(Enterprise Architect)、Astah和亿图，<a href="http://xn--draw-955fn1koi57ny3ibkg51n9w4beb3a3cyhe2c.io" target="_blank" rel="noopener noreferrer">以及免费的在线工具比如draw.io</a>，processon等，建议可以根据自身需要选择合适的工具，同时也建议从简单易用的工具入手。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-10T08:59:39.000Z</published>
  </entry>
  <entry>
    <title type="text">设计算法</title>
    <id>https://ujava.cn/algorithm/</id>
    <link href="https://ujava.cn/algorithm/"/>
    <updated>2023-11-10T08:07:39.000Z</updated>
    <summary type="html"><![CDATA[<h2> 设计算法</h2>
]]></summary>
    <content type="html"><![CDATA[<h2> 设计算法</h2>
]]></content>
    <category term="设计算法"/>
    <published>2023-11-10T08:07:39.000Z</published>
  </entry>
  <entry>
    <title type="text">设计算法:常见算法</title>
    <id>https://ujava.cn/algorithm/common.html</id>
    <link href="https://ujava.cn/algorithm/common.html"/>
    <updated>2023-11-10T08:07:39.000Z</updated>
    <summary type="html"><![CDATA[<h2> 设计算法</h2>
<h2> 1、递归与分治</h2>
<p>1.1 递归算法：直接或者间接不断反复调用自身来达到解决问题的方法。这就要求原始问题可以分解成相同问题的子问题。</p>
<p>示例：阶乘、斐波纳契数列、汉诺塔问题</p>
<p>斐波纳契数列：又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F1=1,F2=1,Fn=F（n-1）+F（n-2）（n&gt;<br>
2,n∈N*））。</p>
<p>1.2 分治算法：待解决复杂的问题能够简化为几个若干个小规模相同的问题，然后逐步划分，达到易于解决的程度。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 设计算法</h2>
<h2> 1、递归与分治</h2>
<p>1.1 递归算法：直接或者间接不断反复调用自身来达到解决问题的方法。这就要求原始问题可以分解成相同问题的子问题。</p>
<p>示例：阶乘、斐波纳契数列、汉诺塔问题</p>
<p>斐波纳契数列：又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、……在数学上，斐波纳契数列以如下被以递归的方法定义：F1=1,F2=1,Fn=F（n-1）+F（n-2）（n&gt;<br>
2,n∈N*））。</p>
<p>1.2 分治算法：待解决复杂的问题能够简化为几个若干个小规模相同的问题，然后逐步划分，达到易于解决的程度。</p>
<ul>
<li>1、将原问题分解为n个规模较小的子问题，各子问题间独立存在，并且与原问题形式相同</li>
<li>2、递归的解决各个子问题</li>
<li>3、将各个子问题的解合并得到原问题的解</li>
</ul>
<p>示例：棋盘覆盖、找出伪币、求最值</p>
<p>棋盘覆盖：在一个(2<sup>k)*(2</sup>k)个方格组成的棋盘上，有一个特殊方格与其他方格不同，称为特殊方格，称这样的棋盘为一个特殊棋盘。要求对棋盘的其余部分用L型方块填满</p>
<h2> 2、动态规划</h2>
<p>动态规划与分治法相似，都是组合子问题的解来解决原问题的解，与分治法的不同在于：分治法的子问题是相互独立存在的，而动态规划应用于子问题重叠的情况。</p>
<p>动态规划方法通常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，找到具有最优值的解称为问题的一个最优解，而不是最优解，可能有多个解都达到最优值。</p>
<p>设计动态规划算法的步骤：</p>
<ul>
<li>1、刻画一个最优解的结构特征</li>
<li>2、递归地定义最优解的值</li>
<li>3、计算最优解的值，通常采用自底向上的方法</li>
<li>4、利用算出的信息构造一个最优解</li>
</ul>
<p>示例：0-1背包问题，钢条切割问题等。</p>
<h2> 3、贪心算法</h2>
<p>贪心算法是就问题而言，选择当下最好的选择，而不从整体最优考虑，通过局部最优希望导致全局最优。</p>
<p>贪心算法的要素</p>
<ul>
<li>1）贪心选择性质：可以通过局部最优选择来构造全局最优解。换言之，直接做出在当前问题中看来最优的选择，而不必考虑子问题的解。</li>
<li>2）最优子结构：一个问题的最优解包含其子问题的最优解。</li>
</ul>
<p>贪心算法的设计步骤：</p>
<ul>
<li>1）将最优化问题转换为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解</li>
<li>2）证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的</li>
<li>3）证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。</li>
</ul>
<p>示例：0-1背包问题，均分纸牌，最大整数</p>
<h2> 4、回溯法</h2>
<p>回溯法是一种搜索算法，从根节点出发，按照深度优先（DFS）搜索的策略进行搜索，到达某一节点后<br>
，探索该节点是否包含该问题的解，如果包含则进入下一个节点进行搜索，若是不包含则回溯到父节点选择其他支路进行搜索。</p>
<p>回溯法的设计步骤：</p>
<ul>
<li>1）针对所给的原问题，定义问题的解空间</li>
<li>2）确定易于搜索的解空间结构</li>
<li>3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数除去无效搜索。</li>
</ul>
<p>示例：0-1背包问题、旅行商问题、八皇后问题</p>
<h2> 5、分支限界法</h2>
<p>和回溯法相似，也是一种搜索算法（广度遍历再深度遍历），但回溯法是找出问题的许多解，而分支限界法是找出原问题的一个解。或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解</p>
<p>在当前节点（扩展节点）处，先生成其所有的儿子节点（分支），然后再从当前的活节点（当前节点的子节点）表中选择下一个扩展节点。为了有效地选择下一个扩展节点，加速搜索的进程，在每一个活节点处，计算一个函数值（限界），并根据函数值，从当前活节点表中选择一个最有利的节点作为扩展节点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。</p>
<p>分支限界法：</p>
<ul>
<li>1）FIFO分支限界法</li>
<li>2）优先队列分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li>
</ul>
<p>示例：装载问题，旅行售货员问题</p>
]]></content>
    <category term="设计算法"/>
    <published>2023-11-10T08:07:39.000Z</published>
  </entry>
  <entry>
    <title type="text">第四梯队思想</title>
    <id>https://ujava.cn/mind/four.html</id>
    <link href="https://ujava.cn/mind/four.html"/>
    <updated>2023-11-09T11:49:55.000Z</updated>
    <summary type="html"><![CDATA[<h1> 第四梯队思想</h1>
<h2> 1.面向过程编程</h2>
<p>“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。</p>
<ul>
<li>特性：模块化 流程化</li>
<li>优点：性能比面向对象高, 因为类调用时需要实例化，开销比较大，比较消耗资源;</li>
<li>单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
]]></summary>
    <content type="html"><![CDATA[<h1> 第四梯队思想</h1>
<h2> 1.面向过程编程</h2>
<p>“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。</p>
<ul>
<li>特性：模块化 流程化</li>
<li>优点：性能比面向对象高, 因为类调用时需要实例化，开销比较大，比较消耗资源;</li>
<li>单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
<p>例如下面这个学生入学的例子：<br>
</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码就是典型的面向过程编程。</p>
<p>面向过程：根据业务逻辑从上到下写代码 。面向过程编程最易被初学者接受，其往往用一长段代码来实现指定功能，开发过程的思路是将数据与函数按照执行的逻辑顺序组织在一起，数据与函数分开考虑。</p>
<p>考虑现实生活中，我们的思维方式是放在学生这个个人上，是学生做了自我介<br>
绍。而不是像我们刚刚写出的代码，先有了介绍的行为，再去看介绍了谁。<br>
用我们的现实思维方式该怎么用程序表达呢？这就要用到面向对象的编程思想了。</p>
<p>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p>
<h2> 2. 函数式编程</h2>
<p>函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p>
<p>主要思想: 把运算过程尽量写成一系列嵌套的函数调用。<br>
例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Python 不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。也有些表现得像函数式编程机制（如：内建函数 filter()、map()、reduce()），但是从传统上也不能被认为是函数式编程语言的构建。</p>
<h2> 3.面向对象编程</h2>
<p>面向对象是按人们认识客观世界的系统思维方式，采用基于对象（实体）的概念建立模型，模拟客观世界分析、设计、实现软件的办法。通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。</p>
<ul>
<li>特性：抽象 封装 继承 多态</li>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
<h2> 4.面向过程与面向对象的区别</h2>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；</li>
<li>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</li>
</ul>
<p>可以拿生活中的实例来理解面向过程与面向对象，例如五子棋。</p>
<p>面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。</p>
<p>如果是面向对象的设计思想来解决问题。面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。</p>
<p>可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。</p>
]]></content>
    <category term="设计思想"/>
    <published>2023-11-09T11:49:55.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:回调</title>
    <id>https://ujava.cn/principle/callback.html</id>
    <link href="https://ujava.cn/principle/callback.html"/>
    <updated>2023-11-09T10:51:43.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>回调是强大的编程模式之一。 它可以实现调用反转，在子函数中调用高层的函数（通常是由高层函数来调用底层的子函数），<br>
获得更灵活的调用关系。通常用于框架、代码复用等场合。 在这里， 函数可以作为参数传入子函数，可以由子函数进行调用和返回。回调函数可以用<br>
Java 的接口， 或者 C/C++ 的函数指针来实现， 而在 Javascript / LISP 中， 函数是一种通用对象，具有很大的灵活性。</p>
<h2> 动机</h2>
<p>调用者 A 想要调用函数 B， 但并不知道具体的 B 应该是哪一个，由 A 的调用者将 函数B 作为参数传入给调用者 A。 函数B 称为回调函数，<br>
B 函数的调用称为回调。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>回调是强大的编程模式之一。 它可以实现调用反转，在子函数中调用高层的函数（通常是由高层函数来调用底层的子函数），<br>
获得更灵活的调用关系。通常用于框架、代码复用等场合。 在这里， 函数可以作为参数传入子函数，可以由子函数进行调用和返回。回调函数可以用<br>
Java 的接口， 或者 C/C++ 的函数指针来实现， 而在 Javascript / LISP 中， 函数是一种通用对象，具有很大的灵活性。</p>
<h2> 动机</h2>
<p>调用者 A 想要调用函数 B， 但并不知道具体的 B 应该是哪一个，由 A 的调用者将 函数B 作为参数传入给调用者 A。 函数B 称为回调函数，<br>
B 函数的调用称为回调。</p>
<p>框架设计者将那些固定不可变的流程和逻辑写好，而对于那些需要根据业务来定制的逻辑，则以回调接口的形式提供给开发者使用。Js<br>
框架中提供了大量回调接口； struts2 的拦截器，WEB 中的过滤器， Spring AOP 等都可以看成是回调的一种形式。它类似于模板方法中的钩子。</p>
<p>回调的威力在于， 能够在任何时间、任何地点、以指定形式调用任何抽象层级的逻辑。</p>
<p>回调最著名的例子是灵活的对象排序。 排序函数对指定的同类型的多个对象进行排序， 但它并不知道如何去比较对象的大小，因此，<br>
必须传入一个比较对象的函数给它。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码<br>
在 Javascript 中：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 中：与命令模式有点像。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端调用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 缘起</h2>
<p>首先， 一段普通的函数调用 :</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述代码意图很明确， main 调用了 A， A 又调用了B 。关系很确定。 然而， A 函数可能是一段模板化的代码块， 其中只有一个地方不确定：</p>
<p>假设单击按钮A 的代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>单击按钮B 的代码如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当按钮很多时， 重复这一段代码是非常无趣的事情。 这时， 可以写一个回调， 来复用代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原来的函数就可以简化为:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看， 这样是不是更加简洁呢？</p>
<h2> 禁忌</h2>
<p>和任何一种强大的编程技术一样， 回调也不宜过度使用， 过多层的回调容易把人弄晕。 遵循“事不过三” 的原则， 可以将回调层数尽量限制在三层及以下。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-09T10:51:43.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:基本陷阱、原理及解决方案</title>
    <id>https://ujava.cn/principle/concurrency-faq.html</id>
    <link href="https://ujava.cn/principle/concurrency-faq.html"/>
    <updated>2023-11-09T04:40:42.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>为什么要使用并发 ？ 有三点足够信服的理由：</p>
<p>性能提升。单核 CPU 的性能基本抵达瓶颈，充分挖掘多核 CPU 的能力，使得性能提升变成水平可扩展的。<br>
事件本质。世界的事件本质上是并行和并发进行的。<br>
响应灵敏。为了构建响应更敏捷的应用，需要异步化处理，并发必不可少。<br>
不过，并发使用姿势不当，很容易出错，导致难以估量的损失。可谓是一把双刃剑。</p>
<p>最近，团队有同学踩了并发的坑。我想，要不梳理下并发的一些陷阱及相关原理和解决方案吧，以备后用。</p>
<h2> 何时使用并发</h2>
<p>并不是在所有情况下都需要使用并发。Java 多线程模型，在并发执行的时候会有线程创建、切换、阻塞、调度的开销、内存同步的开销等。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>为什么要使用并发 ？ 有三点足够信服的理由：</p>
<p>性能提升。单核 CPU 的性能基本抵达瓶颈，充分挖掘多核 CPU 的能力，使得性能提升变成水平可扩展的。<br>
事件本质。世界的事件本质上是并行和并发进行的。<br>
响应灵敏。为了构建响应更敏捷的应用，需要异步化处理，并发必不可少。<br>
不过，并发使用姿势不当，很容易出错，导致难以估量的损失。可谓是一把双刃剑。</p>
<p>最近，团队有同学踩了并发的坑。我想，要不梳理下并发的一些陷阱及相关原理和解决方案吧，以备后用。</p>
<h2> 何时使用并发</h2>
<p>并不是在所有情况下都需要使用并发。Java 多线程模型，在并发执行的时候会有线程创建、切换、阻塞、调度的开销、内存同步的开销等。</p>
<p>在单核 CPU 上，运行 CPU 密集型计算，并不需要使用并发，因为 CPU 本身就是饱和的，使用并发只能带来不必要的线程切换和同步开销。<br>
在多核 CPU 处理器上，运行 CPU 密集型计算，线程数应该与 CPU 个数一样，以便于将工作合理分配到每个 CPU 上，不多不少。 如果线程数大于<br>
CPU 核数，那么就会有不必要的线程切换；如果线程数小于 CPU 核数，就无法充分利用所有的核。</p>
<p>实际应用中，常常是 RPC 调用和纯计算业务逻辑处理的交替执行，也就是 IO 密集型，或者 IO 和 CPU 密集型交叉的任务，则需要线程数远远大于<br>
CPU 核数，来避免 线程等待 IO 操作完成之前的无所事事。</p>
<h4> 线程安全</h4>
<p>要讨论并发问题，首先要理解，何为线程安全的 ？ 详解可参阅《Java并发编程实战》的第二章。</p>
<p>线程安全，是指在多线程执行环境下，并发执行的结果与串行执行的结果始终一致。 这句话有两层意思： 1. 不会因为线程执行顺序不确定，导致不确定的结果；2.<br>
多线程并发执行的结果，应该与多线程串行执行的结果一致。它们的差别仅仅体现在速度上，而不是结果上。</p>
<p>在具体措施上，表现为多线程对“含有共享可变状态的对象”的访问控制与同步。这里有两个前提： 1. 多线程。 单线程执行环境是线程安全的；<br>
2. 共享可变。 不可变的对象是线程安全的；没有任何写操作的共享可变对象是线程安全的； 3. 无状态的对象是线程安全的。</p>
<p>多线程环境下，保证并发安全的若干理念：</p>
<p>从一开始设计成线程安全的类，比在以后将类修改成线程安全的类，要更容易和安全得多。因为线程不安全的类，在实际业务系统中可能已经在各种场景下使用到了，修改成线程安全的类，会导致性能下降，产生不可预知的后果。</p>
<p>程序状态的封装性越好，就越容易实现线程安全的访问，也更容易维护。</p>
<p>优先考虑使用现有的线程安全的类和同步工具类。</p>
<p>使用不可变量和无状态对象（通常是应用中的全局无状态组件）。</p>
<p>不共享变量，比如尽量使用方法内的局部变量，或者声明组件为原型模式。</p>
<p>规定哪些操作组合必须符合原子性，并借助同步和锁来实现组合操作的原子性。</p>
<h2> 并发陷阱</h2>
<h4> “写-读”的不可见</h4>
<h4> 示例</h4>
<p>如下代码一所示。先起一个线程，将 isReady 设置为 true ，然后再进入循环，判断 isReady 是否为 true ，为 true 则退出。</p>
<p>这段代码是线程安全的吗？ 如何判断 ？ 不妨假设这两个线程按照代码顺序串行执行。那么，打印 ready! 之后，不应该有 not ready 的打印。</p>
<p>代码一:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行多次，得到如下结果。打印 ready! 之后，还有 not ready 的输出。这是为什么呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>这里涉及到并发读写的最最基本的陷阱：可见性。根据 “Jvm内存模型深度理解”，当线程更新 isReady<br>
之后，只是写到自己的线程缓存里，并没有立即刷新到主内存中。那么主线程需要等待一段时间，才能检测到主内存的 isReady 已经变化了。</p>
<p>如果不打算使用锁的话，可以加上可见性修饰符：volatile 。 volatile 会立即将更新的线程缓存值刷新到主内存中，使得所有访问该共享变量的线程都能立即感知到新的值。volatile<br>
是一个极轻量级的同步机制，常用于判断标志位是否更新。但是 volatile 并不适合做同步锁（基于 volatile 的同步是很脆弱的）。</p>
<h4> 含有未受保护实例变量的对象</h4>
<h4> 示例</h4>
<p>一个含有未受保护的实例变量的对象，在多线程环境中访问是不安全的。这大概是关于并发陷阱的最经典的栗子。</p>
<p>如代码二所示：一个 UnSafeObject 含有一个实例变量 i 。在 main 中，创建了 3 个线程，分别会设置 i，然后休眠 200ms ，再获取 i 。</p>
<p>这是线程安全的吗 ？ 按照上述定义来看，如果并发与串行执行结果一致，那么应该是：每个线程都会拿到与自己线程号对应的值。至少不会拿到其他的线程号。</p>
<p>代码二：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打印结果如下：很明显，每个线程拿到的值并不一定是它自己设置的。因为在多线程环境下，i 可能被任何一个线程所修改。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>导致对象 UnSafeObject 的实例变量 i 在多线程环境下访问不安全的原因是：JVM 并发机制是基于共享内存模型的。可阅：“Jvm内存模型深度理解”。<br>
这篇文章讲得详细。</p>
<p>怎样才能将 UnSafeObject 变成线程安全的呢 ？ 最简便的方式是，将 i 声明为原子的 AutoInteger。 当只需要一个单变量的原子操作时，使用原子类。</p>
<p>原子类采用的是基于硬件能力提供的 CAS ，可以安全替代 volatile 的使用。在竞争适度（如何衡量?）的情况下， CAS 能够提供更好的性能和可伸缩性。<br>
CAS 有个“ABA”的问题，可以通过增加一个版本号来解决。 CAS 是非阻塞算法，是乐观锁的实现方式。在实际系统中也经常会用到，比如 DB<br>
的乐观锁，ES 版本控制等。通过问题转换，将并发修改的范围映射到原子变量的修改上，可以拓展非阻塞并发的使用范围。</p>
<p>详情可阅：《并发编程实战》的第十五章。</p>
<h4> 真实环境</h4>
<p>对于这样一个简单例子，大家耳熟能详。不过，换到真实环境里，还能看出来么？ 如下代码三所示。这段代码有什么问题呢？<br>
LightTcOrderFormat 是一个含有实例变量 tcOrder 的 Component。 咋一看，确实没啥问题。但是，如果放在多线程环境里跑一跑，tcOrder<br>
就会被随意篡改。</p>
<p>代码三：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>避免措施： LightTcOrderFormat 声明为原型模式：@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) ，成为不共享的对象。</p>
<h4> 原子操作组合的非原子化</h4>
<h4> 示例</h4>
<p>如下代码四所示，使用了 ConcurrentHashMap 对 map 中的 [key,value] 进行保护。</p>
<p>输出 final 不一定等于 300000。为什么会这样呢？ 虽然 get 与 put 是原子操作，但是组合成一个 add 方法， add<br>
方法是非原子化的。两个线程完全可能，同时执行 get("key") = 5 ； 然后先后 put("key", 6) ，使得最终值为 6， 而不是 7。</p>
<p>代码四：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有小伙伴问：那么写成这样可否 ？ 看看 putIfAbsent 的实现，就知道也是不可以的。因为后者只是比前者表达更加简洁，但效果是一致的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>一系列原子操作组合后的复合操作，如果不具有原子化，也会有线程不安全的问题。</p>
<p>一种解决方案是，对对象的所有需要并发访问的方法使用 synchronized 关键字修饰。如果方法里的操作耗时都比较平均，不存在耗时很大的操作，这种方法最经济。详可阅：“深入理解<br>
Synchronized”</p>
<p>同步锁，本质是封闭思想的一种体现。将对共享可变量的访问，限制在指定的同步方法或由锁构建的临界区中。</p>
<p>代码五：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题：读操作也要加 synchronized 吗？ 为什么 ？</p>
<h4> 锁优化</h4>
<p>虽然使用 synchronized 解决了问题，但是稍有不当，会带来性能问题。 这里加在方法上，实际上就是对整个 map 加锁，而<br>
ConcurrentHashMap 是有分段锁优化的，这样就将分段锁优化的优势给去掉了。 那么，如何在保存 ConcurrentHashMap 的优势基础上，安全地访问<br>
key 呢？</p>
<p>这里实际上设计两层锁：1. 给 key 加锁，是分段的； 2. 给计数加锁。 这里可以将初始化的部分抽离出来单独加锁。如下代码六所示。使用<br>
ConcurrentHashMap + AtomicLong 强强联合，来解决这个问题。ConcurrentHashMap 给 key 加分段锁，AtomicLong 给访问同一个 key 的<br>
value 加锁；还有一个给 value 为空时的初始化加锁。</p>
<p>代码六：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码所示，虽然将 get-put 中的 put 解放出来了，但是依然有两个不足：</p>
<p>无论 key 为何值，都会对整个 map 加锁；<br>
只有一把可冲入锁，如果 key 很多，线程数也很多，那么竞争会非常激烈。事实上，上述代码执行有时会出现异常和线程直接退出，而且概率不小。<br>
因此，还需要进一步进行优化。仔细思考可知，实际上只需要初始化（key 对应的 value 为空）的时候加锁即可。如代码七所示，使用 DCL<br>
来安全初始化 key 对应的 AtomicLong 对象。</p>
<p>代码七：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题：以上代码涉及到 key 的监控对象锁和分段锁，是否会出现死锁问题 ？</p>
<h4> synchronized-VS-ReentrantLock</h4>
<p>上述同步代码中，分别使用了 synchronized 和 ReentrantLock 。那么，它们有什么异同？如何在两者之间进行选择呢？ 以下是一些建议：</p>
<ul>
<li>synchronized 是 JVM 内置锁，ReentrantLock 不是。在未来的 JVM 版本中，更可能优化 synchronized 。</li>
<li>synchronized 使用起来更简单紧凑，能够自动释放锁； ReentrantLock 则需要使用 try-final 块，手动在 finally<br>
中释放锁。ReentrantLock 更容易出错。</li>
<li>ReentrantLock 具备更灵活的加锁能力：定时锁，可中断锁，非公平锁，非块结构加锁；而 synchronized 不具备这些特性。这是选择<br>
ReentrantLock 的重要理由。</li>
<li>不应该因为性能的缘故而选择 ReentrantLock 。因为 synchronized 的性能在 JVM 迭代中会不断提升，更受到 JVM 优化的青睐。</li>
<li>优先使用 synchronized。 仅当 synchronized 无法满足需要时，使用 ReentrantLock 。</li>
</ul>
<h4> 关联不一致性</h4>
<p>原子操作组合的非原子化，还表现在一种常用情况：关联不一致性。也就是说，两个变量的变化，必须符合某种一致性规约。比如正方形的边长与面积，就是同步变化的。如下代码八所示。<br>
最终输出情况，square 与 area 不一定会满足 area = square * square 的关系。</p>
<p>代码八：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 逃逸的对象</h4>
<h4> 示例</h4>
<p>如下代码九所示。你能看出问题所在吗 ？ add 也加了 synchronized 关键字。 看上去貌似是没有问题的。</p>
<p>代码九：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下。将线程数调大，抛出异常 ConcurrentModificationException 的概率会更大。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>为什么还会抛并发修改的异常呢 ？ getNums 闯了祸。这个方法将不安全的 nums 暴露出去了。 换个角度说， nums 通过 getNums<br>
这个方法逃逸出去了。 这样 nums 就可能被多个线程同时更改了。</p>
<p>解决方案：1. 不对外暴漏这个实例变量，仅可通过指定方法访问（封闭的思想）；2. 如果需要获取这个 nums<br>
，使它变成不可变的。不允许逃逸出去的对象被修改。这实际上遵循了“不可变量总是线程安全的”原理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事实上，即使返回不可变的 List， List 里的对象依然是线程不安全的。因为 List 的逸出，连带着将 List 里的对象也逸出了。<br>
因此，对于容器的并发，避免将整个容器都返回出去。</p>
<h4> 非受控的线程池</h4>
<h4> 示例</h4>
<p>这个问题恐怕是很少人会特别注意到的陷阱。在调用频繁的实例方法中创建线程池，会导致创建线程数不受控地增长，最终导致应用崩溃。</p>
<p>如下代码十所示。在局部方法 freqCalledMethod 不断创建新的局部线程池。只要方法调用足够次数，就会导致应用崩溃。</p>
<p>代码十：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>报：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>报这个错误的原因是超出了JVM允许创建的最大线程数。</p>
<p>The "java.lang.OutOfMemoryError: unable to create new native thread" is thrown by the JVM whenever it hit the limit of<br>
how many threads it can create. The limit is imposed by the operating system.</p>
<p>线程池原本是用来使得应用中创建的线程数是可控的，结果线程池的创建变得不可控了，显然也会导致线程数不可控。</p>
<p>解决方案：切忌在大量频繁调用的实例方法里创建线程池。创建配置良好的全局线程池。</p>
<p>可以通过如下程序来测试机器上的最大可创建线程数。TimeUnit.SECONDS.sleep(1000); 是为了不让线程过快的退出。</p>
<p>代码十一：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 线程池中的ThreadLocal残留</h2>
<h4> 示例</h4>
<p>如果你有一个比较长的业务链路，有一些公共数据要在整个链路中传递。要么，将公共数据放在方法中逐层传递下去，要么创建一个<br>
ThreadLocal 来保存这些公共数据，在链路里传递。</p>
<p>ThreadLocal 是线程本地副本，每个线程有自己私有的一份数据。通过不共享的思路去避免并发修改问题。不过 ThreadLocal<br>
如果与线程池结合使用，就会有问题。</p>
<p>代码十二：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果如下：</p>
<h4> 原理及解决方案</h4>
<p>要理解 ThreadLocal 的实现，关键是理解 Thread 中含有一个 ThreadLocal.ThreadLocalMap 对象。这个对象实际上就是线程的本地副本。<br>
之所以不直接用 Object, 是因为要实现两个目标： 1. 安全。 使用泛型来存取副本对象，编写代码更加安全，避免强制类型转换； 2.<br>
需要存储多个值。ThreadLocalMap 的 Key 是一个 WeakReference[ThreadLocal] ，ThreadLocal 通过 AtomicInteger 实现了 hashCode<br>
的约定，并提供了方法来获取当前执行线程的本地副本的值。</p>
<p>当线程在线程池中被复用时，执行下一次任务时，就可能拿到上一次任务执行后的残留数据了。</p>
<p>解决方案：在线程执行完任务后，将 ThrealLocal 中的内容清空。</p>
<h4> 手动的同步代码</h4>
<h4> 示例</h4>
<p>为了测试并发陷阱，需要启动多线程去执行任务。为避免写重复代码，需要先写个通用的多线程启动代码。如代码十三所示。这段代码使用了<br>
t.join 方法来同步线程之间的活动，使主线程必须在所有子线程执行之后才退出。 这样做并没有多大问题。不过，使用比较底层的 API<br>
比使用成熟的同步工具类，会更有风险。</p>
<p>代码十三：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 原理及解决方案</h4>
<p>这里需要一个“栅栏”：当所有线程都到达这个栅栏的时候，才触发后续的活动。这实际上是个通用的功能。使用 CountDownLatch 工具来实现更佳。</p>
<p>如代码十四所示。启动线程引用了 CountDownLatch 对象。当线程执行完成退出时，就将 CountDownLatch 计数减一。当 CountDownLatch<br>
计数为 0 时，就会释放栅栏，让等待的主线程通过。</p>
<p>代码十四：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 根因讨论</h4>
<p>Java 并发的这些陷阱，从根本上去追溯，都是由共享内存模型所带来的。如果换用基于消息投递的方式,<br>
自然就不存在这些问题了，当然，消息投递又会带来新的问题：比如消息接收不到，消息延迟，处理的异步化，反直觉的编程模型等。</p>
<p>从根因上去探索，换一种思路和做法，看到的空间更为广阔。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-09T04:40:42.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:对象与并发</title>
    <id>https://ujava.cn/principle/obj.html</id>
    <link href="https://ujava.cn/principle/obj.html"/>
    <updated>2023-11-09T04:40:42.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>具备一些基本必要的思想是重要的。这些思想会影响我们的思考方式，以及设计和编写程序的决策。</p>
<ol>
<li>使用“对象”（而不是类）的思维去思考问题。</li>
</ol>
<p>类只是刻画对象的一种方式而已，但绝不是唯一的方式。 思考应用程序将由那些对象及其交互来构成和实现。应用程序中不一定有类，但一定有对象。</p>
<ol start="2">
<li>编写并发安全的程序的核心是保护共享可变状态的访问。</li>
</ol>
<p>并发安全的核心不是关于并发机制，而是关于状态的管理。从状态的角度来考虑并发，而不是从并发机制。 因为思考方式会决定并发机制的实现与选择。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>具备一些基本必要的思想是重要的。这些思想会影响我们的思考方式，以及设计和编写程序的决策。</p>
<ol>
<li>使用“对象”（而不是类）的思维去思考问题。</li>
</ol>
<p>类只是刻画对象的一种方式而已，但绝不是唯一的方式。 思考应用程序将由那些对象及其交互来构成和实现。应用程序中不一定有类，但一定有对象。</p>
<ol start="2">
<li>编写并发安全的程序的核心是保护共享可变状态的访问。</li>
</ol>
<p>并发安全的核心不是关于并发机制，而是关于状态的管理。从状态的角度来考虑并发，而不是从并发机制。 因为思考方式会决定并发机制的实现与选择。</p>
<blockquote>
<p>关键元素：环境、状态、 对象、资源、 事件、活动、时间</p>
</blockquote>
<ul>
<li>状态：构成应用程序实现的原子量。状态是对数据所包含信息的一种抽象。</li>
<li>环境：是状态的集合。 分为全局环境、局部环境和个体环境。 个体环境是指单个对象的状态所构成的极小语境；<br>
全局环境是由所有对象的状态构成的极大语境；局部环境是根据需求而划定的中间语境，由若干对象的状态所构成的。 环境影响对象及其活动。</li>
</ul>
<p>对象：是拥有状态、执行活动的基本单位。通过对象活动来修改环境的状态，从而实现事件的发展和环境的变更。对象执行活动需要依赖于一些资源。这些资源有些是对象自身所拥有的状态，比如能力、素质等，有些是对象之外的状态，比如机器设备等。根据对象职责的不同，可以分为：<br>
普通对象， 协调者对象、 全局管理者、 资源分配与调度对象等。</p>
<ul>
<li>活动：活动的作用是对环境的状态产生变更。</li>
<li>资源：资源实际上也是一种对象， 但它通常不具备执行活动的能力。资源是对象完成活动的必不可少的元素。</li>
<li>事件： 在一个事件中， 会有零个或多个对象执行活动。事件完成后会具有影响力，这些影响意味着全局环境状态的变化。</li>
<li>时间：一种横跨上述各种概念的重要元素。</li>
</ul>
<p>应用程序的设计与管理就是对上述各种元素的设计与管理，尤其主要的是对状态的管理； 有了时间的影响，<br>
就更加困难了：要对全局状态的变迁进行管理。软件的可扩展性就是因为状态的变迁带来的。</p>
<h2> 基本思路</h2>
<ol>
<li>
<p>对象自治和定期自检。 要管理全局状态实在太困难了， 比如说为了确保人体健康，要明晰人体每个细胞的状态， 那是件繁重的工程。<br>
因此， 第一个思路就是对象自治原则。 每个对象自己负责自己的状态管理和活动。根据需求定期对自己的状态进行检查， 以确保自己满足约束条件；</p>
</li>
<li>
<p>局部自治与全局协调。 分而治之总是一把很好的钥匙。 全局状态的管理是必要的，<br>
通过分治的方式，划定局部范围，每个局部包括若干局部管理者，负责汇总本区域的状态，并向全局管理者进行汇报；<br>
全局管理者根据战略目标进行协调和分配。局部管理者必须保证自己区域的合理状态；</p>
</li>
<li>
<p>备份与候补。 总有故障发生的时候， 比如说一个对象或细胞的坏死， 那么， 就不能因为这么个极小状态影响全局。 因此，<br>
局部管理者必须保证其管理范围内的备份与候补，以保证这个范围不会因为任何对象的错误导致不合理状态；<br>
同样，全局管理者亦可采用相应策略。冗余的优点是保证系统可靠性， 带来的风险是全局状态的不一致，状态同步开销。</p>
</li>
</ol>
<p>有时， 利用“纯对象”的思维来考虑问题会有点怪异。 考虑一个人拿笔写字。 那么，用对象的方式来表达：究竟是人在写字，笔在写字，<br>
还是纸在写字呢？一种思考方式是：</p>
<p>person.use(pen) ; pen.write(paper) ; paper.outprint(something) .</p>
<p>是不是有点拐弯抹角的 ？ 虽然看上去蛮符合对象思维的。</p>
<h2> 场景描述</h2>
<ol>
<li>相互独立。 对象A 与对象B 使用各种相互独立的资源互不干扰地完成各自的活动。 它们唯一的交集是全局环境状态。<br>
比如一位中国的高中生在中国的操场上打篮球与一个美国的高中生在美国的操场上打篮球。 虽然它们共用全局环境状态，<br>
只要这种状态的变更不影响彼此的活动， 基本可以认为是相互独立的。 换句话说， 这两个人所处的局部环境是没有交集的。</li>
<li>共用资源。 对象 A 与对象 B 共用一台打印机。 它们的交集不仅仅是全局环境状态，而且有局部环境状态， 这种环境状态会影响彼此的活动的进行。<br>
这时候，必须进行顺序的协调。基本的方法是: 并发访问。 至于具体的访问实现细节，比如你先用几分钟我后用几分钟， 则依靠协议的约束。</li>
<li>相互协作。对象 A 给对象 B 发送邮件， 邮件中含有 B 的重要工作内容， B 在活动中必须给 A 发送邮件，汇报执行的进展。这时候， A<br>
与 B 是相互协调的关系。 B 的活动开始依赖于 A 的活动的完成； 同时， A 必须抽一点时间来查询 B 的执行状态，<br>
以决定下一步如何走。基本的方法是： 通知。 这里可以有一个通知者对象，专门负责彼此的协调或消息传递。</li>
</ol>
<p>具体到一个应用系统，乃至社会活动与发展，往往涉及这三个场景的相互交织，并且具有更多的复杂性。 不过， 使用这种思考方式还是蛮有趣的。</p>
<h2> 并发程序设计的基本手段</h2>
<p>有一些基本技术手段用来减少并发带来的系统失败风险，提高并发程序的安全性和可维护性。</p>
<ol>
<li>不共享资源；</li>
<li>使用常量和不可变量；</li>
<li>使用实例限定，限制对象的作用范围和生命周期；</li>
<li>使用对象封装，限制对象的访问路径；</li>
<li>使用已有的安全并发组件。</li>
</ol>
<h2> 计算机中的并发</h2>
<ol>
<li>IO操作与CPU计算相分离。 IO 操作是典型的慢性子， 而CPU 是急性子， 注定两者要分离。 事实上， I/0 操作彼此应该都是相互独立和并发的。IO操作和CPU<br>
计算的并发可以发生在单核CPU 计算机中；</li>
<li>多核CPU计算机。CPU 总是埋怨 内存读取太慢， 可仔细想想， 一个CPU 占用一个偌大的内存，是不是有点奢侈呢？ 于是，<br>
出现了多核CPU计算机。多个核共同占用一个内存，或者，多个核各占用各自的内存。然后一个总的CPU 负责调度所有的活动。<br>
现在有了并发的味道了。</li>
<li>分布式系统或计算机网络。当计算机互联后，这种并发的味道更浓了。 多CPU 的并发执行，使得计算机网络的能力更加强大，这就催生了现代互联网的各种奇迹。从最初的WEB<br>
网站，到分布式系统，高性能并行计算， 再到如今热火朝天的移动互联网。</li>
<li>移动设备（手机等）。其实相比微型计算机、笔记本、平板电脑而言，手机更像“计算细胞”，更容易形成繁荣的计算族群、部落。假设人均持有一台手机设备，那么世界将有几十亿个计算细胞，这些计算细胞就如同一个个体一样并发活动，<br>
足够构成一个壮观的计算世界了。</li>
</ol>
<h2> 并发的高层语义</h2>
<p>显然，应用程序开发者不可能总是在原子语义上思考并发程序的设计和编写，那就如同用机器语言编写程序一样。必须存在精确的并发高层语义，由编程语言或操作系统或开发库提供，比如<br>
Java 的线程类， 或者 Linux 系统的进程函数 fork 。<br>
当执行这些语义时，编译器或操作系统会根据自身的实现来自动分发和管理并发活动，保证并发活动的顺利正确完成。当使用各种高层语义时，必须精确理解这些语义，才能正确使用好，必要的时候必须深入底层实现一探究竟。<br>
海面之上的冰山是蔚为壮观的，海面之下的冰山则藏着无限丰富的乐趣。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-09T04:40:42.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:并发</title>
    <id>https://ujava.cn/principle/concurrency.html</id>
    <link href="https://ujava.cn/principle/concurrency.html"/>
    <updated>2023-11-09T05:31:11.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>并发，就是在同一时间段内有多个任务同时进行着。这些任务或者互不影响互不干扰，或者共同协作来完成一个更大的任务。</p>
<p>比如我在做项目 A，修改工程 a ; 你在做项目 B, 修改工程 b 。我们各自做完自己的项目后上线。我和你做的事情就是并发的。如果我和你修改同一个工程，就可能需要协调处理冲突。并发是一种高效的运作方式，但往往也要处理并发带来的冲突和协作。</p>
<p>世界天然是并发的。本文总结并发相关的知识和实践。</p>
<h2> 基础</h2>
<p>计算机中实现并发的方式有：多核、多进程、多线程；共享内存模型。基本方法是分而治之、划分均衡任务、独立工作单元、隔离访问共享资源。可以将一个大任务划分为多个互相协作的子任务，将一个大数据集划分为多个小的子数据集，分别处理后合并起来完成整个任务。并发需要解决执行实体之间的资源共享和通信机制。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>并发，就是在同一时间段内有多个任务同时进行着。这些任务或者互不影响互不干扰，或者共同协作来完成一个更大的任务。</p>
<p>比如我在做项目 A，修改工程 a ; 你在做项目 B, 修改工程 b 。我们各自做完自己的项目后上线。我和你做的事情就是并发的。如果我和你修改同一个工程，就可能需要协调处理冲突。并发是一种高效的运作方式，但往往也要处理并发带来的冲突和协作。</p>
<p>世界天然是并发的。本文总结并发相关的知识和实践。</p>
<h2> 基础</h2>
<p>计算机中实现并发的方式有：多核、多进程、多线程；共享内存模型。基本方法是分而治之、划分均衡任务、独立工作单元、隔离访问共享资源。可以将一个大任务划分为多个互相协作的子任务，将一个大数据集划分为多个小的子数据集，分别处理后合并起来完成整个任务。并发需要解决执行实体之间的资源共享和通信机制。</p>
<p>多核：有多个 CPU 核心，每个 CPU 核心都拥有专享的寄存器、高速缓存。多个 CPU 核心可以分别处理不同的指令和数据集。多核心之间的通信机制是系统总线和共享内存。多核是并发的硬件基础。</p>
<p>多进程模型：进程是程序的一次执行实例，具有私有地址空间，由内核调度。进程有父子关系。进程间通信方式：管道（无名管道和命名管道 FIFO）、消息队列、共享内存、套接字、信号机制。进程创建和切换的开销都比较大。多进程是多任务执行的上下文基础。</p>
<p>多线程模型：线程是运行在进程上下文中的共享同一个进程私有地址空间的执行单元，亦由内核调度。线程之间是对等的。线程通信方式：消息队列、共享内存。线程的创建和切换开销比进程要小很多。多线程是多任务的调度基础。</p>
<p>在 Java 应用语境中，执行实体对应着线程。以下涉及到执行实体的时候，直接以线程代替。并发能有效利用多个线程同时工作，大幅提升性能。同时，也是有一定代价的：线程阻塞与上下文切换（5000-10000 CPU 时钟）、内存同步开销（使 CPU 缓存失效、禁止编译器优化等）。不良的并发设计，可能导致大量线程等待、阻塞、切换，反而不如串行的执行效率高。</p>
<h2> 分析</h2>
<p>如何去思考和分析并发问题呢？ 并发的难点在于，（不同线程里的）任务执行的不同顺序会引发不同的结果，而这些顺序都是有一定概率性存在的。</p>
<p>因此，并发的关键点在于如何在合理的程度上协调任务执行顺序产生预期结果，同时又不对任务的进展产生过大的干预。就像宏观调控之于市场经济。市场经济是非常有活力的经济形式，但听凭市场经济的自由发展，会有失衡的风险。此时，就需要一定的宏观调控来干预一下。而宏观调控也不能过度，否则会抑制市场经济的活力。</p>
<p>注意，是协调执行顺序而不是控制。实际上，执行顺序是难以控制的。大多数时候，能做的是对少数步骤执行施加一些影响，使执行顺序符合某些先后约束，从而能够产生预期结果。绝大多数的步骤执行，还是任之自然进行。</p>
<h4> 资源依赖</h4>
<p>要正确协调执行顺序，先得弄清楚要协调哪些任务，或者说，任务执行受什么影响：</p>
<p>有限共享的同一资源。比如两个人去争用仅有的一台打印机，只有一个人用完释放后，才能让另一个人用。<br>
资源之间的依赖。比如任务 A 读变量 x , 任务 B 写变量 y ，x = y + 1， 则 A 读和 B 写的先后顺序不同，会产生不同的结果。假设 x = 3, y= 2 。B 要写入 y = 5 。若 A 先读 B 再写, 则 A 读到的是 x = 3； 若 B 先写再 A 读，则 A 读到的是 x = 6。当两个变量是同一个时，是一种“写后读”的依赖，姑且称之为“变化依赖”。<br>
比如，同一个订单的下单过程，两个线程去分别读写订单数据（假设都是读 DB 主库）：</p>
<p>共享的资源：订单数据行、网络带宽、请求处理池、DB 连接；<br>
变化依赖：订单状态的读强依赖于订单状态的写。<br>
因此，任务执行受有限共享的资源及资源依赖影响。如果多个任务并发执行，首先要理清楚这些任务所依赖的资源以及资源之间的依赖。资源类型包括：变量、数据行（记录）、文件句柄、网络连接、端口等。如果两个任务没有资源依赖，则各自执行即可；如果有共享资源依赖，则需要在合适的时候自动调节彼此获取共享资源的顺序。</p>
<p>值得提及的是，有一种隐式的资源依赖。比如一个大的任务拆分为 A,B,C 三个任务，A 和 B 都执行完成后，才能执行 C。此时 C 的执行依赖于 A,B 的执行完成状态（也很可能依赖 A,B 的执行结果集）。 这种隐式的资源依赖，也称为任务协作。</p>
<h4> 逻辑时钟</h4>
<p>如何判断并发执行结果是准确的呢？比如 x = 1 。任务 A 在 t 时刻读 x ，任务 B 在 t+1 时刻写 x =5, 任务 C 在 t+2 读 x，按理 A 读到是 1 ，C 读到是 5 。 但由于网络延时，可能 C 的读请求在 B 的写请求提交之前就到达了，因此 C 也可能读到 1。由于网络的不可靠及机器各自的时钟是有细微不同步的，因此，执行读写 x 的服务器无法判断 B, C 请求的先后性。</p>
<p>需要有一个逻辑时钟，给任务进行顺序编号，根据任务编号以及读写的因果性，就能判断 C 读到 1 的结果是错误的了。</p>
<p>happen-before</p>
<p>定一些基本的准则是必要的。就像欧几里得几何首先定义了五条公理然后才开始推导一样。</p>
<p>happen-before 是可见性判断的基本准则：符合准则的两个操作，前面的操作必然先行于/可见于后面的操作。换句话说，就是关于并发的基本定理。如果定理都不成立，那么并发的确定性结果就无从谈起了。 happen-before 的具体细则：</p>
<p>在同一个线程的顺序控制流中，有依赖关系的前面操作可见于后续操作；<br>
同一个锁的 unlock 可见于 lock 操作，即 lock 时总能看到前一个 unlock 操作；<br>
同一个 volatile 变量的写可见于读操作；<br>
同一线程 start 先行于该线程内的所有操作，线程内的所有操作先行于该线程的 exit ；<br>
对象的构造器方法结束先行于对象的所有操作，对象的所有操作先行于对象的 finalize 方法开始；<br>
传递性。A 可见于 B， B 可见于 C ，则 A 可见于 C 。</p>
<h2> 思路</h2>
<p>要正确协调任务的执行顺序，需要解决任务之间的协作与同步。任务之间的协作与同步方式主要有：快照机制、原子操作、指令屏障、锁机制、信号机制、消息/管道机制。</p>
<h4> 快照机制</h4>
<p>生成某个时间点的历史版本的不可变的快照数据，以一定策略去生成新的快照；直接读快照而不是读最新数据。将数据与版本号绑定，根据版本号来读取对应的数据；更新时不会修改已有的快照，而是生成新的版本号和数据。快照机制可以用来回溯历史数据。Git 是运用快照机制的典范。</p>
<p>快照机制并没有对任务的自然进展施加影响，只是记录了某个数据集的某个时刻的状态。应用可以根据需要去读取不同时刻的状态，做进一步处理。快照机制一般用来提升并发读的吞吐量。</p>
<h4> 原子操作</h4>
<p>将多个操作封装为一个不可分割的整体操作，其它操作不可能在这个整体操作之间插入更新相关变量。</p>
<p>实现原子操作有两种方式：</p>
<p>对变量更新加锁。但加锁会导致线程阻塞和等待，且需要释放锁，开销很大。<br>
CAS 操作。对于单个简单变量的读写同步，加锁的开销可能远高于变量更新的开销。可以采用轮询式的 CAS 原子操作。CAS 是封装了变量的“比较相等-更新”的原子操作。</p>
<h4> 指令屏障</h4>
<p>指令屏障是在普通指令中插入特殊指令，从而在读写指令的执行之间加以执行顺序的先后约束，控制某些指令必须在另一些指令之前执行且执行结果可见，禁止 CPU 通过指令重排序来优化内存读写（有性能损失）。最常用的指令屏障是内存屏障 Memory Barrier。</p>
<h4> 锁机制</h4>
<p>锁机制用于有限共享资源的保护性访问，每次只允许一个执行体来访问可获得的共享资源。</p>
<p>锁机制的基础是 P-V 原语和阻塞/唤醒机制：</p>
<p>P(s) 操作：如果 s 是非零的，那么 P 将 s 减一，并立即返回，如果 s 为零，就挂起该线程。<br>
V(s) 操作：将 s 加一，如果有任何线程阻塞在 P 操作等待 s 变成非零，则 V 操作会重启这些线程中的一个，重启之后，P 将 s 减一，并将控制返回给调用者。</p>
<h4> 信号机制</h4>
<p>信号机制是发出特定的信号，让接受信号的任务做相应的处理。中断是信号机制的一种典型场景。中断由某个中断源发出一个信号给某个线程，当线程收到这个信号时，可以做一些特定的动作。</p>
<p>Java 线程有一个中断标志位。处于不同状态时，线程对于中断有不同的反应。处于 New 和 Terminated 时，无意义；处于 Running 和 Blocked 时，只是设置中断标志位，不会影响线程状态； 处于 Time Sleep 时，会抛出异常并清空中断标志位。Java 将中断的具体处理的权力交给了应用。</p>
<h4> 消息/管道</h4>
<p>通过在两个任务之间传递消息或者建立管道，来串联起两个任务的顺序执行。消息机制常用于解耦服务，而管道常用于 Pipeline 流水线模式中。</p>
<h2> 模式</h2>
<p>从并发思路中可以推导出一些常用的同步模式，来确保并发访问的安全性。主要有：Immutable、Unshared Copies、Monitor Locks 、Memory Barrier、Protected Lock、CAS。</p>
<h4> Immutable</h4>
<p>不可变数据。典型的不可变数据有字符串、快照。ES 分片里的倒排索引就是不可变的。ES 会将不可变的倒排索引与更新的倒排索引进行查询合并，得到最终的查询结果。</p>
<h4> Unshared Copies</h4>
<p>每个线程都有一份自己的拷贝，不共享，互不影响。ThreadLocal 即是应用 Unshared Copies 模式。</p>
<h4> Monitor locks</h4>
<p>Java synchronized 块应用 Monitor locks 模式，基于 object monitor 和 monitorenter/2 monitorexit 实现，由编译器和 JVM 共同协作实现。JVM 规范指明：每个对象关联一个 object monitor ，当线程执行 monitorenter 时会去获取 monitor 的 ownership ，而执行 monitorexit 则会释放 monitor 的 ownership。第二个 monitorexit 是为了在异常退出时与 monitorenter 匹配。在 hotSpot 虚拟机中，monitor 是由 ObjectMonitor 实现的。其源码位于 hotSpot 虚拟机源码 ObjectMonitor.hpp 文件中。</p>
<p>synchronized 方法是基于方法常量池中的方法表结构中的 ACC_SYNCHRONIZED 标识符实现。synchronized 是可重入的，同一线程连续多次获取同一个锁，不需要每次都加锁，只需记录加锁次数。同步容器 SynchronizedList, SynchronizedMap 是基于 synchronized(mutex) { // target.operation(); } 实现的对应容器的简单并发版。</p>
<h4> Memory Barrier</h4>
<p>Memory Barrier 内存屏障。当插入内存屏障后，其后的指令不会立即放在 CPU 缓存里，而是和内存屏障一起放在 FIFO 队列里，待 CPU 缓存里的指令都执行完成后，从 FIFO 中取出内存屏障后的指令来执行。</p>
<p>内存屏障主要有两种：</p>
<ul>
<li>写内存屏障（Store Barrier）:处理器将 CPU 缓存值写回主存（阻塞方式）;</li>
<li>读内存屏障（Load Barrier）: 处理器处理失效队列（阻塞方式）。<br>
两两组合，有四种：StoreStoreBarrier, StoreLoadBarrier, LoadStoreBarrier, LoadLoadBarrier。 XYBarrier 是指，在 XYBarrier 之前的所有 X 操作都必须在 XYBarrier 之后的任一 Y 操作之前执行完成。并且写操作对所有处理器可见。</li>
</ul>
<p>volatile 关键字在写操作之后插入 StoreStore Barrier, 在读操作之前操作 LoadLoad Barrier。volatile 适合做单个简单状态标识符的更新、生命周期里的初始化或退出。volatile 是不加锁的。</p>
<h4> Protected Lock</h4>
<p>轻量级更灵活的锁。形式通常如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> CAS</h4>
<p>Compare-And-Swap 。CAS(V,E,N) 操作即是“先将 V 与 E 比较是否相等，如果相等，则更新到指定值 N ，否则什么都不做”。CAS 是无锁的非阻塞的，没有线程切换开销，因此在并发程度不高的情况下性能更优。Java 并发包里的绝大多数同步工具都有 CAS 的影子。 Java CAS 操作是通过 Unsafe 类的 native 方法支持的。</p>
<p>CAS 操作的原子语义是通过底层硬件和指令来支持的。相关指令如下：</p>
<ul>
<li>测试并设置（Tetst-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap）</li>
<li>加载链接/条件存储（Load-Linked/Store-Conditional）<br>
在IA64，x86 指令集中有 cmpxchg 指令完成 CAS 功能。CPU 的原子操作在底层可以通过总线锁定和缓存锁定来实现。总线锁定是 CPU 在总线上输出一个 LOCK# 信号，阻塞其它处理器操作该共享变量的缓存的请求，独占内存；缓存锁定是通过 MESI 缓存一致性机制来保证操作的原子性。在如下情况下只能使用总线锁定：当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，或者 CPU 不支持缓存锁定。</li>
</ul>
<p><strong>CAS 有两个问题</strong>：</p>
<ul>
<li>并发度高时的空耗问题：CAS 是需要消耗 CPU 周期的。如果并发激烈，则可能陷入空耗 CPU 周期的 CAS 循环中。此时，可以采用分段的方式，将要更新的变量分为多段，对不同的段进行 CAS ，然后合并。比如 LongAdder 。</li>
<li>A-B-A 问题：先更新为 A，再更新为 B，又更新为 A。可以采用版本号/时间戳来区分两次相同值。比如 AtomicStampedReference。</li>
</ul>
<h2> 工具</h2>
<p>理解了并发的模型、思路和模式之后，再来看并发工具如何实现。Java 并发包里的绝大多数同步工具都是基于 CAS 和 AQS 的。因此，深入理解 CAS 和 AQS 是非常重要的。</p>
<h4> AQS</h4>
<p>实现 Java 同步工具的基本框架，也是整个 Java 并发包的核心基础类。AQS 实现了“根据某种许可获取的情况将线程入队/出队以及相应的线程阻塞/唤醒”的通用机制，而将何时入队/出队（是否能够获得许可）的控制权交给了库的使用者。AQS 支持按照中断（互斥）或者超时两种模式来获取/释放许可，协调线程执行顺序。</p>
<p>AQS 包含一个同步队列和一个条件队列。两个队列都是基于链表实现的。</p>
<ul>
<li>同步队列：CLH 变体，双向链表实现的队列，从尾部入队，从头部出队。入队是针对尾节点 tail 的 CAS 操作，将 tail 赋给为入队线程创建的新节点；出队则是更新首节点 head。同步队列初始化时，需要对 head 进行 CAS 操作。head 节点相当于一个哨兵元素，head 节点没有 prev 和 thread ，且 waitStatus 不会为 CANCELLED。同步队列的遍历往往是从 tail 开始往前遍历。</li>
<li>条件队列：采用单链表，互斥模式。ConditionObject 对象实现了条件等待/通知机制。调用 await 方法时会从同步队列转移到条件队列，调用 signal 唤醒方法时则从条件队转移到同步队列。</li>
<li>两者联系：同步队列和条件队列复用了相同的链表节点，通过链表节点上的节点指针来标识节点在哪个队列上。同步用来获取锁，而条件队列在获取锁的基础上用来实现在特定条件的等待/唤醒，两者可以配合使用。<br>
链表节点包含如下成员：</li>
</ul>
<p>被阻塞或等待唤醒的线程 Thead 。</p>
<ul>
<li>节点状态 waitStatus 。 CANCELLED -- 超时或中断取消，一旦进入, 就不可改变； SIGNAL -- 需要唤醒后继节点 , CONDITION -- 线程等待唤醒, PROPAGATE -- acquireShare 需要无条件传播下去；处于 CANCELLED 的节点是不可被阻塞或唤醒的，因此在阻塞或唤醒时需要遍历跳过 CANCELLED 节点。</li>
<li>实现同步队列的节点指针 head, tail ; prev, next 。prev 用来处理取消，通过 prev 的节点状态来判断当前线程该如何处理；next 当前节点释放时需要唤醒它的 next 节点，CANCELLED 节点的 next 是它自身。由于前驱或后继节点可能因为超时或中断已被取消，因此需要遍历来找到第一个没有取消的前驱或后继节点。</li>
<li>实现条件队列的节点指针 firstWaiter, lastWaiter ; nextWaiter 。nextWaiter 在条件队列中指向下一个节点，或者指向 Share 节点。</li>
<li>如前所述，AQS 实现了通用的入队/出队以及相应的阻塞/唤醒机制，那么何时会入队/出队呢？这就是自定义方法的作用了。使用 AQS 开发同步工具，需要定义好 state 的同步语义，实现如下方法：tryAcquire/tryRelease，tryAcquireShared/tryReleaseShared，isHeldExclusively。</li>
</ul>
<h4> AtomicXXX</h4>
<p>原子类，提供基本数据类型的原子化更新操作。通过 volatile variable + offset (字段的固定的内存地址偏移量) + Unsafe 来获取的状态字段的可见值，CAS 实现原子操作，适用于计数、安全引用更新等。可阅读 AtomicInteger 和 LongAdder 的实现。</p>
<h4> ReentrantLock</h4>
<p>Protected Lock 模式的一种实现。基于 CAS 和 AQS 实现，提供公平锁 FairSync 和非公平锁 NonfairSync。默认非公平锁。非公平锁吞吐量更高，公平锁倾向于访问授予等待时间最长的线程，吞吐量可能较低，适合防线程饥饿上波动小一点。</p>
<ul>
<li>
<p>ReentrantLock 的 lock 实现默认委托给 NonfairSync，该类继承 AQS 来实现锁机制。</p>
</li>
<li>
<p>nonfairTryAcquire: 分为两种情况处理 -- 线程第一次获取锁和已经获取锁。</p>
</li>
<li>
<p>tryRelease：分两种情况处理 -- 最后一次释放锁和多次获取锁后的某一次释放。</p>
</li>
<li>
<p>state 同步语义： state &gt; 0 表示已有线程获取锁的许可数，只有获取锁的线程能够继续获取锁或者释放锁； state = 0 表示线程可以去获取锁。<br>
ReentrantLock 可以返回一个ConditionObject 对象，用作条件等待阻塞和唤醒。</p>
</li>
<li>
<p>CopyOnWriteArrayList 基于 array + ReentrantLock + System.arraycopy 实现，读多写少场景。读列表不加锁，更新列表使用 ReentrantLock 进行保护性访问。</p>
</li>
<li>
<p>ArrayBlockingQueue 使用一个 ReentrantLock 及一对 Condition ( notEmpty &amp; notFull ) 对队列进行保护性访问，并在队列空/满时阻塞相应线程，在队列非空/非满时唤醒相应线程。</p>
</li>
</ul>
<p>ConcurrentHashMap</p>
<p>HashMap 的并发加锁版。要点如下：</p>
<ul>
<li>为保证高并发，使用了分段锁机制，每个桶关联一个锁；</li>
<li>定位桶索引时使用 CAS ，因为定位桶索引是一个轻量操作；</li>
<li>访问某个桶的数据时使用分段锁(synchronized(tab)) ；</li>
<li>链表冲突转换为红黑树时，插入新节点后将树转平衡时使用 CAS 。</li>
<li>ConcurrentHashMap 可用于并发环境中的缓存实现。<br>
ConcurrentHashMap 体现了一些提升并发性能的技巧：减少串行化部分的耗时、减少持锁逻辑耗时（降低锁粒度）、减少锁竞争程度（数据分段及分段锁）。使用多个细粒度锁交互时要注意防止死锁。</li>
</ul>
<h4> ThreadLocal</h4>
<p>ThreadLocal 类里维护了一个哈希表 ThreadLocalMap[ThreadLocal, Value] ，每个线程都持有一个对 ThreadLocalMap 的引用，在该线程里调用 ThreadLocal.setInitialValue 方法时被初始化。当调用某个 ThreadLocal 对象的 set 方法时，会先获取当前线程，然后将当前线程的 TheadLocal 对象及对应的值写入所持有的 ThreadLocalMap 中。ThreadLocal 对象的哈希码值是通过一个 AtomicInteger 每次自增 0x61c88647 得到的。0x61c88647 是斐波那契乘数，可保证哈希散列分布均匀一些。</p>
<p>ThreadLocal 在一个长流程中存储需要的 Context 。ThreadLocal 使用要注意的问题：</p>
<ul>
<li>内存泄露。由于 ThreadLocalMap 的 key 是弱引用，ThreadLocalMap 是强引用对象，当 key 被回收时，对应的 value 可能不会被回收，会造成内存泄露；</li>
<li>ThreadLocal 与线程池联合使用时，退出线程前必须清除残留的 ThreadLocal 变量数据。</li>
</ul>
<h4> 线程池</h4>
<p>线程池是受控的可执行多任务的线程管理器。Java 线程池实现是 ThreadPoolExecutor。 线程池的主要组成部分如下：</p>
<ul>
<li>
<p>一个阻塞任务队列，用来存放待处理的任务 BlockingQueue[Runnable] workQueue；关联任务拒绝策略 RejectedExecutionHandler handler，当队列满时如何处理后面的任务请求。</p>
</li>
<li>
<p>一个线程工厂 threadFactory，用来生产和标识线程，可以做一点线程定制化的事情；</p>
</li>
<li>
<p>一组可控的复用和回收的工作线程 Set[Worker] works；关联访问工作线程的可重入锁 ReentrantLock mainLock；</p>
</li>
<li>
<p>线程池的配置：核心线程数、最大允许线程数、最小允许线程数、最大线程空闲时间。<br>
线程池的实现要点如下：</p>
</li>
<li>
<p>线程池总状态控制 ctl : （3位 runState rs, 29 位 workCount wc）。 ctl = rs | wc。rs 用来表示线程池的状态：RUNNING-- 运行，可以接受新任务； SHUTDOWN -- 关闭，不接受新任务，但可以运行队列中任务；STOP -- 停止，不接受新任务，中断所有正运行的任务；TIDYING -- 线程池已空，将运行 terminated 钩子方法；TERMINATED -- terminated 方法执行完成，线程池彻底终止。技巧：1. 将多个值打包到一个值的技巧；2. 状态值递增，有利于状态的判断。</p>
</li>
<li>
<p>worker：用来执行任务。同时继承 AQS 根据 0 &amp; 1 状态实现了简单的非重入互斥锁，这可以防止某些中断，这些中断旨在唤醒等待任务的工作线程，而不是中断正在运行的任务。</p>
</li>
<li>
<p>workers &amp; mainLock : 配合起来访问工作线程集合，用来做线程统计，以及线程池终止时防止中断风暴。技巧：轻量级并发访问容器里的对象。</p>
</li>
<li>
<p>任务运行： run(Worker) 方法。使用 Protected Lock 模式。</p>
</li>
<li>
<p>线程池终止：SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED。</p>
</li>
<li>
<p>扩展：可以继承 ThreadPoolExecutor，并覆写 beforeExecute 和 afterExecute 方法，定义在任务执行之前和执行之后的行为。可以用来申请/释放资源、打日志等。</p>
</li>
</ul>
<h2> 陷阱</h2>
<p>要做到并发的准确与安全，需要非常小心地避免一些常见陷阱：</p>
<p>“<a href="/principle/concurrency-faq.html" target="blank">设计原理:基本陷阱、原理及解决方案</a>”</p>
<h2> 应用</h2>
<h4> InnoDB锁</h4>
<ul>
<li>InnoDB 使用锁机制实现事务隔离性级别。避免：脏读（读到未提交数据）、不可重复读（两次查询读到不一致的数据）、幻读（两次查询读到不一样的行）。丢失更新问题需要应用层来控制。InnoDB 锁主要有行锁、页锁和表锁。</li>
<li>表锁：开销小，加锁快，锁粒度最大，冲突概率高，并发度低，不会死锁。使用表锁的情况：没有索引时，更新数据会锁表；串行化隔离级别会锁表; 部分 DDL 会锁表或者阻塞写，不要在业务高峰期进行。</li>
<li>行锁：开销小，加锁慢，锁粒度最小，冲突概率较低，并发度较高，会死锁。InnoDB 行锁是通过给索引树上的索引项加锁来实现的。有索引时，锁定读会锁行，更新数据行会锁行。行锁可分为共享锁（读锁、S 锁）和排他锁（写锁、X 锁）。 S 锁与 S 锁可以并发，其它都需要等待已有锁的释放。</li>
<li>锁定读：select … for update （X 锁）, select … lock in share mode（S 锁）。 自增长键的锁使用 X 锁定读；外键列的 SELECT 会生成 S 锁定读。</li>
<li>自增长键的锁。AUTO-INC Locking --- 含自增长键的表逐渐插入记录时，会生成 select for update 的加锁读。 特殊表锁机制，锁在完成 SQL 插入语句之后立即释放，而不是等事务执行完成后释放。MySQL 5.1.22 之后提供了一种轻量级互斥量的机制，来实现自增长值插入的性能提升。innodb_autoinc_lock_mode 参数可以选择使用何种机制。默认值为 1 ，对于插入前可以确定插入行数的 simple inerts ，使用互斥量机制，不能确定行数的使用 AUTO-INC Locking 机制。innodb_autoinc_lock_mode = 2 时，始终使用 AUTO-INC Locking 机制，性能最优，但容易导致不一致问题。</li>
<li>外键列：外键列的 SELECT 会对父表中的相应行加 S 锁。如果父表中的相应行已经有 X 锁，则外键的 SELECT 需要等待锁释放后才能执行。</li>
<li>行锁算法：Record 锁、Gap 锁、Next-Key 锁。Record 锁通常是索引列的读写引起，锁定行记录本身；Gap 锁定范围边界但不锁定记录；Next-Key 锁是 Record + Gap 的结合，右闭区间，锁定范围内的记录以及范围右端的记录，但不锁定左端的记录，可以防止幻读。InnoDB 默认隔离级别是 Repeatable Read ，该级别下，辅助索引的默认行锁是 Next-key 锁；若查询列为唯一索引列时，Next-Key 锁会降级为 Record 锁。</li>
</ul>
<h4> 分布式锁</h4>
<ul>
<li>锁的要求： 容易替换实现、可重入、高性能、高可用。实现时要考虑异常（应用宕机、网络延时与中断、集群节点宕机等）。</li>
<li>基本思想： 锁 + 超时 + 持锁线程的唯一标识 + 加锁/释放锁的必要检测。通常使用 Redis, ZK 实现。</li>
<li>锁释放： 1. 需要加超时，避免线程不响应时无法释放锁； 2. 加锁时必须加该线程的标识信息，避免释放锁时释放错误。考虑这样一种情况：线程 A 申请了带超时的锁 l ，因某种原因被阻塞或者不响应，锁 l 因超时被释放，被线程 B 申请到； 接着 A 从阻塞或不响应中恢复过来，释放原来申请的锁，如果锁没有线程标识的信息，就很可能把 B 申请的锁给释放掉了。这就是说，释放锁时需要严格的检测。</li>
<li>Redis: 加锁 -- SET NX key unique_value EXPIRE_TIME ，若已持有锁则加 EXPIRE_TIME，如果 NX 和 EXPIRE_TIME 不同时在一起，当进程加锁后就崩溃，则该锁将无法释放；释放锁 -- get-and-del 使用 Lua 脚本保证原子性, if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) 。 可以使用 Redisson API ：”一文掌握 Redisson 分布式锁原理“</li>
<li>ZK: 先创建一个持久化节点，当第一个客户端需要加锁时，在持久化节点下创建一个最小编号的临时顺序节点；后续要加锁的客户端依次创建编号次小的临时顺序节点，并对临近的前一个节点创建 watch 监听任务。 每个客户端释放锁时，都需要检测自己的节点编号是否是最小的那个，每次仅能释放编号最小的那个节点。当释放成功后，释放任务会触发下一个节点所关联的任务和客户端，这个客户端就可以拿到锁进行操作。当客户端崩溃时，这个节点也会被删除，后面的节点则依次往前挪一位。不同业务的锁采用不同的前缀。可使用 Curator SDK。</li>
<li>实现注意事项：1. 最好提供一个分布式锁的接口，隔离应用程序对具体实现的直接依赖； 2. 在加锁时考虑释放，避免使用者忘记释放锁； 3. 降级处理，比如 Redis 锁不可用时可降级为 DB 锁 或 ZK 锁； 4. 加锁和释放锁的监控（加锁和释放锁的时间、锁中业务执行时间、次数、并发量、失败次数等）。</li>
</ul>
<h2> 挑战</h2>
<h4> 大流量</h4>
<p>并发大流量是引起应用不稳定甚至将应用击溃的常见杀手之一。应对并发大流量的措施：1. 缓存，减少对后端存储压力；2. 降级，暂时移除非核心链路；3. 限流； 4. 架构升级，做到动静分离、冷热分离、读写分离、服务器分离、服务分离、分库分表、负载均衡、NoSQL 技术、（多机房）冗余、容器化、上云。</p>
<h4> 不一致</h4>
<p>由于任务顺序的不确定性及脑力思考的局限性，加上大流量，在少许情形下，可能会触发程序的细微 BUG， 引起数据的不一致。</p>
<p>由于人力的有限性，对于高并发引起的不一致，最好能构建准实时的监控、对账、补偿和对账报表。</p>
<h4> 死锁</h4>
<p>多个线程同时要获取多个类型的共享资源时，申请锁的顺序不当，可能导致死锁。</p>
<p>四要件：1. 互斥、请求与保持、不可剥夺、循环等待；<br>
解决方案： 1. 加锁超时释放，破坏不可剥夺； 2. 加锁顺序控制，破坏循环等待； 3. 使用等待图来检测死锁。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-09T04:16:51.000Z</published>
  </entry>
  <entry>
    <title type="text">设计数据库索引</title>
    <id>https://ujava.cn/highfreq/databaseindex.html</id>
    <link href="https://ujava.cn/highfreq/databaseindex.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。</p>
<h2> 基本知识</h2>
<p>InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。</p>
<p>索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。</p>
<h2> 基本知识</h2>
<p>InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。</p>
<p>索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。</p>
<h4> 顺序索引</h4>
<p>InnoDB 的顺序索引是将主键列表构建成一棵 B+ 树。内节点存放的是均是主键值，叶子节点存放的是整张表的行数据。这样，可以让节点尽可能存放更多的主键值，从而降低树的高度。B+ 树是有序查找平衡树，高度通常在 2-4 之间，因为要尽可能减少磁盘读写次数。B+ 树的插入操作在节点关键数满的情况下，会分裂成两个子节点。理解 B+ 树对于理解顺序索引非常关键。</p>
<p>顺序索引可以分为聚簇索引和非聚簇索引。</p>
<p>聚簇索引：在叶子节点中保存了 B-Tree 索引和数据行。将索引列放在内节点上，而将行数据放在叶子节点上。聚簇索引可以极大提升 IO 密集型的性能。一个表只能有一个聚簇索引，通常用主键列。聚簇索引的最优插入顺序是按照主键值顺序插入。如果是随机插入，更新聚簇索引的代价较高：更多的查找操作、频繁的“页分裂”、移动大量数据、产生碎片。<br>
非聚簇索引：非聚簇索引的内节点存放的是非聚簇索引列的值，叶子节点存储的是对应数据行的主键值。因此，根据非聚簇索引需要两次索引查找。先从叶子节点找到主键值，再根据主键值在聚簇索引里找到数据行。非聚簇索引因为不存储数据行的信息，因此占用空间会比聚簇索引更小。</p>
<h4> 哈希索引</h4>
<p>使用哈希原理实现，性能很高，只能等值匹配，按索引整列匹配、不支持范围查找、不能用于排序。哈希函数可以选择 crc32 或者 md5 的一部分。哈希索引要避免大量冲突同时不占用过多空间。哈希索引的选择性取决于该列哈希列值的冲突度。Memory 引擎支持哈希索引，也支持 B+Tree 索引。可以为较长的字符串（比如 URL）创建哈希索引，在条件中必须同时带上哈希值条件和列值条件。where url = xxx and hashed_url = yyy 。</p>
<p>InnoDB 为某些非常频繁的索引值在 B+ 上在内存中再创建一个哈希索引，称为自适应哈希索引。</p>
<h2> 开发事项</h2>
<h4> 适合做索引的列</h4>
<p>选择性高原则。如果所有行在该列上的“不重复值数量/所有值数量”的比率越高，则选择性越高，越适合做索引。列的选择性：count(distinct(col)) / count(col) 。唯一索引的选择性是 1。使用 show index from tablename ，Cardinality 的值展示了索引列的不重复值的预估值。可以用来判断这个索引是否合适。如果 Cardinality 的值接近于表的记录总数，则是选择性高的。</p>
<p>注意，在单列索引的时候，这个值对应指定索引列的 Cardinality 值，而在联合索引中，这个值对应联合列的 Cardinality 值。如下所示: sid_index 的值为 41659 , tid_index 的值是 101 , sid_index 的选择性高于 tid_index ； stc_id_index.t_id 的值是 3443139 ，是指 (s_id, t_id) 联合索引的值，高于 sid_index 单列索引的选择性。</p>
<p>如何找到高选择性的列呢？</p>
<ul>
<li>定性分析：值比较倾向于唯一的，是高选择性的；而值域在某个有限集合的，是低选择性的。比如 ID 值通常是高选择性的，而 age 值则是低选择性的。</li>
<li>测量分析：使用 count(distinct(col)) / count(col) 来计算，值越接近于 1 的是高选择性的。测量分析通常用于验证或否定。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 构建索引</h4>
<p>先列出所有可能的搜索语句，找到出现的列，将选择性高的列放在最左边，有范围查找的列尽可能放最右边。从左开始逐个将列添加到联合索引里，尽可能覆盖所有搜索语句。可能需要建立多个联合索引来覆盖。最后，要考虑选择语句和排序语句的列，尽可能使用索引覆盖获取列数据，使用索引扫描来排序。</p>
<h4> 联合索引</h4>
<p>联合索引也是一棵 B+ 树，关键字是一个元组。类似索引的多级搜索，逐步大幅减少需要扫描和匹配的行。联合索引搜索遵循最左匹配原则。联合索引需要建立最优索引列顺序。注意，在每个需要搜索的列上建立单列索引，不是联合索引（搜索的时候只能单列搜索后，再用到索引合并来合并结果）。</p>
<p>联合索引匹配遵循最左匹配原则。匹配终止条件：将搜索条件按照联合索引顺序重排列，遇到等值查询（包括 IN 查询）继续，遇到范围查询、BETWEEN、LIKE 查询则终止。无法使用索引的情况：在 where 条件中，索引列在表达式中或对索引列使用函数。</p>
<p>实践中，需要用相同的列但顺序不同的联合索引来满足不同的查询需求。</p>
<h4> 前缀索引</h4>
<p>为长字符串建立索引。使用指定长度的字符串的前缀来建立索引。对于 BLOB, TEXT, 很长的 VARCHAR 列，必须使用前缀索引。前缀索引要选择一个合适的长度：选择性与整列的选择性接近，同时不占用过多空间。前缀索引无法使用 GROUP BY 和 ORDER BY，无法做覆盖扫描。如果字符串后缀或某个部分的选择性更高，也可以做一些预处理转化为前缀索引。思想是相同的。</p>
<p>寻找前缀索引最佳长度的步骤：</p>
<ul>
<li>STEP1 - 先找到该列所有值的 TOPN，可以使用 count as c, col from table group by col order by c desc limit N 语句；</li>
<li>STEP2 - 从一个比较合适的值（比如 3）开始，测试选择性，直到 TOPN 绝大部分列的 c 的数量与 TOPN 的 c 比较接近。</li>
</ul>
<h4> 覆盖索引</h4>
<p>覆盖索引的列包含了所有需要查询的列，可以减少大量的磁盘读，大幅提升性能。如果某个列在 select cols 字句中频繁出现，也可以考虑放在联合索引里，利用覆盖索引来优化性能。延迟关联技术可以使用覆盖索引能力。</p>
<h4> 索引扫描排序</h4>
<p>只有当索引的列顺序与 ORDER BY 字句的顺序完全一致，并且所有列的排序方向都一样时，才能使用索引对结果做排序。有一个例外，就是前导列条件指定为常数。比如 (date, fans_id) 对于 where date = 'xxx' order by fans_id desc 也可以使用索引扫描排序。</p>
<h4> 索引提示</h4>
<p>可以使用 FORCE INDEX(a) 强制指定 SQL 语句要使用的索引。</p>
<h4> MRR</h4>
<p>Multi-Range Read。针对范围查询的优化。MRR 会将查询到的辅助索引键放到缓存里，然后按照主键排序（将随机 IO 转换为顺序 IO，可以减少页替换），再根据排序后主键来顺序来访问实际数据。适用于 range, ref, eq_ref 的查询。</p>
<p>MRR 默认开启。使用 optimizer_switch 的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。<br>
SET @@optimizer_switch='mrr=on,mrr_cost_based=on';</p>
<h4> “系统账号”问题</h4>
<p>索引列的某个值出现次数非常多。应避免使用系统账号值出现在查询语句里。</p>
<h2> 索引实验</h2>
<h4> 准备工作</h4>
<h4> 准备表</h4>
<p>假设有个学生选课表。如下所示：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 准备数据</h4>
<p>写个 groovy 脚本生成 800w 条选课数据。批量插入的效率更高。单个插入，每刷新一次，几千的插入；批量插入，每刷新一次，20w 的插入。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的样例数据如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以查看表空间大小：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 开始试验</h2>
<h4> 给裸表添加索引</h4>
<p>假设什么索引都不建，裸表一个，通过 s_id 搜索需要 2.94s; 添加 sid_index 索引后，同样的搜索不到 0.01s 。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 explain 解释下：</p>
<ul>
<li>select_type：查询类型， SIMPLE 表示这是一个简单的 SELECT 查询；</li>
<li>type: 表的连接类型。 const 表示匹配最多一行，通常是根据主键查询；ref 表示使用非主键/唯一索引匹配少量行； range 表示范围查询，&lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, IN, BETWEEN, LIKE ； index 扫描索引树，但数量太大，相当于全表扫描；ALL 全表扫描。</li>
<li>possible_keys 和 key : 可能使用的索引以及实际使用的索引。</li>
<li>ref: 对于 key 给出的列，哪些列或哪些常量被用来比较了。</li>
<li>rows: 为了找到满足条件的行要扫描的预计行数。</li>
<li>filtered: 被过滤行数的比例。</li>
<li>Extra: 索引使用的额外信息。 Using Where 需要使用 where 字句条件来过滤记录; Using Index 要获取的列信息可以从索引树上拿到; Using filesort 文件排序; Using MRR 是否使用了 MRR 优化范围查询.</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对索引列使用了函数不会使用索引：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设有如下语句，可以看到使用了索引 sid_index ，从 194 条过滤到最终 3 条。因为 sid_index 已经过滤了绝大多数记录，因此添加 t_id 索引看上去没有必要。不过，这里只是某个 s_id 值的查询结果，不代表其它的 s_id 查询结果。不能仅仅据此就断定不需要加 (s_id, t_id) 联合索引。可以 count group by s_id 看看 s_id 的重复数量，进一步判断。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在删除 sid_index 索引，添加 tid_index 索引。看看情况如何。由于 t_id 选择性较低，添加 tid_index 过滤后仍然有 8w+ 条记录，两条搜索语句耗时 0.4s 左右。计算一下 s_id 和 t_id 的不重复行数量， s_id 更大，选择性更高。这说明：添加选择性高的索引，性能提升更优。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 联合索引</h4>
<p>考虑如下语句。仍然使用 tid_index ，耗时 0.4s 。如果使用联合索引 (tid_index, cid_index) , 则耗时 0.03s 。相当于做了两次索引查找，当然比一次要快。代价是，索引占用空间更高。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合情形一，通常会将多个业务 ID 建成联合索引 (s_id, t_id, c_id) ，这样，(s_id), (s_id, t_id), (s_id, t_id, c_id) 的联合等值查询都可以应用到这个索引。由于 s_id 选择性非常大，可以单独建一个索引（节省索引占用空间）；而 (t_id, c_id) 需要建一个联合索引，因为 (s_id, t_id, c_id) 无法匹配 t_id 和 c_id 联合查询的情况。根据最左匹配原则，s_id 必须出现。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>联合索引是应对多条件查询的性能提升的关键。最左匹配原则是应用联合索引的最重要的原则之一。将查询条件按照联合索引定义的顺序 (a,b,c,d,e) 重新排列，逐个比较：</p>
<ul>
<li>如果查询条件均是等值查询，则出现顺序没有关系，按照联合索引定义顺序重新排列即可。比如 a=1 and b=2 与 b=2 and a=1 是等同的。顺序可以不同，但必须出现。如果 b=2 and c=3 就无法应用联合索引 (a,b,c,d,e) 了，因为 a 没出现。</li>
<li>如果联合索引里没有出现该列，则匹配到此终止。比如 b=2 and a=1 and d = 4 只能应用 (a,b)，因为 c 没出现。</li>
<li>如果联合索引里出现了范围匹配的列，则匹配到该列终止，后面的条件无法应用索引。比如 b=2 and a=1 and d=4 and c in (2,3) 只能应用 (a,b,c) ，因为 c 出现了范围匹配。<br>
在 explain 命令中，可以看 ref , filter 来判断应用了哪些索引。如果没有应用到某个列的索引，也可以删除相应的查询条件，用 explain 命令的 ref 和 rows 来对比是否有变化。如果只应用到了某个索引，则 Extra = Using index condition 。 假设现在只建立了 (s_id, t_id, c_id) 联合索引。可以用 show index from student_courses; 查看建立了哪些索引。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是各语句以及应用联合索引的情况：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 索引覆盖</h4>
<p>索引覆盖是指 select 中的列均出现在联合索引列中。如下两个语句，后面那个语句应用了索引覆盖，Extra = Using index ，取列数据时可以直接从索引中获取，而不需要去读磁盘。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 索引扫描排序</h4>
<p>索引可以用来排序，从而减少随机 IO，提升排序性能。如下三种情况可以应用索引排序：</p>
<ul>
<li>索引列顺序与 ORDER BY 子句的顺序完全一致时，并且所有列的排序方向都相同；如果要关联多张表，则 ORDER BY 引用的排序字段都为第一张表的字段时；</li>
<li>如果前导列为等值查询，后续的 ORDER BY 子句的字段顺序与索引列顺序一致。<br>
如果使用了索引排序，则 type = index ； 如果未能引用索引排序，那么 Extra 会提示 Using filesort 。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> MRR</h4>
<p>如果使用 MRR 导致的开销过高，也不会开启 MRR。此时，可以使用强制索引，或者设置无论如何都开启 MRR。如下所示，t_id &lt; 'T24' 会开启 MRR，但 t_id &lt; 'T32' 则不会开启。此时，可以强制使用索引 tc_index， 这样，就会使用 MRR。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>数据库是开发人员最常打交道的软件，而索引是高效访问数据库的重中之重。深入理解索引的原理，合理设计适配查询的索引，是有必要下功夫的。</p>
<p>索引基本功：</p>
<ul>
<li>根据查询条件创建高效的索引；</li>
<li>理解最左匹配原则并定义最优的联合索引；</li>
<li>尽可能用好覆盖索引和索引扫描。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-08T09:25:08.000Z</published>
  </entry>
  <entry>
    <title type="text">设计容错</title>
    <id>https://ujava.cn/highfreq/faulttolerant.html</id>
    <link href="https://ujava.cn/highfreq/faulttolerant.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。</p>
<h2> 错误源</h2>
<p>要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。</p>
<p>要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。</p>
<h4> 机器节点</h4>
<ul>
<li>磁盘故障、内存耗尽、CPU 100% 占用、掉电；</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。</p>
<h2> 错误源</h2>
<p>要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。</p>
<p>要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。</p>
<h4> 机器节点</h4>
<ul>
<li>磁盘故障、内存耗尽、CPU 100% 占用、掉电；</li>
</ul>
<h4> 网络</h4>
<ul>
<li>DNS 故障、机架故障、路由器故障、设备故障、电缆故障；</li>
<li>连接中断、请求排队（延迟）、网络丢包、网络重传、网络拥塞、网络分区。</li>
</ul>
<h4> 时间</h4>
<ul>
<li>很多监控统计依赖于时钟；</li>
<li>数据最终一致性的操作依赖于到达先后顺序；</li>
<li>同一台机器的时钟晶振可能受温度影响而波动；</li>
<li>不同机器上的时钟是不一致的，通过 NTP 协议同步；</li>
<li>NTP 协议是经过网络的，这意味着网络的不稳定会影响时钟的同步；</li>
<li>“跳秒”现象：1 分钟有 59s 或 61s ；</li>
<li>任务耗时过长，对外部来说就是无响应。</li>
</ul>
<h4> 资源</h4>
<ul>
<li>资源不存在，比如文件不存在；</li>
<li>资源暂时不可用，比如端口已占用；</li>
<li>没有可用资源，比如连接池满；</li>
<li>资源路径已经被移动；</li>
<li>资源访问时的同步死锁。</li>
</ul>
<h4> 数据</h4>
<ul>
<li>不符合预期格式的数据；</li>
<li>脏数据引起解析错误；</li>
<li>不一致的数据引起后继行为错误；</li>
<li>大对象数据引起 FullGC 导致响应不稳定；</li>
<li>错误配置；</li>
<li>非法请求获得正常资源；</li>
<li>恶意代码。</li>
</ul>
<h4> 计算</h4>
<ul>
<li>溢出，不符合运算法则；</li>
<li>除零，无值可表示；</li>
<li>有限精度，浮点计算错误；</li>
<li>逻辑错误，比如越界、不正确的算法。</li>
</ul>
<h4> 设计</h4>
<ul>
<li>设计不足或不合理，容易令人疏忽而导致误操作；</li>
<li>危险操作无确认、无提示，容易造成损失；</li>
<li>少数服从多数原则，达不到多数；</li>
<li>Leader 的消息无法被其它节点接收，被其它节点判定为下线。</li>
</ul>
<h4> 流程</h4>
<ul>
<li>中途取消操作；</li>
<li>逆向操作。</li>
</ul>
<h4> 负荷</h4>
<ul>
<li>大流量超出应用承受负荷。</li>
</ul>
<h4> 安全</h4>
<ul>
<li>非授权访问；</li>
<li>数据泄露；</li>
<li>数据被篡改；</li>
<li>访问拒绝。</li>
</ul>
<h4> 并发</h4>
<ul>
<li>数据覆写：访问一个共享资源时，进程 A 获取锁，然后进入了 stop-the-world GC pause ； 进程 B 发现锁已过期，然后申请获得锁，进行数据写操作，接着释放锁；进程 A 结束 GC，进行数据写操作。 进程 A 将 进程 B 的写数据覆盖了。</li>
</ul>
<h4> 拜占庭错误</h4>
<ul>
<li>当分布式系统里的节点要达成共识时，少数节点故意发送错误消息迷惑其它节点，以造成整体错误决策。比如航天领域防电子辐射干扰、多参与者协作和决策。</li>
</ul>
<h2> 健壮性</h2>
<p>健壮性是极为重要的程序质量属性。分为代码健壮性和业务健壮性。健壮性体现在代码和业务上的错误和异常处理上，避免整体失败、数据泄露、不一致、资损等故障。要做出健壮性好的设计和程序，就要预先思考清楚：流程中有哪些可能的错误和异常，每一种对应的处理措施是什么 ？ 这样，才能让逻辑思维更加缜密，也是锻炼逻辑思维的一种有效之法。</p>
<ul>
<li>代码健壮性体现在避免局部失败导致整体失败。常见考虑：参数校验以拦截不合法请求、越界异常捕获、JSON 脏数据异常捕获、类型转换异常捕获、底层异常捕获（连接异常、DB 异常、网络超时异常等）。</li>
<li>业务健壮性体现在业务的闭合环。在整个业务过程中会发生什么异常，导致什么问题（体验或资损问题），如何处理。比如同城异常检测要考虑商家同城呼叫失败后又快递发货的情形。</li>
</ul>
<h2> 容错机制</h2>
<h4> 思路与方法</h4>
<ul>
<li>设定系统假定，检测系统假定是否成立，然后在系统假定上构建系统；</li>
<li>聚焦高频错误：磁盘故障 &gt; 服务器单机故障 &gt; DNS 故障 &gt; 机架故障 &gt; 路由器重启；</li>
<li>错误提示规范：定义规范一致的错误码和错误消息；</li>
<li>快速失败并记录日志：适用于“请求检测，请求中含有错误或非法数据”的场景；</li>
<li>忽略失败并记录日志：适用于“不影响整体输出且不造成负面影响的极次要地方有点小问题”的场景；</li>
<li>确认机制：设计一种确认机制，确保交互的多方参与者满足某种契约或约束；</li>
<li>预防策略：避免容易导致错误的做法；</li>
<li>冗余策略：冗余、替换、路由，见高可用部分；</li>
<li>降级策略：当核心服务出现问题时，提供有损服务来维持稍低质量的服务，保证服务的可用性；</li>
<li>重试策略：幂等；完全重试；补偿重试；</li>
<li>回滚策略：中途取消，重续执行很容易导致脏数据，考虑回滚操作；</li>
<li>故障恢复：监控、检测错误和故障、自动恢复；</li>
<li>乐观锁：递增的 fencing token ，防止过期写操作覆盖已经完成的写操作；</li>
</ul>
<h4> 系统假定</h4>
<ul>
<li>同步模型假定：任何网络延迟、进程暂停、时钟错误都不可能超出某个上限值。即：有限的网络延迟；有限的进程暂停；有限的时钟错误。</li>
<li>部分同步模型假定：在同步模型假定的基础上，允许极少数的无法预测的超上限的网络延迟、进程暂停、时钟错误。</li>
<li>异步模型假定：对时序不做假定，难以预料事件何时发生和动作何时执行。</li>
<li>节点崩溃假定：节点突然失去响应，再也无法正常运行；</li>
<li>节点崩溃-恢复假定：节点可能在任何时候失去响应，在一段时间之后自动恢复并正常运行；易失性存储（比如内存）中的数据丢失，而持久性存储（比如磁盘）中的数据完好；</li>
<li>拜占庭假定：部分节点通过虚假消息欺骗其它节点，从而诱导作出错误的整体决策。</li>
</ul>
<p>最常见的系统假定：部分同步模型假定 + 节点崩溃-恢复假定。</p>
<h4> 算法的正确性</h4>
<ul>
<li>正确性假定：算法满足某些指定性质。</li>
<li>达成预期结果、安全、活性。</li>
</ul>
<h4> 重试</h4>
<ul>
<li>使操作满足幂等性质；</li>
<li>可以使用失败队列来记录失败的操作及失败信息、失败现场；</li>
<li>完全重试策略：整个操作从头开始执行，适合多读少写的长事务；</li>
<li>补偿重试策略：从失败现场的地方重续执行，适合多写且回滚代价昂贵的长事务；‘</li>
<li>完全重试策略，可指定重试次数；</li>
<li>可采用定时任务重试。</li>
<li>幂等：唯一索引、Token 机制（防页面重复提交）、分布式锁、select+insert、状态机幂等、查询/删除天然幂等。</li>
</ul>
<h4> 故障检测与恢复</h4>
<ul>
<li>故障检测主要靠监控。服务器监控（CPU、内存利用率、Load、IO RW、Net RW）、服务监控（RT、QPS、消费速率</li>
<li>、延迟、网络连接；来源、TOPN）、Java 监控（ThreadPool、Heap、GC 等）、异常监控（失败次数、失败比例；超时，消费堆积或不均）、业务监控（瞬时峰值、瞬时下跌、同比上涨或下跌、大数据对象）、对账监控（数据一致性检测，尤其资金相关）。</li>
<li>心跳机制：心跳机制用于故障检测。每台工作机每隔指定时间将自己的CPU、内存、磁盘、网络、IO读写、负载等情况上报给 Master， Master 会判断服务器是否正常，以决定是否分发流量给该服务器。每台服务器与 Master 有个超时设置，如果达到超时没有收到该服务器的心跳信息，则会判断服务器出现问题。心跳机制需要 KeepAlive （连接最大空闲时间） 属性，使用 MQTT 协议。</li>
<li>租约机制：每台工作机向 Master 申请具有一定租约期限的服务时间。当服务时间快到时，再向 Master 继续申请延长租约的有效期。如果因为网络或工作机故障导致租约无法响应，则会将该工作机隔离，不再提供服务。</li>
<li>WAL（Write Ahead Log）： 预写日志，恢复日志。基本机理是复制状态机、备忘录、备份。关系数据库系统中用于提供原子性和持久性。in-place 和 shadow paging 。提升磁盘写性能：随机读写改顺序读写、缓冲单条读写改批量读写、单线程读写改并发读写。同步 WAL 文件和数据库文件的行为被称为 checkpoint（检查点）。实现方法：DB - undo, redo 机制；ES - fsync 机制；ZK - 先写 WAL，再更新内存，最后通知客户端；定期将内存中的目录树进行 Snapshot，落磁盘； ETCD - wal 和 snap 目录； HBase - 更新数据前写 WAL， 且写 WAL 与数据更新在同一事务。</li>
<li>检查点（CheckPoint）：系统定期将内存状态以检查点文件的形式dump到磁盘中，并记录检查点时刻对应的操作日志回放点。 检查点可以快速提升故障恢复的速度。</li>
<li>备份。备份是应对数据故障（丢失、不一致）的重要保障。备份只是实现数据的恢复，并不能完全实现故障恢复。故障恢复是指服务或服务器回到正常可用状态。</li>
</ul>
<h4> MySQL备份</h4>
<ul>
<li>逻辑备份和物理备份。逻辑备份是可读文件、恢复简单灵活（恢复工具及选项）、在不同机器上运行、与存储引擎无关、避免物理环境导致的数据损坏，但恢复时间较长，需要<br>
MySQL 来完成、需要测试恢复；物理备份通常是不可读的二进制文件，恢复更简单（只要拷贝文件到目的路径）、恢复时间很短，但 InnoDB<br>
的原始文件通常比逻辑备份的文件更大。两种方式可混合。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-08T09:07:52.000Z</published>
  </entry>
  <entry>
    <title type="text">设计框架</title>
    <id>https://ujava.cn/framework/</id>
    <link href="https://ujava.cn/framework/"/>
    <updated>2023-11-08T08:55:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 设计框架</h2>
<p>列举常见的设计框架等</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 设计框架</h2>
<p>列举常见的设计框架等</p>
]]></content>
    <category term="设计框架"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">DDD框架</title>
    <id>https://ujava.cn/framework/ddd.html</id>
    <link href="https://ujava.cn/framework/ddd.html"/>
    <updated>2023-11-08T08:55:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>领域驱动设计是Eric Evans在2004年发表的Domain Driven Design（领域驱动设计，DDD)著作中提出的一种从系统分析到软件建模的一套方法论。以领域为核心驱动力的设计体系。</p>
<p>从领域驱动定义来看，领域驱动设计-软件核心复杂性应对之道，从Eric 定义中可以看出，领域驱动设计是为了解决复杂的软件设计，而且只是解决软件复杂性的一种方式，并不是唯一选择。另外不是所有的业务服务都合适做DDD架构，DDD适合产品化，可持续迭代，业务逻辑足够复杂的业务系统，对于系统初期业务逻辑相对比较简单的应用，传统MVC架构更具有优势，可以减少一部分认知成本与开发成本。而且领域驱动设计并不是万金油，只是解决复杂软件的一种方案，领域驱动设计本身只提供了理论思想，具体的落地方案一定是结合具体的业务场景实现的。目前市面上也有很多依据领域驱动思想落地的开源框架可以参考。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>领域驱动设计是Eric Evans在2004年发表的Domain Driven Design（领域驱动设计，DDD)著作中提出的一种从系统分析到软件建模的一套方法论。以领域为核心驱动力的设计体系。</p>
<p>从领域驱动定义来看，领域驱动设计-软件核心复杂性应对之道，从Eric 定义中可以看出，领域驱动设计是为了解决复杂的软件设计，而且只是解决软件复杂性的一种方式，并不是唯一选择。另外不是所有的业务服务都合适做DDD架构，DDD适合产品化，可持续迭代，业务逻辑足够复杂的业务系统，对于系统初期业务逻辑相对比较简单的应用，传统MVC架构更具有优势，可以减少一部分认知成本与开发成本。而且领域驱动设计并不是万金油，只是解决复杂软件的一种方案，领域驱动设计本身只提供了理论思想，具体的落地方案一定是结合具体的业务场景实现的。目前市面上也有很多依据领域驱动思想落地的开源框架可以参考。</p>
<p>从领域驱动对应关系来看，一方面目前很多建设中台的时候大多采用DDD思想落地，DDD很多思想比如领域划分，领域事件，领域服务，边界上下文划分，充血模型，代码防腐，统一语义等等可以很好的帮助实现中台的落地，但是中台落地DDD并不是唯一选择。另一方面对于DDD的这些思想，与DDD的关系更多是聚合关系，而不是组合关系，也就是在具体应用开发中，即使采用传统的MVC架构，这些思想依然可以很好的发挥其作用。</p>
<h2> 优缺点</h2>
<h4> 优点</h4>
<p>DDD最大的好处是：接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。DDD让你首先考虑的是业务语言，而不是数据。DDD强调业务抽象和面向对象编程，而不是过程式业务逻辑实现。重点不同导致编程世界观不同。</p>
<ul>
<li>1.面向对象设计，数据行为绑定，告别贫血模型。</li>
<li>2.优先考虑领域模型，而不是切割数据和行为。</li>
<li>3.业务语义显性化，准确传达业务规则。</li>
<li>4.代码即设计，通过领域设计即可很清晰的实现代码。</li>
<li>5.它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现业务和技术统一的架构演进。</li>
</ul>
<h4> 缺点</h4>
]]></content>
    <category term="设计框架"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">MVC框架</title>
    <id>https://ujava.cn/framework/mvc.html</id>
    <link href="https://ujava.cn/framework/mvc.html"/>
    <updated>2023-11-08T08:55:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。</p>
<h4> 1、视图</h4>
<p>视图(View)<br>
代表用户交互界面，对于Web应用来说，可以概括为HTML界面，但有可能为XHTML、XML和Applet。随着应用的复杂性和规模性，界面的处理也变得具有挑战性。一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。业务流程的处理交予模型(<br>
Model)处理。比如一个订单的视图只接受来自模型的数据并显示给用户，以及将用户界面的输入数据和请求传递给控制和模型。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。</p>
<h4> 1、视图</h4>
<p>视图(View)<br>
代表用户交互界面，对于Web应用来说，可以概括为HTML界面，但有可能为XHTML、XML和Applet。随着应用的复杂性和规模性，界面的处理也变得具有挑战性。一个应用可能有很多不同的视图，MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。业务流程的处理交予模型(<br>
Model)处理。比如一个订单的视图只接受来自模型的数据并显示给用户，以及将用户界面的输入数据和请求传递给控制和模型。</p>
<h4> 2、模型</h4>
<p>模型(Model)<br>
：就是业务流程/状态的处理以及业务规则的制定。业务流程的处理过程对其它层来说是黑箱操作，模型接受视图请求的数据，并返回最终的处理结果。业务模型的设计可以说是MVC最主要的核心。目前流行的EJB模型就是一个典型的应用例子，它从应用技术实现的角度对模型做了进一步的划分，以便充分利用现有的组件，但它不能作为应用设计模型的框架。它仅仅告诉你按这种模型设计就可以利用某些技术组件，从而减少了技术上的困难。对一个开发者来说，就可以专注于业务模型的设计。MVC设计模式告诉我们，把应用的模型按一定的规则抽取出来，抽取的层次很重要，这也是判断开发人员是否优秀的设计依据。抽象与具体不能隔得太远，也不能太近。MVC并没有提供模型的设计方法，而只告诉你应该组织管理这些模型，以便于模型的重构和提高重用性。我们可以用对象编程来做比喻，MVC定义了一个顶级类，告诉它的子类你只能做这些，但没法限制你能做这些。这点对编程的开发人员非常重要。</p>
<p>业务模型还有一个很重要的模型那就是数据模型。数据模型主要指实体对象的数据<br>
保存（持续化）。比如将一张订单保存到数据库，从数据库获取订单。我们可以将这个模型单独列出，所有有关数据库的操作只限制在该模型中。</p>
<h4> 3、控制</h4>
<p>控制(Controller)可以理解为从用户接收请求,<br>
将模型与视图匹配在一起，共同完成用户的请求。划分控制层的作用也很明显，它清楚地告诉你，它就是一个分发器，选择什么样的模型，选择什么样的视图，可以完成什么样的用户请求。控制层并不做任何的数据处理。例如，用户点击一个连接，控制层接受请求后,<br>
并不处理业务信息，它只把用户的信息传递给模型，告诉模型做什么，选择符合要求的视图返回给用户。因此，一个模型可能对应多个视图，一个视图可能对应多个模型。</p>
<p>模型、视图与控制器的分离，使得一个模型可以具有多个显示视图。如果用户通过某个视图的控制器改变了模型的数据，所有其它依赖于这些数据的视图都应反映到这些变化。因此，无论何时发生了何种数据变化，控制器都会将变化通知所有的视图，导致显示的更新。这实际上是一种模型的变化-传播机制。模型、视图、控制器三者之间的关系和各自的主要功能</p>
<ul>
<li>1）最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。</li>
<li>2）最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。</li>
<li>3）中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据，然后对其进行相应的操作，产生最终结果。</li>
</ul>
<p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p>
<h2> 优缺点</h2>
<h4> 优点</h4>
<ul>
<li></li>
</ul>
<p>大部分用过程语言比如ASP、PHP开发出来的Web应用，初始的开发模板就是混合层的数据编程。例如，直接向数据库发送请求并用HTML显示,开发速度往往比较快,但由于数据页面的分离不是很直接,因而很难体现出业务模型的样子或者模型的重用性。产品设计弹性力度很小，很难满足用户的变化性需求。MVC要求对应用分层，虽然要花费额外的工作，但产品的结构清晰，产品的应用通过模型可以得到更好地体现。<br>
*<br>
最重要的是应该有多个视图对应一个模型的能力。在目前用户需求的快速变化下，可能有多种方式访问应用的要求。例如，订单模型可能有本系统的订单，也有网上订单，或者其他系统的订单，但对于订单的处理都是一样，也就是说订单的处理是一致的。按MVC设计模式，一个订单模型以及多个视图即可解决问题。这样减少了代码的复制，即减少了代码的维护量，一旦模型发生改变，也易于维护。<br>
其次，由于模型返回的数据不带任何显示格式，因而这些模型也可直接应用于接口的使用。<br>
*<br>
由于一个应用被分离为三层，因此有时改变其中的一层就能满足应用的改变。一个应用的业务流程或者业务规则的改变只需改动MVC的模型层。控制层的概念也很有效，由于它把不同的模型和不同的视图组合在一起完成不同的请求，因此，控制层可以说是包含了用户请求权限的概念。</p>
<ul>
<li>它还有利于软件工程化管理。由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化产生管理程序代码。</li>
</ul>
<h4> 缺点</h4>
<ul>
<li>增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</li>
<li>视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li>
<li>视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li>
<li>目前，一般高级的界面工具或构造器不支持MVC架构。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。</li>
</ul>
]]></content>
    <category term="设计框架"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">MVVM框架</title>
    <id>https://ujava.cn/framework/mvvm.html</id>
    <link href="https://ujava.cn/framework/mvvm.html"/>
    <updated>2023-11-08T08:55:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>MVVM是Model-View-ViewModel的简写，它本质上是MVC的改进版。MVVM（Model-View-ViewModel）框架的由来是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。</p>
<p>MVVM是一种用于构建用户界面的软件架构模式，它的名称代表着三个组成部分：Model（模型）、View（视图）和ViewModel（视图模型）。MVVM的主要目标是将应用程序的UI与其底层数据模型分离，通过数据绑定实现数据和UI的自动同步，从而降低代码的耦合度，提高应用程序的可维护性和可测试性。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>MVVM是Model-View-ViewModel的简写，它本质上是MVC的改进版。MVVM（Model-View-ViewModel）框架的由来是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构框架。</p>
<p>MVVM是一种用于构建用户界面的软件架构模式，它的名称代表着三个组成部分：Model（模型）、View（视图）和ViewModel（视图模型）。MVVM的主要目标是将应用程序的UI与其底层数据模型分离，通过数据绑定实现数据和UI的自动同步，从而降低代码的耦合度，提高应用程序的可维护性和可测试性。</p>
<h2> 原理</h2>
<h4> Model（模型）</h4>
<ul>
<li>Model表示应用程序的数据模型或业务逻辑，负责处理数据的存取、处理和操作。它通常包含数据结构、数据库操作、网络请求等。</li>
<li>Model并不直接与UI层交互，它只暴露一些接口供ViewModel层调用，使得ViewModel可以获取所需的数据。</li>
</ul>
<h4> View（视图）</h4>
<ul>
<li>View是用户界面的可视化部分，负责展示数据并与用户进行交互。</li>
<li>View通常由XML、HTML、XAML等描述，这取决于具体的开发平台。</li>
</ul>
<h4> ViewModel（视图模型）</h4>
<ul>
<li>ViewModel是Model和View之间的桥梁，负责将数据从Model中取出并转换成View可用的形式。</li>
<li>ViewModel不直接操作View，而是通过数据绑定机制将数据与View进行绑定，使得数据的变化可以自动反映在View上，实现了数据的双向绑定。</li>
<li>ViewModel通常也包含用户交互的逻辑，例如处理用户输入、按钮点击等。</li>
</ul>
<h4> 数据绑定（Data Binding）</h4>
<ul>
<li>数据绑定是MVVM框架的核心特性之一。它将View和ViewModel的数据同步连接，使得它们保持同步。</li>
<li>当ViewModel中的数据发生变化时，数据绑定会自动更新View中绑定到这些数据的部分，反之亦然。</li>
</ul>
<h4> 双向绑定（Two-way Data Binding）</h4>
<ul>
<li>双向绑定是数据绑定的一种扩展，它允许数据的改变能够实时地反映在View中，并且用户在View中的输入也能即时地更新ViewModel中的数据。</li>
<li>这种双向绑定在处理表单、用户输入等场景中特别有用。</li>
</ul>
<p>MVVM的本质是解耦。它通过将UI逻辑从View中分离出来，将数据处理逻辑从View和Model中分离出来，使得每个组件的职责更加明确，代码更易于组织和维护。ViewModel充当着View和Model之间的桥梁，负责将Model中的数据转换成View可用的形式，并且通过数据绑定将数据自动同步到View上。这种双向绑定使得UI的更新变得自动化，开发者只需要专注于数据的处理和业务逻辑的编写，而无需过多关心UI的更新。</p>
<h2> 优缺点</h2>
<h4> 优点</h4>
<ul>
<li>低耦合：视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"<br>
上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变</li>
<li>可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑</li>
<li>独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression<br>
Blend可以很容易设计界面并生成xml代码</li>
<li>可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写</li>
</ul>
<h4> 缺点</h4>
<h2> VUE中的MVVM</h2>
<p>在Vue中，MVVM的应用是通过Vue框架提供的功能来实现的。Vue.js是一个流行的JavaScript框架，专注于实现响应式的用户界面和组件化开发。下面是Vue中如何应用MVVM的一些关键点：</p>
<h4> 数据绑定</h4>
<p>Vue.js提供了强大的数据绑定功能，可以通过v-bind和v-model等指令将数据与View进行绑定。v-bind指令用于将数据绑定到View上，v-model指令则可以实现双向数据绑定，使得用户在View中的输入能够即时地更新ViewModel中的数据。</p>
<h4> 视图模板（View Template）</h4>
<p>在Vue中，开发者可以使用类似HTML的模板语法来定义视图，这些模板语法中可以插入Vue实例中的数据，从而实现数据的展示和渲染。</p>
<h4> Vue实例（ViewModel）</h4>
<p>Vue实例充当着ViewModel的角色，它是Vue应用的根实例，负责管理应用中的数据和逻辑。在Vue实例中，开发者可以定义数据、方法和计算属性等，用于处理数据逻辑和响应用户交互。</p>
<h4> 计算属性和观察者</h4>
<p>Vue提供了计算属性和观察者等功能，用于实现数据的处理和监控。计算属性可以根据其他数据的变化自动计算得出新的值，而观察者可以监听数据的变化并执行相应的操作。</p>
<h4> 组件化开发</h4>
<p>Vue支持组件化开发，开发者可以将UI和逻辑封装成可复用的组件。每个组件都有自己的数据和逻辑，通过props和events等机制，实现了组件之间的数据通信和交互。<br>
总的来说，Vue中的MVVM模式是通过数据绑定、视图模板、Vue实例以及计算属性和观察者等特性来实现的。这些功能使得开发者能够轻松地构建响应式的用户界面，并将数据和视图分离，使代码更易于维护和扩展。通过Vue的MVVM特性，开发者可以更专注于业务逻辑的实现，而不用过多关心数据和UI之间的同步。</p>
<h2> MVVM与MVC区别</h2>
<p>MVVM（Model-View-ViewModel）和MVC（Model-View-Controller）都是用于构建软件应用的架构模式，它们在组织代码和分离关注点方面有一些不同之处。以下是MVVM和MVC的核心区别：</p>
<h4> 角色和职责分配</h4>
<ul>
<li>MVC：在MVC中，Model表示应用程序的数据和业务逻辑，View负责展示数据并与用户进行交互，Controller充当着View和Model之间的中介，负责处理用户输入并更新Model和View之间的数据传递。</li>
<li></li>
</ul>
<p>MVVM：在MVVM中，Model同样表示应用程序的数据和业务逻辑，View仍然负责展示数据并与用户进行交互，但ViewModel取代了Controller的角色，它充当着View和Model之间的桥梁，负责将Model中的数据转换成View可用的形式，并通过数据绑定实现数据的同步更新。</p>
<h4> 数据绑定</h4>
<ul>
<li>MVC：在MVC中，View和Model之间通常没有直接的数据绑定机制，通常需要手动编写代码来同步更新数据。</li>
<li>MVVM：MVVM的一个重要特点是数据绑定。ViewModel和View之间通过数据绑定实现数据的双向绑定，使得数据的变化能自动反映在View上，并且用户在View中的输入也能即时地更新ViewModel中的数据。</li>
</ul>
<h4> UI逻辑</h4>
<ul>
<li>MVC：在MVC中，UI逻辑通常存在于View和Controller中，Controller负责处理用户输入和业务逻辑，并将更新后的数据传递给View进行显示。</li>
<li>MVVM：在MVVM中，UI逻辑主要存在于ViewModel中，View只负责展示数据，而不包含业务逻辑。ViewModel负责处理用户交互、按钮点击等，以及数据的转换和处理逻辑。</li>
</ul>
<h4> 应用场景</h4>
<ul>
<li>MVC：MVC适用于许多应用场景，包括Web应用程序、传统的桌面应用程序等。</li>
<li>MVVM：MVVM主要用于现代前端和移动应用程序开发，特别适用于响应式的用户界面和数据驱动的应用。</li>
</ul>
<p>总的来说，MVVM和MVC的核心区别在于ViewModel的引入和数据绑定机制。MVVM通过引入ViewModel来实现数据和UI的自动同步，从而降低了代码的耦合度和提高了应用程序的可维护性。数据绑定是MVVM的重要特性，使得数据的双向绑定在处理用户输入和更新UI方面变得更加高效和方便。</p>
]]></content>
    <category term="设计框架"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">响应式编程/反应式编程</title>
    <id>https://ujava.cn/framework/responsive.html</id>
    <link href="https://ujava.cn/framework/responsive.html"/>
    <updated>2023-11-08T08:55:23.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
<p>在开发应⽤程序代码时，我们可以编写两种⻛格的代码，即命令式和响应式。</p>
<p>命令式（Imperative）的代码：它由⼀组任务组成，每次只运⾏⼀项任务，每项任务⼜都依赖于前⾯的任务。数据会按批次进⾏处理，在前⼀项任务还没有完成对当前数据批次的处理时，不能将这些数据递交给下⼀项处理任务。</p>
<p>响应式（Reactive）的代码：它定义了⼀组⽤来处理数据的任务，但是这些任务可以并⾏地执⾏。每项任务处理数据的⼀部分⼦集，并将结果交给处理流程中的下⼀项任务，同时继续处理数据的另⼀部分⼦集。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
<p>在开发应⽤程序代码时，我们可以编写两种⻛格的代码，即命令式和响应式。</p>
<p>命令式（Imperative）的代码：它由⼀组任务组成，每次只运⾏⼀项任务，每项任务⼜都依赖于前⾯的任务。数据会按批次进⾏处理，在前⼀项任务还没有完成对当前数据批次的处理时，不能将这些数据递交给下⼀项处理任务。</p>
<p>响应式（Reactive）的代码：它定义了⼀组⽤来处理数据的任务，但是这些任务可以并⾏地执⾏。每项任务处理数据的⼀部分⼦集，并将结果交给处理流程中的下⼀项任务，同时继续处理数据的另⼀部分⼦集。</p>
<p>Reactor 是⼀个响应式编程库，同时也是Spring家族的⼀部分。它是Spring 5反应式编程功能的基础。</p>
<h2> 优缺点</h2>
<h4> 优点</h4>
<h4> 缺点</h4>
]]></content>
    <category term="设计框架"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">设计高频</title>
    <id>https://ujava.cn/highfreq/</id>
    <link href="https://ujava.cn/highfreq/"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 设计高频</h2>
<p>列举常见的设计高频等</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 设计高频</h2>
<p>列举常见的设计高频等</p>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">设计缓存</title>
    <id>https://ujava.cn/highfreq/cache.html</id>
    <link href="https://ujava.cn/highfreq/cache.html"/>
    <updated>2024-02-25T01:16:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p>
<p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p>
<ul>
<li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li>
<li>虚拟主存： 作为磁盘数据的缓存。</li>
<li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li>
<li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br>
本文总结互联网技术体系中尤为重要的缓存技术。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p>
<p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p>
<ul>
<li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li>
<li>虚拟主存： 作为磁盘数据的缓存。</li>
<li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li>
<li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br>
本文总结互联网技术体系中尤为重要的缓存技术。</li>
</ul>
<h2> 基本思想</h2>
<ul>
<li>缓存是以空间换时间，提升查询性能。缓存遵循“近水楼台先得月”法则：邻近 CPU 优先，邻近用户优先（CDN）。</li>
<li>缓存依据：访问局部性原理。时间局部性 - 某个存储器位置在短时间内被再次访问；空间局部性 -<br>
若某个存储器位置被访问，则邻近存储器位置也很可能会被访问。重复引用相同变量的程序具有良好的时间局部性。步长为 1<br>
的引用模式的程序具有良好的空间局部性。一个典型例子是数组求和。求和变量体现了时间局部性，数组访问体现了空间局部性。可以用缓存命中率来衡量局部性。</li>
<li>顺序引用模式：顺序地每隔 k 个元素地访问一个连续向量中的每个元素，称为步长为 k 的顺序引用模式 。 k 越大，空间局部性越差。步长为<br>
1 的顺序引用模式是局部性原理的重要应用之一。高效访问顺序与存储结构设计及存储细节是紧密关联的。数组和列表是连续存储结构，因此顺序引用模式很吃香。</li>
<li>存储器层次结构：对于每个 k, 位于第 k 层的更快更小的存储设备作为位于第 k+1 层的更慢更大的存储设备的缓存。数据总是以块为传送单元，在第<br>
k 层和第 k+1 层之间进行复制的。层次结构中，相邻的两层的块大小是一样的；不同层次的块大小可以不同。越靠近慢而大的存储层次，块大小越大。</li>
</ul>
<h2> 缓存问题</h2>
<p>缓存问题主要包括缓存结构设计、缓存一致性分析、缓存策略（热身/替换/清理）、缓存保护（击穿/雪崩/穿透）。<br>
一致性问题涉及准确性；缓存策略涉及性能（缓存命中率及主存占用）；而缓存保护涉及稳定性（在大并发请求下且缓存未能命中时保护原始数据源不被压倒）。</p>
<h4> 缓存结构设计</h4>
<p>缓存数据结构主要包括记录型和哈希型。记录型的缓存，是一个连续存储阵列，可简化为多维数组；哈希型的缓存，是基于哈希表。 CPU<br>
高速缓存是基于记录型的，因为硬件上不宜做复杂的运算；应用缓存通常是基于哈希型的，比如 Redis 缓存。</p>
<h4> CPU高速缓存</h4>
<p>CPU 高速缓存可使用 (S, E, B, m) 来表示组织结构。m 位存储器具有 2^m 个存储器地址，其对应的高速缓存组织划分为 S = 2^s 个组，每组<br>
E 个缓存行，每个缓存行包括一个有效位、t 个标记位、B = 2^b 个字节，缓存大小 C = S * E * B。 其中 s<br>
是组索引，标识缓存块在哪个组里；t = m-s-b 标识缓存块在缓存组的哪个缓存行里；b 是字节在缓存行里的偏移量。[s,t,b]<br>
标识了缓存字节在缓存结构里的位置。发生缓存替换时，替换的是某个组里的某个缓存行。</p>
<p>E = 1 时，DMC Directed-Map Cache ；1 &lt; E &lt; C/B 时，SAC Set Associative Cache ；E = C/B 时 Full Associative Cache FAC。 DMC<br>
每组只有一个缓存行，在组中查找缓存行没有开销，但容易发生组的冲突不命中； SAC 在组中查找缓存行有一定开销，但可以减少组的冲突不命中概率；<br>
FAC 只有一个组，在定位组时无开销，替换缓存行时有更大的选择，但在查找缓存行时开销比较大。在硬件层，搜索和匹配标记位是昂贵的操作，因此<br>
FAC 一般应用在搜索和匹配操作代价不高的地方，比如虚拟主存或应用缓存。</p>
<p>高速缓存定位字的步骤是：首先从 m 中拿到 s 位组索引，找到缓存行所在的组；再根据 t 位标记位找到匹配的组内的缓存行；最后，根据 b<br>
位偏移量找到字在缓存块中的位置。如果有效位未置位，则可能是过期缓存；如果 t 位标记位无法匹配所有的组，则是缓存未命中。</p>
<figure><figcaption>img.png</figcaption></figure>
<p>CPU 写主存时可采用两种方式：直写和回写。直写会在更新缓存是直接写入缓存，而回写在更新缓存时只是标记缓存块的缓存状态，只有在替换缓存块时才会写回主存。这就导致了<br>
CPU 缓存与主存的一致性问题。这个问题是通过 MESI 协议来解决的。</p>
<h4> MESI协议</h4>
<p>MESI 协议是 SMP 体系结构的 CPU 缓存一致性协议，涉及读写时多个 CPU 高速缓存如何与主存保持一致<br>
。主要设计思想包括：缓存条目状态的状态转换自动机、写缓冲器、总线事务定义及缓存控制、操作异步化队列、操作屏障。</p>
<h4> 一致性概念</h4>
<p>多处理器存储系统是一致的，如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（将所有进程的读写操作排成一个全序），此序列与执行结果一致，并且在此序列中：</p>
<ul>
<li>任何特定进程发出的操作，所表现出的序和该进程向存储系统发出他们的序相同；</li>
<li>每个读操作返回的值是对相应单元按串行顺序写入的最后一个值。</li>
</ul>
<h4> 一致性前提</h4>
<ul>
<li>系统总线上的所有事务对所有处理器的高速缓存控制器可见，且以相同顺序可见。</li>
<li>为响应存储的所有必要事务都出现在总线上，且缓存控制器采取适当的措施。</li>
<li>当高速缓存监听到与之相关的写操作事务时，要么使缓存块拷贝作废，要么更新它。处理器随后的访问，要么缓存不命中而加载新的值，要么直接看到新的值。</li>
</ul>
<h4> CPU宏观结构</h4>
<p>CPU 宏观结构主要包括：CPU Core, Store Buffer , CPU Cache , System BUS 。 CPU Cache 和 Store Buffer 是 CPU 专有的，System<br>
BUS 是共享的消息通道。 CPU Cache 是一个缓存条目的阵列（多维数组），每个缓存条目有 tag, data, flag 三个值，tag 表示主存地址，flag<br>
表示缓存条目的状态。flag 定义了如下值：</p>
<ul>
<li>Modified(M)：已修改状态。某个处理器缓存副本拥有已修改的值, 主存里的是过期的；</li>
<li>Exclusive(E)：干净独占状态。仅有该处理器缓存副本与主存一致且主存状态是最新的，独占控制权，缓存能够写操作并转移到 M<br>
状态，却不产生总线事务;</li>
<li>Shared(S)：至少两个处理器缓存副本与主存一致，主存有最新的值，其他处理器可能有最新的或者过期的值;</li>
<li>Invalid(I)：初始状态，缓存无效状态。</li>
</ul>
<p>缓存条目状态简称为 CES。CES 的状态转换图可以定位为一个有限状态自动机。理解 CES 的有限状态转换机是关键。如下图所示，A/B 表示当观察<br>
A 事件时，将产生一个 B 总线事务。Flush’ 表示清除相应的存储块，前提是使用了缓存到缓存的共享，且清除是由提供数据的缓存。BusRd(<br>
S) 表示由共享信号 S 生成的总线读事务。缓存控制器通过共享信号 S 在地址阶段确定是否有其它缓存拥有同样的缓存拷贝。如果一个缓存确定自己拥有同样的存储块拷贝，就会发出<br>
S 信号。</p>
<p>MESI 协议定义了一些总线事务（总线读事务、总线排它读事务、总线写事务、回写事务）。结合 CES 状态转换图、总线事务及 CPU<br>
缓存读写控制来实现一致性。</p>
<h4> 缓存读</h4>
<p>读是指拿到变量的最新值并读取到 CPU 寄存器。假设处理器 P1 和 P2 均拥有变量 x 的副本。如果 P1 发现 x 的 CES 为 M/E/S，则直接获取副本<br>
x 的值。若 P1 发现变量 x 的 CES 为 I，则遵循如下步骤：</p>
<ul>
<li>STEP1 -- 发送 BUS Read 事务；</li>
<li>STEP2 -- P2 拥有变量 x 的最新副本（ CES 为 M），嗅探到 x Read 事务，就会将 x 的最新副本写入主存，构造 Read Response 发送到<br>
BUS 上，并将 CES 更新为 S ；如果有多个处理器缓存都拥有变量 x 的最新副本，则通过某种策略来选择从某个高速缓存来提供新值还是直接由主存来提供新值。</li>
<li>STEP3 -- P1 嗅探到到 x Read Response ，将 CES 更新为 S，写入相应的缓存块。<br>
注意：任何一个处理器在嗅探到缓存块的 BUS Read 事务，且相应缓存块为 M 状态时，都会执行 STEP2 操作。</li>
</ul>
<h4> 缓存写</h4>
<p>写是指将变量 x 的最新值写到缓存块。对一个处于 E 或 I 状态的缓存块的写操作，将其置为 M<br>
状态之前，所有其他处理器缓存拷贝都必须通过一个排它读总线事务将自己的缓存作废。如果缓存状态是 M/E ，则不发送总线事务；遵循如下步骤：</p>
<ul>
<li>STEP1：P1 发送总线排它读事务；</li>
<li>STEP2：其他处理器嗅探到总线排它读事务，更新 CES 为 I，再发送 Invalidate Acknowledge ；后续读会产生一次缓存不命中，从而通过一次总线读事务读取最新值。</li>
<li>STEP3：P1 收到所有 Invalidate Acknowledge ，将 CES 更新为 E，获得数据控制权。然后写入缓存行，将 CES 更新为 M。CPU<br>
写需要等待其他处理器都发送 Invalidate Acknowledge 消息，此时会有写等待问题。</li>
</ul>
<h4> 缓存替换</h4>
<p>当一个缓存块被替换时：</p>
<ul>
<li>如果缓存块处于 S 或 I, 则逻辑上直接更新为 I; 如果缓存块处于 M 状态，则从 M 到 I 的状态转换会触发一次回写事务，将缓存块的状态写入主存。</li>
</ul>
<h4> 写等待问题</h4>
<p>写缓冲器（Store Buffer）、无效化队列（Invalidate Queue）。CPU 会直接先写 Store Buffer ，再同步缓存。其他处理器则会将消息存入<br>
Invalidate Queue 就发送 Invalidate Acknowledge ，异步去更新 CES 。 写缓冲器和无效化队列将 CPU<br>
缓存副本更新变成异步处理。读则采用存储转发，先查询写缓冲器，再查询高速缓存。相当于写缓冲器又加了一层缓存。写缓存异步化又会带来一致性问题。</p>
<h4> 主存屏障</h4>
<p>Store Barrier 和 Load Barrier 。Store Barrier 将 Store Buffer 的数据写入缓存； Load Barrier 根据 Invalidate Queue<br>
的主存地址，将相应的 CES 更新为 I。</p>
<h2> 缓存读写一致性</h2>
<p>要正确使用缓存，必然要保证缓存并发读写的一致性。缓存读写一致性需要保证：</p>
<ul>
<li>源数据与缓存的同一数据达成一致性（或者达成不一致时延可接受的最终一致性）。</li>
<li>以源数据的数据为准。<br>
可以采用 [ xC, xDB, yC, yDB ] 操作序列分析读写一致性问题，x,y 是读、更新、删除，C 表示缓存，DB 表示数据库（源数据）。</li>
</ul>
<p>首先框定讨论范围：两个线程 A, B，一个变量 x ，数据源 DB 和 缓存 C ，其中 C 从 DB 中获取，需要与 DB 保持一致， A,B 有读写操作，读为<br>
RD， 写可以进一步分为更新值 UP 和删除值操作 DE，读写时序不确定。</p>
<p>缓存读模式是确定的：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读 DB。这点无异议。如果 A, B<br>
并发读，均直接从 C 中获取当前值即可。如果 C 中没有值，那么 A, B 可能都会从 DB 获取。在大并发的情形下，会有缓存击穿/穿透的问题。缓存击穿和穿透的问题在后面讨论。</p>
<p>当两个线程处于并发读-并发写，或者并发写-并发写的时候，可以有两种方案：加锁和不加锁。</p>
<ul>
<li>对更新 DB 和更新 C 进行加分布式锁，使之原子化。加锁会更简单，但吞吐量会比较低；</li>
<li>对更新 DB 和 更新 C 不加锁，保证合理的执行顺序，使之达到最终一致性（业务可接受一定的不一致时延）。<br>
以下主要讨论不加锁的方案。分情形讨论：</li>
</ul>
<h4> A写-B读</h4>
<p>先指明期望结果：</p>
<ul>
<li>
<p>如果 B 在 A 写之前读，那么 B 读到的是写之前的值，直接从 C 中获取即可。没问题。</p>
</li>
<li>
<p>如果 B 在 A 写之后读，那么 B 读到的应该是写之后的值。<br>
那么 A 该如何写，才能保证 B 读到最新的值？</p>
</li>
<li>
<p>A 先更新 C，再写 DB。会有什么问题 ？ 如果 A 先更新了 C ，然后更新 DB 失败了，那么 C 与 DB 就不一致了。DB 里是旧值。不符合一致性保证。当然，读<br>
C 会读到新值。可以有一种思路，就是缓存作为读写的前置环节，负责缓存与 DB 的最终一致性。这种方案也是可以接受的。这是 Write<br>
Behind Caching Pattern 模式。</p>
</li>
<li>
<p>A 先删除 C， 再写 DB。会有什么问题？ 如果操作时序是 [ A 删除 C， B 读 C，A 更新 DB ]， 那么在 A 更新 DB 之前，B 读 C 未命中，从<br>
DB 读到旧值，而 A 更新 DB， DB 与 C 的值不一致。不符合一致性保证。</p>
</li>
<li>
<p>A 先写 DB ，再更新 C。会有什么问题？ 1. 更新缓存可能是代价昂贵的操作，频繁更新缓存会导致吞吐量降低；在更新 C<br>
之前读到的是旧值，如果更新操作比较耗时，那么 DB 和 C 的不一致时延会比较大，会影响业务。</p>
</li>
<li>
<p>A 先写 DB ，再删除 C。 会有什么问题？ 避免了更新代价高的问题，在删除 C 之前读到的是旧值，在删除 C<br>
之后读到新值。由于删除缓存往往代价很小，不一致时延通常可接受。这是 Cache Aside Pattern 模式。</p>
</li>
</ul>
<h4> A写-B写</h4>
<ul>
<li>期望结果：无论 A 先写还是 B 先写，最终写入的 DB 和 C 的值应当一致。</li>
<li>A 先更新 C，再写 DB。 会有什么问题？如果操作时序是 [ A 写 C x， B 写 C y， B 写 DB y， A 写 DB x]，会导致 C 是 y , DB 是 x<br>
，DB 与 C 中的数据不一致。</li>
<li>A 先写 DB， 再更新 C。会有什么问题？[ A 写 DB x， B 写 DB y， B 写 C y， A 写 C x]，会导致 C 是 x , DB 是 y ，DB 与 C 中的数据不一致。<br>
从上述分析可知：1. 更新缓存操作可能是一个代价昂贵的操作，会导致 DB 与 C 达到最终一致性的不一致时延较长，对业务有影响； 2.<br>
在并发写-写模式下，DB 和 C 的数据会不一致，从而读到不一致的数据。因此，一般不采用更新缓存的方式，而是直接删除缓存。</li>
</ul>
<p>常见的缓存读写模式有 Cache Aside Pattern 和 Write Behind Caching Pattern 。</p>
<ul>
<li>Cache Aside Pattern：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读<br>
DB。读更写删。读模式基本是固定的；写入数据时，先更新 DB ，再删除缓存。可以采集 DB binlog 异步删除缓存。如果是主从<br>
DB，则必须采集最后一个从库 binlog （最终一致性）。</li>
<li>Write Behind Caching Pattern --- 写入时只更新缓存，异步去更新 DB 。牺牲短暂的一致性来获得高吞吐量。</li>
</ul>
<h2> 缓存热身</h2>
<p>空缓存会直接导致不命中，从而影响第一次读的性能。如果大并发访问空缓存（类似缓存雪崩），很容易导致大量并发请求直接打到 DB 上，使得<br>
DB 压力陡增。</p>
<p>缓存热身即是预先把一些数据加载到缓存，提升第一次访问的性能，同时防止第一次访问面临大并发时会将后台打出问题。比如在应用启动后，可以将一些<br>
TOPN 商品异步加载到缓存（不能影响应用启动）；商家做活动前，把一些活动商品和活动信息数据加载到缓存（可配置化）；把一些极少变动的静态数据加载到缓存。加载缓存可以使用应用通知机制，比如实现<br>
ApplicationListener 的<br>
onApplicationEvent 方法。</p>
<h2> 缓存替换策略</h2>
<p>缓存总有未命中的情况：</p>
<ul>
<li>空不命中：总是不会命中，亦称冷缓存。避免冷缓存的方法是进行“缓存热身”。将 k+1 层的缓存块放到第 k<br>
层的策略称为放置策略。通常采用取模的方式: j = i Mod N ，即：将第 k+1 层的第 i 个块对 N 取模后，放到第 k 层的第 i 个块里。</li>
<li>冲突不命中：比如按取模的放置策略，有可能在缓存未满的情况下，总是对第 k 层的同一个块进行替换。比如 j mod 4 ，当 j=0,4,8,12<br>
时，总是会放在到第 0 块上。缓存抖动是一种特殊的冲突不命中，指高速缓存反复加载或驱逐相同的高速缓存块/组/行。</li>
<li>容量不命中：缓存容量满了。</li>
</ul>
<p>缓存替换策略是指当缓存未命中，且缓存容量已满时，判断要替换哪个块的缓存数据。原则上，应该淘汰：1. 只访问过一次的数据； 2.<br>
相比其他数据更少访问的； 3. 在一段时间内没有再访问的。</p>
<p>缓存替换策略主要有 FIFO, LRU, LFU。</p>
<ul>
<li>FIFO ： 最先进入缓存的首先被淘汰。队列实现。或者使用双向链表，新进入元素添加到链表尾，丢弃链表头的元素。FIFO适合丢弃那些只有一次访问的数据。</li>
<li>LRU ：最近最少使用淘汰。使用链表实现，若缓存命中，则将节点移至首部，淘汰尾部节点。 LRU 适合热点数据访问。LRU<br>
无法识别哪些缓存是最多被访问的。偶发性、周期性的批量操作可能导致缓存被大量替换，造成缓存污染，使得 LRU 的效率大幅下降。实际采用<br>
LRU-K 算法，将缓存分为两级，数据在较短时间被访问 K 次以上，则进入二级缓存。两级都采用 LRU 策略。</li>
<li>LFU ： 最少次数使用淘汰。引用计数 + 优先级队列（堆）。</li>
</ul>
<h2> 缓存清理策略</h2>
<p>当缓存对应的原始数据更新后，缓存里的数据就与原始数据不一致了，即缓存失效了。这时候需要及时清理缓存，避免读到过期数据以及过期数据占用过大的内存。缓存清理策略是指什么时候清理过期或失效缓存。</p>
<ul>
<li>TTL： 设置过期时间。 TTL 一般以数据变化频繁度为依据来设置。不同业务数据的过期时间不一样。</li>
<li>写时失效： 写失效、写更新。写失效 - 标记缓存数据已过期，读时清理或替换；写更新 - 在更新数据时就替换缓存项。</li>
<li>读时失效：写时只标注失效信息，读时判断是否失效并加载最新数据。如果有大量缓存对象要更新，可以采用读时失效将写更新成本分摊到每一个读上。缓存对象时，同时存储相应的版本号或时间戳。需要展示数据时，通过对比版本号来判断是否缓存已失效。</li>
</ul>
<h2> 缓存击穿/雪崩/穿透</h2>
<ul>
<li>缓存击穿【重点】。 热点问题。大并发集中对热点 key 进行访问，当这个 key<br>
在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。基本方案：多级缓存（不同失效时间）+<br>
热点散列 + 热点识别、熔断降级、互斥锁、不过期+异步更新。</li>
<li>缓存雪崩。 大量 key 同时失效，导致大量请求打到 DB，造成巨大 DB 压力和系统不稳定。基本方案：过期时间+随机化。</li>
<li>缓存穿透。大量不存在的 key 的非法访问请求，同样会使得大量请求打到 DB。使用布隆过滤器过滤大量非法请求。还有一种方法是空值缓存，失效时间设置小一些，应对短时间内无效重复<br>
key 的大量查询。</li>
<li>缓存命中统计、缓存监控。</li>
</ul>
<h2> 缓存实现</h2>
<p>以本地缓存为例，来分析缓存实现。本地缓存通常在单机共享范围内：某个进程内的被多次访问的主存数据；单机范围内的多进程共享的主存数据。要实现缓存功能，通常需要考虑如下因素：</p>
<ul>
<li>
<p>缓存的规格指定，会影响缓存的创建和性能。</p>
</li>
<li>
<p>缓存的值的计算和迟加载。</p>
</li>
<li>
<p>缓存策略的配置。</p>
</li>
<li>
<p>缓存对并发的支持。</p>
</li>
<li>
<p>缓存更新的通知与监听。</p>
</li>
<li>
<p>缓存的监控与统计。<br>
Guava.Cache 是本地缓存的一个实现。核心类是 CacheBuilderSpec (规格指定)、CacheBuilder (根据缓存规格创建缓存)、LocalCache (<br>
缓存功能的核心实现类)。 LocalCache 的底层是一个哈希表，支持并发访问，实现了 ConcurrentMap 接口。实现要点如下：</p>
</li>
<li>
<p>缓存数据的读写与 ConcurrentHashMap 类似。</p>
</li>
<li>
<p>有两个用双向链表实现的优先级队列： writeQueue 和 accessQueue ，用来控制缓存何时过期。writeQueue 按写时间排序，accessQueue<br>
按访问时间排序。在每次写入或更新或清理操作的时候，会执行清理操作，根据这两个队列来判断缓存数据是否过期，如果过期则从缓存数据哈希表中移除。</p>
</li>
</ul>
<h2> 高效应用缓存</h2>
<h4> 缓存友好的代码</h4>
<p>针对连续型存储的高速缓存，编写对缓存友好的代码。比如聚焦核心函数的循环；减少循环内部不命中的数量；对局部变量的反复引用；步长为<br>
1 的顺序引用模式；多重循环中的循环变量的次序。</p>
<p>换言之，每个循环都会在高速缓存上产生很大的影响，进而影响程序运行性能。对于上层应用可能感知不明显，但是对于底层却很重要。</p>
<figure><figcaption>img_1.png</figcaption></figure>
<h4> 服务实例缓存</h4>
<p>凡是将数据进行变换后存储起来，在将来的计算中重复多次使用，都是缓存的实现形式。最常见的就是服务单例缓存。比如在类<br>
DefaultSingletonBeanRegistry 中的 singletonObjects 单例缓存，可用来解决循环引用依赖问题 ：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 缓存与动态规划</h4>
<p>动态规划法通常会复用到子问题的解，因此可以使用缓存来存储子问题的解。一个简单的例子如下，计算阶乘：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> HTTP缓存</h4>
<ul>
<li>HTTP 缓存原理：HTTP 缓存服务器上会保存原始服务器上的文档副本。当 HTTP 请求到来时，若缓存命中，则直接返回文档副本，而无需再与原始服务器通信。</li>
<li>缓存再验证：HTTP<br>
缓存服务器会发送特殊请求（无需取整个文档对象），与原始服务器的文档比较，检测缓存副本是否过期；如果检测到未过期 ,<br>
缓存服务器会获取到新的首部和新的过期时间，更新缓存首部，再将文档副本标识为“未过期”的；若检测到缓存副本过期了，则从原始服务器取最新的文档并生成新的文档副本。</li>
<li>缓存命中统计：缓存请求命中占比；缓存字节命中占比。</li>
<li>缓存层次结构：可以使用多级缓存。可分为私有缓存和公有缓存，私有缓存通常是用户浏览器缓存，存放在本地磁盘上；公有缓存则是 HTTP<br>
缓存服务器（可能是代理服务器、CDN服务器）。私有缓存可以作为第一级缓存，公有缓存作为第二级或第 N 级缓存。</li>
<li>缓存过期标识：可使用 Cache-Control 和 Expires 来标明缓存副本何时过期，是否需要做缓存再验证。缓存服务器从 HTTP<br>
请求中解析出首部，并与缓存里的 Cache-Control ( max-age 从生成文档到过期的生存时间，秒为单位 ) 和 Expires (<br>
过期绝对日期 ) 配置进行比较，如果已经超过指定期限，则要做缓存再验证操作。由于时钟不准确，一般不推荐使用 Expires 首部。</li>
<li>条件再验证：将缓存再验证与获取新的缓存副本合为一个请求。主要有 If-Modified-Since 和 If-None-Match。</li>
<li>If-Modified-Since 首部：将 If-Modified-Since 首部添加的 GET 请求中，告知原始服务器，仅当其内容已经修改，才返回修改后的文档对象。若原始服务器文档没有修改，则返回<br>
304 Not Modified ；若文档已修改，返回完整的对象；若文档已删除，则返回 404 Not Found ，缓存服务器会将副本删除。If-Modified-Since<br>
可以与 Last-Modified 配合使用。</li>
<li>If-None-Match:Etags: 当日期不足以区分文档的过期时，可以使用 If-None-Match:Etags 。实际上类似一个版本号。</li>
<li>Cache-Control: no-store （禁止缓存复制响应）, no-cache ( 在进行再验证之前不可提供缓存副本 ), must-revalidation (<br>
必须进行缓存再验证), max-age ( 在指定秒数之后进行缓存再验证 ), max-stale, min-fresh</li>
<li>试探性过期算法：如果 If-Modified-Since 和 If-None-Match<br>
都没有提供，则根据最近修改时间，智能推断需要缓存的时间。若最近修改时间很久，则认为文档稳定，可以缓存更长时间，若最近修改时间很近，则认为文档易变，将缓存时间改下一点。有点自适应缓存的意味。LM-Factor<br>
是一种常用的试探性过期算法。<code>$time_since_modify = max(0, $server_Date - $server_Last_Modified); $server_freshness_limit = int($time_since_modify * $lm_factor);</code></li>
<li>设置缓存的工具： Apache web 服务器 ( mod_headers, mod_expires )，META HTTP-EQUIV 标签。</li>
</ul>
<h4> 分布式缓存</h4>
<p>一般采用 Redis 来做多机共享的分布式缓存。一些有效做法：</p>
<ul>
<li>命名空间规范和隔离，部署隔离，避免业务相互影响和耦合。</li>
<li>采用批量获取缓存数据的方法提升查询性能，减少网络传输开销。</li>
<li>尽量使用 O(1) 的命令，避免使用遍历性命令。</li>
<li>单个 key 的 value 不超过 10KB, list, set, map 等不超过 1000 个元素。</li>
<li>设置合理的定期删除/惰性删除/缓存替换策略。</li>
<li>测量缓存的命中率及性能提升情况；若数据不理想，则要仔细分析原因并优化。</li>
<li>监控大对象缓存。</li>
</ul>
<p>要避免的坑：</p>
<ul>
<li>内存占用和缓存同步要特别注意，避免内存占用大、同步慢影响了业务。</li>
<li>缓存主要用来提升性能，不要当做持久化存储使用，避免数据丢失的风险。</li>
<li>避免滥用和浪费缓存资源。主存缓存是比较昂贵的资源。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2023-11-08T08:55:23.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:定时器</title>
    <id>https://ujava.cn/principle/nine.html</id>
    <link href="https://ujava.cn/principle/nine.html"/>
    <updated>2023-11-02T11:10:38.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>从单机角度，定时任务实现主要有以下 3 种方案：</p>
<ul>
<li>while + sleep 组合</li>
<li>最小堆实现</li>
<li>时间轮实现</li>
</ul>
<h2> while+sleep组合</h2>
<p>while+sleep 方案，简单的说，就是定义一个线程，然后 while 循环，通过 sleep 延迟时间来达到周期性调度任务。</p>
<p>简单示例如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> timeInterval <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"每隔5秒执行一次"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>timeInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>从单机角度，定时任务实现主要有以下 3 种方案：</p>
<ul>
<li>while + sleep 组合</li>
<li>最小堆实现</li>
<li>时间轮实现</li>
</ul>
<h2> while+sleep组合</h2>
<p>while+sleep 方案，简单的说，就是定义一个线程，然后 while 循环，通过 sleep 延迟时间来达到周期性调度任务。</p>
<p>简单示例如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现上非常简单，如果我们想在创建一个每隔3秒钟执行一次任务，怎么办呢？</p>
<p>同样的，也可以在创建一个线程，然后间隔性的调度方法；但是如果创建了大量这种类型的线程，这个时候会发现大量的定时任务线程在调度切换时性能消耗会非常大，而且整体效率低！</p>
<p>面对这种在情况，大佬们也想到了，于是想出了用一个线程将所有的定时任务存起来，事先排好序，按照一定的规则来调度，这样不就可以极大的减少每个线程的切换消耗吗？</p>
<p>正因此，JDK 中的 Timer 定时器由此诞生了！</p>
<h2> 三、最小堆实现</h2>
<p>所谓最小堆方案，正如我们上面所说的，每当有新任务加入的时候，会把需要即将要执行的任务排到前面，同时会有一个线程不断的轮询判断，如果当前某个任务已经到达执行时间点，就会立即执行，具体实现代表就是 JDK 中的 Timer 定时器！</p>
<h4> 3.1、Timer</h4>
<p>首先我们来一个简单的 Timer 定时器例子</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现上，好像跟我们上面介绍的 while+sleep 方案差不多，同样也是起一个TimerTask线程任务，只不过共用一个Timer调度器。</p>
<p>下面我们一起来打开源码看看里面到底有些啥！</p>
<p>进入Timer.schedule()方法</p>
<blockquote>
<p>从方法上可以看出，这里主要做参数验证，其中TimerTask是一个线程任务，delay表示延迟多久执行（单位毫秒），period表示多久执行一次（单位毫秒）</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>接着看sched()方法</li>
</ul>
<blockquote>
<p>这步操作中，可以很清晰的看到，在同步代码块里，会将task对象加入到queue</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>我们继续来看queue对象</li>
</ul>
<blockquote>
<p>任务会将入到TaskQueue队列中，同时在Timer初始化阶段会将TaskQueue作为参数传入到TimerThread线程中，并且起到线程</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>而TaskQueue其实是一个最小堆的数据实体类，源码如下</li>
</ul>
<blockquote>
<p>每当有新元素加入的时候，会对原来的数组进行重排，会将即将要执行的任务排在数组的前面</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>最后我们来看看TimerThread<br>
TimerThread其实就是一个任务调度线程，首先从TaskQueue里面获取排在最前面的任务，然后判断它是否到达任务执行时间点，如果已到达，就会立刻执行任务</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结这个利用最小堆实现的方案，相比 while + sleep 方案，多了一个线程来管理所有的任务，优点就是减少了线程之间的性能开销，提升了执行效率；但是同样也带来的了一些缺点，整体的新加任务写入效率变成了 O(log(n))。</p>
<p>同时，细心的发现，这个方案还有以下几个缺点：</p>
<ul>
<li>串行阻塞：调度线程只有一个，长任务会阻塞短任务的执行，例如，A任务跑了一分钟，B任务至少需要等1分钟才能跑</li>
<li>容错能力差：没有异常处理能力，一旦一个任务执行故障，后续任务都无法执行</li>
</ul>
<h4> 3.2、ScheduledThreadPoolExecutor</h4>
<p>鉴于 Timer 的上述缺陷，从 Java 5 开始，推出了基于线程池设计的 ScheduledThreadPoolExecutor 。</p>
<figure><figcaption>img_9.png</figcaption></figure>
<p>其设计思想是，每一个被调度的任务都会由线程池来管理执行，因此任务是并发执行的，相互之间不会受到干扰。需要注意的是，只有当任务的执行时间到来时，ScheduledThreadPoolExecutor 才会真正启动一个线程，其余时间 ScheduledThreadPoolExecutor 都是在轮询任务的状态。</p>
<p>简单的使用示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的，我们首先打开源码，看看里面到底做了啥</p>
<ul>
<li>进入scheduleAtFixedRate()方法</li>
</ul>
<blockquote>
<p>首先是校验基本参数，然后将任务作为封装到ScheduledFutureTask线程中，ScheduledFutureTask继承自RunnableScheduledFuture，并作为参数调用delayedExecute()方法进行预处理</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>继续看delayedExecute()方法</li>
</ul>
<blockquote>
<p>可以很清晰的看到，当线程池没有关闭的时候，会通过super.getQueue().add(task)操作，将任务加入到队列，同时调用ensurePrestart()方法做预处理</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中super.getQueue()得到的是一个自定义的new DelayedWorkQueue()阻塞队列，数据存储方面也是一个最小堆结构的队列，这一点在初始化new ScheduledThreadPoolExecutor()的时候，可以看出！</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>打开源码可以看到，DelayedWorkQueue其实是ScheduledThreadPoolExecutor中的一个静态内部类，在添加的时候，会将任务加入到RunnableScheduledFuture数组中，同时线程池中的Woker线程会通过调用任务队列中的take()方法获取对应的ScheduledFutureTask线程任务，接着执行对应的任务线程</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>回到我们最开始说到的ScheduledFutureTask任务线程类，最终执行任务的其实就是它</p>
<blockquote>
<p>ScheduledFutureTask任务线程，才是真正执行任务的线程类，只是绕了一圈，做了很多包装，run()方法就是真正执行定时任务的方法。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.3、小结</h2>
<p>ScheduledExecutorService 相比 Timer 定时器，完美的解决上面说到的 Timer 存在的两个缺点！</p>
<p>在单体应用里面，使用 ScheduledExecutorService 可以解决大部分需要使用定时任务的业务需求！</p>
<p>但是这是否意味着它是最佳的解决方案呢？</p>
<p>我们发现线程池中 ScheduledExecutorService 的排序容器跟 Timer 一样，都是采用最小堆的存储结构，新任务加入排序效率是O(log(n))，执行取任务是O(1)。</p>
<p>这里的写入排序效率其实是有空间可提升的，有可能优化到O(1)的时间复杂度，也就是我们下面要介绍的时间轮实现！</p>
<h2> 四、时间轮实现</h2>
<p>所谓时间轮（RingBuffer）实现，从数据结构上看，简单的说就是循环队列，从名称上看可能感觉很抽象。</p>
<p>它其实就是一个环形的数组，如图所示，假设我们创建了一个长度为 8 的时间轮。</p>
<p><br>
插入、取值流程：</p>
<ul>
<li>
<p>1.当我们需要新建一个 1s 延时任务的时候，则只需要将它放到下标为 1 的那个槽中，2、3、...、7也同样如此。</p>
</li>
<li>
<p>2.而如果是新建一个 10s 的延时任务，则需要将它放到下标为 2 的槽中，但同时需要记录它所对应的圈数，也就是 1 圈，不然就和 2 秒的延时消息重复了</p>
</li>
<li>
<p>3.当创建一个 21s 的延时任务时，它所在的位置就在下标为 5 的槽中，同样的需要为他加上圈数为 2，依次类推...<br>
因此，总结起来有两个核心的变量：</p>
</li>
<li>
<p>数组下标：表示某个任务延迟时间，从数据操作上对执行时间点进行取余</p>
</li>
<li>
<p>圈数：表示需要循环圈数<br>
通过这张图可以更直观的理解！</p>
</li>
</ul>
<p><br>
当我们需要取出延时任务时，只需要每秒往下移动这个指针，然后取出该位置的所有任务即可，取任务的时间消耗为O(1)。</p>
<p>当我们需要插入任务式，也只需要计算出对应的下表和圈数，即可将任务插入到对应的数组位置中，插入任务的时间消耗为O(1)。</p>
<p>如果时间轮的槽比较少，会导致某一个槽上的任务非常多，那么效率也比较低，这就和 HashMap 的 hash 冲突是一样的，因此在设计槽的时候不能太大也不能太小。</p>
<h2> 4.1、代码实现</h2>
<p>首先创建一个RingBufferWheel时间轮定时任务管理器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，编写一个客户端，测试客户端</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要周期性执行任务，可以在任务执行完成之后，再重新加入到时间轮中。</p>
<h2> 4.2、应用</h2>
<p>时间轮的应用还是非常广的，例如在 Disruptor 项目中就运用到了 RingBuffer，还有Netty中的HashedWheelTimer工具原理也差不多等等，有兴趣的同学，可以阅读一下官方对应的源码！</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-02T11:10:38.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:代码可复用性问题兼谈团队协作</title>
    <id>https://ujava.cn/principle/eight.html</id>
    <link href="https://ujava.cn/principle/eight.html"/>
    <updated>2023-11-02T10:08:47.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>工作了一两年的软件工程师，大概没有不听说过“可复用性”的概念。可复用性可以从两个视角来体现：</p>
<ul>
<li>创造者： 可以提供通用的服务和成果，别人直接在其工作的基础上构建自己的成果。整个过程不断叠加构建出恢弘的建筑。</li>
<li>使用者： 可以直接使用已有的服务和成果，无需重复创作，达到高效。</li>
</ul>
<p>理性学科，比如数学、物理是遵循可复用性的生动体现和典范。因为大家都知道，不充分了解别人的成果，根本无法进行自己的工作，而且即使耗费大量时间和精力作出成果，如果与已有成果重复了，基本等于零。遗憾的是，工程领域里，却充斥着大量的重复创作和浪费，且很少有人察觉这种浪费。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>工作了一两年的软件工程师，大概没有不听说过“可复用性”的概念。可复用性可以从两个视角来体现：</p>
<ul>
<li>创造者： 可以提供通用的服务和成果，别人直接在其工作的基础上构建自己的成果。整个过程不断叠加构建出恢弘的建筑。</li>
<li>使用者： 可以直接使用已有的服务和成果，无需重复创作，达到高效。</li>
</ul>
<p>理性学科，比如数学、物理是遵循可复用性的生动体现和典范。因为大家都知道，不充分了解别人的成果，根本无法进行自己的工作，而且即使耗费大量时间和精力作出成果，如果与已有成果重复了，基本等于零。遗憾的是，工程领域里，却充斥着大量的重复创作和浪费，且很少有人察觉这种浪费。</p>
<p>当你想要一个小功能点的时候，从以下场景上想想：</p>
<ul>
<li>你发现有一个函数能够实现想要的功能，一行代码调用就能搞定，心欢喜焉；</li>
<li>你发现有一个函数能够实现想要的功能，做一个简单的适配就能搞定，心戚戚然焉；</li>
<li>你发现有一个函数能够实现想要的功能，但参数不是想要的，得改改参数，抽离出一个子函数出来；</li>
<li>你发现有一个函数能够实现大部分功能，还需要做点修改才能适配自己的需要，于是在里面添加了一个新的逻辑；</li>
<li>你发现有一个函数能够实现，但这个函数做了太多事情，需要从中抽离出自己想要的部分；</li>
<li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有点麻烦，但还可以接受；</li>
<li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有点麻烦，但不困难；</li>
<li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分有些困难，而且容易导致问题，需要大量回归测试。</li>
<li>你发现有一个函数能够实现，但这个函数做了太多事情，而且依赖比较复杂，从中抽离出自己想要的部分很困难，不如重写一个。</li>
<li>你没有发现现有函数能够实现。自己重写一个。<br>
以上场景，可复用性逐渐降低，而重复创造和浪费的概率逐渐增大。软件行业发展到至今，几乎不太存在最后一种情况，但很尴尬的是，据我所接手的业务工程，处于第一种情形的极少，处于前三种情形的也不多，大多数都落在了后六种情形上。</li>
</ul>
<h2> 是什么阻碍了做到代码可复用性</h2>
<p>现在，让我们来看看，是什么阻碍了代码可复用性。</p>
<h4> 违反单一事实原则</h4>
<p>违反单一事实原则，可以说是阻碍可复用性的首要“罪魁祸首”。“单一事实”原则，可以说是中高级工程师耳熟能详的一个基本代码原则。遗憾的是，真正做到这一点的并不多。这体现了一个有趣的事实：越是简单的事情，越做不好。起床、吃饭都是极为简单而且基本没有“技术含量”的事情，人体天然能够支持的能力，然而，真正坚持专注做到做好的有多少人呢？</p>
<p>举出违反单一事实的例子非常容易，在代码工程里俯拾即是。随便拿一个函数，看看它干了什么事，想想它能够在什么情形下被复用。大多数已有的函数和类，不是把技术逻辑和业务逻辑混杂在一起，就是恨不得一下子把所有事情都做了，瀑布一泻而下，疑是银河落九天。</p>
<p>先不要谈什么设计原则或设计模式，先把“单一事实”原则切实做好。如何做好单一事实原则？</p>
<ul>
<li>想清楚这个函数做什么事，遏制想做两件及以上事情的冲动； 克制！大家都知道产品设计要克制，过于臃肿的产品谁都不想用，但过于臃肿的代码谁又想去碰呢？</li>
<li>如果需要做两件事，拆分出两个可以组合的函数；</li>
<li>如果想要新增流程或逻辑，新增函数，然后在其中调用；</li>
<li>仔细定义参数，参数最小化；</li>
<li>每个方法不超过 50 行（除去空行）；</li>
<li>拆分，新增函数，成为无意识的习惯！<br>
惟有养成这样严格遵循“单一事实”原则的习惯，才能在项目工期很赶的时候，依然能够写出质量不错的不臃肿的代码。</li>
</ul>
<h4> 参数过多</h4>
<p>由于特别容易做很多事情的倾向性，因此参数往往过多。当你发现一个函数里的参数过多，这个函数很可能违反了单一事实职责。或者是，在某种程度上，逻辑拆分存在问题。</p>
<p>参数过多的直接后果就是：</p>
<ul>
<li>如果你想复用这个函数，就得推敲和构造这么多参数；</li>
<li>你需要猜测每个参数的含义，与自己所需功能的相关性，过滤掉不需要设置的参数；</li>
<li>当传空的参数时，往往是一种不佳的代码体现； 而当传很多空的参数时，很难看；</li>
<li>理工科的人，需要一点艺术的熏陶。只懂逻辑不懂表达和设计的人只能写出难看的代码，虽然或许很管用。</li>
</ul>
<h4> 领域逻辑没有抽离</h4>
<p>说起来，软件工程领域落到实处的进步真是很慢（大概对于任何涉及多人协作的事情都是如此）。从最初的一团面条，到后来有人提出了<br>
Controller-Service-Dao 分层理念，大家才开始有了分层抽离的概念，知道把参数校验写在 Controller 里，把应用业务逻辑写在 Service<br>
里，把数据访问相关写在 Dao 层里。</p>
<p>不过，这样还远远不够。Controller 和 Dao 倒是清晰了，但 Service 还是很臃肿。为什么？因为程序员习惯于把各种业务逻辑、技术逻辑、业务流程都扔到<br>
Service 里，哪怕有些技术逻辑是一个可以复用的工具类，哪怕有些业务逻辑是可以复用的领域知识。</p>
<p>DDD 是一种设计理念，但看上去掌握这种设计理念的人不多。实际上，我觉得 DDD 对代码编写更有启发。把 DDD<br>
相关的领域知识，放到富血模型里或者领域层里。比如，对于一个安全业务工程，安全检测相关的逻辑，就很适合单独抽离到领域层里；比如，K8S<br>
相关的资产，就适合把 Pod, Controller, Container Image 这些基础概念的关联关系抽离出来，放在领域层里，应用业务层只需要使用领域层的方法即可，而无需充斥在各种<br>
Service 里。</p>
<p>DDD 的核心思想就是：领域知识是一个业务工程里的核心资产。领域层是需要持续沉淀而稳定提升的。如果系统要做大的技术重构，按道理领域层应该是不用动的，动的是技术层。对于复杂业务工程来说，一定要有领域层。</p>
<h4> 代码拆分太粗放</h4>
<p>代码放置太粗放，也是导致代码可复用性差的一个因素。只按照 Controller - Service - Dao 来拆分代码，自然很多代码重担就落在了<br>
Service 里，因为 Controller 和 Dao 的职责比较固定，逻辑也偏少。</p>
<p>更加细致的代码拆分是怎样的？</p>
<p>以下是业务层的：</p>
<ul>
<li>Controller : 仅作为请求转发层和参数适配层；</li>
<li>Service: 参数校验与业务逻辑流程。很多人把参数校验放在 Controller 层，我觉得不妥。因为如果要复用 Service 的方法，参数校验也是要复用的；</li>
<li>Dao: 数据库访问层。可以作为数据库中间件的适配和隔离；</li>
<li>Model: 与数据库直接交互的数据对象，目前基本是贫血模型，只有属性；</li>
<li>DTO： 数据传输对象，目前基本是贫血模式，实际上应该是富写模型，放在领域层；</li>
<li>Helper: 业务辅助类，领域层。可复用的业务逻辑判断、业务流程需要放在这里；</li>
<li>Exception: 异常处理和错误管理相关；</li>
<li>Constants: 业务枚举，业务常量；</li>
<li>Config: 系统配置相关；</li>
<li>Loader：系统初始化相关；</li>
<li>Cache: 业务缓存；</li>
<li>Components: 业务组件；</li>
<li>Receiver：数据消费接收器；</li>
<li>Handler: 事件处理类；</li>
<li>Context: 长流程里的上下文语境类；</li>
<li>Strategy： 同一业务目标的不同业务处理逻辑的策略类。用于分离不同业务的差异很好用；</li>
<li>Plugin: 业务插件，用于扩展；</li>
<li>Listener: 监听器；</li>
<li>Scheduler: 定时任务调度；</li>
<li>Job: 业务任务；</li>
<li>Producer: 任务生产者；</li>
<li>Consumer: 任务消费者；</li>
<li>Switch: 开关控制；</li>
<li>Wrapper: 包装器；</li>
<li>Adapter: 适配器。</li>
</ul>
<p>以下是技术层的：</p>
<ul>
<li>Concurrent: 线程池、分布式锁等。</li>
<li>Util: 工具类，可复用的技术逻辑。</li>
<li>Interceptor: 拦截器，用于流程修改和业务逻辑转换。</li>
<li>[De]Serializer: JSON 自定义序列化与反序列化</li>
</ul>
<p>总之，当仔细去思考业务中的大大小小的关注点，把关注点的粒度最小化，就能发现更多放置代码的层次和地方。这并非是固定不变的。</p>
<p>还有一个问题： 整体工程结构是按技术结构拆分还是按业务功能拆分？</p>
<ul>
<li>按照技术结构拆分，然后在每个技术子包里有业务拆分的子包。益处是，技术结构清晰；弊端是，业务实现则需要从各个子包里寻找拼凑出来，对业务不友好；</li>
<li>按照业务功能拆分。每个业务下有自己的技术子包。益处是，很容易定位一个业务的所有相关实现；弊端是，公共的部分容易散落在具体业务里，且子包数量会膨胀。<br>
目前基本是按照技术结构拆分，符合研发同学对设计理念的认知。也许有一天，会开始按照业务拆分。</li>
</ul>
<h4> 不合理的访问级别</h4>
<p>由于倾向于把很多业务逻辑都放在 Service 里，自然很多潜在可复用的方法就会被设置成 private， 外部无法复用。当要复用时：</p>
<ul>
<li>可复用的方法放在很大的 Service 和 Flow 里，即使可以复用，但依赖这么大一个类或不恰当的层次，心有戚戚然焉；适合被依赖的最好是一个具有单一职责的小组件类；</li>
<li>可复用的方法是 private，需要改成 public ，增加相应接口定义。<br>
这种情形，通常就是代码放置的层次和地方不合理。应该抽离到一个单独的小组件类里，设置为 public 方法。</li>
</ul>
<h4> 惰性</h4>
<p>惰性是人固有的生理特性，也是阻碍人持续进步的最大的因素。或许是老天爷开的善意玩笑吧。毕竟，生物的基本设定就是，能够躺着就不想坐着。</p>
<p>简单的事情如果做不好，基本可以归为惰性的缘故。就像单一事实原则，到底是这个原则实际上很难做到，还是因为惰性而不愿意主动多走一步？</p>
<h4> 缺乏可复用代码的意识和技巧</h4>
<p>没有思考过，没有学习过，没有被教授过，没有练习过，写可复用代码。这样，写出的代码就是“山大王代码”。这是我的地盘，只能我动，其它人只能远观不能亵玩焉。</p>
<p>缺乏写可复用代码的意识，如果异常处理做得比较周密，还能成为一个合格的程序员，起码能保证基本的工程质量。但别指望他能做一些对团队整体有益的事情。</p>
<p>如果有写可复用代码的意识，而缺乏写可复用代码的方法和技巧，那么就从做好单一事实职责开始吧！</p>
<p>如果要有更强的写可复用代码的意识，每写一段代码，都会思考，哪些部分是通用的，哪些部分是差异的，然后努力将公共的或者差异的部分提取出来，这样，才能逐渐提升写可复用代码的意识和技能。</p>
<h4> 缺乏分离与解耦差异的技能</h4>
<p>如果要达到更高层次的可复用性，则需要掌握分离和解耦差异的技能。善于把业务逻辑和流程进行分离和解耦，让每个组件自行负责各自的工作，让关注点清晰可辨，让交互自然流畅。</p>
<p>为什么代码难以复用？正常情况下，一段代码总会有一些特定差异的逻辑和一些通用的逻辑，而且差异的逻辑往往潜藏在代码的任任意位置。由于缺乏将特定差异的逻辑提取出来的技巧，就会导致代码很正常但就是难以复用。</p>
<p>函数式编程和设计模式，能够很大程度上提升代码的可复用性。函数式编程，用函数来表达差异；设计模式，确定了明确的组件职责，让交互更加自然，容易扩展。</p>
<h4> 细小关注点没有抽离</h4>
<p>软件系统中充满着各种大大小小的关注点，技术关注点，业务关注点。哪怕是一段中文乱码处理，也是一个小关注点。细小的关注点没有抽离出来，就会导致高度的重复。我是见证了职业生涯所遇到的最高程度的代码重复艺术。</p>
<h4> 瀑布流代码的益处与弊处</h4>
<p>当然，不能只是负向批评。难以复用的瀑布流代码也是有其益处的：读起来贴合程序员的自然思维。好的瀑布流代码读起来很流畅。遗憾的是，<br>
很少瀑布流代码能够做到这一点。大多数瀑布流代码都会面临后期的各种修改，逐渐因为各种分支语句导致水滴四溅，甚为壮观唯美。</p>
<p>与其益处相比，其弊处更多：</p>
<ul>
<li>如果代码只写一次，那么很清爽；</li>
<li>如果代码会被改动多次，每次改动都会影响整个流程，每次都需要大范围的回归测试；</li>
<li>多个人一起改动，容易产生冲突，在代码合并和解决冲突上会耗费很多时间和精力。</li>
</ul>
<h2> 团队协作</h2>
<p>为什么代码可复用性如此重要？</p>
<p>软件开发是团队协作的生动体现。然而，<br>
团队协作并不是“你在我代码上修修补补，我在你代码上修修补补”这种简单低级的协作。何为真正的团队协作？每个成员都充分分享和贡献自己的创作和成果，同时每个人都能从团队其它成员的创作和成果上获得新知、经验和工具，高效促进自己的工作。</p>
<p>代码可复用性体现了团队协作的高效程度。</p>
<ul>
<li>每个成员都致力于创造可复用的构件；</li>
<li>每个成员都把别人写的代码当成自己写的代码，改进和测试所使用到构件；</li>
<li>大多数时候，并不需要从头写起，而是可以直接在某个基础上开始工作；</li>
<li>如果要修改，则是新增而不是在里面修改，即符合开闭原则。<br>
代码可复用性差，那么研发效率不会高到哪里去。</li>
</ul>
<p>如何衡量代码可复用性？ 非常简单。当你开始构建一个功能时：</p>
<ul>
<li>过程：想要一个基础功能时，是否有现成可用；是否专注于构建自己所关注的业务自身相关的逻辑，而不是还要构建技术逻辑，构建一些基础业务逻辑，处理复杂的技术和业务交互；</li>
<li>结果： 最终写了多少行代码。代码越多，说明现有工程的可复用性越差（前提是你已经通读了整个工程的代码，知道没有可复用的，或者复用起来很麻烦）。</li>
</ul>
<h2> 小结</h2>
<p>软件开发是团队协作的生动体现，代码可复用性体现了团队协作的高效程度。本文探讨了阻碍代码可复用性的因素，以及如何做到代码可复用性的方法和技巧，希望对大家有所益处。</p>
<p>PS: 细想一下，做到代码可复用性还真的不那么容易：</p>
<ul>
<li>严格遵循单一事实原则。保持克制。避免一个方法做两件事；</li>
<li>最小化输入参数；</li>
<li>领域层逻辑抽离；</li>
<li>识别小业务组件并抽离，设置合理的访问级别；</li>
<li>细致放置代码到合适的地方，合理的包拆分；</li>
<li>细致识别小关注点并分离出来；</li>
<li>思考通用与差异的部分；</li>
<li>练习分离和解耦差异的技巧：函数式编程与设计模式。</li>
</ul>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-02T10:08:47.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:如何表达和维护大型逻辑</title>
    <id>https://ujava.cn/principle/seven.html</id>
    <link href="https://ujava.cn/principle/seven.html"/>
    <updated>2023-11-02T09:59:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>让我们暂时撇开平台、框架、技术、设计模式、对象思想、敏捷开发论等。 追问程序本质。</p>
<p>从本质上来说， 程序就是一系列有序执行的指令集合。 如何将指令集合组织成可靠可用可信赖的软件（美妙的逻辑之塔）， 这是个问题。</p>
<blockquote>
<p>程序 = 逻辑 + 控制。 what to do + when to do.</p>
</blockquote>
<p>从编程角度来说， 开发者应对的就是逻辑， 逻辑的表达、组织和维护。 逻辑是事物自此及彼的合乎事物发展规律的序列。指令是逻辑的具体实现形式。</p>
<p>逻辑成立的先决条件是合乎事物发展规律。 程序只能处理数值， 却传入了字符串， 就只能报错而无法继续； 当处理海量数据时， 若内存不足，<br>
就会导致程序崩溃； 若程序存在内存泄露， 随着时间的推移而耗尽内存， 也会导致程序崩溃。 多个线程同时修改一个共享变量， 若不加控制，<br>
就会因为不同线程执行修改变量的时序的不确定导致该变量最终值的不确定。 这些就是程序执行的发展规律。 要编写程序， 必定要先通悉这些规律。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>让我们暂时撇开平台、框架、技术、设计模式、对象思想、敏捷开发论等。 追问程序本质。</p>
<p>从本质上来说， 程序就是一系列有序执行的指令集合。 如何将指令集合组织成可靠可用可信赖的软件（美妙的逻辑之塔）， 这是个问题。</p>
<blockquote>
<p>程序 = 逻辑 + 控制。 what to do + when to do.</p>
</blockquote>
<p>从编程角度来说， 开发者应对的就是逻辑， 逻辑的表达、组织和维护。 逻辑是事物自此及彼的合乎事物发展规律的序列。指令是逻辑的具体实现形式。</p>
<p>逻辑成立的先决条件是合乎事物发展规律。 程序只能处理数值， 却传入了字符串， 就只能报错而无法继续； 当处理海量数据时， 若内存不足，<br>
就会导致程序崩溃； 若程序存在内存泄露， 随着时间的推移而耗尽内存， 也会导致程序崩溃。 多个线程同时修改一个共享变量， 若不加控制，<br>
就会因为不同线程执行修改变量的时序的不确定导致该变量最终值的不确定。 这些就是程序执行的发展规律。 要编写程序， 必定要先通悉这些规律。</p>
<p>规律的表现形式是：如果条件 (C1, C2, ...,Cn)是产生结果(R1, R2, ... , Rn) 的充分必要条件， 那么当 C1, C2, ..., Cn 任一不满足条件时，<br>
都不可能产生结果 (R1, R2, ..., Rn) ； 反之， 若结果 (R1, R2, ..., Rn) 没有出现， 则必定是 C1, C2, ..., Cn 某一条件不满足导致。<br>
错误和异常即是 C1, C2, ..., Cn 任一不满足条件的表现。规律的性质是必然的， 不存在可能之说；<br>
只存在人们探索的是否足够精确。编程开发首先应当懂得程序执行的规律， 然后才是实际的开发； 否则就会被程序的结果折腾得死去活来。</p>
<p>在通悉程序执行规律之后， 程序需要解决如下问题：</p>
<ol>
<li>要表达什么逻辑；</li>
<li>如何表达该逻辑；</li>
<li>如何维护该逻辑。</li>
</ol>
<p>软件的复杂性表现在如何表达和维护交互复杂的大型逻辑上。</p>
<p>暂时先回到软件的起点， 回顾一下这一切是如何发生的。 最初，人们使用物理的或逻辑的二进制机器指令来编写程序， 尝试着表达思想中的逻辑，<br>
控制硬件计算和显示， 发现是可行的； 接着， 创造了助记符 —— 汇编语言， 比机器指令更容易记忆； 再接着， 创造了编译器、解释器和计算机高级语言，<br>
能够以人类友好自然的方式去编写程序，在牺牲少量性能的情况下， 获得比汇编语言更强且更容易使用的语句控制能力：条件、分支、循环，<br>
以及更多的语言特性： 指针、结构体、联合体、枚举等， 还创造了函数， 能够将一系列指令封装成一个独立的逻辑块反复使用；</p>
<p>逐渐地，产生了面向过程的编程方法； 后来， 人们发现将数据和逻辑封装成对象， 更接近于现实世界， 且更容易维护大型软件，又出现了面向对象的编程语言和编程方法学，<br>
增加了新的语言特性： 继承、 多态、 模板、 异常错误。 为了不必重复开发常见工具和任务， 人们创造和封装了容器及算法、SDK， 垃圾回收器，<br>
甚至是并发库； 为了让计算机语言更有力更有效率地表达各种现实逻辑， 消解软件开发中遇到的冲突， 还在语言中支持了元编程、 高阶函数，<br>
闭包 等有用特性。</p>
<p>为了更高效率地开发可靠的软件和应用程序， 人们逐渐构建了代码编辑器、 IDE、 代码版本管理工具、公共库、应用框架、<br>
可复用组件、系统规范、网络协议、 语言标准等， 针对遇到的问题提出了许多不同的思路和解决方案， 并总结提炼成特定的技术和设计模式，<br>
还探讨和形成了不少软件开发过程， 用来保证最终发布的软件质量。 尽管编写的这些软件和工具还存在不少 BUG ，但是它们都“奇迹般地存活”，<br>
并共同构建了今天蔚为壮观的软件世界。九层之台，起于累土， 这话用在软件开发上， 真是太贴切了。</p>
<p>此外， 软件还经历了“单机程序 =&gt; 多机程序 =&gt; 分布式程序” 的过程 ，多机联网程序因为多个子系统的交互变得更加复杂。 这里不再赘述。</p>
<p>但请注意， 无论软件发展到多么复杂的程度， 总有一群人， 在试图从程序的本质中探究软件开发的基本问题，<br>
他们试图论证和确保程序的正确性、提炼软件的基本属性并进行衡量；程序的正确性本质是逻辑学来保证的。 没有逻辑学， 程序根本就无法立足，<br>
更不可能有今天的大规模应用。</p>
<ul>
<li>软件开发工具让我们更有效率地创造逻辑、 远离语法错误的困扰；</li>
<li>公共库将常用的通用逻辑块封装成可反复使用的组件， 避免不必要的重复劳动；</li>
<li>设计模式体现的是如何可扩展地解决常见的逻辑交互问题；</li>
<li>应用框架解决的是应用的通用逻辑流的控制的问题，让开发者更多地聚焦具体业务逻辑上；</li>
<li>开发技术是在具体的应用情境下按照既定总体思路去探究具体问题解决的方法。</li>
</ul>
<p>我们要解决的是更通用的问题： 如何以更不易出错的方式去表达和维护大型逻辑 ？<br>
本文尝试从逻辑表达和维护的角度， 探索中大型软件的构建和维护。</p>
<p>表达和维护大型逻辑的终极诀窍就是：将大型逻辑切分为容易消化的一小块一小块， “不急不忙地吃掉”。<br>
在该方法的实践中， 可以充分利用现有的开发工具、公共库、设计模式、应用框架、开发技术。</p>
<h4> 1.独立无交互的大型逻辑或接口实现</h4>
<p>独立无交互的逻辑通常体现为公共库， 可以解决常用或公共的日常任务， 对其他逻辑无任何依赖和交互， 即自足逻辑。<br>
应对独立无交互的大型逻辑的首要方法是分解为若干的容易实现、测试和复用的小块逻辑， 编写和严格测试。<br>
其次是运用成熟的编程模式去表达逻辑， 尽可能复用经过严格测试的可靠的库。<br>
独立无交互的大型逻辑通过合理的逻辑块切分、严格的单元测试可以获得充分的测试和可靠度。</p>
<h4> 2.独立无交互的耗时长的逻辑或接口实现</h4>
<p>快速响应的问题： “用户要求等待时间短” 与 “请求处理耗时长” 之间的矛盾导致的。</p>
<p>解决独立无交互的耗时长的逻辑依然可以采用切分逻辑块、严格的单元测试的做法使之更容易处理；<br>
此外， 有两种设计思路可以考虑： 并发 与 异步。</p>
<p>并发思路是将切分的相互独立的逻辑块分配给不同的控制线程中执行， 从而降低请求处理时长； 并发方案获得的性能提升取决于串行操作在总操作中的时间占比。</p>
<p>异步思路是“先响应， 后处理， 终通知” 的"先奏后斩"方案。将一步分离成了三步， 为了让用户首先获得初步的承诺， 再去履行承诺。</p>
<p>这样做能让用户暂时地放心， 却增加了新的问题： 消息中间件组件的开发与部署、异步消息发送与接收、编程模型的变化和适应。如果整个过程运作良好，<br>
将会达到很好的体验，容易为用户接受。如果其中一步发生差错， 就会导致各种问题， 比如数据不一致， 消息堆积、<br>
请求无法被处理。最终用户等待时间并没有降低， 反而使体验更加糟糕。 当然， 如果成功率为 95%， 也是“可以接受”的，<br>
这样用户可能会怪自己“运气不太好”， 而不会过多怪责系统的不完善。毕竟没有任何事情能够做到完美的地步。</p>
<p>并发与异步方案的调试难度和排查问题都比同步方案增加不少。 每一种新的设计方案都会有其优点， 同时也会有其缺点。 权衡优缺点，<br>
择善而从之 。值得注意的是， 并发方案是针对服务端实际处理请求逻辑而言， 而异步方案是针对请求处理之前是否立即回复的方式。<br>
并发与顺序、 异步与同步两两组合， 可得到四种方式：</p>
<ul>
<li>顺序同步：最初的编程模型；优点是简单、安全、 容易维护和调试；缺点是性能较低， 响应时间和吞吐量都不高； 若请求处理时长非常短，<br>
采用顺序同步的方案佳；</li>
<li>并发同步：改进的编程模型； 优点是通过并发提高服务端的处理速度和吞吐量， 但若请求处理耗时较长， 响应时间仍然不高， 影响客户端体验；<br>
若通过并发方案处理请求的时长非常短， 或客户端体验要求不高， 可以采用并发同步的方案；</li>
<li>顺序异步：改善客户端体验的编程模型； 优点是提高了响应时间和客户端体验， 由于其逻辑处理仍然采用顺序方式，请求处理时长并未有改善，<br>
因此吞吐量并没有改善。 是一种较好的折衷方案； 若请求处理耗时较长， 影响客户端体验， 且请求处理逻辑复杂， 采用并发方案容易出错或难以并发，<br>
可采用顺序异步方案；</li>
<li>并发异步： 同时改善客户端体验和服务端处理速度； 优点是提高了响应时间、客户端体验和处理速度、吞吐量。 缺点是容易出错， 且不易调试；<br>
若客户端对响应体验要求较高， 请求处理逻辑简单（比如简单的数据拉取和汇总）， 采用并发方式可有效提升处理速度， 可以采用并发异步方案；</li>
</ul>
<h4> 3.逻辑块之间的交互耦合与可扩展性</h4>
<p>软件的复杂性真正体现在逻辑块的持续长久的交互耦合和可扩展上。这是软件开发与维护中极具挑战性的部分。<br>
逻辑块之间的交互耦合通常体现在三种情境：</p>
<ul>
<li>a. 操作顺序的依赖。 比如资源更新操作必须在指定资源已经创建的情况下进行。</li>
<li>b. 对共享有限资源的并发申请。比如打印机只有两台， 却有多个应用程序连接上去请求打印文档；</li>
<li>c. 对共享可变状态的并发访问。比如两个操作同时要更新数据库中的同一条记录；</li>
</ul>
<p>三种情境的复杂性均是由并发引起的。假设所有操作都是串行进行的， 逻辑块的交互无非是“你方唱罢我登场”的次序控制，<br>
而资源对单个请求通常是足够的；一旦采用了并发方案， 就难以控制逻辑块的执行次序和资源分配的具体情况了， 容易导致某资源对单个请求不足的情况，<br>
从而阻塞多个请求的处理甚至死锁。并发提升了应用的性能， 却增加了出错的风险和几率。并发控制是大型逻辑交互的本质性难点。并发控制的难点在于时序的合理控制和有效资源的合理分配。</p>
<p>对于 a 情境， 通常采用添加前置条件来求解，在操作之前校验相关资源是否满足、实体状态是否合理， 实体之间的关联是否正确；若前置条件不满足，<br>
则直接返回错误提示， 或者暂时挂起以备后续继续执行；</p>
<p>对于 b 情境， 需要创建一个可靠适用的资源分配算法 和资源分配模块 ， 应用程序不再“自行”去拉取资源， 而是向资源分配模块申请资源，<br>
由资源分配模块根据实际申请的整体情况及申请条件来决定如何分配资源；</p>
<p>对于 c 情境， 需要进行安全的互斥访问， 谨慎地控制。</p>
<p>逻辑块之间的交互耦合应该交给交互解耦模块去完成， 而不是在自己的接口里实现。 也就是说， 只有交互解耦模块知道所有接口之间的交互，<br>
而接口只做自己知道的事情就可以了。否则， 接口 A 与接口 B 必须知道彼此究竟做了什么， 才能正确地做自己的事情。 假设 接口 A 和接口<br>
B 都修改某个资源的状态。 接口 A 在做某项操作执行必须执行 IF (ConditionX) do something ； DoMyOwnThing ；接口 B 也要根据 A<br>
的逻辑相应地执行 if (ConditionY) do anotherThing；DoMyOwnThing.而程序员在维护和修改接口 A 的逻辑时， 不一定知道接口 B<br>
的逻辑与之相关， 于是修改不可避免地破坏了接口 B 的逻辑。 耦合的接口数量越多， 或者耦合接口之间的耦合资源越多，<br>
对后期维护和扩展将是一个难以应对的噩梦。</p>
<p>对于逻辑块之间的交互解耦， 或者通俗地说， 模块解耦，您有怎样的高见， 敬请提出！</p>
<h4> 4.实现逻辑时的容错考虑</h4>
<p>程序中的逻辑主要是三类：</p>
<ol>
<li>获取值： 从数据库、网络或对象中获取值。 如果数据库或网络访问足够稳定的话， 可以看成是简单的获取值， 数据库访问和网络访问对获取值是透明的；</li>
<li>检测值： 检测值是否合法， 通常是前置条件校验、 中间状态校验和后置结果校验， 根据检测结果执行“获取值”或“设置值”的逻辑；</li>
<li>设置（拷贝）值： 设置数据库、对象中的值； 或者发送数据和指令给网络。如果数据库或网络访问足够稳定的话， 可以看成是简单的设置值，<br>
数据库访问和网络访问对设置值是透明的；</li>
</ol>
<p>这三类逻辑可以称为逻辑元。 具体业务逻辑就是基于物理的或逻辑的资源限制， 将逻辑元的组合封装成逻辑块， 有效控制逻辑块的时序交互和资源分配。<br>
时序控制不合理和资源缺乏导致错误和异常。两个程序同时更新一个共享变量， 如果时序不控制， 就会导致错误的结果； 网络通信错误，<br>
是因为网络带宽资源是有限的。</p>
<p>如何应对错误和异常 ？请参考 《如何使错误日志更加方便排查问题》，仔细总结了软件错误产生的各种原因及如何预防和定位。 当然，<br>
还有一些复杂的软件错误， 比如事务与并发， 限于开发经验尚浅， 还给不出有效的方案和措施， 需要根据实践学习和深化。这是当错误和异常已经发生时，<br>
该如何更好地定位和解决问题。</p>
<p>预防错误的方法就是进行防御性编程， 进行容错考虑。 多思考： 如果这一步发生错误， 会导致什么问题？ 该如何做才能预防这个错误？<br>
如果难以预防，该如何描述， 才能在出现错误时更好地定位出这样的错误？ 在出现错误时， 如何才能恢复到正常合法的状态 ？如果无法程序自动恢复，<br>
怎样做才能让手工处理更加简单 ？</p>
<p>要健壮地表达和维护大型逻辑， 首先系统整体架构必须足够稳固可靠， 在开发和维护过程中持续加固。假设一栋建筑整体设计有问题， 那么，<br>
无论里面的房间装饰得多么漂亮优雅， 都会随着建筑的坍塌而消亡。 这需要深入去探究所使用的应用框架， 挖出可能的不可靠风险，<br>
并加以预防和控制。</p>
<p>在已确定的设计方案和业务逻辑的情况下，如何编写BUG更少的代码：</p>
<blockquote>
<p>简明扼要的注释 + 契约式/防御式编程 + 更短小的逻辑块 + 复用公共库 + 严格测试</p>
</blockquote>
<ol>
<li>在方法前面编写简明扼要的注释： 方法用途， 接收参数，返回值， 注意事项， 作者， 时间。</li>
<li>契约式编程： 在方法入口处编写前置条件校验，在方法出口处编写后置结果校验 ；</li>
<li>防御式编程： 编程时严格校验参数和前置条件； 仔细考虑各种错误与异常的定位和处理；</li>
<li>编写和保持短小逻辑块， 易于为人的脑容量一次性处理， 容易测试；</li>
<li>复用经过严格测试的可靠的公共库； 如果库没有经过很好的测试，但有很好的用处， 帮助其添加测试；</li>
<li>对所编写的代码， 如果不是逻辑元， 都要进行严格测试。</li>
</ol>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-02T09:59:55.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:架构模式</title>
    <id>https://ujava.cn/principle/six.html</id>
    <link href="https://ujava.cn/principle/six.html"/>
    <updated>2023-11-02T08:59:01.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>架构模式是系统组件及组件交互的模式，决定了处理数据和领域对象的全局控制结构。组件化是使用架构模式的前提。</p>
<h2> 模式清单</h2>
<h4> 分层模式</h4>
<p>分层模式：<br>
将应用划分为多个层次，定义各层的接口、任务抽象及消息格式，以及各层之间的通信与交互。业务系统通常会划分为业务逻辑层、服务层、领域层、数据层。网络栈协议是分层模式的典型应用。应用分层模式时，为确保系统可维护性，通常第j+1层只依赖于第j层的接口和服务；在性能场合下，可能会有跨层依赖的情况；应对特殊场景的设计中，会有“第j层的服务依赖于第j+1层的服务”的反向依赖关系。可参阅《面向模式的软件架构：模式系统》第2.2.1节。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>架构模式是系统组件及组件交互的模式，决定了处理数据和领域对象的全局控制结构。组件化是使用架构模式的前提。</p>
<h2> 模式清单</h2>
<h4> 分层模式</h4>
<p>分层模式：<br>
将应用划分为多个层次，定义各层的接口、任务抽象及消息格式，以及各层之间的通信与交互。业务系统通常会划分为业务逻辑层、服务层、领域层、数据层。网络栈协议是分层模式的典型应用。应用分层模式时，为确保系统可维护性，通常第j+1层只依赖于第j层的接口和服务；在性能场合下，可能会有跨层依赖的情况；应对特殊场景的设计中，会有“第j层的服务依赖于第j+1层的服务”的反向依赖关系。可参阅《面向模式的软件架构：模式系统》第2.2.1节。</p>
<h4> RESTFUL模式</h4>
<p>RESTFul模式：适合资源构建与共享的可伸缩的架构模式，适合于构建API接口。全局规范一致的资源逻辑命名、寻址、返回码定义，关注资源与数据而非行为或服务；无状态的声明式的请求；对客户端隐藏实现细节；通用的数据返回格式(<br>
JSON)，跨语言与平台；使用名词而非动词作为路径名。 可参阅《架构之美》第5章：“Web：面向资源的架构”。</p>
<h4> MVC模式</h4>
<p>MVC模式：“模型-视图-控制”， 经典的WebUI架构模式，控制处理请求从而更新模型和返回视图，模型更新驱动视图更新，视图请求控制处理。经典的JavaMVC框架有<br>
Struts2, SpringMVC, 前端MVC框架有Extjs4.</p>
<h4> 插件模式</h4>
<p>插件模式：设计了可扩展的插件接口及插件交互机制，开发者只要遵循规范编写和调试具体的插件并融入到系统，即可为系统增加新功能和新特性。使用插件模式的系统有<br>
Eclipse, Emacs, Firefox, Chrome 等。</p>
<h4> 订阅-消费模式</h4>
<p>订阅-消费模式：<br>
大型互联网应用中几乎都存在订阅和消费业务表更新或业务消息推送的子系统。订阅-消费模式需要高稳定可用的消息中间件，并仔细评估消息延迟对用户活动造成的影响。新品消息推送、商品消费订阅、发货提醒等，我们正处于一个“消息/通知的订阅-推送-被消费”的移动互联网时代里。</p>
<h4> Pipeline模式</h4>
<p>管道-过滤器-处理器链：一个请求沿着管道连接的处理链，依次由链上的过滤器、拦截器、处理器进行处理并返回。JavaWeb应用的Servlet架构模式是“过滤器-处理器链”的典型应用；UnixShell<br>
则是“管道-过滤器-重定向”结构的典型应用。</p>
<h4> 事件驱动模式</h4>
<p>事件驱动模式： 在系统内定义一系列的组件、事件及监听器，组件发生变化时触发事件，通知相应的监听器处理事件更新组件，进而触发新的事件，如此循环直至手动终止系统或系统崩溃。适用于GUI应用开发。</p>
<h4> Actor模式</h4>
<p>Actor模型：<br>
基于事件驱动的分布式的、异步并发的、可伸缩的、有故障恢复能力的大型消息处理架构。</p>
<h4> 规则-工作流模式</h4>
<p>规则-工作流模式： 将系统分析成一系列的工作流节点以及规则的解析匹配，使用规则引擎来控制和运行，通过添加规则及规则流，实现可扩展性和可配置性。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-02T08:59:01.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:从指令到软件</title>
    <id>https://ujava.cn/principle/five.html</id>
    <link href="https://ujava.cn/principle/five.html"/>
    <updated>2023-11-02T08:51:26.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>软件的构造，本质上就是组件与组合。组件是实现了特定功能的逻辑单元（程序），组合则是将“小组件集成为大组件，将大组件集成为整个应用系统”的联结方式。只要学过编程语言的人，大抵是会构造或大或小的组件的，那么组合结构就决定了程序是如何构成或优雅或拙劣的软件的。本文想探讨下软件是如何组合起来的。</p>
<h2> 路线图</h2>
<figure><figcaption>img_6.png</figcaption></figure>
<h2> 基本构造元素</h2>
<h4> 指令</h4>
<p>计算机的使命是计算和处理数据，而处理数据的最小单位就是指令。指令完成不可细分的原子的计算功能。也可以说，指令就是用于构造软件的原子组件。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>软件的构造，本质上就是组件与组合。组件是实现了特定功能的逻辑单元（程序），组合则是将“小组件集成为大组件，将大组件集成为整个应用系统”的联结方式。只要学过编程语言的人，大抵是会构造或大或小的组件的，那么组合结构就决定了程序是如何构成或优雅或拙劣的软件的。本文想探讨下软件是如何组合起来的。</p>
<h2> 路线图</h2>
<figure><figcaption>img_6.png</figcaption></figure>
<h2> 基本构造元素</h2>
<h4> 指令</h4>
<p>计算机的使命是计算和处理数据，而处理数据的最小单位就是指令。指令完成不可细分的原子的计算功能。也可以说，指令就是用于构造软件的原子组件。</p>
<h4> 控制</h4>
<p>控制是指令的组合与执行顺序，主要有顺序/条件/循环三种。</p>
<p>计算机科学家已经证明：<br>
任何复杂的计算都可以分解为顺序、条件和循环三种基本结构。顺序是先吃饭后睡觉的时序结构；条件是根据某种因素决定下一步做什么，比如根据天气好坏决定出去玩还是宅家里；循环就是将某件事重复做若干次直到某种终止条件，比如某人玩游戏入迷直到被揪耳朵手机被摔。可以通过顺序/条件/循环三种基本结构来组合指令得到能做更多事情的指令序列。</p>
<h4> 算法</h4>
<p>算法是能够完成一件事的指令序列的精确描述。比如一个人回家，先坐公交或地铁抵达火车站，然后检票上车抵达家所在的省份城市的火车站，然后从该城市的火车站坐火车到达家所在的县，最后做公交或出租车抵达家，就是一个算法。算法是通过顺序、条件、循环三种基本结构来构造的。相同的事情可以用不同复杂度的算法来实现，不同的事情需要复杂度不同的算法。算法的设计和实现决定了程序实现和完成任务的效率与优雅。</p>
<h4> 函数</h4>
<p>将指令序列通过算法组织起来，从而能够完成特定功能，并为之命名，就构成了函数。函数是有签名的算法。比如完成一段文字的单词计数。函数可以通过传入的参数来控制其行为，比如单词计数是否需要包含标点符号。传入的参数序列就是函数的签名。有了函数，通过函数的组合，就能构造出实用的程序。</p>
<h2> 组合</h2>
<h4> 函数组合</h4>
<p>函数的基本组合方式有两种：直调和回调。<br>
直调是一个函数直接调用其他函数的能力来实现自己的能力；比如一个文件单词计数函数，可以调用文件读写函数来读取文件内容，这是直调，直调的逻辑是写死的；回调是通过传入的函数来灵活改变自己的能力；比如排序函数，通过调用传入的对象比较函数来实现任意的对象排序策略，则是回调，执行回调的函数是模板函数。<br>
回调衍生出高阶函数。</p>
<h4> 递归</h4>
<p>直调有一种特殊形式： 函数反复调用自身，直到某个终止条件而退出。称之为“递归”。 递归是一种强大而有效的编程技术。</p>
<h4> 高阶函数</h4>
<p>高阶函数是一个函数通过传入的函数来灵活地变换自己的行为，是函数式编程范式的基本思想。函数的功能粒度越小，可复用和可组合的能力程度越强。</p>
<h4> 泛化</h4>
<p>泛化体现了函数和行为能够适配不同的类型和对象的能力。 比如排序功能可以对整数、字符串或任意对象进行排序；遍历功能可以对任意类型的对象列表或映射。</p>
<h2> 面向对象</h2>
<p>程序用于处理数据。将函数组织成流水线，让数据依次经过流水线进行加工处理得到最终结果，这是过程式编程范式。过程式编程范式可以完成很多实用功能，但过程式实现不容易组合成更大的容易理解、维护和修改的软件，不容易与外部系统交互和集成，也很难反映现实的语义，——<br>
过程式展现的是数据结构与算法的视角，而现实中的实体是拥有状态和行为的有机生命体。对于具有大量实体及复杂交互行为的系统，过程式很容易写成缠结在一起的一团面条。</p>
<p>面向对象则是在过程式范式的基础上，提供了一层数据与行为绑定的封装。数据就是事物或实体的各种属性的抽象与聚合，比如学生就是一个实体，而学生的身心的各种指标就是数据，行为则是实体数据的算法。这样，通过对象可以从语义上更自然清晰地描述现实中的实体及其行为，而程序的组织方式变成如何去分配对象的职责，以及如何组合对象的交互。对象的交互通过设计模式可以更加优雅的实现。</p>
<h4> 继承与多态</h4>
<p>继承与多态是对象编程范式中的基本结构，体现了对象之间的普遍性和差异性。</p>
<p>继承是子类从基类直接获取的特征和行为。比如多数哺乳动物都有恒温胎生的行为；绝大多数人都具有相同的五官结构。</p>
<p>多态是子类相同的行为但是表现出不同的特征。 比如人和鸟都会飞，但是飞的实现方式不一样。鸟是靠生物自身机制，人是靠工具。绝大多数人都具备五感能力，但是使用五感的方式又有差异。</p>
<p>适宜地使用继承与多态，可以使对象的职责和组合更加自然清晰，使状态与行为的实现可复用和可扩展，程序的结构更加自然优雅，尽可能地避免难以维护和扩展的条件与分支语句。</p>
<h4> 委托</h4>
<p>一个对象将某种行为委托给另一个对象来完成。比如一些危险的任务，在环境恶劣的地洞里或地球之外的其他星球勘探工作，人将这种无法适应环境工作的任务交给能够适应环境的机器人去完成。老板把任务委托给下属去完成。委托是直调在对象交互中的表现。</p>
<h4> 组件</h4>
<p>组件是能够完成实用功能的封装的具有良好接口的可组合的逻辑单元。类似于俄罗斯方块游戏里的积木。函数、对象都可以看做是组件的实现形式。组件的设计优劣，一方面体现在内部设计实现上是否容易理解和修改以及运行得是否足够高效，一方面体现在其接口设计上是否更容易使用和与其它组件组合。组件的接口就类似插槽，插槽的设计决定了组件如何更好地使用。<br>
软件的构造，就是将功能各异的具有各种接口的组件合理地组织和集成起来，构成一个可视化的容易使用的实体。</p>
<h2> 并发</h2>
<p>既然能够完成一件事，那人们就想完成得更快。要完成得更快，要么投入更强的资源，比如招能力更强的工程师，要么投入更多的资源，比如招更多的工程师。能力更强的工程师总是少数，并且有瓶颈和上限，那么招更多的工程师，更合理滴分配任务就成了更常见的选择。俗话说：三个臭皮匠，顶个诸葛亮， ——<br>
嗯，对于软件人才来说，是很不真确的； 对于机器资源来说，还是合理的。</p>
<p>做一件事的算法，可以顺序，也可以并发。比如烧开水与读书，可以先烧开水，等开水烧好后再读书，这是顺序；<br>
可以在烧开水的同时读书。并发从本质上需要两个实体能够相互独立的行动，从语义上则可能针对某个实体来说。比如烧开水与读书，从语义上说是以人为中心的并发，但本质上是水与人两个实体的相互独立的活动。当然，也有人说并发也可以看成同一个实体在一段时间内能够做多个事情的能力，比如操作系统“看上去像是”可以在同一时间既运行音乐程序也运行文字处理程序和网页浏览程序。这是理解的差别。</p>
<p>并发反映了人希望能够通过投入更多资源获得更高效率的愿望和手段。<br>
比如多核处理器，通过将任务分配到多个处理器运行，通常比只有一个处理器运行更快。当然，这也取决于算法的设计是否可以充分利用多核处理器。糟糕或者不合理的算法可以使得多个处理器运行比一个处理器更慢。可以同时使用多个工作单元相互独立的工作，最后将这些单元的工作组合起来得到最终结果，这个是并行的概念，即增强的并发。</p>
<blockquote>
<p>并发提升了效率，也增加了复杂性。这是必得的命运。</p>
</blockquote>
<h4> 协作</h4>
<p>既然涉及到多个工作单元的工作组合，那就涉及到协作。协作主要包括资源竞争和时序控制。如何控制多个资源访问有限的资源，比如多个人要共用少量的打印机；如何控制时序与进行，比如多个人集合达到某个地点后进行下一项活动。</p>
<p>第一种并发协作方式就是流水线。工作单元A,B,C,D,E,...<br>
依次执行，就像流水线一样。第I道工序与第J道工序是可以并发的。流水线并发方式需要对工序的时间有更精确的控制和安排。生产工艺制作流程，就是属于这种协作方式。</p>
<p>第二种并发协作方式就是每个工作单元都相互独立地工作，互不干扰。每个资源都完成了工作，那么整个工作就结束了。比如并发地下载多个文件，可以把这些文件分发到不同的处理器或进程，每个工作单元处理完成后，整个任务就结束了。</p>
<p>第三种并发协作方式是分而治之，聚而合之。<br>
比如要计算一亿个数的和。可以把这一亿个数分解成多个区间，每个区间使用一个工作单元进行求和处理，最后将所有工作单元的和合并起来（合并的过程还可以继续使用多区间分而合之的算法）。这种协作模式，需要规定一个抵达点，先完成工作到达抵达点的工作单元需要等待后完成工作到达抵达点的工作单元。</p>
<p>如果涉及到多个工作单元同时要访问有限的公共资源，就必须对工作单元访问同一个资源进行加锁和互斥操作。</p>
<h2> 通信</h2>
<p>既然涉及到协作，那么必然涉及到通信。单机上的程序协作需要竞争资源和时序控制；多机的程序通信需要协议。</p>
<h4> 信号</h4>
<p>一种通信方式是信号机制。比如程序与操作系统之间的通信就是信号。不同的信号有不同的含义，操作系统通过给程序发送信号来表达有某种事件发生，而程序则根据信号进行相应的处理，处理完成后发送信号给操作系统。</p>
<h4> 消息</h4>
<p>一种通信方式是消息机制。比如程序与程序之间的通信是消息机制。 消息是信号的高级形式，含有更多的信息内容，程序可以根据消息做出更优的处理。</p>
<h4> 协议</h4>
<p>消息投递和处理需要通过协议指定来完成。<br>
不同工作单元的效率是不一样的。比如单元A给单元B发送消息，如果A的发送速率远大于B的处理速率，那么B就会来不及处理，消息就会堆积甚至丢失；如果A的发送效率远小于B的处理效率，那么B就会一直等待闲置浪费。这时候就需要协议来控制A的发送速率和B的处理速率。此外，如果消息在中途阻塞、丢失等，都需要协议对这些情况指定如何处理。这样才能保证消息顺利滴从A发送到B并被适当滴处理。</p>
<h2> 组合过程</h2>
<p>组合过程： 流程与规则 - 数据与算法 - 对象与交互 - 函数组合</p>
<p>首先，梳理事物运行规律的流程与规则；其次，设计表达流程与规则的数据结构与算法<br>
；接着，运用对象建模技术，将终端获取的数据合理地组织和分配到不同的对象实体中，通过交互的方式表达算法；然后，通过并发与通信手段，将实现不同功能的程序组件集成和连接构成最终的应用系统。</p>
<p>算法通过对象方法的交互来实现。对象方法保持尽可能少的逻辑，主要是提供交互的接口定义，而实现则通过基础工具函数和业务点函数的组合来完成。这就很好地融合了面向对象与函数式编程的优点：对象技术用于声明对象的特征和行为，而函数式编程用于实现对象的行为。</p>
<h2> 算法是核心</h2>
<p>抛去纷扰的APP和技术，就能看到软件的灵魂：算法。算法，同数学、文学、绘画、艺术等，是更纯粹的思维形式，是人的生命中最精髓的部分。人之行踪，社会之变迁，皆此之外延。</p>
<p>无论是原子、函数、对象、组件、程序级别的组合，算法作为主线始终贯穿其中，组合可表达为算法。算法是计算领域的明珠。</p>
<h4> 小结</h4>
<p>本文对软件的组合结构进行了粗浅的探讨，旨在梳理软件的基本组合结构，为构造更大型的软件提供有益的思想基础。</p>
<p>指令是计算的原子单位，通过顺序、条件、循环三种基本结构组合成算法。这是原子级别上的组合结构。</p>
<p>算法可以实现成具有特定功能的指令序列，命名为函数。函数可以通过直调和回调实现更强大的函数和计算能力，可以通过泛化获得对类型的适配能力。这是在函数级别上的组合结构。</p>
<p>将数据和行为绑定在一起形成对象。继承和多态体现了对象特征与行为的普遍性和差异性。对象之间可以通过委托的方式来交互。这是在对象级别上的组合结构。</p>
<p>并发是提升效能的重要手段。并发涉及到算法在多核和多机上的分配和并发控制，涉及到程序与组件的协作与通信。程序与组件之间的信号与消息通过协议进行有效的通信，从而构成大型互联网应用系统。这是在程序与组件级别上的组合结构。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-11-02T08:51:26.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理</title>
    <id>https://ujava.cn/principle/</id>
    <link href="https://ujava.cn/principle/"/>
    <updated>2023-10-31T11:10:45.000Z</updated>
    <summary type="html"><![CDATA[<h2> 设计原理</h2>
]]></summary>
    <content type="html"><![CDATA[<h2> 设计原理</h2>
]]></content>
    <category term="设计原理"/>
    <published>2023-10-31T11:10:45.000Z</published>
  </entry>
  <entry>
    <title type="text">第一性原理:结构化抽象</title>
    <id>https://ujava.cn/principle/first.html</id>
    <link href="https://ujava.cn/principle/first.html"/>
    <updated>2023-11-02T09:02:15.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>软件设计的第一性原理，是结构化抽象。术生于道，技术生于原理。</p>
</blockquote>
<h1> 简介</h1>
<p>所谓的第一性原理，就是无论使用什么方法论，都无法绕过的那最最基础的部分。无论是 DDD 设计，还是面向模式的架构设计，或<br>
微服务架构，均建基于结构化抽象。</p>
<p>何为结构化抽象 ？ 先回答 “何为抽象” 与 “何为结构化” 两个问题。</p>
<p>何为抽象 ？ “<a href="/principle/second.html" target="blank">设计原理:抽象</a>” 一文阐述了什么是抽象及在编程与计算中的意义； “<a href="/principle/third.html" target="blank">设计原理:代码抽象与分层</a>”<br>
则列举了从代码中提炼出来的六类抽象，涵盖了编程开发中常见的实体及处理。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>软件设计的第一性原理，是结构化抽象。术生于道，技术生于原理。</p>
</blockquote>
<h1> 简介</h1>
<p>所谓的第一性原理，就是无论使用什么方法论，都无法绕过的那最最基础的部分。无论是 DDD 设计，还是面向模式的架构设计，或<br>
微服务架构，均建基于结构化抽象。</p>
<p>何为结构化抽象 ？ 先回答 “何为抽象” 与 “何为结构化” 两个问题。</p>
<p>何为抽象 ？ “<a href="/principle/second.html" target="blank">设计原理:抽象</a>” 一文阐述了什么是抽象及在编程与计算中的意义； “<a href="/principle/third.html" target="blank">设计原理:代码抽象与分层</a>”<br>
则列举了从代码中提炼出来的六类抽象，涵盖了编程开发中常见的实体及处理。</p>
<p>何为结构化 ？ 结构，是事物的组成元素及关联和作用。 “<a href="/principle/four.html" target="blank">设计原理:编程概要</a>” 一文阐述了编程中的各种数据结构及控制结构，“<a href="/principle/five.html" target="blank">设计原理:从指令到软件</a>”<br>
则阐述了组合元素的方法与结构。结构化，分为数据结构化和控制结构化。数据结构化指海量数据的组织和存储及需要满足的约束（比如一致性、完整性等）；控制结构化，是指，操作的组织和执行以及需要满足的约束。</p>
<p>软件，本质上是一种可动态而弹性变化的逻辑装置。结构化，即是将逻辑进行抽象、提炼、分离、聚合，构建成更加缜密、动态、弹性的结构流。</p>
<p>逻辑，是思维意识的一种形式。软件设计与开发，是与自己的思维意识进行抗争与和解。</p>
<h2> 理念</h2>
<h4> 设计与开发</h4>
<p>软件设计与开发工作渗透着结构化抽象的思想。譬如：</p>
<ul>
<li>软件建模。是对大量原始数据进行结构化组织，使之更加有序、有意义、可交互。</li>
<li>数据存取。在建立对数据的组织抽象之后，就要进行数据的存取操作。数据是规则的还是不规则的 ？ 数据量有多少及增长速度如何 ？</li>
<li>是否要进行缓存 ？ 选取合适的数据存储组件。数据存储组件是对海量数据存储和访问的结构化抽象。</li>
<li>流程构造。在确定数据存取方案后，需要构建完整的流程。流程可以使用时序图来表示。流程包含前置、操作与契约。前置，是进行操作需要满足的条件；操作则是获取数据或请求某种执行；契约，是在完成操作之后，必须满足的一系列断言。完整流程通常是：“前置-操作-契约”的子流程的有序组合。</li>
<li>编程实现。需要评估潜在变化的部分，将通用的部分与易变化的部分相分离。</li>
</ul>
<h4> 设计模式</h4>
<p>设计模式是对象职责及交互的结构化抽象，是体现结构化抽象思想的基本单元。可参阅：“<a href="/design/" target="blank">设计模式</a>” 。</p>
<p>架构模式是基于设计模式的更高层次的结构化抽象。可参阅：“<a href="/principle/six.html" target="blank">设计原理:架构模式</a>” 。</p>
<p>设计模式和架构模式主要应对软件的业务可扩展性难题。</p>
<h4> 技术机制</h4>
<p>在软件设计中，技术是绕不开的一道槛。技术的作用在于，在指定的场景下，所执行的操作效果必须满足某种约束。技术机制，是将多个相关联的结构化抽象进行聚合后的成品。</p>
<h4> 异步</h4>
<p>比如先快速响应客户端，再进行请求处理。其结构化抽象是，操作相对于主进程的执行耗时与实际执行耗时无关。</p>
<h4> 幂等</h4>
<p>比如处理资金问题，必须考虑幂等问题，即同一个请求，执行多次的效果必须与执行一次的效果等同。幂等的结构化抽象是，操作的主效果与操作次数无关。</p>
<h4> 事务</h4>
<p>比如多个关联数据的插入、更新和删除，必须保证原子性。要么全部执行，要么一个都不执行。需要使用事务来保证。事务的特性是ACID，结构化抽象是关联数据集合在操作前后必须满足某种一致性约束。确定“关联数据集的一致性约束”是关键，其实现是还原点、快照与回滚日志。</p>
<h4> 并发</h4>
<p>大量请求或数据集的处理，使用串行的方式效率难以满足性能或吞吐量要求，需使用并发的方式，充分利用多核CPU资源。结构化抽象是，多个相互独立的执行单元。这些执行单元拥有独立的CPU和缓存，所使用的内存可以为共享内存型和独立内存型。</p>
<h4> 同步</h4>
<p>在并发场景下，要保证多个执行单元（比如线程、进程等）能够看到共享内存的最新更新值。同步的本质是确保指定顺序执行，避免不确定的执行顺序带来不确定性的结果。其结构化抽象是临界区。临界区是约束执行顺序的一种结构。</p>
<h4> 框架</h4>
<p>应用的组件、配置与启动，可以做成通用的框架和脚手架反复使用，快速启动和部署一项工程，减少不必要的重复工作量。框架的结构化抽象是，将工程中的配置、部署与启动、运行结构、通用任务进行提炼并形成固定的模式，应用只需要关注可变的业务部分。</p>
<h4> 限流</h4>
<p>突发的峰值流量，为了避免瞬间占满和击垮服务器的资源和服务能力，需要进行限流。其结构化抽象是，在指定时间间隔内的通过许可数必须满足指定规格。</p>
<h4> 缓存</h4>
<p>对于热点数据，为了避免反复从源存储获取，增大对存储的访问压力，可以使用缓存来存储热点数据，增大命中率，提升性能，减少对存储的不必要的访问压力。缓存的结构化抽象是，使用少而精的空间优先于大而全的空间的搜索。“少而精”是指聚焦应用的经常被访问的热点数据。缓存的衡量指标是命中率和过期时间，操作是缓存与源存储的读写同步。</p>
<h4> 降级</h4>
<p>当非核心的依赖不可用时，可以及时切断依赖，舍小取大，保证整体服务正常运行，不受局部影响。降级的结构化抽象是，是主备策略的设计与切换机制。</p>
<h4> 重试</h4>
<p>当处理数据发生错误时，可以进行重试来进行补偿和恢复。 重试的结构化抽象是，至少（且通常只需）保证一次操作成功。</p>
<h4> 切面</h4>
<p>比如耗时统计。耗时统计与操作的执行内容无关，仅关注操作的耗时。切面的结构化抽象是，操作的非功能属性与功能本身的解耦。</p>
<h4> 代理</h4>
<p>比如请求的负载均衡。不是直接执行目标操作，而是创建一个代理，由这个代理转发请求和执行目标操作。代理的结构化抽象是，隐藏目标操作。</p>
<h4> 版本号</h4>
<p>版本号通常用于实现非阻塞式并发，即乐观锁。其结构化抽象是，一个严格保证特征数值单调递增的机制。</p>
<h2> 实践</h2>
<h4> 示例分析</h4>
<p>要对问题进行结构化抽象，需要先提取问题的结构特征。可以分别从数据结构化和操作结构化两个角度来思考。</p>
<h4> 分页</h4>
<p>比如分页功能是大多数信息系统管理的必备功能之一。 怎么实现一个通用的分页功能呢 ？</p>
<p>从数据结构化来思考，其结构要素为：偏移量、页大小、起始和结束位置。 分页本身和获取何种对象无关。</p>
<p>从操作结构化来思考，其结构要素为：1. select columns from table where condition limit offset, size ; 2. count distinct(id)<br>
from table where condition limit offset, size .</p>
<p>columns , table, condition 都是可以根据具体业务来动态生成的，而整个 SQL 的骨架是固定的。 table 不一定指 DB , select ,<br>
count 也不一定是 DB 的 sql ，它只是表示在指定搜索条件下进行对象选择与统计的操作语义。 columns , table, cond<br>
的动态生成，可以使用泛型和回调函数来传入和处理。</p>
<h4> 限购</h4>
<p>限购，是指定时间内，指定 key 的实体允许通过的许可数量。与限流是同一类结构化抽象。 许可数量，是一个全局性约束。</p>
<p>假设去掉“指定时间”的约束，只限制许可数量， 其结构化抽象是，dec if total - count(key) &gt; 0. 并发的场景下，total - count(key) &gt;<br>
0 的值需要进行全局同步。</p>
<p>如果加上“指定时间”的约束，还需要考虑高并发场景下 dec if total - count(key) &gt; 0 的操作耗时。如果指定时间内不允许超过限购数量（强约束），则必须对<br>
dec if total - count(key) &gt; 0 进行加锁，吞吐量取决于操作耗时而不是指定的限购数；如果指定时间内可允许暂时地超过限购数量（弱约束），则可参考限流算法。</p>
<h4> 数据同步</h4>
<p>数据同步的结构化抽象是，将源存储 S1, S2, ..., Sn 的数据复制到目标存储 D 。</p>
<p>数据同步分为两种不同的场景，有实时同步和离线同步。实时同步对数据延迟性容忍非常低，离线同步则要求更快的吞吐量。</p>
<p>实时同步通常采用流式同步，通过接收消息流来处理。 操作的结构化是，Receiver (msg) -&gt; Format(msg) -&gt; Save for each msg . msg<br>
是源存储中的一条数据或一个单位数据集。</p>
<p>离线同步通常采用批量处理，实现方式是批量获取数据并批量格式化后存储。 操作的结构化是，Divide(S) into N part(S) ; Select<br>
part(S) Then Format part(S) and Save for each part(S) 。 可以根据业务唯一 ID 实现一个通用的 Divide 算法。</p>
<p>离线同步要注意 format<br>
的超时和健壮性处理，记录下异常以便重试，同时不因单个数据处理失败而中断整体流程；流式同步则要注意控制好并发情形下的准确性。由于对吞吐量要求比较高，往往采用乐观锁的方式，找到某种能够控制全局版本号单调递增的机制，或者尽量避免“多表同步到单表”的场景【并发场景下会带来更多复杂性】。</p>
<p>积累抽象</p>
<p>在实际工作中，可以反思和提炼设计中所用到的结构化抽象。如果现有的结构化抽象及组合难以解决问题，是否需要新的结构化抽象<br>
？创建新的结构化抽象，并使之与已有的进行组合和集成。</p>
<h4> 规模化挑战</h4>
<p>如果程序媛猿面对的是几万的数据量，那是可以夜夜笙歌的。然而，现实情况是，面对的是亿级以上规模的数据量，且数据量仍然在指数级增长。为了人类社会的无理性发展，程序媛猿们真是费尽了心思花白了头。</p>
<p>为了应对亿级规模的数据量，并发、分布式等方案层出不穷，结合变化的业务场景，又衍生出更多的挠人烧脑的复杂问题。如何应对呢？</p>
<p>规模化挑战的结构化抽象是，在指定时间内，每秒处理的请求/单位数据集的吞吐量，处理一个请求或单位数据集的平均响应时间，以及在流量剧烈变化时的弹性扩展能力。</p>
<h4> 并发</h4>
<p>并发和并行机制取代了串行机制。单CPU和单机的性能基本抵达瓶颈，只能从多核CPU和多机上想办法。将要处理的数据量分解为多个相互独立的子数据集，并在不同的执行实体里相互独立地执行。比如线程池，Fork/Join ，<br>
Map-Reduce 执行模型。 并发和并行虽然解决了单机性能不足的问题，却引发了更多的问题。</p>
<h4> 同步</h4>
<p>有了并发执行之后，由于有些资源是共享的，而一些热点数据往往被多个执行实体同时读取和修改，又产生了竞争问题。<br>
为了解决竞争，引入了同步机制。大量对同一资源、数据的操作进行同步，引起性能问题。</p>
<h4> 缓存</h4>
<p>对于热点数据的读取和操作，通过“空间换时间”的策略，使用缓存来提升性能，降低对源存储的访问压力。</p>
<h4> 限流</h4>
<p>由于允许并发请求进入，则必须应对瞬间的峰值流量（可见世态）。限流必须有度，不能因噎废食。<br>
需要对系统承载的负荷及极限负荷进行测量，根据测量值来确定一个可动态调整的限流值。极限负荷测量即是压测。</p>
<h4> 降级</h4>
<p>由于业务特性的不同，环境的不稳定波动，以及采用方案的局限性，依赖服务有可能出现部分失败，对于调用极其频繁的服务来说，依赖服务的少许失败可能导致上层的雪崩效应。因此在依赖服务出现问题时，必须进行适当的降级熔断。</p>
<h4> 测量</h4>
<p>为了避免大流量或大数据结构导致软件运行出现问题，降低维护成本，不能仅仅停留在定性分析上，还要进行量化。需要对系统进行仔细的测量。服务接口的<br>
RT 和 吞吐量 如何 ？存取操作耗时如何 ？ 消息处理耗时和吞吐量如何 ？ 内存占用如何 ？ 大数据对象占用内存多大<br>
？能够承载的极限流量有多大 ？ 能够承载的极限对象大小是多大 ？ 指定时间段的失败数和失败率有多大 ？</p>
<h4> 集群</h4>
<p>若以单机视角去考虑问题，就会殚精竭虑地在“并发、同步、缓存、限流、降级”等上做到极致，就像在单核时代将CPU主频做到极致一样。然而，即使做到极致，为了峰值流量所构建的机器资源，在平均流量场景下会造成很大的浪费；并且，很难预估峰值流量会在什么时候来到。如果有一个超级大的聚合的池化资源，总可以提供足够强大而弹性的CPU计算能力、内存能力、磁盘空间，那么以上规模化引起的问题也将迎刃而解。这个超级大的聚合的池化资源，就来自于构成集群的分布式系统的资源虚拟化后的能力，即云计算能力。</p>
<h4> 可视化</h4>
<p>为了从数据集中发现整体性的规律和趋势，通过将大量数据集进行可视化，拥有一个简明的全局视角。</p>
<h4> AI</h4>
<p>以数据为基础，以规则集为准绳，训练机器通过基本的规则集与数据的计算而获得某种“学习”能力，从而能够分析更多的数据集，调整现实活动和方式，获得人力所无法得到的见解和经济效益。</p>
<h2> 经验与洞见</h2>
<p>招聘或找工作的人，常常说要“工作经验多少年才行”，然而，在软件设计中，却容易“有经验而无洞见”。</p>
<p>经验是什么？ 经验是工作中遇到的问题及解决方案。有些问题，只有在规模达到足够大的时候才会出现；而大多数问题，只要根据原理就能推导出来。在软件世界里，并没有一成不变的最佳经验。</p>
<p>洞见是什么？ 洞见来自于究根追源，从最基本的公理进行推导得出定理和定律，从而能够预知问题。逻辑，本质上是一种数学结构，而数学正是能够进行推导的严密思维体系。</p>
<p>软件设计的洞见来自哪里 ？ 究根追源，软件逻辑建始于两条公理：</p>
<ul>
<li>1 + 1 = 2</li>
<li>机器的字长有限，内存有限； 执行指令需要 CPU 时钟周期</li>
</ul>
<p>几乎所有软件问题都是这两个基本要素的组合和叠加而产生的。软件设计崇尚“自顶向下”的方式，然而，要获得洞见，却需要“自底向上”的思考和推导，通过多个层次的结构化抽象来建立。万变不离其宗。</p>
<p>注意到，第二条公理描述了现实系统的局限性。 局限性，正是经验的用武之地。</p>
<p>在初期，可以 80% 依据经验，20% 依据原理；而在后期，则应该 80% 依靠原理，20% 依靠经验。 那么，不依靠经验应该怎么做呢 ？ 举一个<br>
API 调用的例子。 可以测量这个 API 的平均耗时，耗时分布，大体了解这个 API 的对外输出指标。API 超时是因为什么呢<br>
？可能是网络环境波动导致。很难通过设计和开发优化环境的波动。如果不是，从 API 的实现层面来说，很可能是因为并发的大流量导致了竞争加剧，线程死锁或者大量线程阻塞。API<br>
超时又会导致多个子系统间数据不一致。 可见，并发与大流量，是系统必须要面对的“对手”。 并发与大流量一定需要通过工作经验来获得吗？非也。并发与大流量的场景是可以模拟的。</p>
<p>可以通过原理推导，结合实验，来模拟各种现实场景，测量数据， 并制订应对方案。 这是细功夫，也是洞见的产生之源。</p>
<h4> 小结</h4>
<p>本文阐述了软件设计中的结构化抽象的理念及实践方法，涉及设计与开发、设计模式、技术机制、示例分析、规模化挑战，及设计中的经验与洞见。结构化，即是将逻辑进行抽象、提炼、分离、聚合，构建成更加缜密、动态、弹性的结构流。</p>
<p>做软件设计，要同时看到骷髅与美人。论理，要看到骷髅；论情，要看到美人。理，即是结构化抽象。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-10-31T11:10:45.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:编程概要</title>
    <id>https://ujava.cn/principle/four.html</id>
    <link href="https://ujava.cn/principle/four.html"/>
    <updated>2023-10-31T11:27:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h4> 0与1</h4>
<p>在可预见的很长一段时间，计算世界仍然是由 0 和 1 组成的。 无论是字母、数字、图表、网页、动画、超酷炫的特效等，在计算底层看来，都是流畅的一系列01数字串，就像硬件只会看到一团极其壮丽的电子流一样。我们的旅程从这里出发。</p>
<h4> 原子数据</h4>
<p>计算世界的原子数据通常包括字符、整数、字符串、布尔量、浮点数。 打开某种编程语言的入门书籍，第二章通常都会是变量，以及变量的若干基本类型。</p>
<h4> 字符</h4>
<p>最先映入眼帘的，大概就是字母表。大小写的 ABCDEFG, HIJKLMN,OPQRST,UVWXYZ。 咋看上去，似乎没有什么结构，都是单个的字母。实际上，在计算机内部，任何字母都是一个字节8位的01串编码而成的，通过ASCII 码表来进行映射。比如A，ASCII码值是65，对应的01串是 01000001。 单个数字以及其他控制字符，也是通过 ASCII 码表来标识的。可以百度或谷歌 ASCII 了解详情。由此认识到： 字符是 8 位01串。后面会知道，这里的“串”可以理解为一种“数组”。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h4> 0与1</h4>
<p>在可预见的很长一段时间，计算世界仍然是由 0 和 1 组成的。 无论是字母、数字、图表、网页、动画、超酷炫的特效等，在计算底层看来，都是流畅的一系列01数字串，就像硬件只会看到一团极其壮丽的电子流一样。我们的旅程从这里出发。</p>
<h4> 原子数据</h4>
<p>计算世界的原子数据通常包括字符、整数、字符串、布尔量、浮点数。 打开某种编程语言的入门书籍，第二章通常都会是变量，以及变量的若干基本类型。</p>
<h4> 字符</h4>
<p>最先映入眼帘的，大概就是字母表。大小写的 ABCDEFG, HIJKLMN,OPQRST,UVWXYZ。 咋看上去，似乎没有什么结构，都是单个的字母。实际上，在计算机内部，任何字母都是一个字节8位的01串编码而成的，通过ASCII 码表来进行映射。比如A，ASCII码值是65，对应的01串是 01000001。 单个数字以及其他控制字符，也是通过 ASCII 码表来标识的。可以百度或谷歌 ASCII 了解详情。由此认识到： 字符是 8 位01串。后面会知道，这里的“串”可以理解为一种“数组”。</p>
<h4> 整数</h4>
<p>接着为人所熟知的，便是整数。 同字符类似，整数也是01串。不过由于整数比较大，一个字节8位可能存不下，因此需要多个字节。Java编程语言里，整数是4个字节32位01串，可以表示的数值是 -2^31 ~ 2^31-1. 还有长整数 8 个字节 64 位 01 串，可以表示的数值是 -2^63 ~ 2^63-1 . 拿整数 10000 来说，可以表示为 00000000 00000000 00100111 00010000 , 可以使用 python 的 bin(10000) 方法来获取10000的二进制表示，也可以使用python 的 int('00000000000000000010011100010000', 2) 来获取二进制表示的整数。关于二进制如何表示整数，有一套模2取余的算法；而如何表示负整数，则要涉及到反码和补码计算。详情可百度或谷歌。由此认识到，整数，实际上也是若干位01串。</p>
<h4> 字符串</h4>
<p>字符串大概是计算世界里处理得最最多的原子数据了。任何文本都是字符串。字符串其实是由字符组成的序列，比如 “ABC” 就是 ["A", "B", "C"]。因此字符串编码为01串，就是把字符串中的每个字符都编码为01串，然后串联起来：010000010100001001000011.</p>
<h4> 布尔</h4>
<p>布尔类型就是 True 和 False ， 真与假。 用于各种条件判断中。</p>
<h4> 十六进制</h4>
<p>写成01串实在太痛苦啦，也不直观。因此先辈们发明了十六进制。实际上，二进制，十进制，十六进制，都是表示计数的一种方法。 N 进制，就是用 0~N-1的数字(N&lt;=10)或0-9, N-10个字母(N&gt;10)来表示所有的整数。十进制，就是用 0-9 来表示整数； 十六进制，就是用 0-9, A-F 来表示整数。 N 表示进位数，逢N进一。十进制转十六进制，采用模N取余的方法来确定各个位的数字。比如 24， 可以表示 2<em>10 + 4； 也可以表示成 1</em>16 + 8, 即0x18 , 0x 表示使用十六进制计数法。使用python的hex(24)即可获得24的十六进制表示。 有了十六进制，表示大量的01串，妈妈再也不用为我担心啦！</p>
<h4> 变量</h4>
<p>前面讲了原子数据字符、整数、字符串、布尔，那么在程序里怎么使用这些原子数据呢？变量是用于存储这些值并引用的。 比如 x = "i am java programmer" , x 就是个变量。 给变量指定某个值的动作叫“赋值”。变量在程序的不同地方可以重新赋值，比如 x = "now i am mixed coder. haha!"</p>
<h4> 常量</h4>
<p>常量也是可以指定和存储原子数据值的地方，不过常量在初始化完成后就不能改变了。比如光速在真空中的速度、圆周率PI 、自然常数、默认参数配置等。</p>
<h4> 初始化</h4>
<p>变量与常量都是数据引用。初始化是指为一个数据引用第一次赋值的过程。int x; 这只是声明了一个整数变量 x，而没有初始化这个变量； 而 int x = 1 就为 x 完成了初始化工作，赋予初始值 1 。初始化也称为“声明并定义了”。</p>
<h4> 地址</h4>
<p>“赋值”是个逻辑意义的操作，比如 x = "i am java programmer", 是将字符串赋值给变量 x , 这是从自然语言的角度理解； 从计算机存储和运行的角度来理解，必然要为这个字符串分配一个内存来存放，这就存在变量的内存地址 d = 0xb708a410。使用python的id(x)可以打印x的地址。现在我们知道变量有双重身份啦： 一个是变量指代的值 v ，一个是存储变量值使用的内存地址 d。</p>
<h4> 指针</h4>
<p>上面讲了地址的概念。指针就是用来存放地址 d 的数据引用 p， 可以通过指针来操作变量的值。 比如说，x = "i am java programmer" , x 的地址是 d = 0xb708a410 ，那么 p = 0xb708a410 ； 如果想将 x 的值变成 "i am mixed now." ， 那么可以使用 x = "i am mixed now."; 也可以使用指针 (*p) = "i am mixed now.". *p 的含义就是取出变量 p 所存放的变量地址所指代的变量的值。是不是有点拐弯抹角？ 别担心，很多中高级程序yuan 都在指针上栽了很多次的跟头 ~~</p>
<h2> 原子控制</h2>
<h4> 指令</h4>
<p>指令由操作码和操作数组成。操作数就是前面所说的各种原子数据；操作码是预先定义好的01串。比如在8位系统上，定义： 10000000 表示加法， 11000000 表示减法。最高2位表示操作码，其他位表示操作数。 那么， 10000000 00000001 00000010 就表示 1+2 ， 11000000 00000010 00000001 表示 2-1。实际指令可以比这更复杂，但原理是一样的。指令由CPU来执行完成。</p>
<h4> 汇编</h4>
<p>程序yuan，或者码农就是靠编写指令为生的。不过要编写这么多01串，恐怕吃饭都要吐出来的。于是，程序猿中的先驱们发明了汇编。 汇编对指令并没有实质性的改变，仅仅是对指令做了个助记符或者说是命名，不过这个命名产生的意义却是非凡的！比如 10000000 简记为 ADD，11000000 简记为 SUB， 那么上面的指令就可以写成， ADD 0x01 0x02 , SUB 0x02 0x01 ，是不是更直观了？</p>
<h4> 拷贝与位运算</h4>
<p>别看计算机能胜任超级广泛的任务，其实它只会两件事：拷贝与位运算。拷贝，就是将一个值从一个地方挪到另一个地方：我只是大自然的搬运工，哈哈！位运算，就是将指定的操作数的各个位进行运算(与或非)得到新的值。要问计算机为什么能胜任各种各样的事情，其实都是可以拆解为拷贝与位运算。比如我们使用手机聊天，其实就是把数据信息从一个手机拷贝到另一个手机上而已。当然，为了安全的考虑，需要对数据信息进行加密。而加密则无非是一大串的数学计算。任何数学计算都可以通过位运算来完成。就这么简单！ 是不是很神奇？</p>
<h4> 编译器与编程语言</h4>
<p>使用汇编写程序，仍然是很困难的，稍微大点的程序就让人头发掉光光。如果 ADD 0x01 0x02 能够直接写成 1 + 2 岂不是更好？ 于是，编译器和编程语言发明出来了。 编程语言，就是用自然人容易懂的语言来编写程序，而编译器则负责将其翻译成机器能懂的二进制指令；这样，只要我能编写出编译器认得的程序，一样能够在计算机上运行， 而要让编译器认得写出的程序，就要符合编程语言指定的语法规则。这其实跟自然语言很类似，只是编程语言更精确严谨些，比自然语言的容错能力更低一些。为什么猿媛们这么爱细节呢？是因为计算机太太认真啦！</p>
<p>有了编译器和编程语言，现在我们终于能用人话来谈论编程了！</p>
<h2> 数据与控制</h2>
<p>处理什么数据？ 怎样处理数据？如何组织大量指令来完成指定目标？ 这三个问题构成了编程的中心问题。</p>
<p>处理什么数据，是编程需求所决定的， 也是由观察世界的角度来产生的；<br>
怎么处理数据，包括如何采集、容纳、传输、存储、组织、加工、展示数据； 这一步产生出许多技术手段；<br>
怎么组织指令，涉及到指令的组织结构，控制指令的执行路径；<br>
因此，编程的中心问题，转化为“数据结构”与“控制结构”的问题。值得提及的一点是，数据的含义，也包括数据之间的关联。</p>
<h2> 编码</h2>
<p>将字符、整数、字符串、指令转换成01串，实际上就是编码了。编码是指将现实中的万事万物编码成01串的操作。神乎其技兮！</p>
<p>现在，让我们来一次“对象编程”。假设我们要对对象编码（这是要逆天么）。对象有很多特征，身高、体重、爱好等等，不过我们很难全部覆盖。那么就针对身高、体重和最爱的菜吧。这就是抽象。抽象就是从现实事物的诸多特征中萃取出真正要研究的那些特征。</p>
<p>确定要编码身高、体重和最爱的菜之后，就可以思考如何表示了。可以使用变量 height 表示身高，使用变量 weight 表示体重， 使用变量 favorite 表示最爱。假设身高是 168cm, 体重是 100 kg, 最爱的是番茄炒鸡蛋。 那么，身高和体重， 可以使用整数， 最爱可以使用字符串。比如 int height = 168 , weight = 100 , String favorite = "番茄炒鸡蛋"。 int 是Java语言中表示整数的类型， String 是 Java 语言中表示字符串的类型。使用十六进制表示 height = 0xa8 ; weight = 0x64；favorite=0x795aae88c84e78292e9b8a1e89b8b。十进制转十六进制，使用 python 的 hex 函数。计算机在运行的时候，必定要为这三个变量分配内存空间，比如 d_height = 0x08cce04c, d_weight = 0x08ccdbc4 , d_favorite=0xb708fd90。</p>
<p>各种原子数据的编码：</p>
<p><br>
恭喜你！一下子掌握了编程的两个最精髓的概念： 抽象与编码。</p>
<p>我们了解了程序里的原子数据和原子控制。这些是我们理解程序如何运行的基础。事实上， 无论多么复杂的程序或软件，数据都将被编码成01串，代码都将被编译器翻译成01串，从而被计算机识别和执行。当然，要编写和理解大型程序，仅仅有这些基本知识和思想是不够的。但是，我们已经很勇敢地迈出了第一步，就像人类探索浩瀚宇宙的登月之旅。</p>
<h2> 第一站-初识结构</h2>
<h2> 基本数据结构</h2>
<p>原子类型的变量就像非正规的散兵，虽然有初步的战斗力，可是这战斗力是很弱的。假设你有十个苹果要发给某人，很难说一个一个苹果发过去，多半是把十个苹果打包成一箱后一起发过去。这个“箱”就是结构。结构是任何可以容纳多个事物的事物。被容纳的事物，称为元素， 既可以是原子类型的值，也可以是结构本身。嗯，这里面就包含了递归的思想。</p>
<h4> 数组</h4>
<p>数组是最基本的数据结构。往连续的固定空间连续存储一系列相同类型的值，就构成了数组。比如 [1,2,3], ['A','B', 'C'] 或者 ["I", "have", "a", "dream"] 。 数组的操作也很简单直接：设置或取出指定位置的值，指定位置使用下标来表示。比如 [1,2,3]，取出下标为 0 的值是1。如果设置下标为2的值为10，那么数组就变成[1,2,10]。最大的下标是2，也就是数组长度减去一。注意，下标是从0开始算起的，第一个这么设计的程序员一定是天才，思维与常人如此不同！这个传统被沿袭下来，从此所有程序yuan都与普通人的思维有所不同~~~</p>
<h4> 链表</h4>
<p>假设有若干人站成一列玩游戏，每个人用双手搭在前面人的肩膀上，就形成了链表。当我们要找到某个人时，可以从最后那个手搭着别人肩的人开始，根据手到肩的指向数过来，直到找到那个人为止。</p>
<p>相同类型的值使用指针相互连接起来，就组成了链表。比如 1 -&gt; 2 -&gt; 3 -&gt; 4 。 链表不能像数组那样指定位置来设置或取值，而是要通过指针遍历一个个数过去。但链表是容易高效扩展的，比如要把 5 插入到 3 与 4 之间， 只要把3指向5,5指向4，就OK 了： 1-&gt;2-&gt;3-&gt;5-&gt;4 。</p>
<p>链表是元素通过指针指向来形成关联的结构。</p>
<h4> 栈</h4>
<p>假设我们要把东西一件件放置在冰箱里。这个冰箱每次仅容放置或取出一件物品，每次放置物品都要放置在最里层，要取出最里层的东西，必须先取出最外层的东西，那么，冰箱的这种结构就构成了“栈”。栈是先存后取型的结构。</p>
<h4> 队列</h4>
<p>队列应该是中国人最熟悉的结构了。你可以不懂数组、链表、栈，但你一定知道队列，—— “万恶”的排队。若干个人站成一队等待着， 先到者先得之。</p>
<p>队列是先进先出型的结构。</p>
<h4> 联合</h4>
<p>联合，其实就是“大杂烩”的意思。为了方便计算，数组、链表、栈、队列通常都是存放相同类型的值，俗称“清一色”。联合则比较多样化，什么都可以往里塞。比如说小书架，既可以放几本书，也可以放小饰品，遥控器等。 联合是对象的雏形。</p>
<h4> 元组</h4>
<p>元组，也是一种“大杂烩”。不同之处在于，元组存储的数据通过彼此的逻辑关联共同表达一种概念。比如三维空间里点的直角坐标 (x,y,z) ，一件事情的起始结束时间 (start_time, end_time)。元组的值初始化后就不能改变。</p>
<h4> 位图</h4>
<p>位图，就是一串01。前面讲到原子类型的值时已经提到。现在你明白了，在计算世界里，真正的原子只有0与1，其他的都是位串，都是结构。数组、链表等是位串的结构。位图操作就是置位(指定位置为1)、清零(指定位置零)与测试位(判断指定位是0还是1)。位图用于任何事物的编码结果，亦可以用于任意稠密的不重复整数数组的排序。</p>
<h4> 列表</h4>
<p>列表与数组极为相似，不同之处在于，数组是固定长度的，而列表是长度可变的。实际上，Java 的列表是以数组为基础来实现的(当然并不是所有列表都是以数组来实现的，譬如Scala, Lisp的列表是以链表来实现的)。初始化列表时，会为列表分配一个指定长度的数组，当原来的容量不够存放时，就会申请更大的数组，并将原来数组的元素拷贝到新的数组。如此而已。</p>
<h4> 集合</h4>
<p>集合，是若干个不重复值的可变长结构。集合与列表非常相似，不同之处在于，集合里不存在重复的值，而列表中可能存在重复的值；集合是无序的，而列表是有序的。集合，比方天气的几种类型，有 Set(晴，雨，雪，阴，雾，霾) ， 那么一周的天气就能构成列表： [晴，晴，霾，雨，雪，阴，雾]</p>
<h4> 映射</h4>
<p>映射，就是键与值的一对一或多对一的关系。比如一个人的身高体重， map = { 'height': 168, 'weight': '100' }。这里 height, weight 是键， 而 168, 100 分别是键 height, weight 对应的值。可以根据键快速获取和设置对应的值，是映射的主要操作。映射在计算机中使用哈希表来实现，可实现快速查找、中断处理等。</p>
<h4> 变体</h4>
<p>变体是在现有结构基础上作出某种改动从而能够适应特殊需要的结构。比如优先级队列，就是在普通队列的基础上添加了优先级的概念，允许高优先级的元素“插队”。队列还有三种变体： 双端队列、循环队列、多重队列。 双端队列，允许在一端进行插入和删除，一端只允许插入，从而具有栈和队列的用途；循环队列将队列首尾相连，可高效使用存储空间；多重队列可创建多个同时进行的队列，通常用于多任务所需要的进程挂起/就绪等待队列。栈也有“双栈”的变体，允许从两端进行插入和删除，适合于需要两个栈的场景。</p>
<p>变体是基本结构的微创新。</p>
<h4> 嵌套</h4>
<p>基本数据结构的真正威力在于可以任意的嵌套。嵌套 是指结构中可以包含任意的子结构，子结构又可以包含子结构，一直这样包含下去(能够无穷无尽地包含下去么？)。比如一个公司的职工的信息， persons = [ { 'name': 'qin', 'address': { 'prov': 'zhejiang', 'city': 'hangzhou' } , 'hobby' : ['writing', 'walking', 'riding']，'features': '01001001' } , { 'name': 'ni', ... } ]</p>
<p>图示<br>
</p>
<p>现在我们已经了解了数组、链表、栈、队列、联合、元组、位图、列表、集合、映射这些基本数据结构，也知道可以通过嵌套的方法创造任意复杂的新结构。使用基本数据结构，就能批量存放更多的数据，批量操作更多的数据，组建正规化军队，形成更强的战斗力。这些基本数据结构是构建中大型程序的结构基础。其中，列表和映射是最最常用的两种结构。在Java里称为容器，容纳东东的器物，是不是很形象？</p>
<h2> 基本控制结构</h2>
<p>存放更多的数据有了基本数据结构及其嵌套结构，那么，如何组织超级多的指令呢？ 根据现实中的逻辑需求以及数学家、科学家的不懈思考，结合工程师的实践经验，就形成了“顺序、分支、循环”三种最基本的控制结构； 并且可以证明，任意代码结构都可以使用这三种控制结构来表示。嗯，数学家就是这个用处：将万事万物统一为简洁而基本的模型。</p>
<h4> 代码块</h4>
<p>单木不成林，单掌不成鸣。单条指令没法做什么事情，只有组合多条指令才能完成具体的功能。就比如乘法运算，也需要拷贝操作数、对操作数移位和相加、拷贝新得到结果。代码块就是将多条指令顺序组织起来进行执行从而实现具体的功能。代码块一般用大括号括起来， 指令之间用分号隔开。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 分支</h4>
<p>分支就是当条件A发生时做某事，当条件B发生时做某事。比如周末如果天晴就出去逛，下雨就宅家里，或者如果心情好的话，去看场电影，或者去找个人一起玩。就是这样了。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 选择</h4>
<p>选择是在多个相同类型的选项中选择匹配的一项并执行相应的操作。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 循环</h4>
<p>循环就是把一件事重复做多次。过程必有终结之时。此之结束，彼之开端。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 跳转</h4>
<p>当一条路走不下去，或者发现要及时掉头时，就会使用跳转语句。break 是终止整个循环；continue 是跳过后面的操作进入下次循环。GOTO是万能跳转语句，曾经盛行一时，但当今高级语言只作为保留关键字，不再推荐使用它了。从底层看来，分支、选择、循环、跳转应该是采用GOTO来实现的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 函数</h4>
<p>函数，就是把一系列指令组织起来实现一个具体通用的功能，并对其命名的过程。 比如前面早上的例程就可以写成函数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相比代码块，函数可以带有参数，比如上面的 delay, time , 根据参数来调节实际的动作。就像电饭煲可以调节温度、时间、闹钟可以设置铃声一样。参数可能带有默认值。以后就可以根据不同的参数执行 doInMorning 行为了。</p>
<p>此外，函数比代码块多了命名。别看只是多了命名，其意义犹如编码一样非凡！ 从此，编程迈入了“堆积木”时代。只要你花时间编写了一个可靠的函数，成千上万的人就可以在数秒内数千万次甚至上亿次地反复使用这个函数，—— 你能找到第二个行业做到这一点吗？ 这就是软件行业能够一日千里、日新月异、天天刷屏的根本原因。</p>
<p>九层之台，起于累土。正如我们可以从四则运算开始，经过代数、方程式、函数、数列、复数、平面几何、解析几何， 直到微积分、卷积、级数等非常高阶的数学运算，也可以从实现1+1=2的简单函数开始，一层层地累加，直到构建起超大规模互联网软件系统。</p>
<p>如果你要程序员造一座巴比伦城市，那么，程序员会写一个函数去创造一个城市，然后传入参数名为巴比伦。</p>
<p>到现在为止，真值得为自己庆祝一下： 我们已经走过一段路了。 熟悉了基本数据结构和基本控制结构，已经可以编写小型程序了。不过， 如果要以登山作比方的话，那么，我们现在正处于山脚下，望着巍峨高山，是否有一种登高望远的冲动呢？O(∩_∩)O</p>
<p>请多休息一会，补充充沛的体力和精力。接下来， 我们将开始真正的登山之旅。</p>
<h2> 第二站-中级结构</h2>
<p>中级结构通常是一种或多种基本结构通过某种组合形式而实现的更复杂一点的结构，亦称为“复合结构”。组合蕴藏的威力是非常强大的。现实中的事物几乎都是由基本元素和基本事物组合而形成的。嵌套是组合的一种形式。</p>
<h4> 中级数据结构</h4>
<h4> 多维数组</h4>
<p>多维数组是一维数组在多维空间的扩展，是数组(...的数组)。比较常用的是二维数组。比如 [[1,2,3], [4,5,6], [7,8,9]] 是二维数组； [ [ [1,2,3], [4,5,6], [7,8,9]], [ [11,22,33], [44,55,66], [77,88,99] ] ] 是三维数组。 访问 N 维数组的元素需要 N个对应的下标，可以根据指定位置随机存取。 比如访问二维数组需要 [row][col] 下标， 访问三维数组需要 [N][row][col]。 二维数组可用于点阵图表示、曲线模拟、矩阵表示；三维数组可用于立体图形的模拟。</p>
<h4> 二叉树</h4>
<p>从一个起点出发，每次选择向左或向右进行探索；如果不想在一个方向走下去了，那么回退到上一个地方向另一个方向进行探索，如此反复，最终形成的结构就是二叉树。二叉树实际上可以看成是多个链表的组合。字典查找就使用到了二叉树。处理二叉树通常会用到递归的方法。</p>
<p>二叉树是编程中第一个不太容易掌握的数据结构，其原因是，人们更习惯于以线性的方式思考问题，然后二叉树告诉我们：要分叉，要多向探索，世界有更多可能。</p>
<figure><figcaption>img_3.png</figcaption></figure>
<h4> 模板</h4>
<p>模板是含有固定不变内容和待填充内容（称为占位符）的混合体。当实际运行时，将具体的内容替换占位符，即可得到动态内容。常用于生成动态页面，自动生成代码等。</p>
<p>比如 I have a dream that ${dream}. 就是个模板， ${dream} 是占位符。当使用具体内容“someday i will teach kids programming”替换时，就生成了最终内容： I have a dream that someday i will teach kids programming.</p>
<h4> 缓存</h4>
<p>我们来做个游戏：有一个教官和一队顺序编号的十名学员。教官与学员相距 10 米。现在，教官要点到名的学员来到跟前敬礼然后回去。教官的记性和视力不太好，容易点到重复的名字，且如果有不超过5名学员都站在离教官5米远的距离，教官是分辨不出来的。学员怎么走才能更少距离到达教官呢？</p>
<p>当然，所有学员可以来到教官面前，然后敬礼归队，这样每位点到名的学员都得往返 20米。但有些淘气的学员故意离得近一点，站在离教官5米的距离，这样教官点到名的时候，就只要往返 10 米。当然，如果点到名的学员站在10米远的地方，就不得不往返20米了。现在的问题是，学员得找到教官点名的规律，并及时让相应的学员站到5米远的地方，从而使得全部点名后，所有学员的往返距离最小？</p>
<p>这5个离教官5米远的位置，就是缓存。缓存是计算世界中仅次于编码的极为重要的编程思想之一。计算世界的缓存几乎无处不在：CPU与内存之间有缓存，磁盘、网络与操作系统之间有缓存，应用程序与数据库之间访问有缓存。你与我之间也有缓存。缓存能够让获取数据更快，从而运算更快，效率更高，但缓存也更贵。缓存的两大指标是：缓存容量和命中率。如果相同成本下的缓存容量更大，就能使用缓存来替代原来的存储，然后制造更近的缓存；如果缓存容量难以提高，就要琢磨数据存取的规律，尽可能让每次的命中率更大。缓存容量就是有多少个离教官5米远的位置；命中率就是有总共的点名次数中多大的比率教官点到了离教官5米远位置的学员。</p>
<h2> 中级控制结构</h2>
<h4> 迭代</h4>
<p>迭代是使用固定的计算规则集合不断用新值取代旧值趋向真实值的控制结构。比如牛顿迭代法求N的平方根 X(k+1) = (X(k) + N/X(k))/2 (k&gt;=0) 就是一个迭代过程。可以指定初始值和终结迭代过程的迭代次数。迭代的重要指标是收敛性和收敛速度。</p>
<h4> 遍历</h4>
<p>遍历是从结构中的某个初始节点出发，使用某种控制算法直至访问结构中的所有节点。遍历有深度遍历和广度遍历。深度遍历是一直往一个方向走，直到无路可走，然后回退到上一个可选择路径的节点，选择另一个没有遍历的路径。依次直至所有节点都访问完毕。深度遍历上述的数结构，得到的节点顺序依次是 { 9,6,3,8,7,12,15,18,13} ； 广度遍历是首先访问初始节点的所有邻接节点，然后访问这些邻接节点的邻接节点，这样一层层地辐射般的铺开，得到的节点顺序依次是 { 9,6,12,3,8,15,7,13,18 } 。</p>
<p>常见的遍历操作有列表遍历、对象遍历和合并操作。列表遍历主要有映射、过滤和查找(匹配)。 映射即是对列表的所有元素依次应用一个函数得到另一个列表，比如 [1,2,3,4,5] 应用 f(x) = x*2 得到 [2,4,6,8,10]; 过滤即是对列表的所有元素依次应用一个函数得到另一个列表，这个函数根据某种条件返回 true or false , 比如 [1,2,3,4,5] 应用 f(x) = { return x &gt; 2; } 返回 [3,4,5]； 查找操作是在列表中找到指定元素的第一次出现位置或所有出现位置；实际中的列表遍历往往两者兼之，在遍历列表的时候判断是否满足某种条件，如果满足，对列表元素做一定处理，然后添加到结果列表中。Traverse(list) = list.filter(condition).map(listElemHandler)</p>
<p>对象遍历是遍历对象的所有状态以及递归遍历对象引用的对象，由此形成了对象遍历图。</p>
<p>合并是通过遍历将两个数据结构的对应元素通过某种方式合并成一个列表的过程。比如折叠操作 zip([1,2,3,4], [6,7,8,9]) = [(1, 6), (2, 7), (3, 8), (4, 9)]； 比如 Map 合并 merge ({'name':'qin', 'address': 'hubei'}, { 'hobby': ['writing', 'programming, 'walking'] } ) = {'name':'qin', 'address': 'hubei', 'hobby': ['writing', 'programming, 'walking']}.</p>
<p>对于嵌套的数据结构的遍历，需要使用递归的方法来完成。</p>
<h4> 递归</h4>
<p>数据有嵌套的结构，控制也有嵌套的结构。递归就是在函数F以不同的参数调用它自身。比如计算 1+2+3 , 既可以顺序循环地计算，也可以递归地计算： 1+(2+(3)) ， 1-3 的和，就是 1 与 (2-3) 的和，而 2-3 的和，是 2 与 (3) 的和，(3)的和就是它本身。这里有三个要素： 1. 一个可以以不同参数重复调用自身的过程，这些不同参数通常是要处理的总结构以某种方式依次去掉一些元素的子结构； 2. 一个原子的操作，比如这里两个数的和； 3. 终止条件： 在某一次调用时传入参数的子结构只有一个值的情况。</p>
<p>递归是计算世界中与缓存思想同等重要的编程思想。</p>
<h4> 中断</h4>
<p>当你正投入工作状态的时候，领导发话了：开会开会！ 于是你不得不放下手头心爱的事情，跑去听一段@#￥@#%@￥%@%#￥%#的讲话，讲话回来后再以莫名的心绪重新干活。当然，人是有记忆的，当你去开会前，实际上已经记忆了当时做的事情的一些重要细节和进程，这样在回来时就能从这些细节和进程逐渐恢复到当时状态继续干活，就像讲话似乎发生过一样。这就是中断：做某件事，更高优先级事情插入，保存现场，完成更高优先级的事情，恢复现场，继续做原来的事情。</p>
<p>中断是计算世界中与递归思想同等重要的编程思想。</p>
<h4> 回调</h4>
<p>回调是常规逻辑的一种变体。通常代码会顺序地执行A -&gt; B -&gt; C -&gt;D 等，但在某些情况下，我们希望在 B 处做不同的处理，比如 A 生成一个列表 [1,2,3] , 而在 B 处既可能去对列表元素做乘法运算，也可能做加法运算。这时候，可以在B 处提供一个回调 callback(list)，允许传入不同的函数 add(list) 或 multi(list) 对列表做不同的处理。再比如前端发送一个ajax异步请求，当成功的时候显示表格数据，当失败的时候打印友好的错误信息，就需要提供两个回调： success(response) 和 fail(response) ，分别处理成功和错误时的情况。回调通常用于模板设计模式中。</p>
<h4> 回滚</h4>
<p>当我们在编辑器里编辑错误时，就会使用 Ctrl+z 快捷键回退到上一个编辑状态，即“撤销”操作。回退到某个指定状态的操作叫做回滚。比如发布代码到线上后，发现有重要BUG，就需要回滚发布代码到上一个可靠的状态。在软件中，回滚有两个应用领域：一个是事务管理，一个是GUI编程。事务管理中，比如处理入账汇款的功能，当你向家人汇款一笔钱时，通常需要在你的账户里扣减这笔钱且同时在家人的账户里增加一笔钱，两者必须同时成功才构成一次正确的汇款操作。如果在你账户里扣减款项之后，设备出故障了，那么就必须回滚到未扣减的初始状态，以确保你的财产不受损失。在GUI编程中，常常存放用户的编辑操作序列，以便于在用户操作出错时可以撤销，从某个状态重新开始编辑。</p>
<h4> 流计算</h4>
<p>假设有个列表 [1,2,3,4,5] , 你想先对列表中所有元素依次乘以10，再依次加上4，再依次除以2，最后依次过滤掉结果少于20的元素。那么有两种方式。一种方式是按照指定计算顺序地进行，每次都遍历列表对所有元素计算，先得到 [10,20,30,40,50]，然后得到[14,24,34,44,54], 然后得到 [7,12,17,22,27]，最后过滤后的元素是 [22,27] ; 很简单，不过要对列表遍历4次。如果指定运算更多一些，就要遍历更多次。另外一种计算方式是，先收集相关信息，比如所有的计算要求及顺序，然后进行聚合，对于上述计算而言，实际上就是把列表中的每个元素乘以5再加上2，然后保留大于或等于20的元素。即将 5x+2 &gt;=20 应用于列表中的每个元素得到新的列表 。这样就只需要对列表进行一次遍历。这就是流计算。流计算不同于普通计算之处，在于它把待处理数据看成流，将要做的运算聚合成一次运算，然后在真正需要结果的时候才进行计算。</p>
<p>一次流计算的基本组成元素有列表遍历和列表聚合操作。列表遍历见遍历部分，列表聚合主要指求和、求平均、最大最小值等。流计算可以是串行的，也可以是并行的。详见 Java8 Stream API.</p>
<h4> 闭包</h4>
<p>闭包是一个从学院流传到工程界的思想，历来众说纷纭，莫衷一是。既然如此，不妨从其溯源、本质和形式来理解。</p>
<p>为什么有闭包呢？这是变量为了突破函数的限制而产生的。假设函数F里定义了一个局部变量 x，那么当函数执行完成退出后，x 就会自动被销毁。这就像寄生于宿主中的寄生者一样，宿主灭亡就会导致寄生者灭亡；又像古代陪葬，做奴的要随主子的入葬而陪葬。闭包，就是为了创建能够突破这一限制的变量。当在函数F中定义了闭包 C 来访问变量 x, 那么在函数F退出后 x 并不会被销毁，而是以当前状态存留并长眠，等待函数F的下一次执行的时候复苏过来。嗯，是不是像在看科幻小说？这就是闭包的溯源。</p>
<p>闭包就是为了创建函数中的自由变量。在不同编程语言中的实现形式有所不同。C语言中，在函数中的变量使用 static 修饰，就可以成为不随函数退出而灭亡的自由之身，不过这并不算是闭包；Python 语言中，闭包使用在函数内被定义的嵌套函数来实现；Groovy 语言中，是一段自由出现的用括号括起来的代码块，可以赋值给变量和传递给函数；Java语言中，是含有参数和函数体但没有函数声明的代码块。</p>
<h4> Curry</h4>
<p>在学习数学时，常常会遇到这样的函数，f(n, x) = 1^x + 2^x + ... + n^x ， 其中 n^x 是 n 的x 次方。当 x 取不同值时， f(n,x) 就退变为一元函数，比如 x=1 时， f(n,1) = 1+2+...+n, 是求n个数的和；x=2 时，f(n,2) = 1^2 + 2^2+ ... + n^2 是求n个数的平方和等。将 f(n,x) Curry 化，就得到了 f(n)(x) = 1^x + 2^x + ... + n^x； 那么 f(n)(1) 就是 n 个数的和， f(n)(2) 就是 n个数的平方和，依然是函数。这对计算世界里的传统函数是一个创新：传统函数得到的结果总是具体的值。运用 Curry 化，编程语言就有表达数学公式的抽象能力而不仅仅只是计算值了。功力又见长了！</p>
<p>Curry 将多元函数逐层拆解，可以批量生产出大量的低元函数，简直就是个“函数工厂”！运用Curry很容易做出可扩展的微框架，组合基础函数来完成大量数据处理的功能。Scala 语言提供了 Curry 的支持。</p>
<p>在这一站里，我们学到了新的数据结构（二叉树、模板、缓存）以及新的控制结构（迭代、遍历、递归、中断、回调、回滚、流计算、闭包、Curry）。熟悉这些结构会略有点难度，因为其特征与人类的顺序、线性的日常思维不太适配。</p>
<p>迭代在科学计算与软件工程中广泛使用，体现了“逐步求精”的思想；遍历是开发中最常用的控制结构，很多代码都需要对一个列表或映射进行遍历和操作；递归需要思维随着结构逐层递进深入，甚至超越思维能够承受的范围（当结构可能嵌套任意有限的任意结构时）；中断相对容易接受，与日常场景比较相似；回调则类似在代码路径中做了个多路分叉，在不同情况下可以选择不同的算法来处理；回滚则可回退到历史存在的某个状态重新操作，提供了出错处理的机制；流计算体现了对源数据流的聚合与延迟的计算特性；闭包创建了函数里的自由变量，从而扩展了函数的能力；Curry 将多元函数拆解为多个低元函数的层层调用，批量生产大量函数，能够以最大灵活性组合代码逻辑，有时甚至以简短的几行代码就能做出一个简易微框架。</p>
<p>学习这些结构，需要思维能够更加灵活，突破顺序、线性思维的局限性，甚至需要深入思考和练习；学会这些结构，基本可以应对软件开发中的普通难度的业务编程了。</p>
<p>现在我们已经站在山腰了，可以看到一点点壮观的风景了！那么，继续向上，还是返航？ 由你决定。</p>
<h2> 第三站-高级结构</h2>
<h4> 高级数据结构</h4>
<h4> 图</h4>
<p>图是多个事物相互关联形成的复合结构。国家铁路交通网，公司所有成员的社交关系网，都是图的例子。图是数据结构中最难掌握的BOSS级结构。图编程的难点在于事物之间的多向关联，让线性思维的人们无所适从。事物的关联蕴藏着惊人的价值。Google是利用网页之间的关联权重发迹的，Facebook则更直接利用人们的社交关系来成就的。大部分程序yuan写不出像样的处理图的基本程序，工作一年后绝大部分程序yuan几乎不会表示图了。图是数据结构领域的金字塔顶。可以说，掌握了图结构编程，就意味着数据结构最终通关成功，编程领域里几乎没有可以难倒你的数据结构了。</p>
<p>图可以使用二维数组来表示， 也可以使用数组和邻接链表组合起来表示。这充分说明：最基本数据结构的组合，就可以创建最复杂的BOSS级数据结构。</p>
<h4> 正则表达式</h4>
<p>正则表达式是一种非典型数据结构，用于描述数据文本的特征。比如 0571-8888888, 027-6666666 都是电话号码，是由连字符 - 分隔的两数字串，可以使用正则表达式来描述这样的文本: [0-9]{3,4}-[0-9]{7}。[0-9]表示匹配0-9的任意某个数字，{m,n}表示位数为[m,n]之间，{m}表示位数就是m。[0-9]通常也简写为\d. 正则表达式广泛用于文本匹配和替换工作。</p>
<h4> 对象</h4>
<p>到现在为止，数据与控制都是分开发展的。分久必合。在对象这里，数据与控制合为一体。对象是具有状态和行为的统一体。正如人具有身体结构、精力、体力等状态，并能够运用这些结构和状态来完成实际行动一样。数据通过复杂结构构成实体，实体具备影响数据变化的能力；数据与控制成为相互影响密不可分的整体。对象是程序yuan对现实世界的事物的抽象。</p>
<h4> 高级控制结构</h4>
<h4> 设计模式</h4>
<p>设计模式是对象编程的技艺。要完成一件事情，通常要很多人一起来配合协作，充分发挥每个人的专长。那么职责任务分配就非常重要了。设计模式即解决对象的职责以及对象之间怎么协作的问题。比如程序yuanA代码写得特别溜，就是不喜欢跟人交流，那么就需要一个和TA合得来的yuanB来传达yuanA思想。这个合得来的yuanB就是yuanA对于外界的适配器。适配器模式并不完成新的事情，只是将一件事转换一种形式来完成。设计模式能够让软件的柔性更强。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 异步</h4>
<p>在顺序的模型下，当你执行计算时，需要等待计算完成后获得结果。如果执行计算的时间会比较长，那么显然不能干等着吧。这时候，就需要采用异步模型。异步与在餐馆点菜很相似。当你付款后，由于菜肴要准备一段时间不能立即获得，这时候，你会得到一个类似令牌的东西，代表你的一次请求和要获取的菜肴。在菜肴准备期间，你可以去做任何事情，除了不能挂掉。当菜肴准备好后，就会通知你使用令牌来获取相应的菜肴。这也有两种方式，要么服务员直接把饭菜端上你的桌（推），要么你拿着令牌去取（拉）。异步广泛用于请求不能立即完成和获得结果的场合。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 并发</h4>
<p>一边烧开水，一边看报纸。这大概是并发的最经典比方了。不过对于现代人来说，看报纸大概要换成“追剧”了。不错，并发就是同时做两件事了。这个“同时”可以有两种理解：(1) 两个人在同一个时刻各做了两件事； (2) 一个人在一段时间内同时做了两件事。（1）是严格的并发，也称为“并行”。一边烧开水，一边看报纸，实际上是壶在烧水，人在看报纸。可以说壶与人是并行工作的；(2) 称为“分时切换”，是广义的并发，比如单CPU在IO操作时执行其他的计算，此时称CPU也是并发的，实际上是因为CPU与IO设备同时在工作，但是以CPU为中心而言的缘故。 并发操作的原因，是因为一个事物由多个部分组成，而每个部分都能独立地做一件事。比如千手观音，假如人真的有千手，那么真的可以同时吃饭、看报纸、写字等（量子化的世界，是否可能实现一个事物在一个时刻点同时做多件事？）。</p>
<p>别看并发理解起来比较容易，在软件开发中，并发是最本质的难题。并发会导致多个事情的执行顺序和结果的不确定，导致数据访问死锁，加上大规模数据流，大规模的逻辑并发，基本超过了人类理解力能够承受的极限。并发是导致极难排查的BUG的根本原因（很难复现，但它又会不请自来，像软件中的幽灵）。现有的大多数应用，还仅仅只是使用多台服务器并行提供服务，使用多线程或多进程来运行相互独立的子任务，并发在应用中只是局部使用，也就是顺序为主、并发为辅的。</p>
<p>并发的实现方式主要有： 多线程(Java)、多进程(C)、多协程(GO)、Actor(Scala).</p>
<h4> 通信协议</h4>
<p>到目前为止，我们讨论的范围还仅限于单机范围。可是绝大多数人是无法忍受孤独的，人亦非孤岛般存在。让计算机能够彼此通信，让人们能够跨时空互联深入交流，才是互联网的最大梦想。通信协议就是解决计算机中间如何可靠通信的问题，而为了可靠通信，就必须制定好协议。比如一次5个人的聚会吧，首先大家肯定要事先约定什么时候什么地点碰头，好各自安排行程；这是静态协议； 不过计划总赶不上变化。当实际去赴会时，会发现因为某位明星的到来导致路上特堵，结果2个人不能如约到达；这时候，就必须重新调整计划另约时间和地点，甚至还可能改变原来的游玩计划；或者在原计划中留下充分的缓冲余地。这就是协议要做的事情：约定与标准（碰头时间地点）、缓冲余地（容错）、动态调整（灵活性）。实际的通信协议可能更复杂，依据不同的应用而设定，不过原理是相同的。</p>
<p>通信协议是互联网诞生和发展的基础软件设施。最为人所熟知的莫过于 HTTP， TCP 和 IP 协议了。</p>
<p>很有勇气！你已经抵达山上大约 2/3 的地方，可以看到更加壮美的风景！高级数据结构和高级控制结构，理解起来比较容易，大规模实践起来，却是件很有难度的事情，需要扎实的功底、多年的经验、出色的悟性和直觉， 就像习武一样，起初的进步是飞快的，随着功力的提升，以及事情固有的难度（或许是因为我们还没有真正理解事情，没有找到有效的方法），会遇到一个瓶颈。在这一层中，大量的努力和实践可能只带来少量的收获，但仍然要不懈攀登。当能够掌握这些高级结构时，就编程功底而言，已经没有什么编程难题是无法跨越的了。</p>
<p>接下来的事情，就是最后的冲刺，真正的实战与挑战。</p>
<h2> 第四站-应用</h2>
<p>应用中的数据结构和控制结构在编程领域不一定是最困难的，但由于要承载现实世界中的大规模流量，以及多人协作维护的大型工程，因此更多的是工程领域的难点和挑战。大流量、并发用户访问、不可避免的脏数据和无规则数据、非法访问代码等，都是应用数据结构和控制结构需要应对的问题。</p>
<h4> 应用数据结构</h4>
<h4> JSON</h4>
<p>JSON是基本数据结构的嵌套而成的结构， 是广泛应用于子系统之间的标准数据交换结构。比如服务端返回给前端的数据结构就是 JSON，服务A 调用服务 B 的 API 接口获取的返回数据结构也是 JSON。 JSON 定义可参考网站：<a href="http://JSON.org" target="_blank" rel="noopener noreferrer">JSON.org</a><br>
</p>
<h4> XML</h4>
<p>XML是一种标记语言，通过 &lt;标记含义&gt;标记内容&lt;/标记含义&gt; 来表达语义内容。超文本标记语言HTML是一种结构相对松散容错性较高的XML。比如一个人的信息，可以使用 {'name':'qin', 'hobby': ['programming','riding']} , 也可以使用以下格式来表示。XML也是系统之间一种标准数据交换结构，同时也常用于配置文件。与JSON相比，在数据交换结构方面，XML更重量级，可能不如JSON那么灵活，但是用途更广泛一些。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 记录文本</h4>
<p>记录文本是每行以固定规律呈现的结构化文本。比如csv文件是每行以逗号分隔的文本，properties配置每行是以key=value形式的文本。记录文本格式简单，容易解析，常用于Shell任务处理和应用配置文件。</p>
<h4> 关系型数据库</h4>
<p>关系型数据库是几乎所有互联网应用必不可少的数据结构组件。</p>
<p>关系型数据库的基础是二维表，就是一行一行的记录，每行记录都是由多条数据项组成的。为了支持大容量记录以及方便地按照各种条件进行检索，二维表采用了B+树实现，并实现了一套数据库管理系统，包括数据库服务器、数据库语言SQL、以及数据库客户端。数据库服务器用于确保所有记录能够按照条件进行访问（查询、插入、更新、删除，俗称 CRUD），包括服务器的正常运转；数据库语言SQL提供了要查询什么数据的表达方式；客户端提供了编写、执行SQL和查看结果的操作界面。</p>
<p>关系数据库适合存储和检索结构化的有规则的数据集，一个业务功能的详细设计通常都会从数据库设计着手。比如学生选课，可以设计四张表：学生表，每一行都是格式相同的记录，数据项为（学号，姓名，学生的其他信息字段等）； 课程表，每一行都是格式相同的记录，数据项为(课程编号，课程名称，课程的其他信息字段等)；教师表，每一行都是格式相同的记录，(教师编号，教师姓名，教师的其他信息字段等)； 选课表，每一行都是格式相同的记录，数据项为（学号，课程编号，教师编号），这里学号会关联学生表的学号来获取对应学生的信息，课程号会关联课程表的课程编号字段来获取对应课程的信息，教师编号会关联教师表的教师编号来获取对应教师的信息，这种关联称为Join操作，在数学上称作“笛卡尔乘积”。数据库表的设计是有一套范式可遵循的，尽可能保证数据的一致性、完整性和最小冗余度。</p>
<h4> key-value型数据库</h4>
<p>关系数据库适合存储和检索结构化的有规则的数据集，但对于移动互联网时代的应用所要承载的大规模数据流量来说，就很有点吃力了。随着表记录的大幅增多，数据库的查询响应时间会逐渐降低，数据库也面临着巨大的并发访问压力，因此出现了 key-value型数据库，可以作为数据库的辅助。 key-value 数据库适合存储非规则型的容量级别更大的数据，可以有效地作为应用与数据库访问之间的缓存，从而大幅减少直接访问数据库产生的压力。</p>
<h4> 应用控制结构</h4>
<h4> API</h4>
<p>API的实质就是函数。API是被封装的可复用的函数在软件工程语境中的正式称谓，常用于表示一个子系统、子模块对外所能提供的服务，以及子系统、子模块之间的交互关系。封装和复用，是软件工程领域中最重要的思想。</p>
<p>API可以是操作系统提供的，比如文件读写接口；可以是某种编程语言库提供的，比如JDK； 可以是第三方平台提供的，比如用于获取商家用户及交易数据的淘宝API，用于获取位置信息的谷歌地图API等。</p>
<h4> 应用框架</h4>
<p>当我们登录访问互联网网站时，需要填入用户名或扫码，提交请求后，请求就会发送到服务器后台，后台会对请求进行格式化、合法性校验、权限校验、日志记录等，然后交给特定的服务程序处理，处理后的结果再经过格式化后返回页面展示给用户。这个过程中，“浏览器发送请求给服务后台，服务后台做请求格式化、合法性校验、权限校验、日志记录、提交特定程序处理、结果格式化等”其实都是通用的控制流程，跟网站业务只有一毛钱关系，于是，程序yuan就将这些通用流程抽离出来，形成应用框架。这样，以后无论是搭小学生网站，还是搭大学生网站，都可以使用这个应用框架快速搭建起应用。除了网站应用框架，还有很多其他用途的成熟的应用框架。一位熟练的工程师完全可能在一周内独立搭建起一个可演示的系统。</p>
<p>应用框架使得搭建应用可以从 40% 起步，甚至从 70% 起步。一个正式运营的互联网应用软件，使用的应用框架、复用的程序库代码，占比可能达到90%，真正由应用程序yuan写的代码，可能只有10%左右。也就是1000行代码中，大约100行是应用相关代码。</p>
<h4> 组件</h4>
<p>组件是用于特定用途的可复用的符合该组件类型约定标准的成品，可以在不同的应用系统中灵活地组装使用。类似于标准化的汽车零部件。比如消息中间件，可以可靠地在极短时间内接收和推送数亿条消息； 日志组件可以根据应用指定的配置打印格式多样化的不同级别的信息到指定的输出流中；工作流组件可以将业务流程(比如审批)抽象成一个个顺序或分支节点来执行和完成。应用框架也是一种组件。组件使得初始应用系统可以从更大粒度进行组装完成，在后续开发和维护中也可以灵活地进行去旧换新。</p>
<p>如果想了解更多组件类型，可参考网站： Java开源组件 。Java 语言中，组件采用 Jar 包的形式，使用开源组件 Maven 自动化管理。</p>
<h4> 控件</h4>
<p>控件是指那些能够容纳数据和展示数据的客户端界面。比如文本框、表格、图片、图表等。控件由数据模型、数据管理器和界面组成。数据模型是控件可以容纳的数据结构的形式，比如字符串、记录列表、二维数组等，界面就是用于展示数据模型容纳的数据的可视化的视觉子组件；而数据管理器则是可以用于搜索、过滤、排序、下载等操作的子组件。数据模型是控件的数据部分，界面是控件的视图部分，数据管理器是控件的控制部分，通常称为“MVC”设计模式。</p>
<h4> 分布式</h4>
<p>分布式是利用部署在不同服务器上的大量子系统或子服务相互协作共同完成请求的。比如网站 W 给消费者提供行业咨询服务，可能要使用到云服务商 B 提供的大规模云服务器 E、负载均衡服务 L、关系数据库服务 R、开放存储服务 S、大数据离线计算服务 D，使用到 T 公司平台提供的第三方API接口，使用到 C 公司的 CDN ， 使用到 D 公司的域名解析服务， 使用到 E 网站提供的广告推广链接，而服务商 B 提供的服务器集群需要许多管理、监控、运维等内部系统 M 来维护，这些内部系统 M 可能使用 F 网站提供的链接和 G 网站提供的开源组件，使用到自身的云服务集群，而 F,G 网站也可能使用到 B 提供的云服务集群等。</p>
<p>再比如IAAS服务商 A ，为了提供可靠友好的云服务器服务接口 S ，需要前端控制台应用 F 调用 OpenApi 接口应用 O, O 又调用后台Dubbo服务应用 D, D 解析请求中的信息转发给对应地域的网关代理接口 P , P 将请求转发给控制系统 C , C 进行计算调度后发送虚拟机相关指令(比如重启)到指定的物理机 H 上执行相应的虚拟化、存储、网络底层模块接口 M 。这些物理机 H 需要定时上报心跳给控制系统 C ，需要在底层模块处理成功或失败的时候推送消息给消息中间件 N ， N 需要推送消息给控制系统 C 来更新其数据库服务器 R 上的虚拟机状态。 所有这些应用 F,O,D P, C, R 都是部署多台服务器来避免单点故障的， 而 H 则更是分布在不同地域不同机房的数万台物理机中的某一台。</p>
<p>简单地理解，一个跨地域、通过多人并协作完成目标的组织机构，就是分布式的。分布式系统可以组合廉价服务器来获取高可靠高可用，可以通过多个中小型应用并发、协作地完成高难度的计算目标（比如基因测序)，其潜能非常巨大。不过分布式系统具有并发所带来的难题，同时又增加了不同机器之间的时序同步、数据不一致性等疑难问题，具有相当高的复杂度。</p>
<h4> 互联网</h4>
<p>分布式的互联网，或许是人类构建的最为恢弘壮丽而错综复杂的系统了，一个全新的虚拟世界，远超过埃菲尔铁塔和万里长城，虽然后者也是令人震撼的杰作。数亿的在线访问用户、部署在数千万的服务器上的不计其数的应用服务、相互依赖的子服务协作良好地稳定而不知疲倦地运行着，并发的不确定性、机器时序分布式同步等带来的困扰，似乎并没有影响互联网正常秩序的运转。如果说这是人类智慧的结晶，也间接证明了上帝奇迹般的设计，—— 因为只要一个无规则的微小扰动，这些可能就根本不存在。</p>
<p>在山顶静静驻留一刻，或者在水的包围中静静驻留一刻，将是生命中难得的记忆之一。</p>
<p>在这一站中，我们领略了人们为了应对和攻克现实世界和实际工程中的难题所发明创造的具有实用性的可复用的数据结构和控制结构，感受到编程所创造的超级世界 —— 互联网。或许，这就是《终结者》中天网的雏形，一个还不具备足够智能和思考能力的处于胚胎期的生命体。未来将会怎样呢？ 无法得知，唯有珍惜此刻。</p>
<h2> 软件之道的思考</h2>
<h4> 性能与效率</h4>
<p>程序yuan永恒地追求着性能与效率。低性能几乎总是由不必要的重复操作造成的。比如在多重循环中重复地取出相同的值，在循环中重复创建开销很大的相同对象，在循环中一次次调用相同的网络服务接口（重复的网络传输开销），重复调用相同的接口获取相同的数据等。要达到高性能和高效率，就要聚焦热点区域，设计优良的结构，精打细算，去除那些不必要的重复操作，尽可能减少不必要的网络操作。</p>
<h4> 健壮性</h4>
<p>健壮性通常是对现实复杂性估计不足，没有考虑到：</p>
<ul>
<li>各种可能的非法输入：脏数据、不规则数据、格式合法但内容非法的数据、含恶意代码的数据等；</li>
<li>运行环境的低概率的不稳定，比如偶尔的网络波动，读取不到资源的URL等；</li>
<li>难以覆盖到所有场景的组合情况。<br>
对于第一点，尽可能对输入数据严苛地检查并拒绝；对于第二点，及时捕获异常打印日志并返回友好的提示信息；对于第三点，则要思虑周全，需要不断积累功底和经验才能做得更好(但永远无法做到完美)。</li>
</ul>
<h4> 可扩展性</h4>
<p>可扩展性涉及到对控制结构的设计。简单地使用顺序、分支、循环语句来编写代码实现需求总是可以的，毕竟这是数学家已经证明的事情； 不过，埋下的坑总有一天要让人跌进去的，虽然不用上医院，也要让人灰了头。</p>
<p>要达到良好的可扩展性，就要对控制结构进行仔细的设计。能够通用化的控制流程要设法抽离出来进行复用；尽量做到“模型与业务”分离。创建稳定可扩展的模型（比如主从模型、订阅-推送模型），将易变更的业务点抽离出来提供回调，允许根据实际情况进行适当的变更调节。</p>
<h4> 存储设计与请求构造</h4>
<p>从多源头解析和获取数据、对数据进行变换处理、聚合数据【可选】、构造和发送请求 或 存储数据、从多源头解析和获得数据、对数据进行变换处理、聚合数据【可选】、构造和发送请求 或 存储数据、。。。， 大部分互联网应用在不知疲倦无休无止地重复做着这些事情。数据的存储设计，即存取和组织数据的结构设计，与请求流的构造， 是完成具体业务功能的两大要素。</p>
<h4> 配置式的软件通用框架</h4>
<p>当仔细观察和推敲软件的构成和运行时会发现，软件一直在做的事情就是：构造请求、发送请求、获取数据、聚合数据、存储数据。或许我们可以做成一个可配置式的软件通用框架：可配置的请求参数列表、可配置的服务名称、可配置的数据获取器、可配置的可灵活组合的数据聚合器、标准化的数据存储设计，即服务模板的可配置化和服务调用的可配置化。这些都与具体的业务无关。就像规则引擎做的那样，将业务逻辑以规则的形式进行动态配置，通过将对象匹配规则和触发规则来完成实际功能。一旦服务可以实现可配置化，那么，就像5分钟搭建一个WordPress博客一样，或许我们也能在5分钟内搭建起一个可以运行的实际系统，需要填充的只是具体的参数和流程配置。</p>
<h4> 编程之道</h4>
<p>创建和使用结构来组织和容纳数据，创建和使用相应的控制结构来遍历结构处理数据，创建结构来聚合重组数据作为最终展示，这就是编程之道。编程是结构的艺术。</p>
<h4> 数据-结构-控制-流</h4>
<p>从0和1出发到现在，似乎已经走过很长的一段路程。我们已经登上山顶。山顶上风光无限，山下的房屋像蚂蚁一样密密麻麻地排列着，河流蜿蜒地流淌在群山之间。现在，让我们闭上眼，感受下软件的生命灵动：大流量的数据在控制流的指引下，像水流一样穿梭流动于形态各异的结构中，犹如车辆在道路的指引下川流不息。如果结构设计得不够好，数据就会像水流撞在暗礁上那样溅起水花，出现错误或不一致的数据；如果控制设计得不够好，那么数据就会在结构中堵塞滞留，导致系统出现各种问题甚至崩溃。数据-结构-控制-流，这就是运行中的软件，亦即运行中的世界。</p>
<h4> 路线图</h4>
<figure><figcaption>img_5.png</figcaption></figure>
]]></content>
    <category term="设计原理"/>
    <published>2023-10-31T11:10:45.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:抽象</title>
    <id>https://ujava.cn/principle/second.html</id>
    <link href="https://ujava.cn/principle/second.html"/>
    <updated>2023-10-31T11:10:45.000Z</updated>
    <summary type="html"><![CDATA[<h2> 抽象（编程的实质）</h2>
<p>抽象是针对问题的特征对现实事物的紧密相关的属性的提炼过程及结果。程序中弥漫着大大小小的抽象。 分页控件是对分页功能的抽象，<br>
Extjs 中 store 是对组件的数据管理者的抽象， Java 并发库是对底层多核处理器的抽象， 拦截器，回调函数， Socket , 管道， 消息，<br>
对象， 都是对现实世界的某种实体的抽象。 没有抽象， 也可以写出程序； 但当系统越来越大时， 就会无休止地重复相似的代码，<br>
使系统变得臃肿而难以忍受； 而通过将实体和事件抽象成简洁的概念并找到一致的处理方法， 就可能开发出更为简洁优雅的方案。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 抽象（编程的实质）</h2>
<p>抽象是针对问题的特征对现实事物的紧密相关的属性的提炼过程及结果。程序中弥漫着大大小小的抽象。 分页控件是对分页功能的抽象，<br>
Extjs 中 store 是对组件的数据管理者的抽象， Java 并发库是对底层多核处理器的抽象， 拦截器，回调函数， Socket , 管道， 消息，<br>
对象， 都是对现实世界的某种实体的抽象。 没有抽象， 也可以写出程序； 但当系统越来越大时， 就会无休止地重复相似的代码，<br>
使系统变得臃肿而难以忍受； 而通过将实体和事件抽象成简洁的概念并找到一致的处理方法， 就可能开发出更为简洁优雅的方案。</p>
<p>编程的实质是抽象与表达。 将现实世界的问题抽象成容易处理的可计算对象，然后使用计算语言来实现它。</p>
<p>编程可以是一种冥想与表达的过程，一种纯粹的心智活动，甚至不需要计算机，就可编程。不是敲入屏幕的一行行字符，而是淌过心里的一条流，从来处来，往去处去，这才是编程之美。</p>
<p>如果善于将万事万物予以合理的抽象，掌握对这些抽象的处理手段， 那么，表达与编程将是一件非常流畅自然的事情，就像 《SICP》 做的那样；<br>
不然，就只好凭有限的思维、经验与一时的直觉来编写还算能工作的代码，艰难地与现实困境作战了。这也是抽象思维能力强弱将导致的差别。</p>
<p>因此， 编程不仅仅只是编写和练习， 更是思考与冥想的过程； 编程与弹钢琴相似，都需要大量的练习； 编程又与弹钢琴不一样：<br>
弹钢琴更需要娴熟的手法，而编程更倾向于作为一种缜密的心智活动， 心思到了，编程也就下笔千言了。</p>
<h2> 在合适的抽象层次上思考问题</h2>
<p>程序员通常是在一定的抽象层次上思考问题。 int i = 4 , 从最底层来看， 是将某个内存地址 0xXXXXXXXX 填入数值 0x04 ， 对于小程序，<br>
当然可以这么思考； 但是， 当面对一个软件系统时， 总是以这个层面来思考问题就显得非常吃力了。 此时， 它的合适语义是： “将变量 i<br>
赋值为 4 ， 变量 i 代表着某个地址， 但我们暂时不需要去关注是哪个地址。” 这是更高抽象层的思考。 再高一层，<br>
可能是在函数、类、组件级别的语义层面上来理解程序。</p>
<p>抽象， 意味着要学会在合适的语义层面来理解程序， 而不是从最原始最底层的地方开始。 api 文档， 或者语言规范，<br>
即是定义了某个实体的标准可参考的语义。 因此， 写 java web 应用写到一定程度， 会去阅读 Servlet 规范和 JVM 规范。</p>
<p>开发的本质是解决问题。 将问题表达为可计算的对象， 使用编程语言、开发框架、组件、库、包等各种抽象的编程设施来实现它。开发一个功能可以分为三步：</p>
<ol>
<li>理解需求， 分析问题， 并将问题抽象成可计算的对象；</li>
<li>从编程语言、开发框架、组件、库、包等提供的抽象工具中寻找适合处理指定对象的编程设施；</li>
<li>将编程设施作用于处理的计算对象， 实现问题的解决方案。</li>
</ol>
<h2> 计算世界里的抽象</h2>
<ul>
<li>计算机世界里的抽象无处不在。</li>
<li>技术是问题的解决方案和手段的机制抽象； 每一类技术都建立了一套抽象，针对所面临的问题提出一种一致的机制，然后遵从该机制来实现这一类问题的求解；</li>
<li>开发框架是对不可变的过程抽象，将可变部分留给应用开发者根据具体问题域来定义和实现；</li>
<li>编程语言是对硬件执行的语义抽象；</li>
<li>标准库SDK 是对常用子任务的过程抽象或数据抽象；</li>
<li>操作系统是对进程实例执行的过程抽象；</li>
<li>数据库是对大量数据存储、查询与汇总统计的抽象；</li>
<li>网络是对计算互联与远程数据传输的抽象；</li>
</ul>
<figure><figcaption>img.png</figcaption></figure>
<p>所有这些抽象都是一种强有力的工具。抽象，实现了“关注点分离”的原则，将一件复杂而完整的应用系统分解成多个子系统，各司其责，更容易构建和维护；<br>
善于系统地使用抽象， 在合适的抽象层次上思考问题， 或许就真正掌握了编程之道。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-10-31T11:10:45.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原理:代码抽象与分层</title>
    <id>https://ujava.cn/principle/third.html</id>
    <link href="https://ujava.cn/principle/third.html"/>
    <updated>2023-10-31T11:10:45.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p>抽象与分层，是计算与程序世界里最根本的思想。逻辑之始。</p>
</blockquote>
<h2> 抽象</h2>
<h4> 抽象在代码中</h4>
<p>有同学会问：抽象是什么？看上去真的很难懂啊！ 实际上，抽象就隐藏在写下的每一行代码里。</p>
<p>抽象主要有通用域抽象和领域抽象。通用域抽象是所有软件都会复用的概念、实体与交互；领域抽象则特定于某个具体的行业领域。抽象通常使用术语来表达。</p>
<p>让我们来重新看看写过的代码，从中找出抽象吧！</p>
<p>主要有六类抽象：</p>
<ul>
<li>流程型抽象： 表达应用流程，将单一功能构造成实用的服务</li>
<li>任务型抽象： 使用有限可控的任务执行者集稳定高效地完成源源不断来临的任务</li>
<li>数据处理抽象： 任务的实际内容</li>
<li>结构型抽象： 存储和容纳执行任务所需要的资源、数据集</li>
<li>数据模型抽象： 具有语义关联的数据项聚合体</li>
<li>原子数据抽象： 组成数据的基本数据单位</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p>抽象与分层，是计算与程序世界里最根本的思想。逻辑之始。</p>
</blockquote>
<h2> 抽象</h2>
<h4> 抽象在代码中</h4>
<p>有同学会问：抽象是什么？看上去真的很难懂啊！ 实际上，抽象就隐藏在写下的每一行代码里。</p>
<p>抽象主要有通用域抽象和领域抽象。通用域抽象是所有软件都会复用的概念、实体与交互；领域抽象则特定于某个具体的行业领域。抽象通常使用术语来表达。</p>
<p>让我们来重新看看写过的代码，从中找出抽象吧！</p>
<p>主要有六类抽象：</p>
<ul>
<li>流程型抽象： 表达应用流程，将单一功能构造成实用的服务</li>
<li>任务型抽象： 使用有限可控的任务执行者集稳定高效地完成源源不断来临的任务</li>
<li>数据处理抽象： 任务的实际内容</li>
<li>结构型抽象： 存储和容纳执行任务所需要的资源、数据集</li>
<li>数据模型抽象： 具有语义关联的数据项聚合体</li>
<li>原子数据抽象： 组成数据的基本数据单位</li>
</ul>
<h2> 六类抽象</h2>
<h4> 流程型抽象</h4>
<p>流程型抽象，是对各种应用流程的表达，控制和引导流程的实体。</p>
<p>流程抽象要解决应用中的请求（及携带的数据）在流程及节点里的处理流转。这些流转有分支、循环、回溯、转发、路由、阻塞、等待、退出等。</p>
<ul>
<li>Entrance: 入口 ； Exit: 出口</li>
<li>Flow: 流程，具有入口 Entrance 和出口 Exit 的NodePath</li>
<li>Node: Flow 中的节点</li>
<li>NodePath: 节点路径，由一系列节点及连接组成的子流程</li>
<li>Condition: 触发条件，决定流程的转向</li>
<li>Request: 请求 ； Response: 响应 ;</li>
<li>Component: 组件，Node 的能力抽象</li>
<li>Dependency: Node 之间的依赖关系</li>
<li>Plugin: 具有不同功能的插件，可配置化，Component 的一种形态</li>
<li>Service: 提供某种全局服务，通常是单例，Component 的一种形态</li>
<li>Enginer: 引擎，控制整个流程的执行</li>
<li>Initializer：流程启动时，元数据、配置依赖及全局服务的初始化，比如Spring进行Bean初始化</li>
<li>Handler: 接收请求 Request ， 输出响应 Response</li>
<li>Filter: 过滤掉不能处理的请求 Request</li>
<li>Goto: 直接跳转到某个 Node</li>
<li>Dispatcher: 将 Request 转发给合适的 Handler</li>
<li>Router: 将 Request 路由到适合的地方做下一步处理</li>
<li>Tracer: NodePath 的追踪与记录</li>
<li>Switcher: 流程开关，根据匹配结果切换到某个 NodePath</li>
<li>Breaker: 适配某种 Condition 时，退出所在 NodePath</li>
<li>Blocker: 阻塞 NodePath ，通常是某种 Condition 未能满足</li>
<li>Joiner: 动态加入者，可以是 Node, NodePath , Component 等</li>
<li>ConflictSolver: 当条件适配多种规则或节点时的解决策略</li>
<li>Waiter: 等待某种 Condition 触发的实体</li>
<li>Notifier: 触发某种 Condition 的实体</li>
<li>Terminator: Flow 的终结者</li>
</ul>
<h4> 任务型抽象</h4>
<p>功能的实现，可以抽象为任务来处理。任务型抽象包含了用于执行任务的实体。</p>
<p>任务型抽象必须解决“有限可控的任务执行者集合”与“任务集合的增减不可控”之间的矛盾。因为应用内存是有限的，不能无限增长，因此必须用可控地执行数量和抵达速率均不可控的任务集合。</p>
<ul>
<li>Function: 实现某种功能的表达</li>
<li>Task: 基于 Function 的通用任务语义</li>
<li>Job: 通常指不受人工干预的后台运行的 Task</li>
<li>Resource: 完成任务所需要的资源</li>
<li>TasksHolder: Task 持有者，通常是任务队列</li>
<li>Worker：从 TasksHolder 取出 Task 并实际执行者</li>
<li>Pool: 池对象，有限 Worker 的持有者，并使之增减可控和合理利用</li>
<li>Executor：将 Worker 和 Pool 组合起来执行任务的管理者</li>
<li>ResultFetcher: Task 执行结果的获取</li>
<li>Rejecter: 拒绝执行的实体，通常采用某种策略 Strategy</li>
<li>Protector: 保护 Woker 不受干扰正确执行，比如锁 * Lock * ，同步 Sychronizer 等</li>
<li>Lock: 并发执行下的锁，Protector 的一种形态</li>
<li>Sychronizer: 并发执行的同步体，通常会使用一个监视器</li>
<li>Cleaner: 清理/释放 Resource</li>
<li>State: Task 或 Worker 或 Pool 或 Executor 的状态</li>
<li>Strategy: Task 的执行策略，当没有足够 Worker 时要采取的处理策略</li>
</ul>
<h4> 数据处理抽象</h4>
<p>数据处理抽象，是对数据或数据集执行特定操作的实体。在程序中尤为多见。</p>
<ul>
<li>Assembler: 数据组装，将来自多个源的数据组装成中间或最终对象</li>
<li>Builder: 参数构建、结果构建。 还专门有个 Builder 模式来构建复杂对象</li>
<li>Checker: 参数校验、结果校验， 检测参数是否合法，结果是否符合预期</li>
<li>Caster： 数据的类型转换</li>
<li>Converter： 数据转换，将数据从一个形态转换为另一个形态</li>
<li>Formatter： 按照某种格式聚合和输出可读的数据形态</li>
<li>Fetcher: 从某个 DataSource 获取数据</li>
<li>Cacher：数据的缓存，复用提升性能</li>
<li>Copier：将数据从一个结构拷贝到另一个结构</li>
<li>Sync: 将大数据集从一个源同步到另一个源</li>
<li>Extracter : 数据提取，从复杂数据结构解析出所需字段和信息，比如从 JSON 或 XML 中解析出所需信息</li>
<li>Parser： 数据解析，从一种表现形态解析为另一种表现形态，数据信息不变，比如 JSON 转为 Map，日期转时间戳</li>
<li>Transfer: 数据类型传输，从 DO 到 DTO</li>
<li>Transfomer: 数据变换，从一种形态变换到另一种</li>
<li>Getter: 从对象中获取某个字段的值 ; Setter: 设置对象的某个字段的值</li>
<li>Finder： 查找到符合条件的数据或数据的位置</li>
<li>Replacer： 使用某个数据替换掉指定数据</li>
<li>Iterator: 迭代遍历地访问某种数据结构而屏蔽内部实现细节</li>
<li>Joiner: 将多个不同列的数据集根据关联字段合并为一个具有所有列的数据集</li>
<li>Matcher： 将数据匹配某个条件或模式</li>
<li>Merger： 将多个子数据集合并为一个汇总的数据集</li>
<li>Splitter: 将一个聚合的数据集分割为多个子数据</li>
<li>Separator: 分割符、关注点隔离</li>
<li>Collector: 从Stream里根据指定操作收集数据并构建出新的数据集</li>
<li>Filter: 根据指定条件从一个数据集中筛选出指定的数据构成新的数据集</li>
<li>Foreach： 遍历数据集的每个元素并执行某种操作</li>
<li>Grouper: 对数据集根据某个条件进行分组</li>
<li>Generator: 数据集的生产者</li>
<li>Mapper: 将一个数据集映射为另一个数据集</li>
<li>Reducer: 对某个集合的元素反复执行某种指定操作得到数据集或单个数据结果</li>
<li>Supplier: 数据集的提供者</li>
<li>Searcher: 从一个结构中搜索某个元素</li>
<li>Sorter：排序，将数据集按照某个顺序重新组合成新的数据集，每个相邻元素都满足某种指定条件</li>
<li>Add&amp;Delete：在某个结构中添加/删除数据</li>
<li>Query: 客户端向服务端请求数据</li>
<li>Selecter: 选择，从数据集或组合结构中选择符合某种条件的元素集合，比如DOM Selecter, SQL Selector</li>
<li>Updater：更新，将已有的数据更新为新的状态</li>
</ul>
<h2> 结构型抽象</h2>
<p>结构型抽象，用于存储数据集，便于批量高效地处理。</p>
<ul>
<li>Buffer: 缓冲</li>
<li>BitMap: 位图</li>
<li>Empty: 空结构</li>
<li>Enum: 有限可列元素的枚举</li>
<li>File: 具有文本语义的数据簇的聚合</li>
<li>List：有序、可重复的数据组成的列表</li>
<li>Set：无序、不重复的数据组成的集合</li>
<li>Map: 键-值对</li>
<li>Stack : 后进先出的数据结构</li>
<li>Queue：队列，一般是先进先出</li>
<li>Heap: 前驱元素与后继元素总是满足某种比较关系的数据结构</li>
<li>Partition：分区，将数据集分区为多个子数据集进行存储和处理</li>
<li>Tree: 树，有分叉的数据结构</li>
<li>Graph: 图，节点相互有连通的数据结构</li>
<li>Stream: 具有惰性计算能力的、可无界的数据结构</li>
<li>Text: 文本，具有松散结果的字符串数据聚合</li>
</ul>
<h4> 数据模型抽象</h4>
<p>数据模型，将有关联的一系列数据组成携带领域语义的对象</p>
<ul>
<li>Class: 类，类别； 具有相似性的实例的普遍性表达</li>
<li>Config: 配置，一般是 键值对，JSON，XML，Yaml 等，来自文件、内存数据等</li>
<li>Context: 上下文，在流程中起串联所有必要资源的作用</li>
<li>MetaData: 元数据，描述数据及结构的数据</li>
<li>Entity&amp;Object： 通用实体/领域实体</li>
<li>Instance: 实例，实体的某个存在</li>
<li>Field: 字段，包含字段的名称、类型、修饰符等信息</li>
<li>Property&amp;Attribute: 属性，包含属性的名称、类型、修饰符等信息</li>
<li>State: 实例的状态</li>
<li>Method: 方法，实例行为的表达</li>
<li>Factory: 工厂，组件的创建者</li>
<li>Holder：任意对象的持有者，通常与泛型结合使用</li>
<li>Model: 数据模型，定义返回对象包含的数据字段及类型</li>
<li>Pager: 分页，页数和页大小</li>
<li>Result: 结果，通常包含 code, message, data</li>
<li>Placeholder： 占位符，内含待替换的引用变量</li>
<li>Option: 可选项</li>
<li>Range: 区间，最常见的就是时间区间</li>
<li>Tuple: 元组，若干语义关联的数据聚合体</li>
<li>Record: 记录，具有语义关联的数据聚合而成</li>
<li>Message: 消息</li>
<li>Tag: 标签，从某个角度标识某个实体</li>
<li>Variable: 变量，临时可变数据的持有者</li>
</ul>
<h2> 原子数据抽象</h2>
<p>原子数据，是组成数据的基本数据单位。</p>
<ul>
<li>Bit: 位</li>
<li>Byte: 字节</li>
<li>Bool： 真，假</li>
<li>Char：单个字符</li>
<li>Int&amp;Long：整数</li>
<li>Float&amp;Double：浮点数</li>
<li>Number：数值</li>
<li>String：有序字符列表组成的字符串</li>
<li>Constant： 常量</li>
<li>Error&amp;Exception: 错误与异常</li>
<li>Pointer: 指针，存储指向对象的内存地址</li>
<li>Reference: 对象的引用者</li>
</ul>
<h4> 抽象的实际应用</h4>
<p>从程序中提炼抽象后，如何应用到实际工作中呢？</p>
<p>实际程序中，往往是上述抽象的灵活组合。 各种抽象的关系，在程序中的体现是：</p>
<blockquote>
<p>原子数据抽象 -&gt; 聚合为数据模型抽象 -&gt; 由结构型抽象来存储 -&gt; 通过数据处理抽象 -&gt; 组合为任务抽象 -&gt;<br>
通过流程抽象来控制任务执行和流转 -&gt; 最终流程实现</p>
</blockquote>
<p>在命名时，可以直接使用这些词汇，凸显语义，使代码更容易可读可理解。</p>
<h2> 分层</h2>
<p>分层，就是将提炼出的抽象置于合适的语义层次。 比如常用的Controller, FacadeService, BaseService, DAO， Repository 等，就是不同的层次。</p>
<p>分层原则主要有：</p>
<ul>
<li>高层语义表达意图，底层语义呈现细节。</li>
<li>上一层依赖下一层的语义抽象而不是实现。</li>
<li>业务层 -&gt; 共享产品层 -&gt; 共享层 -&gt; 基础层</li>
<li>相同层次一般不相互直接调用，比如 Controller 不要直接调用其他的 Controller 的东西。</li>
<li>不建议跨层调用，比如 Controller 不直接调用 DAO 的功能。</li>
<li>原子语义的层次，与组合语义的层次不要混杂在一起。</li>
</ul>
<p>合适的语义层次划分，会使流程和交互更加清晰可读容易理解。</p>
<h2> 缺失抽象与分层会怎样</h2>
<h4> 抽象缺失</h4>
<p>最近排查解决一个问题，大概是这样的：</p>
<ul>
<li>存储层： 订单的赠品的价格数据存储，没有存储相应的商品ID(订单内的正常商品是一定有的)；</li>
<li>中间层： 无法取到订单赠品的价格信息（没法对应上）；</li>
<li>输出层： 一些报表字段的输出没有考虑到对赠品的处理，导致输出有误；要对赠品做一些特殊的逻辑处理。</li>
</ul>
<p>看上去不存储赠品的商品ID，也不算是什么问题；但从抽象角度来看，是不能理解的。赠品虽然与商品在价格上表现有些特殊，但在商品ID存储上，并没有特别之处。如果能够一致性地处理，那么就不会出现无法取到赠品信息的价格信息，也不需要针对赠品做一些特殊的兼容（比如聚合价格数据对应到商品时有特殊处理、报表字段输出的逻辑要过滤赠品等），也就不需要花时间去调试和排查解决这个问题。</p>
<p>突然想到那个问题：软件维护成本是怎么产生的？除新需求外，往往来自之前埋下的坑。那么坑又是怎么产生的呢？通常是设计不严谨导致。<br>
由于设计不严谨，遇到特定情况或者扩展就要做特殊处理，要做兼容，一个兼容可能引发一系列兼容，尤其源头的不严谨，会导致源到端的一整条路径的兼容，代码就会比较难看难理解，这样就埋坑了；解决坑的时候，兼容性的解决方案，在事情的变化中又会埋下新的坑。程序猿媛们就在埋坑和填坑的往复循环中“痛并快乐着”。</p>
<p>那么设计不严谨又是怎么产生的呢？<br>
通常是抽象和分层做的不够导致的。开发人员习惯于按照流程顺手写下来，而不细思和提炼出流程中的概念、关联、实体、交互等，将其构建成一件更有序更柔软的逻辑装置。结果就是当有变化或变体的时候，装置就出毛病罢工，就要做修修补补。因此，建议能够克制性地退后一步思考，不急于着手，而是先仔细推敲流程，提炼出关键因素，进行抽象和分层，在其指引下进行设计和开发。这个建议也是给自己的。</p>
<h4> 分层缺失</h4>
<p>工作伙伴CR我的代码时，有时会觉得我写的代码看起来比较累。这并不是因为我写的函数很长。实际上，我很注重代码复用，写的函数都是比较短小的，按理来说不应该有这样的感受。</p>
<p>仔细思考后发现，是分层不够清晰导致。就是写程序时，往往需要的函数就写到一个类里，导致这个类混杂了很多功能，掺杂了很多不同的语义，导致理解流程时不够直观清晰。</p>
<p>通过抽象和分层，将不同功能语义抽离到不同的类中实现，并在合适的地方引入依赖，这样代码层次就更容易理解可读了。</p>
<h2> 小结</h2>
<p>抽象与分层，是计算与程序世界里最根本的思想。逻辑之始。本文从代码中提炼了许多表达通用抽象语义的词汇，可以作为设计、开发和交流的指引，同时通过案例说明了抽象缺失和分层缺失导致的后果。对于开发人员，能够预先细致思考抽象与分层，做出的设计和写出的代码往往更加简洁优雅。</p>
]]></content>
    <category term="设计原理"/>
    <published>2023-10-31T11:10:45.000Z</published>
  </entry>
  <entry>
    <title type="text">第一梯队思想</title>
    <id>https://ujava.cn/mind/first.html</id>
    <link href="https://ujava.cn/mind/first.html"/>
    <updated>2023-10-31T10:25:33.000Z</updated>
    <summary type="html"><![CDATA[<h1> 第一梯队思想</h1>
<p>第一梯队思想，是计算机编程领域最为核心而根本的思想。因其威力强大，且无处不在，简直是天神般的存在。</p>
<h2> 编程</h2>
<p>编程没什么神秘的。本质上，编程与写作、绘画、雕塑一样，也是一种手艺，一种探索和求解问题的方式。只不过，编程高度依赖于算法步骤的正确性和可行性，需要高度的理性。</p>
<p>理性有三种类型：逻辑理性、沟通理性和思想理性。编程属于逻辑理性。逻辑理性要求逻辑层次是缜密无矛盾的，不能有一丝纰漏，否则可能会导致全盘溃败。逻辑理性是一层层堆叠起来的。上层的缜密依赖于下层的缜密。</p>
<p>构建逻辑理性的缜密性：</p>
<ul>
<li>原则与思想：从根本上构建行为一致性。</li>
<li>约定与惯例：减少多变环境下的管理。</li>
<li>推导与演绎：即给定若干条件及事实，能够正确推导出深入而广泛的结论。推导演绎能力是逻辑理性的生动体现和重要特征。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h1> 第一梯队思想</h1>
<p>第一梯队思想，是计算机编程领域最为核心而根本的思想。因其威力强大，且无处不在，简直是天神般的存在。</p>
<h2> 编程</h2>
<p>编程没什么神秘的。本质上，编程与写作、绘画、雕塑一样，也是一种手艺，一种探索和求解问题的方式。只不过，编程高度依赖于算法步骤的正确性和可行性，需要高度的理性。</p>
<p>理性有三种类型：逻辑理性、沟通理性和思想理性。编程属于逻辑理性。逻辑理性要求逻辑层次是缜密无矛盾的，不能有一丝纰漏，否则可能会导致全盘溃败。逻辑理性是一层层堆叠起来的。上层的缜密依赖于下层的缜密。</p>
<p>构建逻辑理性的缜密性：</p>
<ul>
<li>原则与思想：从根本上构建行为一致性。</li>
<li>约定与惯例：减少多变环境下的管理。</li>
<li>推导与演绎：即给定若干条件及事实，能够正确推导出深入而广泛的结论。推导演绎能力是逻辑理性的生动体现和重要特征。</li>
</ul>
<h2> 结构化</h2>
<p>结构化是编程领域的第一性原理。</p>
<p>软件，本质上是一种可动态而弹性变化的逻辑装置。结构化，即是将逻辑进行抽象、提炼、分离、组合，构建成缜密、动态、弹性的结构流。</p>
<h2> 关注点分离</h2>
<p>关注点分离，是有序组织大规模逻辑结构的根本性思想。</p>
<p>软件中蕴藏着不计其数的大大小小的关注点。软件开发和设计的本质，就是将关注点分离、组织、连接。 能够将不同的关注点分离开，再合理有序地组织起来，呈现在代码里，就离写出清晰可维护的代码不远了。</p>
<p>从“关注点分离”思想，可以推导出很多重要的软件开发和设计思想。</p>
<h2> 抽象</h2>
<p>优雅的编程始于抽象。</p>
<p>萃取出主要特征，而摒弃次要或不相关的特征；无需了解事物的内部实现细节而基于其提供的抽象来构造应用。声明与实现相分离；语义与细节分离。</p>
<p>计算机科学中的抽象俯拾即是，比如指令集是对机器硬件执行能力的基础抽象，高级程序语言是对机器硬件执行能力的更高层次的抽象，进程是对程序一次执行的抽象等。</p>
<h2> 封装</h2>
<p>由抽象直接引出的重要概念就是封装。封装是抽象的实现形式。比如，函数是算法的封装，对象是属性与关联逻辑的封装。封装是实现软件模块化、提高软件可维护性的重要思想，是许多软件工程思想的源头。比如隔离变化， 将变化的影响局部化等。封装在计算机软件领域内俯拾即是。比如系统调用，是对操作系统能力的封装； SDK 是利用某种语言或技术进行开发的封装；框架，是对通用技术逻辑流程的封装。</p>
<p>日常生活中，封装的例子也不计其数。任何一个产品设计，都是一种复杂事物的封装。举个例子，汽车方向盘和刹车油门就是汽车驾驶的封装。几乎不需要知道汽车的具体运转原理，只要掌握好方向盘和刹车油门就能驾驶汽车；比如火箭发射，不需要知道火箭的发射原理，只要知道按下哪个按钮即可。</p>
<h2> 复用</h2>
<p>没有封装就没有复用。复用是微小的编程能够构建起虚拟大千世界的最重要的秘诀。先构建一个小块，然后在这个小块上构建更大的块，就像建造房子一样。从泥到砖，从砖到墙，从墙到房子四围。最典型的例子就是积木。积木是可复用的组块，在积木的基础上可以建造各种各样的形状。</p>
<p>复用是软件工程领域的重要思想。从 LinuxShell、标准库函数，STL，JDK这样的代码级复用，到 Struts，Spring 的应用框架复用， 以及 设计模式的复用， 解决方案的复用， 复用无处不在。 复用是站在巨人的肩膀上， 能够直接利用专家级的知识和经验，何乐而不为？</p>
<p>新的更优的解决方案往往是现有可复用方案的组合创新。</p>
<h2> 分治</h2>
<p>分治几乎是求解编程问题的万能思路。难以求解的问题，都可以分解成若干个可以在能力范围内解决的子问题；如果还不能求解，继续分解。自顶向下，逻辑树法，都是分治法的典型应用。</p>
<p>自顶向下，即是根据目标先分解成一系列的子目标，然后再根据这些子目标进一步分解成子子目标，就像公司的组织结构一样。直到子子目标可以被完成。自顶向下法可用于系统设计、任务分解等。</p>
<p>逻辑树，即是先根据一个论点，引出若干个子论点，然后每个子论点又可以引出若干个子子论点，每个子子论点都可以由相应的论据支撑，最终形成缜密的论证逻辑。逻辑树法可用于工作汇报、数学证明等。</p>
<p>实际工程应用中，分表、分库、分区、分片、微服务，都是分治思想的应用。可以按时间、冷热、业务ID、不同业务分。可以按范围分，也可以哈希映射。</p>
<h2> 组合</h2>
<p>有分即有合。单一逻辑单元能够做的事情很有限，但是多个逻辑单元组合起来就能完成很强大的功能。就像一个人的力量有限，但如果多个人的力量团结起来，就不可估量了。</p>
<p>函数式编程，即是充分利用短小函数及各种组合方式，构建出强大的功能。</p>
<p>组合是构建强大功能的最重要的方式之一。</p>
<h2> 缓存</h2>
<p>缓存是性能加速的重要法宝。在计算机体系结构里，缓存的身影无处不在。</p>
<ul>
<li>CPU 三级缓存</li>
<li>存储器层次体系结构</li>
<li>内存缓存/分布式缓存</li>
<li>预编译缓存</li>
<li>数据库缓存</li>
<li>浏览器缓存</li>
<li>CDN缓存</li>
<li>代理缓存</li>
<li>域名系统</li>
<li>计算结果缓存</li>
</ul>
<h2> 解耦</h2>
<p>解耦是软件应对多变需求和软件复杂性的重要思想。如果缺乏解耦，软件就会缠绕成一团，无法解开，难以修改，很容易出错。</p>
<p>现代软件工程与技术，实际上就是在各个层次上进行解耦。</p>
<ul>
<li>高级语言与编译器：将编程语义与实际机器执行实现解耦</li>
<li>开闭原则：将基于同一数据源的不同业务的处理解耦</li>
<li>插件架构：将基于同一系统的不同功能的定制解耦</li>
<li>设计模式：将对象的职责与交互解耦</li>
<li>事件与队列机制：将事件的发生与处理解耦；将消息的发送与接收处理解耦</li>
<li>框架： 将应用业务逻辑与通用技术逻辑流程解耦</li>
<li>JVM： 将指令执行与操作系统平台解耦</li>
<li>容器： 将应用运行环境与操作系统平台解耦</li>
<li>K8S： 将应用的部署与基础设施和资源利用解耦</li>
</ul>
<p>解耦思想直接带来了软件工程领域的“高内聚、低耦合”的软件模块化实践。模块化实践大幅降低了软件长期维护的复杂性。</p>
<figure><figcaption>img.png</figcaption></figure>
<h2> 编码</h2>
<p>上述思想都有点”玄虚“，但编码却是实实在在的实践和基本编程思想。</p>
<p>要写程序，必定要将现实中的实体和活动编码成 01 串，进行处理，最后再解码还原到现实世界。编码是指将现实中的万事万物编码成01串的操作。神乎其技兮！</p>
<p>当然，现代编程并不是要编码成 0,1 串，而是使用高级编程语言来编码。因为高级编程语言是 0,1 串编码的封装。</p>
<p>精通编码，就能洞察程序世界，如镜透明。</p>
<h2> 协议</h2>
<p>计算机不是孤立地运行，人亦非孤岛般存在。让计算机能够彼此通信，让人们能够跨时空互联深入交流，是互联网的梦想。协议是网络程序相互协作的必不可少的要件和基石。协议解决计算机程序如何可靠通信的问题。</p>
<p>比如一次5个人的聚会吧，首先大家肯定要事先约定什么时候什么地点碰头，好各自安排行程；这是静态协议； 不过计划总赶不上变化。当实际去赴会时，会发现因为某位明星的到来导致路上特堵，结果2个人不能如约到达；这时候，就必须重新调整计划另约时间和地点，甚至还可能改变原来的游玩计划；或者在原计划中留下充分的缓冲余地。这就是协议要做的事情：约定与标准（碰头时间地点）、缓冲余地（容错）、动态调整（灵活性）。实际的通信协议可能更复杂，依据不同的应用而设定，不过原理是相同的。</p>
<p>协议是互联网通信的基本软件思想。最为人所熟知的莫过于 HTTP(S)， TCP 和 IP 协议了。</p>
<h2> 容错</h2>
<p>程序运行过程中，会遇到各种不可预料的情况，产生多姿多彩的错误。比如读文件，文件不存在、找不到、格式被破坏、有恶意代码；获取网络数据，网络波动或者中断；大流量下，扛不住压力而崩溃；甚至于直接掉电。</p>
<p>容错是设计健壮程序的不可或缺的重要考量因素。容错涉及到用户体验问题。试想，一个程序动不动就报错，谁能有耐心使用呢？</p>
<h2> 自动化</h2>
<p>自动化使得人从繁琐易错的事情中解脱出来， 从事更具有创造性的工作， 使人与计算机并行协作， 在计算机干活的时候人休息一会也不耽搁事情。善于发现可自动化的流程、规律、事务， 尽可能使用程序自动化和简化手工活， 减少或消除繁琐易错的手工操作。</p>
<p>高效可靠的自动化几乎是程序（员）存在的最主要的使命和价值。</p>
<h2> 预处理</h2>
<p>预处理，是指先对待处理数据做一波前期的处理，转换结构，然后再对转换后的结构进行操作，起到加速或方便处理的作用。</p>
<p>比如要多次查询一个无序列表里的元素，可以先把无需列表转成一个映射，再进行查询。这样多次查询的效率就会很高。</p>
<p>比如 Rete 算法，即是将一系列规则或模式，转换成一个拓扑图结构，然后再进行匹配。这样就比用原始结构的匹配更容易效率更高。</p>
<p>预处理有一定的前期开销，但能够为后续处理提供很大的便利或效率价值。</p>
<h2> 时空权衡</h2>
<p>时间换空间，或者空间换时间。</p>
<p>空间换时间，是提升性能的常用手段。比如缓存，就是用冗余的空间来换取快速的处理。</p>
<p>时间换空间，是解决内存不足的常用手段。比如要处理大量数据，不会一次性将所有数据都加载到内存里，而是分批次加载和处理，这样小内存也能解决大数据集，代价是处理时间会更长一些（因为需要更多次的加载）。</p>
<h2> 统筹规划</h2>
<p>统筹规划思想，注重在全局视角下解决问题。</p>
<p>找到关键路径和节点，解决这些路径和节点的问题，往往会加速整体流程的效率。</p>
<p>不在次要路径和节点上耗时耗力。</p>
<p>统筹规划的典型应用是项目路径规划，最短路径、资源配置优化。</p>
]]></content>
    <category term="设计思想"/>
    <published>2023-10-31T10:25:33.000Z</published>
  </entry>
  <entry>
    <title type="text">第二梯队思想</title>
    <id>https://ujava.cn/mind/second.html</id>
    <link href="https://ujava.cn/mind/second.html"/>
    <updated>2023-10-31T10:25:33.000Z</updated>
    <summary type="html"><![CDATA[<h1> 第二梯队思想</h1>
<p>第二梯队思想，虽然不如第一梯队思想那么通用广泛，却也是编程领域的重要思想，有着举足轻重的地位。</p>
<h2> 递归</h2>
<p>一个规模为N的问题的解可以由规模为S（S&lt;=N）的同样性质的问题的解来构造。</p>
<p>举个简单的例子，1+2+3+4+5 = 1 + (2+3+4+5) = 1 + (2 + (3+4+5)) = 1 + (2 + (3 + (4+5))) = 1 + (2 + (3 + (4+(5))))。 N 个数的和等于第 N 个数加上 N-1 个数的和。</p>
<p>递归技术是一种非常有效的程序设计技术。很多数据结构都有递归特性。列表、字符串、二叉树、JSON等。</p>]]></summary>
    <content type="html"><![CDATA[<h1> 第二梯队思想</h1>
<p>第二梯队思想，虽然不如第一梯队思想那么通用广泛，却也是编程领域的重要思想，有着举足轻重的地位。</p>
<h2> 递归</h2>
<p>一个规模为N的问题的解可以由规模为S（S&lt;=N）的同样性质的问题的解来构造。</p>
<p>举个简单的例子，1+2+3+4+5 = 1 + (2+3+4+5) = 1 + (2 + (3+4+5)) = 1 + (2 + (3 + (4+5))) = 1 + (2 + (3 + (4+(5))))。 N 个数的和等于第 N 个数加上 N-1 个数的和。</p>
<p>递归技术是一种非常有效的程序设计技术。很多数据结构都有递归特性。列表、字符串、二叉树、JSON等。</p>
<h2> 索引</h2>
<p>索引类似于书的目录。要定位某篇文章，只要按目录页码直接翻到对应页码即可，而无需一页一页地翻看和查找。</p>
<p>通过某种算法对数据项标识和设置索引值，从而能够按照索引值快速定位相应数据，提升查找效率。</p>
<p>索引是海量数据查询的技术基础，而海量数据查询是现代互联网应用的基石。</p>
<h2> 迭代</h2>
<p>迭代是使用固定的计算规则集合不断用新值取代旧值趋向真实值的控制结构。比如牛顿迭代法求N的平方根 X(k+1) = (X(k) + N/X(k))/2 (k&gt;=0) 就是一个迭代过程。可以指定初始值和终结迭代过程的迭代次数。迭代的重要指标是收敛性和收敛速度。</p>
<p>TDD 是一种迭代的测试开发方法论。先写好一个测试用例，运行测试用例，亮红灯，然后编程实现，再运行测试用例，亮绿灯。如此，一个测试用例就通过了。反复如此，直到所有测试用例都通过。迭代使得可控地趋于期望的目标。</p>
<h2> 遍历</h2>
<p>遍历是从结构中的某个初始节点出发，使用算法访问结构中的所有节点。遍历有深度优先遍历和广度优先遍历。</p>
<p>深度遍历是一直往一个方向走（一条胡同走到底），先遍历根节点的第一个子节点，然后是第一个子节点的第一个子节点，如此递归，直到没有子节点，然后回退到上一个可选择路径的节点，遍历其下的第二个子节点，接着第二个子节点的第一个子节点，递归，如此，其依次直至所有节点都访问完毕。</p>
<p>广度遍历是先遍历根节点的所有第一层子节点，遍历完成后，从第一层的第一个子节点开始，遍历该节点下的第二层的所有节点；然后再从第一层的第二个子节点，遍历该节点下的第二层的所有节点；如此，其依次直至所有节点都访问完毕。</p>
<h2> 中断</h2>
<p>当你正投入工作状态的时候，领导发话了：开会开会！ 于是你不得不放下手头“心爱”的事情，跑去听一段@#￥@#%@￥%@%#￥%#的讲话，讲话回来后再以莫名的心绪重新干活。当然，人是有记忆的，当你去开会前，实际上已经记忆了当时做的事情的一些重要细节和进程，这样在回来时就能从这些细节和进程逐渐恢复到当时状态继续干活，就像讲话似乎没发生过一样。这就是中断：做某件事，更高优先级事情插入，保存现场，完成更高优先级的事情，恢复现场，继续做原来的事情。</p>
<p>中断是计算机心脏 CPU 来应对系统内外各种事件的机制。当发生某种事件时，产生一个信号中断，CPU 会保存现场，去执行中断处理程序；待中断处理程序执行完成后，就会恢复现场，继续执行之前的查询。</p>
<p>中断提供了有效应对系统中各种事件、使得系统能够正常运转的重要机制。同时，它也是一种重要思想：保存现场，做更高优先级事情, 恢复现场。</p>
<h2> 回滚</h2>
<p>回滚是计算机执行发生错误时，希望能够回到某个保存点，以便下次能够接续执行。</p>
<p>回滚提供了一种可靠的中途接续执行机制。 事务机制是回滚思想的重要应用。</p>
<h2> 模板</h2>
<p>通过替换静态模板中的变量， 从而生成动态文本的思想和技术。</p>
<p>如果多个输出都具有相似的格式或流程，就可以定义模板，通过模板与具体数据的结合，来实现具体的输出。</p>
<p>比如结婚请柬就是典型大的模板应用。请柬上的大部分内容是相同的，只有被邀请的人是不一样的，这部分是空出待填充的。</p>
<h2> 模式</h2>
<p>模式，俗称套路，是已有经验的提炼和总结。适当借助模式，能够有效地复用已有经验和实践，高效处理问题，避免重复踩坑。</p>
<p>模式，有编程模式、设计模式、分析模式、架构模式、业务模式等。善于发现模式、使用模式，是站在专家的肩膀上，能够看得更远。模式，即是学会汲取别人的丰富经验。</p>
<p>用模式“斩断”日常问题后，才能腾出更多精力做有创造性的事情。</p>
<h2> 代理</h2>
<p>代理，顾名思义，就是代替某物做某事。</p>
<p>代理通常作为”中间人“，起着缓存、保护、延迟加载、负载均衡等作用。</p>
]]></content>
    <category term="设计思想"/>
    <published>2023-10-31T10:25:33.000Z</published>
  </entry>
  <entry>
    <title type="text">第三梯队思想</title>
    <id>https://ujava.cn/mind/third.html</id>
    <link href="https://ujava.cn/mind/third.html"/>
    <updated>2023-10-31T10:25:33.000Z</updated>
    <summary type="html"><![CDATA[<h1> 第三梯队思想</h1>
<p>第三梯队思想，是程序执行流程的高层构建块，能够用来构建灵活而强大的指令流程。</p>
<h2> 管道</h2>
<p>管道是类 Unix 系统的经典发明。管道将左边程序的输出传给右边程序的输入，可以轻易将连接的多个实用程序组成一条流水线，实现强大而多样化的功能（小程序、微功能）。</p>
<p>比如如下命令：在当前目录及子目录下的所有 .java 文件中查找匹配模式 pattern 的字符串，显示文件名，行号及匹配的行内容。</p>
<p><code>find . -name '*.java' | xargs awk ' $0 ~ /pattern/ { printf "%s : Line %s :\n%s \n" , FILENAME, FNR, $0 } ' | sed 's/^[[:space:]]\{1,\}/ /'</code></p>]]></summary>
    <content type="html"><![CDATA[<h1> 第三梯队思想</h1>
<p>第三梯队思想，是程序执行流程的高层构建块，能够用来构建灵活而强大的指令流程。</p>
<h2> 管道</h2>
<p>管道是类 Unix 系统的经典发明。管道将左边程序的输出传给右边程序的输入，可以轻易将连接的多个实用程序组成一条流水线，实现强大而多样化的功能（小程序、微功能）。</p>
<p>比如如下命令：在当前目录及子目录下的所有 .java 文件中查找匹配模式 pattern 的字符串，显示文件名，行号及匹配的行内容。</p>
<p><code>find . -name '*.java' | xargs awk ' $0 ~ /pattern/ { printf "%s : Line %s :\n%s \n" , FILENAME, FNR, $0 } ' | sed 's/^[[:space:]]\{1,\}/ /'</code></p>
<h2> 并发</h2>
<p>并发是同一个执行单元在一段时间内交替做多件事情。</p>
<p>比如一个人一边烧水，一遍看电视，一遍督促孩子做作业。看上去就像是在同一时间段内同时做了多件事情。由于某一项需要等待，往往在多项任务之间不断切换（保留现场和恢复现场）。切换会耗费一定的时间。</p>
<p>并发是利用多核的性能提升手段。事实上，并发也是世界运行的本质。这个世界正是由不计其数的人并发地去进行自己的活动所构建起来的。</p>
<h2> 并行</h2>
<p>并行是多个互相独立的执行单元在同一段时间相互独立地做不同事情。</p>
<p>比如一个公司里，产品在理需求，研发在做技术调研，两个人都是朝同一目标前进，但做着不同的事情。</p>
<p>并行是并发的一种更严格的形式。</p>
<h2> 批量</h2>
<p>涉及网络传输时，单个单个去获取数据和处理数据往往会比较慢，因为传输的次数增多，需要反复建立和销毁连接，会耗费不必要的连接建立时间和传输时间，尤其是连接建立成本、传输成本与处理成本相当甚至更大的情形。</p>
<p>比如传输一次需要 10s， 处理一个需要 5s。如果单个处理，那么处理 10 个需要 (10+5)10 = 150s；而如果一次批量获取10个，然后批量处理，则只需要 10 + 510 = 60s。 中间 90s 的传输成本都是不必要的。因此大量数据的获取和处理，往往是批量方式处理的。</p>
<p>比如运货，通常是一整箱一整箱地运送，而不是一个个的运送。</p>
<p>批量是提升大量数据处理的效率的常用手段。</p>
<h2> 异步</h2>
<p>异步最初是为了解决响应的体验问题。在提交后台任务执行的同时，给前端先返回一个消息，让用户能够有所感知，而不是百无聊赖的等待。异步，多用于解耦后台耗时任务与前台展示。</p>
<p>多路 IO 复用，是异步方式解决高并发问题的技术基础。</p>
<h2> 回调</h2>
<p>回调有点类似于埋点。指定做完一件事之后，要去处理一段特定逻辑，而这段特定逻辑可能是不同的。这段特定逻辑就称为回调逻辑。</p>
<p>回调能够让函数的功能更加灵活，是函数式编程的重要特征之一。回调的函数参数通常是函数指针。</p>
<h2> 延迟</h2>
<p>亦称惰性加载。仅在必要时才去加载、访问和计算。</p>
<p>通常用于创建需要耗费资源较大的对象，或者将访问和计算延迟到必要的时候才去进行，以减少不必要的消耗。</p>
<p>比如说，举办一次会议，仅在会前一天或几个小时，才有必要在会场去”铺设“饮用矿泉水。因为如果提前去铺设，万一会议取消了，或者转换场地了，那么这些努力（连带时间和精力）就都白费了；比如说颁奖，只有在需要颁奖的时候，才让获奖人上台领奖，而不是从一开始就在台前等着。</p>
<p>延迟加载的常见使用场景：</p>
<ul>
<li>大图片延迟加载。浏览网站时，往往会先展示图片的缩略图，点击之后才会展示原图，这即是一种延迟加载策略。</li>
<li>Stream 流计算。 从 Stream 流读取数据，可以进行 filter, map，flatmap 等各种操作，但只有在 collect 的时候才进行计算。</li>
<li>初始化大对象。 对于创建开销高昂的对象，仅在需要的时候才去创建。</li>
</ul>
<h2> 定时</h2>
<p>定时是在指定的时间周期性地做一件事。</p>
<p>软件系统中充满了各种定时任务。比如闹钟就是一个定时任务。</p>
<h2> 通知</h2>
<p>与定时的指定时间不同，通知，是在所关注的事情发生变化时，发送消息通知，以便做相应处理。</p>
<p>比如订阅了一个公众号，公众号在发布文章时，就会给你推送一个消息。</p>
<p>通知往往是基于事件驱动机制或订阅推送机制来实现的。</p>
<h2> 阻塞</h2>
<p>我们自然希望程序能够时时刻刻流畅无阻地永远运行下去，但人类的思维能力是有限的。面对现实的复杂多变，很难做到如此完美。</p>
<p>阻塞，也是一种重要的编程思想。阻塞用于两种情形：</p>
<ul>
<li>适当阻塞，可以消减大规模程序的快速运转状况下的时间差（这种时间差是人很难消除和预料的）导致的 BUG，让程序行为容易推断；</li>
<li>程序在大流量的侵袭下，适当阻塞，能够让程序免于瞬间崩溃，有效利用系统资源。<br>
当然，程序阻塞也可以实现让客户持续付费</li>
</ul>
<p>排队机制，也是一种阻塞实现。当数据量超过系统能力承载范围时，让数据先入队等待，待系统处理有余力时再出队处理。“生产者-消费者”模式就是一种经典的阻塞并发模式。</p>
<p>阻塞有利有弊。可控地阻塞时，可以让系统有节奏地处理； 重度阻塞时，就可能会导致系统运行进一步恶化，最终导致崩溃。不可不防。</p>
]]></content>
    <category term="设计思想"/>
    <published>2023-10-31T10:25:33.000Z</published>
  </entry>
  <entry>
    <title type="text">必读</title>
    <id>https://ujava.cn/required/</id>
    <link href="https://ujava.cn/required/"/>
    <updated>2024-02-27T08:33:08.000Z</updated>
    <summary type="html"><![CDATA[<h2> <a href="./faq">常见问题</a></h2>
<h2> <a href="./history">网站历史</a></h2>
]]></summary>
    <content type="html"><![CDATA[<h2> <a href="./faq">常见问题</a></h2>
<h2> <a href="./history">网站历史</a></h2>
]]></content>
    <category term="必读"/>
    <published>2023-10-23T11:22:31.000Z</published>
  </entry>
  <entry>
    <title type="text">设计规范</title>
    <id>https://ujava.cn/standard/design.html</id>
    <link href="https://ujava.cn/standard/design.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h4> 1.【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。</h4>
<p>说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行 double check。</p>
<p>正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要在评审通过后上线。</p>
<h4> 2.【强制】在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 UseCase 超过 5 个，使用用例图来表达更加清晰的结构化需求。</h4>]]></summary>
    <content type="html"><![CDATA[<h4> 1.【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。</h4>
<p>说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行 double check。</p>
<p>正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要在评审通过后上线。</p>
<h4> 2.【强制】在需求分析阶段，如果与系统交互的 User 超过一类并且相关的 UseCase 超过 5 个，使用用例图来表达更加清晰的结构化需求。</h4>
<h4> 3.【强制】如果某个业务对象的状态超过 3 个，使用状态图来表达并且明确状态变化的各个触发条件。</h4>
<p>说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。<br>
正例：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p>
<h4> 4.【强制】如果系统中某个功能的调用链路上的涉及对象超过 3 个，使用时序图来表达并且明确各调用环节的输入与输出。</h4>
<p>说明：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。</p>
<h4> 5.【强制】如果系统中模型类超过 5 个，且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。</h4>
<p>说明：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁 Z 空间大楼，肯定需要详细的施工图。</p>
<h4> 6.【强制】如果系统中超过 2 个对象之间存在协作关系，并需要表示复杂的处理流程，使用活动图来表示。</h4>
<p>说明：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。</p>
<h4> 7.【强制】系统设计时要准确识别出弱依赖，并针对性地设计降级和应急预案，保证核心系统正常可用。</h4>
<p>说明：系统依赖的第三方服务被降级或屏蔽后，依然不会影响主干流程继续进行，仅影响信息展示、或消息通知等非关键功能，那么这些服务称为弱依赖。</p>
<ul>
<li>正例：当系统弱依赖于多个外部服务时，如果下游服务耗时过长，则会严重影响当前调用者，必须采取相应降级措施，比如，当调用链路中某个下游服务调用的平均响应时间或错误率超过阈值时，系统自动进行降级或熔断操作，屏蔽弱依赖负面影响，保护当前系统主干功能可用。</li>
<li>反例：某个疫情相关的二维码出错：“服务器开了点小差，请稍后重试”，不可用时长持续很久，引起社会高度关注，原因可能为调用的外部依赖服务 RT 过高而导致系统假死，而在显示端没有做降级预案，只能直接抛错给用户。</li>
</ul>
<h4> 8.【推荐】系统架构设计时明确以下目标：</h4>
<ul>
<li>⚫ 确定系统边界。确定系统在技术层面上的做与不做。</li>
<li>⚫ 确定系统内模块之间的关系。确定模块之间的依赖关系及模块的宏观输入与输出。</li>
<li>⚫ 确定指导后续设计与演化的原则。使后续的子系统或模块设计在一个既定的框架内和技术方向上继续演化。</li>
<li>⚫ 确定非功能性需求。非功能性需求是指安全性、可用性、可扩展性等。</li>
</ul>
<h4> 9.【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。</h4>
<h4> 10.【推荐】类在设计与实现时要符合单一原则。</h4>
<p>说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。</p>
<h4> 11.【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。</h4>
<p>说明：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。</p>
<h4> 12.【推荐】系统设计阶段，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。</h4>
<p>说明：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。</p>
<h4> 13.【推荐】系统设计阶段，注意对扩展开放，对修改闭合。</h4>
<p>说明：极端情况下，交付的代码是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。</p>
<h4> 14.【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，在系统中不出现重复代码的情况，即 DRY 原则（Don't Repeat Yourself）。</h4>
<p>说明：随着代码的重复次数不断增加，维护成本指数级上升。随意复制和粘贴代码，必然会导致代码的重复，在维护代码时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。</p>
<p css-module=".">正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取： private boolean checkParam(DTO dto)</p>
<h4> 15.【推荐】避免如下误解：敏捷开发=讲故事+编码+发布。</h4>
<p>说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。</p>
<p>反例：某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。</p>
<h4> 16.【参考】设计文档的作用是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。</h4>
<p>说明：避免为了设计而设计，系统设计文档有助于后期的系统维护和重构，所以设计结果需要进行分类归档保存。</p>
<h4> 17.【参考】可扩展性的本质是找到系统的变化点，并隔离变化点。</h4>
<p>说明：世间众多设计模式其实就是一种设计模式即隔离变化点的模式。</p>
<p>正例：极致扩展性的标志，就是需求的新增，不会在原有代码交付物上进行任何形式的修改。</p>
<h4> 18.【参考】设计的本质就是识别和表达系统难点。</h4>
<p>说明：识别和表达完全是两回事，很多人错误地认为识别到系统难点在哪里，表达只是自然而然的事情，但是大家在设计评审中经常出现语焉不详，甚至是词不达意的情况。准确地表达系统难点需要具备如下能力：表达规则和表达工具的熟练性。抽象思维和总结能力的局限性。基础知识体系的完备性。深入浅出的生动表达力。</p>
<h4> 19.【参考】代码即文档的观点是错误的，清晰的代码只是文档的某个片断，而不是全部。</h4>
<p>说明：代码的深度调用，模块层面上的依赖关系网，业务场景逻辑，非功能性需求等问题要相应的文档来完整地呈现。</p>
<h4> 20.【参考】在做无障碍产品设计时，需要考虑到：</h4>
<ul>
<li>⚫ 所有可交互的控件元素必须能被 tab 键聚焦，并且焦点顺序需符合自然操作逻辑。</li>
<li>⚫ 用于登录校验和请求拦截的验证码均需提供图形验证以外的其它方式。</li>
<li>⚫ 自定义的控件类型需明确交互方式。<br>
正例：登录场景中，输入框的按钮都需要考虑 tab 键聚焦，符合自然逻辑的操作顺序如下，"输入用户名，输入密码，输入验证码，点击登录"，其中验证码实现语音验证方式。如有自定义标签实现的控件设置控件类型可使用 role 属性。</li>
</ul>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T09:50:08.000Z</published>
  </entry>
  <entry>
    <title type="text">码值规范</title>
    <id>https://ujava.cn/standard/errorcode.html</id>
    <link href="https://ujava.cn/standard/errorcode.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> 用户类</h2>
<table>
<thead>
<tr>
<th>错误码</th>
<th>中文描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000</td>
<td>一切 ok</td>
<td>正确执行后的返回</td>
</tr>
<tr>
<td>A0001</td>
<td>用户端错误</td>
<td>一级宏观错误码</td>
</tr>
<tr>
<td>A0100</td>
<td>用户注册错误</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0101</td>
<td>用户未同意隐私协议</td>
<td></td>
</tr>
<tr>
<td>A0102</td>
<td>注册国家或地区受限</td>
<td></td>
</tr>
<tr>
<td>A0110</td>
<td>用户名校验失败</td>
<td></td>
</tr>
<tr>
<td>A0111</td>
<td>用户名已存在</td>
<td></td>
</tr>
<tr>
<td>A0112</td>
<td>用户名包含敏感词</td>
<td></td>
</tr>
<tr>
<td>A0113</td>
<td>用户名包含特殊字符</td>
<td></td>
</tr>
<tr>
<td>A0120</td>
<td>密码校验失败</td>
<td></td>
</tr>
<tr>
<td>A0121</td>
<td>密码长度不够</td>
<td></td>
</tr>
<tr>
<td>A0122</td>
<td>密码强度不够</td>
<td></td>
</tr>
<tr>
<td>A0130</td>
<td>校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0131</td>
<td>短信校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0132</td>
<td>邮件校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0133</td>
<td>语音校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0140</td>
<td>用户证件异常</td>
<td></td>
</tr>
<tr>
<td>A0141</td>
<td>用户证件类型未选择</td>
<td></td>
</tr>
<tr>
<td>A0142</td>
<td>大陆身份证编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0143</td>
<td>护照编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0144</td>
<td>军官证编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0150</td>
<td>用户基本信息校验失败</td>
<td></td>
</tr>
<tr>
<td>A0151</td>
<td>手机格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0152</td>
<td>地址格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0153</td>
<td>邮箱格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0200</td>
<td>用户登录异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0201</td>
<td>用户账户不存在</td>
<td></td>
</tr>
<tr>
<td>A0202</td>
<td>用户账户被冻结</td>
<td></td>
</tr>
<tr>
<td>A0203</td>
<td>用户账户已作废</td>
<td></td>
</tr>
<tr>
<td>A0210</td>
<td>用户密码错误</td>
<td></td>
</tr>
<tr>
<td>A0211</td>
<td>用户输入密码错误次数超限</td>
<td></td>
</tr>
<tr>
<td>A0220</td>
<td>用户身份校验失败</td>
<td></td>
</tr>
<tr>
<td>A0221</td>
<td>用户指纹识别失败</td>
<td></td>
</tr>
<tr>
<td>A0222</td>
<td>用户面容识别失败</td>
<td></td>
</tr>
<tr>
<td>A0223</td>
<td>用户未获得第三方登录授权</td>
<td></td>
</tr>
<tr>
<td>A0230</td>
<td>用户登录已过期</td>
<td></td>
</tr>
<tr>
<td>A0240</td>
<td>用户验证码错误</td>
<td></td>
</tr>
<tr>
<td>A0241</td>
<td>用户验证码尝试次数超限</td>
<td></td>
</tr>
<tr>
<td>A0300</td>
<td>访问权限异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0301</td>
<td>访问未授权</td>
<td></td>
</tr>
<tr>
<td>A0302</td>
<td>正在授权中</td>
<td></td>
</tr>
<tr>
<td>A0303</td>
<td>用户授权申请被拒绝</td>
<td></td>
</tr>
<tr>
<td>A0310</td>
<td>因访问对象隐私设置被拦截</td>
<td></td>
</tr>
<tr>
<td>A0311</td>
<td>授权已过期</td>
<td></td>
</tr>
<tr>
<td>A0312</td>
<td>无权限使用 API</td>
<td></td>
</tr>
<tr>
<td>A0320</td>
<td>用户访问被拦截</td>
<td></td>
</tr>
<tr>
<td>A0321</td>
<td>黑名单用户</td>
<td></td>
</tr>
<tr>
<td>A0322</td>
<td>账号被冻结</td>
<td></td>
</tr>
<tr>
<td>A0323</td>
<td>非法 IP 地址</td>
<td></td>
</tr>
<tr>
<td>A0324</td>
<td>网关访问受限</td>
<td></td>
</tr>
<tr>
<td>A0325</td>
<td>地域黑名单</td>
<td></td>
</tr>
<tr>
<td>A0330</td>
<td>服务已欠费</td>
<td></td>
</tr>
<tr>
<td>A0340</td>
<td>用户签名异常</td>
<td></td>
</tr>
<tr>
<td>A0341</td>
<td>RSA 签名错误</td>
<td></td>
</tr>
<tr>
<td>A0400</td>
<td>用户请求参数错误</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0401</td>
<td>包含非法恶意跳转链接</td>
<td></td>
</tr>
<tr>
<td>A0402</td>
<td>无效的用户输入</td>
<td></td>
</tr>
<tr>
<td>A0410</td>
<td>请求必填参数为空</td>
<td></td>
</tr>
<tr>
<td>A0411</td>
<td>用户订单号为空</td>
<td></td>
</tr>
<tr>
<td>A0412</td>
<td>订购数量为空</td>
<td></td>
</tr>
<tr>
<td>A0413</td>
<td>缺少时间戳参数</td>
<td></td>
</tr>
<tr>
<td>A0414</td>
<td>非法的时间戳参数</td>
<td></td>
</tr>
<tr>
<td>A0420</td>
<td>请求参数值超出允许的范围</td>
<td></td>
</tr>
<tr>
<td>A0421</td>
<td>参数格式不匹配</td>
<td></td>
</tr>
<tr>
<td>A0422</td>
<td>地址不在服务范围</td>
<td></td>
</tr>
<tr>
<td>A0423</td>
<td>时间不在服务范围</td>
<td></td>
</tr>
<tr>
<td>A0424</td>
<td>金额超出限制</td>
<td></td>
</tr>
<tr>
<td>A0425</td>
<td>数量超出限制</td>
<td></td>
</tr>
<tr>
<td>A0426</td>
<td>请求批量处理总个数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0427</td>
<td>请求 JSON 解析失败</td>
<td></td>
</tr>
<tr>
<td>A0430</td>
<td>用户输入内容非法</td>
<td></td>
</tr>
<tr>
<td>A0431</td>
<td>包含违禁敏感词</td>
<td></td>
</tr>
<tr>
<td>A0432</td>
<td>图片包含违禁信息</td>
<td></td>
</tr>
<tr>
<td>A0433</td>
<td>文件侵犯版权</td>
<td></td>
</tr>
<tr>
<td>A0440</td>
<td>用户操作异常</td>
<td></td>
</tr>
<tr>
<td>A0441</td>
<td>用户支付超时</td>
<td></td>
</tr>
<tr>
<td>A0442</td>
<td>确认订单超时</td>
<td></td>
</tr>
<tr>
<td>A0443</td>
<td>订单已关闭</td>
<td></td>
</tr>
<tr>
<td>A0500</td>
<td>用户请求服务异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0501</td>
<td>请求次数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0502</td>
<td>请求并发数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0503</td>
<td>用户操作请等待</td>
<td></td>
</tr>
<tr>
<td>A0504</td>
<td>WebSocket</td>
<td>连接异常</td>
</tr>
<tr>
<td>A0505</td>
<td>WebSocket</td>
<td>连接断开</td>
</tr>
<tr>
<td>A0506</td>
<td>用户重复请求</td>
<td></td>
</tr>
<tr>
<td>A0600</td>
<td>用户资源异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0601</td>
<td>账户余额不足</td>
<td></td>
</tr>
<tr>
<td>A0602</td>
<td>用户磁盘空间不足</td>
<td></td>
</tr>
<tr>
<td>A0603</td>
<td>用户内存空间不足</td>
<td></td>
</tr>
<tr>
<td>A0604</td>
<td>用户 OSS 容量不足</td>
<td></td>
</tr>
<tr>
<td>A0605</td>
<td>用户配额已用光 蚂蚁森林浇水数或每天抽奖数</td>
<td></td>
</tr>
<tr>
<td>A0700</td>
<td>用户上传文件异常 二级宏观错误码</td>
<td></td>
</tr>
<tr>
<td>A0701</td>
<td>用户上传文件类型不匹配</td>
<td></td>
</tr>
<tr>
<td>A0702</td>
<td>用户上传文件太大</td>
<td></td>
</tr>
<tr>
<td>A0703</td>
<td>用户上传图片太大</td>
<td></td>
</tr>
<tr>
<td>A0704</td>
<td>用户上传视频太大</td>
<td></td>
</tr>
<tr>
<td>A0705</td>
<td>用户上传压缩文件太大</td>
<td></td>
</tr>
<tr>
<td>A0800</td>
<td>用户当前版本异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0801</td>
<td>用户安装版本与系统不匹配</td>
<td></td>
</tr>
<tr>
<td>A0802</td>
<td>用户安装版本过低</td>
<td></td>
</tr>
<tr>
<td>A0803</td>
<td>用户安装版本过高</td>
<td></td>
</tr>
<tr>
<td>A0804</td>
<td>用户安装版本已过期</td>
<td></td>
</tr>
<tr>
<td>A0805</td>
<td>用户 API 请求版本不匹配</td>
<td></td>
</tr>
<tr>
<td>A0806</td>
<td>用户 API 请求版本过高</td>
<td></td>
</tr>
<tr>
<td>A0807</td>
<td>用户 API 请求版本过低</td>
<td></td>
</tr>
<tr>
<td>A0900</td>
<td>用户隐私未授权 二级宏观错误码</td>
<td></td>
</tr>
<tr>
<td>A0901</td>
<td>用户隐私未签署</td>
<td></td>
</tr>
<tr>
<td>A0902</td>
<td>用户摄像头未授权</td>
<td></td>
</tr>
<tr>
<td>A0903</td>
<td>用户相机未授权</td>
<td></td>
</tr>
<tr>
<td>A0904</td>
<td>用户图片库未授权</td>
<td></td>
</tr>
<tr>
<td>A0905</td>
<td>用户文件未授权</td>
<td></td>
</tr>
<tr>
<td>A0906</td>
<td>用户位置信息未授权</td>
<td></td>
</tr>
<tr>
<td>A0907</td>
<td>用户通讯录未授权</td>
<td></td>
</tr>
<tr>
<td>A1000</td>
<td>用户设备异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A1001</td>
<td>用户相机异常</td>
<td></td>
</tr>
<tr>
<td>A1002</td>
<td>用户麦克风异常</td>
<td></td>
</tr>
<tr>
<td>A1003</td>
<td>用户听筒异常</td>
<td></td>
</tr>
<tr>
<td>A1004</td>
<td>用户扬声器异常</td>
<td></td>
</tr>
<tr>
<td>A1005</td>
<td>用户 GPS 定位异常</td>
<td></td>
</tr>
</tbody>
</table>]]></summary>
    <content type="html"><![CDATA[<h2> 用户类</h2>
<table>
<thead>
<tr>
<th>错误码</th>
<th>中文描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>00000</td>
<td>一切 ok</td>
<td>正确执行后的返回</td>
</tr>
<tr>
<td>A0001</td>
<td>用户端错误</td>
<td>一级宏观错误码</td>
</tr>
<tr>
<td>A0100</td>
<td>用户注册错误</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0101</td>
<td>用户未同意隐私协议</td>
<td></td>
</tr>
<tr>
<td>A0102</td>
<td>注册国家或地区受限</td>
<td></td>
</tr>
<tr>
<td>A0110</td>
<td>用户名校验失败</td>
<td></td>
</tr>
<tr>
<td>A0111</td>
<td>用户名已存在</td>
<td></td>
</tr>
<tr>
<td>A0112</td>
<td>用户名包含敏感词</td>
<td></td>
</tr>
<tr>
<td>A0113</td>
<td>用户名包含特殊字符</td>
<td></td>
</tr>
<tr>
<td>A0120</td>
<td>密码校验失败</td>
<td></td>
</tr>
<tr>
<td>A0121</td>
<td>密码长度不够</td>
<td></td>
</tr>
<tr>
<td>A0122</td>
<td>密码强度不够</td>
<td></td>
</tr>
<tr>
<td>A0130</td>
<td>校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0131</td>
<td>短信校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0132</td>
<td>邮件校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0133</td>
<td>语音校验码输入错误</td>
<td></td>
</tr>
<tr>
<td>A0140</td>
<td>用户证件异常</td>
<td></td>
</tr>
<tr>
<td>A0141</td>
<td>用户证件类型未选择</td>
<td></td>
</tr>
<tr>
<td>A0142</td>
<td>大陆身份证编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0143</td>
<td>护照编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0144</td>
<td>军官证编号校验非法</td>
<td></td>
</tr>
<tr>
<td>A0150</td>
<td>用户基本信息校验失败</td>
<td></td>
</tr>
<tr>
<td>A0151</td>
<td>手机格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0152</td>
<td>地址格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0153</td>
<td>邮箱格式校验失败</td>
<td></td>
</tr>
<tr>
<td>A0200</td>
<td>用户登录异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0201</td>
<td>用户账户不存在</td>
<td></td>
</tr>
<tr>
<td>A0202</td>
<td>用户账户被冻结</td>
<td></td>
</tr>
<tr>
<td>A0203</td>
<td>用户账户已作废</td>
<td></td>
</tr>
<tr>
<td>A0210</td>
<td>用户密码错误</td>
<td></td>
</tr>
<tr>
<td>A0211</td>
<td>用户输入密码错误次数超限</td>
<td></td>
</tr>
<tr>
<td>A0220</td>
<td>用户身份校验失败</td>
<td></td>
</tr>
<tr>
<td>A0221</td>
<td>用户指纹识别失败</td>
<td></td>
</tr>
<tr>
<td>A0222</td>
<td>用户面容识别失败</td>
<td></td>
</tr>
<tr>
<td>A0223</td>
<td>用户未获得第三方登录授权</td>
<td></td>
</tr>
<tr>
<td>A0230</td>
<td>用户登录已过期</td>
<td></td>
</tr>
<tr>
<td>A0240</td>
<td>用户验证码错误</td>
<td></td>
</tr>
<tr>
<td>A0241</td>
<td>用户验证码尝试次数超限</td>
<td></td>
</tr>
<tr>
<td>A0300</td>
<td>访问权限异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0301</td>
<td>访问未授权</td>
<td></td>
</tr>
<tr>
<td>A0302</td>
<td>正在授权中</td>
<td></td>
</tr>
<tr>
<td>A0303</td>
<td>用户授权申请被拒绝</td>
<td></td>
</tr>
<tr>
<td>A0310</td>
<td>因访问对象隐私设置被拦截</td>
<td></td>
</tr>
<tr>
<td>A0311</td>
<td>授权已过期</td>
<td></td>
</tr>
<tr>
<td>A0312</td>
<td>无权限使用 API</td>
<td></td>
</tr>
<tr>
<td>A0320</td>
<td>用户访问被拦截</td>
<td></td>
</tr>
<tr>
<td>A0321</td>
<td>黑名单用户</td>
<td></td>
</tr>
<tr>
<td>A0322</td>
<td>账号被冻结</td>
<td></td>
</tr>
<tr>
<td>A0323</td>
<td>非法 IP 地址</td>
<td></td>
</tr>
<tr>
<td>A0324</td>
<td>网关访问受限</td>
<td></td>
</tr>
<tr>
<td>A0325</td>
<td>地域黑名单</td>
<td></td>
</tr>
<tr>
<td>A0330</td>
<td>服务已欠费</td>
<td></td>
</tr>
<tr>
<td>A0340</td>
<td>用户签名异常</td>
<td></td>
</tr>
<tr>
<td>A0341</td>
<td>RSA 签名错误</td>
<td></td>
</tr>
<tr>
<td>A0400</td>
<td>用户请求参数错误</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0401</td>
<td>包含非法恶意跳转链接</td>
<td></td>
</tr>
<tr>
<td>A0402</td>
<td>无效的用户输入</td>
<td></td>
</tr>
<tr>
<td>A0410</td>
<td>请求必填参数为空</td>
<td></td>
</tr>
<tr>
<td>A0411</td>
<td>用户订单号为空</td>
<td></td>
</tr>
<tr>
<td>A0412</td>
<td>订购数量为空</td>
<td></td>
</tr>
<tr>
<td>A0413</td>
<td>缺少时间戳参数</td>
<td></td>
</tr>
<tr>
<td>A0414</td>
<td>非法的时间戳参数</td>
<td></td>
</tr>
<tr>
<td>A0420</td>
<td>请求参数值超出允许的范围</td>
<td></td>
</tr>
<tr>
<td>A0421</td>
<td>参数格式不匹配</td>
<td></td>
</tr>
<tr>
<td>A0422</td>
<td>地址不在服务范围</td>
<td></td>
</tr>
<tr>
<td>A0423</td>
<td>时间不在服务范围</td>
<td></td>
</tr>
<tr>
<td>A0424</td>
<td>金额超出限制</td>
<td></td>
</tr>
<tr>
<td>A0425</td>
<td>数量超出限制</td>
<td></td>
</tr>
<tr>
<td>A0426</td>
<td>请求批量处理总个数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0427</td>
<td>请求 JSON 解析失败</td>
<td></td>
</tr>
<tr>
<td>A0430</td>
<td>用户输入内容非法</td>
<td></td>
</tr>
<tr>
<td>A0431</td>
<td>包含违禁敏感词</td>
<td></td>
</tr>
<tr>
<td>A0432</td>
<td>图片包含违禁信息</td>
<td></td>
</tr>
<tr>
<td>A0433</td>
<td>文件侵犯版权</td>
<td></td>
</tr>
<tr>
<td>A0440</td>
<td>用户操作异常</td>
<td></td>
</tr>
<tr>
<td>A0441</td>
<td>用户支付超时</td>
<td></td>
</tr>
<tr>
<td>A0442</td>
<td>确认订单超时</td>
<td></td>
</tr>
<tr>
<td>A0443</td>
<td>订单已关闭</td>
<td></td>
</tr>
<tr>
<td>A0500</td>
<td>用户请求服务异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0501</td>
<td>请求次数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0502</td>
<td>请求并发数超出限制</td>
<td></td>
</tr>
<tr>
<td>A0503</td>
<td>用户操作请等待</td>
<td></td>
</tr>
<tr>
<td>A0504</td>
<td>WebSocket</td>
<td>连接异常</td>
</tr>
<tr>
<td>A0505</td>
<td>WebSocket</td>
<td>连接断开</td>
</tr>
<tr>
<td>A0506</td>
<td>用户重复请求</td>
<td></td>
</tr>
<tr>
<td>A0600</td>
<td>用户资源异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0601</td>
<td>账户余额不足</td>
<td></td>
</tr>
<tr>
<td>A0602</td>
<td>用户磁盘空间不足</td>
<td></td>
</tr>
<tr>
<td>A0603</td>
<td>用户内存空间不足</td>
<td></td>
</tr>
<tr>
<td>A0604</td>
<td>用户 OSS 容量不足</td>
<td></td>
</tr>
<tr>
<td>A0605</td>
<td>用户配额已用光 蚂蚁森林浇水数或每天抽奖数</td>
<td></td>
</tr>
<tr>
<td>A0700</td>
<td>用户上传文件异常 二级宏观错误码</td>
<td></td>
</tr>
<tr>
<td>A0701</td>
<td>用户上传文件类型不匹配</td>
<td></td>
</tr>
<tr>
<td>A0702</td>
<td>用户上传文件太大</td>
<td></td>
</tr>
<tr>
<td>A0703</td>
<td>用户上传图片太大</td>
<td></td>
</tr>
<tr>
<td>A0704</td>
<td>用户上传视频太大</td>
<td></td>
</tr>
<tr>
<td>A0705</td>
<td>用户上传压缩文件太大</td>
<td></td>
</tr>
<tr>
<td>A0800</td>
<td>用户当前版本异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A0801</td>
<td>用户安装版本与系统不匹配</td>
<td></td>
</tr>
<tr>
<td>A0802</td>
<td>用户安装版本过低</td>
<td></td>
</tr>
<tr>
<td>A0803</td>
<td>用户安装版本过高</td>
<td></td>
</tr>
<tr>
<td>A0804</td>
<td>用户安装版本已过期</td>
<td></td>
</tr>
<tr>
<td>A0805</td>
<td>用户 API 请求版本不匹配</td>
<td></td>
</tr>
<tr>
<td>A0806</td>
<td>用户 API 请求版本过高</td>
<td></td>
</tr>
<tr>
<td>A0807</td>
<td>用户 API 请求版本过低</td>
<td></td>
</tr>
<tr>
<td>A0900</td>
<td>用户隐私未授权 二级宏观错误码</td>
<td></td>
</tr>
<tr>
<td>A0901</td>
<td>用户隐私未签署</td>
<td></td>
</tr>
<tr>
<td>A0902</td>
<td>用户摄像头未授权</td>
<td></td>
</tr>
<tr>
<td>A0903</td>
<td>用户相机未授权</td>
<td></td>
</tr>
<tr>
<td>A0904</td>
<td>用户图片库未授权</td>
<td></td>
</tr>
<tr>
<td>A0905</td>
<td>用户文件未授权</td>
<td></td>
</tr>
<tr>
<td>A0906</td>
<td>用户位置信息未授权</td>
<td></td>
</tr>
<tr>
<td>A0907</td>
<td>用户通讯录未授权</td>
<td></td>
</tr>
<tr>
<td>A1000</td>
<td>用户设备异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>A1001</td>
<td>用户相机异常</td>
<td></td>
</tr>
<tr>
<td>A1002</td>
<td>用户麦克风异常</td>
<td></td>
</tr>
<tr>
<td>A1003</td>
<td>用户听筒异常</td>
<td></td>
</tr>
<tr>
<td>A1004</td>
<td>用户扬声器异常</td>
<td></td>
</tr>
<tr>
<td>A1005</td>
<td>用户 GPS 定位异常</td>
<td></td>
</tr>
</tbody>
</table>
<h2> 系统类</h2>
<table>
<thead>
<tr>
<th>错误码</th>
<th>中文描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>B0001</td>
<td>系统执行出错</td>
<td>一级宏观错误码</td>
</tr>
<tr>
<td>B0100</td>
<td>系统执行超时</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>B0101</td>
<td>系统订单处理超时</td>
<td></td>
</tr>
<tr>
<td>B0200</td>
<td>系统容灾功能被触发</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>B0210</td>
<td>系统限流</td>
<td></td>
</tr>
<tr>
<td>B0220</td>
<td>系统功能降级</td>
<td></td>
</tr>
<tr>
<td>B0300</td>
<td>系统资源异常</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>B0310</td>
<td>系统资源耗尽</td>
<td></td>
</tr>
<tr>
<td>B0311</td>
<td>系统磁盘空间耗尽</td>
<td></td>
</tr>
<tr>
<td>B0312</td>
<td>系统内存耗尽</td>
<td></td>
</tr>
<tr>
<td>B0313</td>
<td>文件句柄耗尽</td>
<td></td>
</tr>
<tr>
<td>B0314</td>
<td>系统连接池耗尽</td>
<td></td>
</tr>
<tr>
<td>B0315</td>
<td>系统资源访问异常</td>
<td></td>
</tr>
<tr>
<td>B0320</td>
<td>系统资源访问异常</td>
<td></td>
</tr>
<tr>
<td>B0321</td>
<td>系统读取磁盘文件失败</td>
<td></td>
</tr>
</tbody>
</table>
<h2> 中间件类</h2>
<table>
<thead>
<tr>
<th>错误码</th>
<th>中文描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C0001</td>
<td>调用第三方服务出错</td>
<td></td>
</tr>
<tr>
<td>C0100</td>
<td>中间件服务出错</td>
<td>一级宏观错误码</td>
</tr>
<tr>
<td>C0110</td>
<td>RPC 服务出错</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>C0111</td>
<td>RPC 服务未找到</td>
<td></td>
</tr>
<tr>
<td>C0112</td>
<td>RPC 服务未注册</td>
<td></td>
</tr>
<tr>
<td>C0113</td>
<td>接口不存在</td>
<td></td>
</tr>
<tr>
<td>C0120</td>
<td>消息服务出错</td>
<td></td>
</tr>
<tr>
<td>C0121</td>
<td>消息投递出错</td>
<td></td>
</tr>
<tr>
<td>C0122</td>
<td>消息消费出错</td>
<td></td>
</tr>
<tr>
<td>C0123</td>
<td>消息订阅出错</td>
<td></td>
</tr>
<tr>
<td>C0124</td>
<td>消息分组未查到</td>
<td></td>
</tr>
<tr>
<td>C0130</td>
<td>缓存服务出错</td>
<td></td>
</tr>
<tr>
<td>C0131</td>
<td>key 长度超过限制</td>
<td></td>
</tr>
<tr>
<td>C0132</td>
<td>value 长度超过限制</td>
<td></td>
</tr>
<tr>
<td>C0133</td>
<td>存储容量已满</td>
<td></td>
</tr>
<tr>
<td>C0134</td>
<td>不支持的数据格式</td>
<td></td>
</tr>
<tr>
<td>C0140</td>
<td>配置服务出错</td>
<td></td>
</tr>
<tr>
<td>C0150</td>
<td>网络资源服务出错</td>
<td></td>
</tr>
<tr>
<td>C0151</td>
<td>VPN 服务出错</td>
<td></td>
</tr>
<tr>
<td>C0152</td>
<td>CDN 服务出错</td>
<td></td>
</tr>
<tr>
<td>C0153</td>
<td>域名解析服务出错</td>
<td></td>
</tr>
<tr>
<td>C0154</td>
<td>网关服务出错</td>
<td></td>
</tr>
<tr>
<td>C0200</td>
<td>第三方系统执行超时</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>C0210</td>
<td>RPC 执行超时</td>
<td></td>
</tr>
<tr>
<td>C0220</td>
<td>消息投递超时</td>
<td></td>
</tr>
<tr>
<td>C0230</td>
<td>缓存服务超时</td>
<td></td>
</tr>
<tr>
<td>C0240</td>
<td>配置服务超时</td>
<td></td>
</tr>
<tr>
<td>C0250</td>
<td>数据库服务超时</td>
<td></td>
</tr>
<tr>
<td>C0300</td>
<td>数据库服务出错</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>C0311</td>
<td>表不存在</td>
<td></td>
</tr>
<tr>
<td>C0312</td>
<td>列不存在</td>
<td></td>
</tr>
<tr>
<td>C0321</td>
<td>多表关联中存在多个相同名称的列</td>
<td></td>
</tr>
<tr>
<td>C0331</td>
<td>数据库死锁</td>
<td></td>
</tr>
<tr>
<td>C0341</td>
<td>主键冲突</td>
<td></td>
</tr>
<tr>
<td>C0400</td>
<td>第三方容灾系统被触发</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>C0401</td>
<td>第三方系统限流</td>
<td></td>
</tr>
<tr>
<td>C0402</td>
<td>第三方功能降级</td>
<td></td>
</tr>
<tr>
<td>C0500</td>
<td>通知服务出错</td>
<td>二级宏观错误码</td>
</tr>
<tr>
<td>C0501</td>
<td>短信提醒服务失败</td>
<td></td>
</tr>
<tr>
<td>C0502</td>
<td>语音提醒服务失败</td>
<td></td>
</tr>
<tr>
<td>C0503</td>
<td>邮件提醒服务失败</td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T09:50:08.000Z</published>
  </entry>
  <entry>
    <title type="text">名词规范</title>
    <id>https://ujava.cn/standard/noun.html</id>
    <link href="https://ujava.cn/standard/noun.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h4> 1. POJO（Plain Ordinary Java Object）：在本规约中，POJO 专指只有 setter / getter / toString 的简单类，包括DO / DTO / BO / VO 等。</h4>
<h4> 2. DO（Data Object）：阿里巴巴专指数据库表一 一对应的 POJO 类。此对象与数据库表结构一 一对应，通过 DAO 层向上传输数据源对象。</h4>
<h4> 3. PO（Persistent Object）：也指数据库表一 一对应的 POJO 类。此对象与数据库表结构一 一对应，通过 DAO 层向上传输数据源对象。</h4>
<h4> 4. DTO（Data Transfer Object ）：数据传输对象，Service 或 Manager 向外传输的对象。</h4>]]></summary>
    <content type="html"><![CDATA[<h4> 1. POJO（Plain Ordinary Java Object）：在本规约中，POJO 专指只有 setter / getter / toString 的简单类，包括DO / DTO / BO / VO 等。</h4>
<h4> 2. DO（Data Object）：阿里巴巴专指数据库表一 一对应的 POJO 类。此对象与数据库表结构一 一对应，通过 DAO 层向上传输数据源对象。</h4>
<h4> 3. PO（Persistent Object）：也指数据库表一 一对应的 POJO 类。此对象与数据库表结构一 一对应，通过 DAO 层向上传输数据源对象。</h4>
<h4> 4. DTO（Data Transfer Object ）：数据传输对象，Service 或 Manager 向外传输的对象。</h4>
<h4> 5. BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</h4>
<h4> 6. Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</h4>
<h4> 7. VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</h4>
<h4> 8. CAS（Compare And Swap）：解决多线程并行情况下使用锁造成性能损耗的一种机制，这是硬件实现的原子操作。</h4>
<p>CAS 操作包含三个操作数：内存位置、预期原值和新值。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</p>
<h4> 9. GAV（GroupId、ArtifactId、Version）：Maven 坐标，是用来唯一标识 jar 包。</h4>
<h4> 10. OOP（Object Oriented Programming）：本文泛指类、对象的编程处理方式。</h4>
<h4> 11. AQS（AbstractQueuedSynchronizer）：利用先进先出队列实现的底层同步工具类，它是很多上层同步实现类的基础，比如：ReentrantLock、CountDownLatch、Semaphore 等，它们通过继承 AQS 实现其模版方法，然后将 AQS子类作为同步组件的内部类，通常命名为 Sync。</h4>
<h4> 12. ORM（Object Relation Mapping）：对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS，mybatis 等框架。</h4>
<h4> 13. NPE（java.lang.NullPointerException）：空指针异常。</h4>
<h4> 14. OOM（Out Of Memory）：源于 java.lang.OutOfMemoryError，当 JVM 没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。</h4>
<h4> 15. GMT（Greenwich Mean Time）：指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。地球每天的自转是有些不规则的，而且正在缓慢减速，现在的标准时间是协调世界时（UTC），它由原子钟提供。</h4>
<h4> 16. 一方库：本工程内部子项目模块依赖的库（jar 包）。</h4>
<h4> 17. 二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</h4>
<h4> 18. 三方库：公司之外的开源库（jar 包）。</h4>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T09:50:08.000Z</published>
  </entry>
  <entry>
    <title type="text">工程规范</title>
    <id>https://ujava.cn/standard/project.html</id>
    <link href="https://ujava.cn/standard/project.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> (一) 应用分层</h2>
<h4> 1.【推荐】根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示，默认上层依赖于下层，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层（Controller 层），也可以直接依赖于 Service 层，依此类推：</h4>
<figure><figcaption>img.png</figcaption></figure>
<ul>
<li>
<p>⚫ 开放 API 层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。</p>
</li>
<li>
<p>⚫ 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p>
</li>
<li>
<p>⚫ Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p>
</li>
<li>
<p>⚫ Service 层：相对具体的业务逻辑服务层。</p>
</li>
<li>
<p>⚫ Manager 层：通用业务处理层，它有如下特征</p>
</li>
<li>
<p>1）对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</p>
</li>
<li>
<p>2）对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</p>
</li>
<li>
<p>3）与 DAO 层交互，对多个 DAO 的组合复用。</p>
</li>
<li>
<p>⚫ DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OceanBase等进行数据交互。</p>
</li>
<li>
<p>⚫ 第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、 高德地图服务等。</p>
</li>
<li>
<p>⚫ 外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> (一) 应用分层</h2>
<h4> 1.【推荐】根据业务架构实践，结合业界分层规范与流行技术框架分析，推荐分层结构如图所示，默认上层依赖于下层，箭头关系表示可直接依赖，如：开放 API 层可以依赖于 Web 层（Controller 层），也可以直接依赖于 Service 层，依此类推：</h4>
<figure><figcaption>img.png</figcaption></figure>
<ul>
<li>
<p>⚫ 开放 API 层：可直接封装 Service 接口暴露成 RPC 接口；通过 Web 封装成 http 接口；网关控制层等。</p>
</li>
<li>
<p>⚫ 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p>
</li>
<li>
<p>⚫ Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p>
</li>
<li>
<p>⚫ Service 层：相对具体的业务逻辑服务层。</p>
</li>
<li>
<p>⚫ Manager 层：通用业务处理层，它有如下特征</p>
</li>
<li>
<p>1）对第三方平台封装的层，预处理返回结果及转化异常信息，适配上层接口。</p>
</li>
<li>
<p>2）对 Service 层通用能力的下沉，如缓存方案、中间件通用处理。</p>
</li>
<li>
<p>3）与 DAO 层交互，对多个 DAO 的组合复用。</p>
</li>
<li>
<p>⚫ DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase、OceanBase等进行数据交互。</p>
</li>
<li>
<p>⚫ 第三方服务：包括其它部门 RPC 服务接口，基础平台，其它公司的 HTTP 接口，如淘宝开放平台、支付宝付款服务、 高德地图服务等。</p>
</li>
<li>
<p>⚫ 外部数据接口：外部（应用）数据存储服务提供的接口，多见于数据迁移场景中。</p>
</li>
</ul>
<h4> 2.【参考】（分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e) 方式，并 throw new DAOException(e)，不需要打印日志，因为日志在Manager 或 Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数和上下文信息，相当于保护案发现场。Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，尽量加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</h4>
<h4> 3.【参考】分层领域模型规约：</h4>
<ul>
<li>⚫ DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>
<li>⚫ DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li>
<li>⚫ BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</li>
<li>⚫ Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li>
<li>⚫ VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
</ul>
<h2> (二) 二方库依赖</h2>
<h4> 1.【强制】定义 GAV 遵从以下规则：</h4>
<ul>
<li>1）GroupId 格式：com.{公司/BU}.业务线.[子业务线]，最多 4 级。
<ul>
<li>说明：{公司/BU}例如：alibaba / taobao / tmall / kaikeba 等 BU 一级；子业务线可选。</li>
<li>正例：com.taobao.jstorm 或 com.alibaba.dubbo.register</li>
</ul>
</li>
<li>2）ArtifactId 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。
<ul>
<li>正例：dubbo-client / fastjson-api / jstorm-tool</li>
</ul>
</li>
<li>3）Version：详细规定参考下方。</li>
</ul>
<h4> 2.【强制】二方库版本号命名方式：主版本号.次版本号.修订号</h4>
<ul>
<li>1）主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。</li>
<li>2）次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。</li>
<li>3）修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。<br>
说明：注意起始版本号必须为：1.0.0，而不是 0.0.1。</li>
</ul>
<p>反例：仓库内某二方库版本号从 1.0.0.0 开始，一直默默“升级”成 1.0.0.64，完全失去版本的语义信息。</p>
<h4> 3.【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）；正式发布的类库必须先去中央仓库进行查证，使 RELEASE 版本号有延续性，且版本号不允许覆盖升级。</h4>
<p>说明：不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p>
<h4> 4.【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证。</h4>
<p>说明：在升级时，进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命 令，找出差异点，进行排除 jar 包。</p>
<h4> 5.【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</h4>
<h4> 6.【强制】二方库定制包的命名方式，在规定的版本号之后加“-英文说明[序号]”，英文说明可以是部门简称、业务名称，序号直接紧跟在英文说明之后，表示此定制包的顺序号。</h4>
<p>说明：fastjson 给 SCM 定制的版本号：1.0.0-SCM1。注：请尽可能在应用端来解决类冲突和加载问题，避免随意发布此类定制包。</p>
<h4> 7.【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。</h4>
<p>说明：依赖 springframework-core，-context，-beans，它们都是同一个版本，可以定义一个变量来保存版本： ${spring.version}，定义依赖的时候，引用该版本。</p>
<h4> 8.【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。</h4>
<p>说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录 中。曾经出现过线下调试是正确的，发布到线上却出故障的先例。</p>
<h4> 9.【推荐】底层基础技术框架、核心数据管理平台、或近硬件端系统谨慎引入第三方实现。</h4>
<h4> 10.【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在语句块中。</h4>
<p>说明：里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的里的依赖都会自动引入，并默认被所有的子项目继承。</p>
<h4> 11.【推荐】二方库不要有配置项，最低限度不要再增加配置项。</h4>
<h4> 12.【推荐】不要使用不稳定的工具包或者 Utils 类。</h4>
<p>说明：不稳定指的是提供方无法做到向下兼容，在编译阶段正常，但在运行时产生异常，因此，尽量使用业界稳定的二方工具包。</p>
<h4> 13.【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：</h4>
<ul>
<li>1）移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。</li>
<li>2）每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</li>
</ul>
<h2> (三) 服务器</h2>
<h4> 1.【强制】调用远程操作必须有超时设置。</h4>
<p>说明：类似于 HttpClient 的超时设置需要自己明确去设置 Timeout。根据经验表明，无数次的故障都是因为没有设置超时时间。</p>
<h4> 2.【推荐】客户端设置远程接口方法的具体超时时间（单位 ms），超时设置生效顺序一般为：</h4>
<ul>
<li>1）客户端 Special Method；</li>
<li>2）客户端接口级别；</li>
<li>3）服务端 Special Method；</li>
<li>4）服务端接口级别。</li>
</ul>
<h4> 3.【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。</h4>
<p>说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</p>
<p>正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout=30</p>
<h4> 4.【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）</h4>
<p>说明：主流操作系统的设计是将 TCP / UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，<br>
导致新的连接无法建立。建议将 linux 服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p>
<h4> 5.【推荐】给 JVM 环境参数设置-XX：+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。</h4>
<p>说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</p>
<h4> 6.【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</h4>
<h4> 7.【推荐】了解每个服务大致的平均耗时，可以通过独立配置线程池，将较慢的服务与主线程池隔离开，免得不同服务的线程同归于尽。</h4>
<h4> 8.【参考】服务器内部重定向必须使用 forward；外部部重定向地址必须使用 URL Broker 生成，否则因线上采用 HTTPS 协议而导致浏览器提示“不安全”。此外，还会带来 URL 维护不一致的问题。</h4>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T09:50:08.000Z</published>
  </entry>
  <entry>
    <title type="text">库表规范</title>
    <id>https://ujava.cn/standard/database.html</id>
    <link href="https://ujava.cn/standard/database.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> (一) 建表规约</h2>
<h4> 1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</h4>
<p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</p>
<ul>
<li>说明：任何字段如果为非负数，必须是 unsigned。</li>
<li>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> (一) 建表规约</h2>
<h4> 1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。</h4>
<p>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</p>
<ul>
<li>说明：任何字段如果为非负数，必须是 unsigned。</li>
<li>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</li>
</ul>
<h4> 2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</h4>
<p>说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<ul>
<li>正例：aliyun_admin，rdc_config，level3_name</li>
<li>反例：AliyunAdmin，rdcConfig，level_3_name</li>
</ul>
<h4> 3.【强制】表名不使用复数名词。</h4>
<p>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<h4> 4.【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</h4>
<h4> 5.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</h4>
<p>说明：pk_即 primary key；uk_即 unique key；idx_即 index 的简称。</p>
<h4> 6.【强制】小数类型为 decimal，禁止使用 float 和 double。</h4>
<p>说明：在存储的时候，float 和 double 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数并分开存储。</p>
<h4> 7.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</h4>
<h4> 8.【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引率。</h4>
<h4> 9.【强制】表必备三字段：id，create_time，update_time。</h4>
<p>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time，update_time 的类型均为datetime 类型，如果要记录时区信息，那么类型设置为 timestamp。</p>
<h4> 10.【强制】在数据库中不能使用物理删除操作，要使用逻辑删除。</h4>
<p>说明：逻辑删除在数据删除后可以追溯到行为操作。不过会使得一些情况下的唯一主键变得不唯一，需要根据情况来酌情解决。</p>
<h4> 11.【推荐】表的命名最好是遵循“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config / tes_question</h4>
<h4> 12.【推荐】库名与应用名称尽量一致。</h4>
<h4> 13.【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</h4>
<h4> 14.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</h4>
<ul>
<li>1）不是频繁修改的字段。</li>
<li>2）不是唯一索引的字段。</li>
<li>3）不是 varchar 超长字段，更不能是 text 字段。<br>
正例：各业务线经常冗余存储商品名称，避免查询时需要调用 IC 服务获取。</li>
</ul>
<h4> 15.【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</h4>
<p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<h4> 16.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</h4>
<p>正例：无符号值可以避免误存负数，且扩大了表示范围：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>年龄区间</th>
<th>类型</th>
<th>字节</th>
<th>表示范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>人</td>
<td>150 岁之内</td>
<td>tinyint unsigned</td>
<td>1</td>
<td>无符号值：0 到 255</td>
</tr>
<tr>
<td>龟</td>
<td>数百岁</td>
<td>smallint unsigned</td>
<td>2</td>
<td>无符号值：0 到 65535</td>
</tr>
<tr>
<td>恐龙化石</td>
<td>数千万年</td>
<td>int unsigned</td>
<td>4</td>
<td>无符号值：0 到约 43 亿</td>
</tr>
<tr>
<td>太阳</td>
<td>约 50 亿年</td>
<td>bigint unsigned</td>
<td>8</td>
<td>无符号值：0 到约 10 的 19 次方</td>
</tr>
</tbody>
</table>
<h2> (二) 索引规约</h2>
<h4> 1.【强制】业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</h4>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
<h4> 2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</h4>
<p>说明：即使双表 join 也要注意表索引、SQL 性能。</p>
<h4> 3.【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</h4>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名，索引长度)) / count(*) 的区分度来确定。</p>
<h4> 4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</h4>
<p>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<h4> 5.【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 filesort 的情况，影响查询性能。</h4>
<ul>
<li>正例：where a = ? and b = ? order by c；索引：a_b_c</li>
<li>反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a &gt; 10 ORDER BY b；索引 a_b 无法排序。</li>
</ul>
<h4> 6.【推荐】利用覆盖索引来进行查询操作，避免回表。</h4>
<p>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br>
正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。</p>
<h4> 7.【推荐】利用延迟关联或者子查询优化超多分页场景。</h4>
<p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<p>正例：先快速定位需要获取的 id 段，然后再关联：</p>
<p>SELECT t1.* FROM 表 1 as t1 , (select id from 表 1 where 条件 LIMIT 100000 , 20) as t2 where <a href="http://t1.id" target="_blank" rel="noopener noreferrer">t1.id</a> = <a href="http://t2.id" target="_blank" rel="noopener noreferrer">t2.id</a></p>
<h4> 8.【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 const 最好。</h4>
<p>说明：</p>
<ul>
<li>1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</li>
<li>2）ref 指的是使用普通的索引（normal index）。</li>
<li>3）range 对索引进行范围检索。<br>
反例：explain 表的结果，type = index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。</li>
</ul>
<h4> 9.【推荐】建组合索引的时候，区分度最高的在最左边。</h4>
<p>正例：如果 where a = ? and b = ?，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p>
<p>说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where c &gt; ? and d = ? 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即建立组合索引 idx_d_c。</p>
<h4> 10.【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</h4>
<h4> 11.【参考】创建索引时避免有如下极端误解：</h4>
<ul>
<li>1）索引宁滥勿缺。认为一个查询就需要建一个索引。</li>
<li>2）吝啬索引的创建。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</li>
<li>3）抵制唯一索引。认为唯一索引一律需要在应用层通过“先查后插”方式解决。</li>
</ul>
<h2> (三) SQL 语句</h2>
<h4> 1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(<em>)，count(</em>) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</h4>
<p>说明：count(*) 会统计值为 NULL 的行，而 count(列名) 不会统计此列为 NULL 值的行。</p>
<h4> 2.【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1 , col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</h4>
<h4> 3.【强制】当某一列的值全是 NULL 时，count(col) 的返回结果为 0；但 sum(col) 的返回结果为 NULL，因此使用 sum() 时需注意 NPE 问题。</h4>
<p>正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IFNULL(SUM(column) , 0) FROM table;</p>
<h4> 4.【强制】使用 ISNULL() 来判断是否为 NULL 值。</h4>
<p>说明：NULL 与任何值的直接比较都为 NULL。</p>
<ul>
<li>1）NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。</li>
<li>2）NULL=NULL 的返回结果是 NULL，而不是 true。</li>
<li>3）NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。<br>
反例：在 SQL 语句中，如果在 null 前换行，影响可读性。</li>
</ul>
<p>select * from table where column1 is null and column3 is not null；而 ISNULL(column) 是一个整体，简洁易懂。从性能数据上分析，ISNULL(column) 执行效率更快一些。</p>
<h4> 5.【强制】代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</h4>
<h4> 6.【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</h4>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p>
<h4> 7.【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</h4>
<h4> 8.【强制】数据订正（特别是删除或修改记录操作）时，要先 select，避免出现误删除的情况，确认无误才能执行更新语句。</h4>
<h4> 9.【强制】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。</h4>
<p>说明：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p>
<ul>
<li>正例：select <a href="http://t1.name" target="_blank" rel="noopener noreferrer">t1.name</a> from first_table as t1 , second_table as t2 where <a href="http://t1.id" target="_blank" rel="noopener noreferrer">t1.id</a> = <a href="http://t2.id" target="_blank" rel="noopener noreferrer">t2.id</a>;</li>
<li>反例：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常： Column 'name' infield list is ambiguous。</li>
</ul>
<h4> 10.【推荐】SQL 语句中表的别名前加 as，并且以 t1、t2、t3、...的顺序依次命名。</h4>
<p>说明：</p>
<ul>
<li>1）别名可以是表的简称，或者是依照表在 SQL 语句中出现的顺序，以 t1、t2、t3 的方式命名。</li>
<li>2）别名前加 as 使别名更容易识别。<br>
正例：select <a href="http://t1.name" target="_blank" rel="noopener noreferrer">t1.name</a> from first_table as t1 , second_table as t2 where <a href="http://t1.id" target="_blank" rel="noopener noreferrer">t1.id</a> = <a href="http://t2.id" target="_blank" rel="noopener noreferrer">t2.id</a>;</li>
</ul>
<h4> 11.【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在1000 个之内。</h4>
<h4> 12.【参考】因国际化需要，所有的字符存储与表示，均采用 utf8mb4 字符集，字符计数方法需要注意。</h4>
<p>说明：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表情需要用 utf8mb4 来进行存储，注意它与 utf8 编码的区别。</p>
<h4> 13.【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。</h4>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
<h2> (四) ORM 映射</h2>
<h4> 1.【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</h4>
<p>说明：</p>
<ul>
<li>1）增加查询分析器解析成本。</li>
<li>2）增减字段容易与 resultMap 配置不一致。</li>
<li>3）无用字段增加网络消耗，尤其是 text 类型的字段。</li>
</ul>
<h4> 2.【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</h4>
<p>说明：参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。</p>
<h4> 3.【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。</h4>
<p>说明：配置映射关系，使字段与 DO 类解耦，方便维护。</p>
<h4> 4.【强制】sql.xml 配置参数使用：#{}，#param# 不要使用 ${} 此种方式容易出现 SQL 注入。</h4>
<h4> 5.【强制】iBATIS 自带的 queryForList(String statementName，int start，int size) 不推荐使用。</h4>
<p>说明：其实现方式是在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start，size的子集合，线上因为这个原因曾经出现过 OOM。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。</h4>
<p>反例：某同学为避免写一个，直接使用 Hashtable 来接收数据库返回结果，结果出现日常是把 bigint 转成 Long 值，而线上由于数据库版本不一样，解析成 BigInteger，导致线上问题。</p>
<h4> 7.【强制】更新数据表记录时，必须同时更新记录对应的 update_time 字段值为当前时间。</h4>
<h4> 8.【推荐】不要写一个大而全的数据更新接口。</h4>
<p>传入为 POJO 类，不管是不是自己的目标更新字段，都进行update table set c1 = value1 , c2 = value2 , c3 = value3；这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p>
<h4> 9.【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</h4>
<h4> 10.【参考】中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；表示不为空且不为 null 时执行；表示不为 null 值时执行。</h4>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T08:14:59.000Z</published>
  </entry>
  <entry>
    <title type="text">安全规范</title>
    <id>https://ujava.cn/standard/security.html</id>
    <link href="https://ujava.cn/standard/security.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h4> 1.【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。</h4>
<p>说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。</p>
<h4> 2.【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</h4>
<p>正例：中国大陆个人手机号码显示：139****1219，隐藏中间 4 位，防止隐私泄露。</p>
<h4> 3.【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</h4>
<p>反例：某系统签名大量被恶意修改，即是因为对于危险字符#--没有进行转义，导致数据库更新时，where 后边的信息被注释掉，对全库进行更新。</p>]]></summary>
    <content type="html"><![CDATA[<h4> 1.【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。</h4>
<p>说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容。</p>
<h4> 2.【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</h4>
<p>正例：中国大陆个人手机号码显示：139****1219，隐藏中间 4 位，防止隐私泄露。</p>
<h4> 3.【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</h4>
<p>反例：某系统签名大量被恶意修改，即是因为对于危险字符#--没有进行转义，导致数据库更新时，where 后边的信息被注释掉，对全库进行更新。</p>
<h4> 4.【强制】用户请求传入的任何参数必须做有效性验证。</h4>
<p>说明：忽略参数校验可能导致：</p>
<ul>
<li>⚫ 页面 page size 过大导致内存溢出</li>
<li>⚫ 恶意 order by 导致数据库慢查询</li>
<li>⚫ 缓存击穿</li>
<li>⚫ SSRF</li>
<li>⚫ 任意重定向</li>
<li>⚫ SQL 注入，Shell 注入，反序列化注入</li>
<li>⚫ 正则输入源串拒绝服务 ReDoS<br>
扩展：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 5.【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</li>
</ul>
<p>说明：XSS 跨站脚本攻击。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览时，嵌入其中 Web 里面的 html 代码会被执行，造成获取用户 cookie、钓鱼、获取用户页面数据、蠕虫、挂马等危害。</p>
<h4> 6.【强制】表单、AJAX 提交必须执行 CSRF 安全验证。</h4>
<p>说明：CSRF (Cross-site request forgery) 跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。</p>
<h4> 7.【强制】URL 外部重定向传入的目标地址必须执行白名单过滤。</h4>
<p>说明：攻击者通过恶意构造跳转的链接，可以向受害者发起钓鱼攻击。</p>
<h4> 8.【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。</h4>
<p>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。</p>
<h4> 9.【强制】对于文件上传功能，需要对于文件大小、类型进行严格检查和控制。</h4>
<p>说明：攻击者可以利用上传漏洞，上传恶意文件到服务器，并且远程执行，达到控制网站服务器的目的。</p>
<h4> 10.【强制】配置文件中的密码需要加密。</h4>
<h4> 11.【推荐】发贴、评论、发送等即时消息，需要用户输入内容的场景。必须实现防刷、内容违禁词过滤等风控策略。</h4>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T07:40:27.000Z</published>
  </entry>
  <entry>
    <title type="text">测试规范</title>
    <id>https://ujava.cn/standard/unit.html</id>
    <link href="https://ujava.cn/standard/unit.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h4> 1.【强制】好的单元测试必须遵守 AIR 原则。</h4>
<p>说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>
<ul>
<li>⚫ A：Automatic（自动化）</li>
<li>⚫ I：Independent（独立性）</li>
<li>⚫ R：Repeatable（可重复）</li>
</ul>
<h4> 2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用 System.out 来进行人肉验证，单元测试必须使用 assert 来验证。</h4>]]></summary>
    <content type="html"><![CDATA[<h4> 1.【强制】好的单元测试必须遵守 AIR 原则。</h4>
<p>说明：单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。</p>
<ul>
<li>⚫ A：Automatic（自动化）</li>
<li>⚫ I：Independent（独立性）</li>
<li>⚫ R：Repeatable（可重复）</li>
</ul>
<h4> 2.【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。不允许使用 System.out 来进行人肉验证，单元测试必须使用 assert 来验证。</h4>
<h4> 3.【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</h4>
<p>反例：method2 需要依赖 method1 的执行，将执行结果作为 method2 的输入。</p>
<h4> 4.【强制】单元测试是可以重复执行的，不能受到外界环境的影响。</h4>
<p>说明：单元测试通常会被放到持续集成中，每次有代码 push 时单元测试都会被执行。如果单测对外部环境（网络、服 务、中间件等）有依赖，容易导致持续集成机制的不可用。</p>
<p>正例：为了不受外界环境影响，要求设计代码时就把 SUT（Software under test）的依赖改成注入，在测试时用 Spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。</p>
<h4> 5.【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</h4>
<p>说明：测试粒度小才能在出错时尽快定位到出错的位置。单元测试不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p>
<h4> 6.【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。</h4>
<p>说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p>
<h4> 7.【强制】单元测试代码必须写在如下工程目录： src/test/java，不允许写在业务代码目录下。</h4>
<p>说明：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。</p>
<h4> 8.【推荐】单测的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%</h4>
<p>说明：在工程规约的应用分层中提到的 DAO 层，Manager 层，可重用度高的 Service，都应该进行单元测试。</p>
<h4> 9.【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。</h4>
<ul>
<li>⚫ B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li>
<li>⚫ C：Correct，正确的输入，并得到预期的结果。</li>
<li>⚫ D：Design，与设计文档相结合，来编写单元测试。</li>
<li>⚫ E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。</li>
</ul>
<h4> 10.【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。</h4>
<p>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。</p>
<h4> 11.【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。</h4>
<p>正例：在基础技术部的内部单元测试中，使用 FOUNDATION_UNIT_TEST_的前缀来标识单元测试相关代码。</p>
<h4> 12.【推荐】对于不可测的代码在适当的时机做必要的重构，使代码变得可测避免为了达到测试要求而书写不规范测试代码。</h4>
<h4> 13.【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。</h4>
<h4> 14.【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。</h4>
<h4> 15.【参考】为了更方便地进行单元测试，业务代码应避免以下情况：</h4>
<ul>
<li>⚫ 构造方法中做的事情过多。</li>
<li>⚫ 存在过多的全局变量和静态方法。</li>
<li>⚫ 存在过多的外部依赖。</li>
<li>⚫ 存在过多的条件语句。</li>
</ul>
<p>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</p>
<h4> 16.【参考】不要对单元测试存在如下误解：</h4>
<ul>
<li>⚫ 那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li>
<li>⚫ 单元测试代码是多余的。系统的整体功能与各单元部件的测试正常与否是强相关的。</li>
<li>⚫ 单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。</li>
<li>⚫ 单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</li>
</ul>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-18T07:40:27.000Z</published>
  </entry>
  <entry>
    <title type="text">异常规范</title>
    <id>https://ujava.cn/standard/exception.html</id>
    <link href="https://ujava.cn/standard/exception.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> (一)、错误码</h2>
<h4> 1.【强制】错误码的制定原则：快速溯源、沟通标准化。</h4>
<p>说明：错误码想得过于完美和复杂，就像康熙字典的生僻字一样，用词似乎精准，但是字典不容易随身携带且简单易懂。</p>
<p>正例：错误码回答的问题是谁的错？错在哪？</p>
<ul>
<li>1）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。</li>
<li>2）错误码必须能够进行清晰地比对（代码中容易 equals）。</li>
<li>3）错误码有利于团队快速对错误原因达到一致认知。</li>
</ul>
<h4> 2.【强制】错误码不体现版本号和错误等级信息。</h4>]]></summary>
    <content type="html"><![CDATA[<h2> (一)、错误码</h2>
<h4> 1.【强制】错误码的制定原则：快速溯源、沟通标准化。</h4>
<p>说明：错误码想得过于完美和复杂，就像康熙字典的生僻字一样，用词似乎精准，但是字典不容易随身携带且简单易懂。</p>
<p>正例：错误码回答的问题是谁的错？错在哪？</p>
<ul>
<li>1）错误码必须能够快速知晓错误来源，可快速判断是谁的问题。</li>
<li>2）错误码必须能够进行清晰地比对（代码中容易 equals）。</li>
<li>3）错误码有利于团队快速对错误原因达到一致认知。</li>
</ul>
<h4> 2.【强制】错误码不体现版本号和错误等级信息。</h4>
<p>说明：错误码以不断追加的方式进行兼容。错误等级由日志和错误码本身的释义来决定。</p>
<h4> 3.【强制】全部正常，但不得不填充错误码时返回五个零：00000。</h4>
<h4> 4.【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。</h4>
<p>说明：错误产生来源分为 <code>A/B/C</code>，</p>
<ul>
<li>A 表示错误来源于用户，比如参数错误，用户安装版本过低，用户支付超时等问题；</li>
<li>B 表示错误来源于当前系统，往往是业务逻辑出错，或程序健壮性差等问题；</li>
<li>C 表示错误来源于第三方服务，比如 CDN 服务出错，消息投递超时等问题；四位数字编号从 0001 到 9999，大类之间的步长间距预留 100。</li>
</ul>
<h4> 5.【强制】编号不与公司业务架构，更不与组织架构挂钩，以先到先得的原则在统一平台上进行，审批生效，编号即被永久固定。</h4>
<h4> 6.【强制】错误码使用者避免随意定义新的错误码。</h4>
<p>说明：尽可能在原有错误码附表中找到语义相同或者相近的错误码在代码中使用即可。</p>
<h4> 7.【强制】错误码不能直接输出给用户作为提示信息使用。</h4>
<p>说明：堆栈（stack_trace）、错误信息(error_message) 、错误码（error_code）、提示信息（user_tip）是一个有效关联并互相转义的和谐整体，但是请勿互相越俎代庖。</p>
<h4> 8.【推荐】错误码之外的业务信息由 error_message 来承载，而不是让错误码本身涵盖过多具体业务属性。</h4>
<h4> 9.【推荐】在获取第三方服务错误码时，向上抛出允许本系统转义，由 C 转为 B，并且在错误信息上带上原有的第三方错误码。</h4>
<h4> 10.【参考】错误码分为一级宏观错误码、二级宏观错误码、三级宏观错误码。</h4>
<p>说明：在无法更加具体确定的错误场景中，可以直接使用一级宏观错误码，分别是：A0001（用户端错误）、B0001（系统执行出错）、C0001（调用第三方服务出错）。</p>
<p>正例：调用第三方服务出错是一级，中间件错误是二级，消息服务出错是三级。</p>
<h4> 11.【参考】错误码的后三位编号与 HTTP 状态码没有任何关系。</h4>
<h4> 12.【参考】错误码有利于不同文化背景的开发者进行交流与代码协作。</h4>
<p>说明：英文单词形式的错误码不利于非英语母语国家（如阿拉伯语、希伯来语、俄罗斯语等）之间的开发者互相协作。</p>
<h4> 13.【参考】错误码即人性，感性认知+口口相传，使用纯数字来进行错误码编排不利于感性记忆和分类。</h4>
<p>说明：数字是一个整体，每位数字的地位和含义是相同的。</p>
<p>反例：一个五位数字 12345，第 1 位是错误等级，第 2 位是错误来源，345 是编号，人的大脑不会主动地拆开并分辨每位数字的不同含义。</p>
<h2> (二)、异常处理</h2>
<h4> 1.【强制】Java 类库中定义的可以通过预检查方式规避的 RuntimeException 异常不应该通过 catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException 等等。</h4>
<p>说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，可能存在数字格式错误，不得不通过 catch NumberFormatException 来实现。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.【强制】异常捕获后不要用来做流程控制，条件控制。</h4>
<p>说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。</p>
<h4> 3.【强制】catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</h4>
<p>说明：对大段代码进行 try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。</p>
<p>正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。</p>
<h4> 4.【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</h4>
<h4> 5.【强制】事务场景中，抛出异常被 catch 后，如果需要回滚，一定要注意手动回滚事务。</h4>
<h4> 6.【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。</h4>
<p>说明：如果 JDK7，可以使用 try-with-resources 方式。</p>
<h4> 7.【强制】不要在 finally 块中使用 return</h4>
<p>说明：try 块中的 return 语句执行成功后，并不马上返回，而是继续执行 finally 块中的语句，如果此处存在 return 语句， 则会在此直接返回，无情丢弃掉 try 块中的返回点。</p>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</h4>
<p>说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p>
<h4> 9.【强制】在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常使用 Throwable 类进行拦截。</h4>
<p>说明：通过反射机制来调用方法，如果找不到方法，抛出 NoSuchMethodException。什么情况会抛出NoSuchMethodError 呢？二方包在类冲突时，仲裁机制可能导致引入非预期的版本使类的方法签名不匹配，或者在字节码修改框架（比如：ASM）动态创建或修改类时，修改了相应的方法签名。这些情况，即使代码编译期是正确的，但在代码运行期时，会抛出 NoSuchMethodError。</p>
<p>反例：足迹服务引入了高版本的 spring，导致运行到某段核心逻辑时，抛出 NoSuchMethodError 错误，catch 用的 类却是 Exception，堆栈向上抛，影响到上层业务。这是一个非核心功能点影响到核心应用的典型反例。</p>
<h4> 10.【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。</h4>
<p>说明：本规约明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败，运行时异常等场景返回 null 的情况。</p>
<h4> 11.【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：</h4>
<ul>
<li>1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE<br>
反例：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>2）数据库的查询结果可能为 null。</li>
<li>3）集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</li>
<li>4）远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</li>
<li>5）对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</li>
<li>6）级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。</li>
</ul>
<p>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。</p>
<h4> 12.【推荐】定义时区分 <code>unchecked / checked</code> 异常，避免直接抛出 new RuntimeException()，更不允许</h4>
<p>抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：<code>DAOException / ServiceException </code>等。</p>
<h4> 13.【参考】对于公司外的 <code>http / api</code> 开放接口必须使用错误码，而应用内部推荐异常抛出；跨应用间RPC 调用优先考虑使用 Result 方式，封装 isSuccess() 方法、错误码、错误简短信息；应用内部推荐异常抛出。</h4>
<p>说明：关于 RPC 方法返回方式使用 Result 方式的理由：</p>
<ul>
<li>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。</li>
<li>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。<br>
如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</li>
</ul>
<h2> (三)、日志规约</h2>
<h4> 1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架（SLF4J、JCL—Jakarta Commons Logging）中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</h4>
<p>说明：日志框架（SLF4J、JCL--Jakarta Commons Logging）的使用方式（推荐使用 SLF4J），使用 SLF4J：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以 “应用名.log”来保存，保存在<code>/{统一目录}/{应用名}/logs/目录</code>下，过往日志格式为：{logname}.log.{保存日期}，日期格式：yyyy-MM-dd</h4>
<p>正例：以 mppserver 应用为例，日志保存<code>/home/admin/mppserver/logs/mppserver.log</code>，历史日志名称为 mppserver.log.2021-11-28</p>
<h4> 3.【强制】根据国家法律，网络运行状态、网络安全事件、个人敏感信息操作等相关记录，留存的日志不少于六个月，并且进行网络多机备份。</h4>
<h4> 4.【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：</h4>
<p>appName_logType_logName.log。logType：日志类型，如 <code>stats / monitor / access</code> 等；</p>
<p>logName：日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。</p>
<p>说明：推荐对日志进行分类，将错误日志和业务日志分开放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p>
<p>正例：mppserver 应用中单独监控时区转换异常，如：mppserver_monitor_timeZoneConvert.log</p>
<h4> 5.【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。</h4>
<p>说明：因为 String 字符串的拼接会使用 StringBuilder 的 append() 方式，有一定的性能损耗。使用占位符仅是替换动作，可以有效提升性能。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.【强制】对于 <code>trace / debug / info</code> 级别的日志输出，必须进行日志级别的开关判断：</h4>
<p>说明：虽然在 debug(参数) 的方法体内第一行代码 isDisabled(Level.DEBUG_INT) 为真时（Slf4j 的常见实现 Log4j 和Logback），就直接 return，但是参数可能会进行字符串拼接运算。此外，如果 debug(getName()) 这种参数内有getName() 方法调用，无谓浪费方法调用的开销。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.【强制】避免重复打印日志，浪费磁盘空间，务必在日志配置文件中设置 additivity=false</h4>
<p>正例：<code>&lt;logger name="com.taobao.dubbo.config" additivity="false"&gt;&lt;/logger&gt;</code></p>
<h4> 8.【强制】生产环境禁止使用 System.out 或 System.err 输出或使用 e.printStackTrace() 打印异常堆栈。</h4>
<p>说明：标准日志输出与标准错误输出文件每次 Jboss 重启时才滚动，如果大量输出送往这两个文件，容易造成文件大小超过操作系统大小限制。</p>
<h4> 9.【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws 往上抛出。</h4>
<p>正例：logger.error("inputParams: {} and errorMessage: {}", 各类参数或者对象 toString(), e.getMessage(), e);</p>
<h4> 10.【强制】日志打印时禁止直接用 JSON 工具将对象转换成 String。</h4>
<p>说明：如果对象里某些 get 方法被覆写，存在抛出异常的情况，则可能会因为打印日志而影响正常业务流程的执行。</p>
<p>正例：打印日志时仅打印出业务相关属性值或者调用其对象的 toString() 方法。</p>
<h4> 11.【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</h4>
<p>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p>
<h4> 12.【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。</h4>
<p>说明：注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。</p>
<h4> 13.【推荐】尽量用英文来描述日志错误信息，如果日志中的错误信息用英文描述不清楚的话使用中文描述即可，否则容易产生歧义。</h4>
<p>说明：国际化团队或海外部署的服务器由于字符集问题，使用全英文来注释和描述日志错误信息。</p>
<h4> 14.【推荐】为了保护用户隐私，日志文件中的用户敏感信息需要进行脱敏处理。</h4>
<p>说明：日志排查问题时，推荐使用订单号、UUID 之类的唯一编号进行查询。</p>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-16T12:01:48.000Z</published>
  </entry>
  <entry>
    <title type="text">设计规范</title>
    <id>https://ujava.cn/standard/</id>
    <link href="https://ujava.cn/standard/"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>标准依次分为【强制】、【推荐】、【参考】三大类。在延伸的信息中，“说明”对规约做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。</p>
<p>标准的愿景是码出高效，码出质量。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>标准依次分为【强制】、【推荐】、【参考】三大类。在延伸的信息中，“说明”对规约做了适当扩展和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。</p>
<p>标准的愿景是码出高效，码出质量。</p>
]]></content>
    <category term="设计规范"/>
    <published>2023-10-16T11:56:58.000Z</published>
  </entry>
  <entry>
    <title type="text">编程规范</title>
    <id>https://ujava.cn/standard/code.html</id>
    <link href="https://ujava.cn/standard/code.html"/>
    <updated>2023-10-23T12:02:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> (一) 命名风格</h2>
<h4> 1.【强制】所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h4>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>反例：_name <span class="token operator">/</span> __name <span class="token operator">/</span> $<span class="token class-name">Object</span> <span class="token operator">/</span> name_ <span class="token operator">/</span> name$ <span class="token operator">/</span> <span class="token class-name">Object</span>$
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h2> (一) 命名风格</h2>
<h4> 1.【强制】所有编程相关的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.【强制】所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</h4>
<p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。</p>
<ul>
<li>正例：ali / alibaba / taobao / kaikeba / aliyun / youku / hangzhou 等国际通用的名称，可视同英文。</li>
<li>反例：DaZhePromotion【打折】/ getPingfenByName()【评分】 / String fw【福娃】/ int 变量名 = 3</li>
</ul>
<h4> 3.【强制】代码和注释中都要避免使用任何人类语言中的种族歧视性或侮辱性词语。</h4>
<ul>
<li>正例：blockList / allowList / secondary</li>
<li>反例：blackList / whiteList / slave / SB / WTF</li>
</ul>
<h4> 4.【强制】类名使用 UpperCamelCase 风格，以下情形例外：DO / PO / DTO / BO / VO / UID 等。</h4>
<ul>
<li>正例：ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</li>
<li>反例：forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</li>
</ul>
<h4> 5.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</h4>
<p>正例：localValue / getHttpMessage() / inputUserId</p>
<h4> 6.【强制】常量命名应该全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</h4>
<ul>
<li>正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME</li>
<li>反例：MAX_COUNT / EXPIRED_TIME</li>
</ul>
<h4> 7.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾，测试类命名以它要测试的类的名称开始，以 Test 结尾。</h4>
<h4> 8.【强制】类型与中括号紧挨相连来定义数组。</h4>
<ul>
<li>正例：定义整形数组 int[] arrayDemo。</li>
<li>反例：在 main 参数中，使用 String args[] 来定义。</li>
</ul>
<h4> 9.【强制】POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</h4>
<ul>
<li>说明：本文 MySQL 规约中的建表约定第 1 条，表达是与否的变量采用 is_xxx 的命名方式，所以需要在&lt;resultMap####&lt;/resultMap####设置从 is_xxx 到 xxx 的映射关系。</li>
<li>反例：定义为布尔类型 Boolean isDeleted 的字段，它的 getter 方法也是 isDeleted()，部分框架在反向解析时，“误以为”对应的字段名称是 deleted，导致字段获取不到，得到意料之外的结果或抛出异常。</li>
</ul>
<h4> 10.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</h4>
<p>正例：应用工具类包名为 com.alibaba.ei.kunlun.aap.util；类名为 MessageUtils（此规则参考 spring 的框架结构）。</p>
<h4> 11.【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。</h4>
<p>说明：子类、父类成员变量名相同，即使是 public 也是能够通过编译，而局部变量在同一方法内的不同代码块中同名<br>
也是合法的，但是要避免使用。对于非 setter / getter 的参数名称也要避免与成员变量名称相同。</p>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 12.【强制】杜绝完全不规范的英文缩写，避免望文不知义。</h4>
<p>反例：AbstractClass“缩写”成 AbsClass；condition“缩写”成 condi；Function“缩写”成 Fu，此类随意缩写<br>
严重降低了代码的可阅读性。</p>
<h4> 13.【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用完整的单词组合来表达。</h4>
<ul>
<li>正例：在 JDK 中，对某个对象引用的 volatile 字段进行原子更新的类名为 AtomicReferenceFieldUpdater。</li>
<li>反例：常见的方法内变量为 int a; 的定义方式。</li>
</ul>
<h4> 14.【推荐】在常量与变量命名时，表示类型的名词放在词尾，以提升辨识度。</h4>
<ul>
<li>正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT</li>
<li>反例：startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD</li>
</ul>
<h4> 15.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时要体现出具体模式。</h4>
<p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br>
正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 16.【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义常量，如果一定要定义，最好确定该常量与接口的方法相关，并且是整个应用的基础常量。</h4>
<ul>
<li>正例：接口方法签名 void commit();</li>
<li>接口基础常量 String COMPANY = "alibaba";</li>
<li>反例：接口方法定义 public abstract void commit();<br>
说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。</li>
</ul>
<h4> 17.接口和实现类的命名有两套规则：</h4>
<p>1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</p>
<ul>
<li>正例：CacheServiceImpl 实现 CacheService 接口。<br>
2）【推荐】如果是形容能力的接口名称，取对应的形容词为接口名（通常是 –able 结尾的形容词）。</li>
<li>正例：AbstractTranslator 实现 Translatable。</li>
</ul>
<h4> 18.【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</h4>
<p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p>
<ul>
<li>正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON</li>
</ul>
<h4> 19.【参考】各层命名规约：</h4>
<p>A）Service / DAO 层方法命名规约：</p>
<ul>
<li>1）获取单个对象的方法用 get 做前缀。</li>
<li>2）获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects</li>
<li>3）获取统计值的方法用 count 做前缀。 4）插入的方法用 save / insert 做前缀。</li>
<li>5）删除的方法用 remove / delete 做前缀。 6）修改的方法用 update 做前缀。</li>
</ul>
<p>B）领域模型命名规约：</p>
<ul>
<li>1）数据对象：xxxDO，xxx 即为数据表名。</li>
<li>2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li>
<li>3）展示对象：xxxVO，xxx 一般为网页名称。</li>
<li>4）POJO 是 DO / DTO / BO / VO 的统称，禁止命名成 xxxPOJO。</li>
</ul>
<h2> (二) 常量定义</h2>
<h4> 1.【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</h4>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.【强制】long 或 Long 赋值时，数值后使用大写 L，不能是小写 l，小写容易跟数字混淆，造成误解。</h4>
<p>说明：public static final Long NUM = 2l; 写的是数字的 21，还是 Long 型的 2？</p>
<h4> 3.【强制】浮点数类型的数值后缀统一为大写的 D 或 F。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</h4>
<p>说明：大而全的常量类，杂乱无章，使用查找功能才能定位到要修改的常量，不利于理解，也不利于维护。</p>
<ul>
<li>正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 SystemConfigConsts 下。</li>
</ul>
<h4> 5.【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</h4>
<ul>
<li>1）跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。</li>
<li>2）应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>3）子工程内部共享常量：即在当前子工程的 constant 目录下。</li>
<li>4）包内共享常量：即在当前包下单独的 constant 目录下。</li>
<li>5）类内共享常量：直接在类内部 private static final 定义。</li>
</ul>
<h4> 6.【推荐】如果变量值仅在一个固定范围内变化用 enum 类型来定义。</h4>
<p>说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> (三) 代码格式</h2>
<h4> 1.【强制】如果大括号内为空，简洁地写成{}即可，大括号中间无需换行和空格；如果是非空代码块，则：</h4>
<ul>
<li>1）左大括号前不换行。</li>
<li>2）左大括号后换行。</li>
<li>3）右大括号前换行。</li>
<li>4）右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。</li>
</ul>
<h4> 2.【强制】左小括号和右边相邻字符之间不需要空格；右小括号和左边相邻字符之间也不需要空格；而左大括号前需要加空格。详见第 5 条下方正例提示。</h4>
<p>反例：if(空格 a == b 空格)</p>
<h4> 3.【强制】if / for / while / switch / do 等保留字与左右括号之间都必须加空格。</h4>
<h4> 4.【强制】任何二目、三目运算符的左右两边都需要加一个空格。</h4>
<p>说明：包括赋值运算符 =、逻辑运算符 &amp;&amp;、加减乘除符号等。</p>
<h4> 5.【强制】采用 4 个空格缩进，禁止使用 Tab 字符。</h4>
<p>说明：如使用 Tab 缩进，必须设置 1 个 Tab 为 4 个空格。IDEA 设置 Tab 为 4 个空格时，请勿勾选 Use tab character；<br>
而在 Eclipse 中，找到 tab policy 设置为 Spaces only，Tab size：4，最后必须勾选 insert spaces for tabs<br>
正例：（涉及上述中的 1-5 点）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.【强制】注释的双斜线与注释内容之间有且仅有一个空格。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</h4>
<ul>
<li>1）第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li>
<li>2）运算符与下文一起换行。</li>
<li>3）方法调用的点符号与下文一起换行。</li>
<li>4）方法调用中的多个参数需要换行时，在逗号后进行。</li>
<li>5）在括号前不要换行，见反例。<br>
正例：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 9.【强制】方法参数在定义和传入时，多个参数逗号后面必须加空格。</h4>
<p>正例：下例中实参的 args1 逗号后边必须要有一个空格。 method(args1, args2, args3);</p>
<h4> 10.【强制】IDE 的 text file encoding 设置为 UTF-8；IDE 中文件的换行符使用 Unix 格式，不要使用Windows 格式。</h4>
<h4> 11.【推荐】单个方法的总行数不超过 80 行。</h4>
<p>说明：除注释之外的方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数不超过 80 行。</p>
<p>正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加晰；共性逻辑抽取<br>
成为共性方法，便于复用和维护。</p>
<h4> 12.【推荐】没有必要增加若干空格来使变量的赋值等号与上一行对应位置的等号对齐。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：增加 builder 这个变量，如果需要对齐，则给 one、two、three 都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。</p>
<h4> 13.【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行，分隔开来以提升可读性。</h4>
<p>说明：任何情形，没有必要插入多个空行进行隔开。</p>
<h2> (四) OOP 规约</h2>
<h4> 1.【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</h4>
<h4> 2.【强制】所有的覆写方法，必须加 @Override 注解。</h4>
<p>说明：getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override 可以准确判断是否覆盖<br>
成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p>
<h4> 3.【强制】相同参数类型，相同业务含义，才可以使用的可变参数，参数类型避免定义为 Object。</h4>
<p>说明：可变参数必须放置在参数列表的最后。（建议开发者尽量不用可变参数编程）</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 4.【强制】外部正在调用的接口或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</h4>
<h4> 5.【强制】不能使用过时的类或方法。</h4>
<p>说明：java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数<br>
decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用<br>
方来说，有义务去考证过时方法的新实现是什么。</p>
<h4> 6.【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</h4>
<ul>
<li>正例："test".equals(param);</li>
<li>反例：param.equals("test");<br>
说明：推荐使用 JDK7 引入的工具类 java.util.Objects#equals(Object a, Object b)</li>
</ul>
<h4> 7.【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。</h4>
<p>说明：对于 Integer var = ? 在 -128 至 127 之间的赋值，Integer 对象是在 IntegerCache.cache 产生，会复用已有对<br>
象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复<br>
用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p>
<h4> 8.【强制】任何货币金额，均以最小货币单位且为整型类型进行存储。</h4>
<h4> 9.【强制】浮点数之间的等值判断，基本数据类型不能使用 == 进行比较，包装数据类型不能使用 equals进行判断。</h4>
<p>说明：浮点数采用“尾数+阶码”的编码方式，类似于科学计数法的“有效数字+指数”的表示方式。二进制无法精确表<br>
示大部分的十进制小数。</p>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正例：</p>
<p>(1)指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(2)使用 BigDecimal 来定义值，再进行浮点数的运算操作。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.【强制】BigDecimal 的等值比较应使用 compareTo() 方法，而不是 equals() 方法。</h4>
<p>说明：equals() 方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo() 则会忽略精度。</p>
<h4> 11.【强制】定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</h4>
<ul>
<li>正例：数据库字段的 bigint 必须与类属性的 Long 类型相对应。</li>
<li>反例：某业务的数据库表 id 字段定义类型为 bigint unsigned，实际类对象属性为 Integer，随着 id 越来越大，超过 Integer 的表示范围而溢出成为负数，此时数据库 id 不支持存入负数抛出异常产生线上故障。</li>
</ul>
<h4> 12.【强制】禁止使用构造方法 BigDecimal(double) 的方式把 double 值转化为 BigDecimal 对象。</h4>
<p>说明：BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。如：<br>
BigDecimal g = new BigDecimal(0.1F)；实际的存储值为：0.100000001490116119384765625</p>
<p>正例：优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的<br>
toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 13.关于基本数据类型与包装数据类型的使用标准如下：</h4>
<ul>
<li>1）【强制】所有的 POJO 类属性必须使用包装数据类型。</li>
<li>2）【强制】RPC 方法的返回值和参数必须使用包装数据类型。</li>
<li>3）【推荐】所有的局部变量使用基本数据类型。</li>
</ul>
<p>说明：POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何 NPE 问题，或者入库检查，<br>
都由使用者来保证。</p>
<ul>
<li>正例：数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。</li>
<li>反例：某业务的交易报表上显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的<br>
信息，如：远程调用失败，异常退出。</li>
</ul>
<h4> 14.【强制】定义 DO / PO / DTO / VO 等 POJO 类时，不要设定任何属性默认值。</h4>
<p>反例：某业务的 DO 的 createTime 默认值为 new Date()；但是这个属性在数据提取时并没有置入具体值，在更新其<br>
它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p>
<h4> 15.【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</h4>
<p>说明：注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>
<h4> 16.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</h4>
<h4> 17.【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具 source &gt; generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString()。</h4>
<p>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString() 方法打印其属性值，便于排查问题。</p>
<h4> 18.【强制】禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx() 和 getXxx() 方法。</h4>
<p>说明：框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到，神坑之一。</p>
<h4> 19.【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，</h4>
<p>否则会有抛 IndexOutOfBoundsException 的风险。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 20.【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，</h4>
<p>此条规则优先于下一条。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 21.【推荐】类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter / setter 方法。</h4>
<p>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设<br>
计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有<br>
Service 和 DAO 的 getter / setter 方法放在类体最后。</p>
<h4> 22.【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在 getter / setter 方法中，不要增加业务逻辑，增加排查问题的难度。</h4>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 23.【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</h4>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过<br>
toString() 返回 String 对象，造成内存资源浪费。</p>
<h4> 24.【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：</h4>
<ul>
<li>1）不允许被继承的类，如：String 类。</li>
<li>2）不允许修改引用的域对象，如：POJO 类的域变量。</li>
<li>3）不允许被覆写的方法，如：POJO 类的 setter 方法。</li>
<li>4）不允许运行过程中重新赋值的局部变量。</li>
<li>5）避免上下文重复使用一个变量，使用 final 关键字可以强制重新定义一个变量，方便更好地进行重构。</li>
</ul>
<h4> 25.【推荐】慎用 Object 的 clone 方法来拷贝对象。</h4>
<p>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝需覆写 clone 方法实现域对象的深度遍历式拷贝。</p>
<h4> 26.【推荐】类成员与方法访问控制从严：</h4>
<ul>
<li>1）如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。</li>
<li>2）工具类不允许有 public 或 default 构造方法。</li>
<li>3）类非 static 成员变量并且与子类共享，必须是 protected。</li>
<li>4）类非 static 成员变量并且仅在本类使用，必须是 private。</li>
<li>5）类 static 成员变量如果仅在本类使用，必须是 private。</li>
<li>6）若是 static 成员变量，考虑是否为 final。</li>
<li>7）类成员方法只供类内部调用，必须是 private。</li>
<li>8）类成员方法只对继承类公开，那么限制为 protected。</li>
</ul>
<p>说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个<br>
private 的方法，想删除就删除，可是一个 public 的 service 成员方法或成员变量，删除一下，不得手心冒点汗吗？<br>
变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p>
<h2> (五) 日期时间</h2>
<h4> 1.【强制】日期格式化时，传入 pattern 中表示年份统一使用小写的 y。</h4>
<p>说明：日期格式化时，yyyy 表示当天所在的年，而大写的 YYYY 代表是 week in which year（JDK7 之后引入的概念），<br>
意思是当天所在的周属于的年份，一周从周日开始，周六结束，只要本周跨年，返回的 YYYY 就是下一年。</p>
<p>正例：表示日期和时间的格式如下所示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>反例：某程序员因使用 YYYY/MM/dd 进行日期格式化，2017/12/31 执行结果为 2018/12/31，造成线上故障。</p>
<h4> 2.【强制】在日期格式中分清楚大写的 M 和小写的 m，大写的 H 和小写的 h 分别指代的意义。</h4>
<p>说明：日期格式中的这两对字母表意如下：</p>
<ul>
<li>1）表示月份是大写的 M</li>
<li>2）表示分钟则是小写的 m</li>
<li>3）24 小时制的是大写的 H</li>
<li>4）12 小时制的则是小写的 h</li>
</ul>
<h4> 3.【强制】获取当前毫秒数：System.currentTimeMillis()；而不是 new Date().getTime()。</h4>
<p>说明：获取纳秒级时间，则使用 System.nanoTime 的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p>
<h4> 4.【强制】不允许在程序任何地方中使用：</h4>
<ul>
<li>1）java.sql.Date</li>
<li>2）java.sql.Time</li>
<li>3）java.sql.Timestamp。</li>
</ul>
<p>说明：第 1 个不记录时间，getHours() 抛出异常；第 2 个不记录日期，getYear() 抛出异常；第 3 个在构造方法<br>
super((time / 1000) * 1000)，在 Timestamp 属性 fastTime 和 nanos 分别存储秒和纳秒信息。</p>
<p>反例：java.util.Date.after(Date) 进行时间比较时，当入参是 java.sql.Timestamp 时，会触发 JDK BUG（JDK9 已修<br>
复），可能导致比较时的意外结果。</p>
<h4> 5.【强制】禁止在程序中写死一年为 365 天，避免在公历闰年时出现日期转换错误或程序逻辑错误。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 6.【推荐】避免公历闰年 2 月问题。闰年的 2 月份有 29 天，一年后的那一天不可能是 2 月 29 日。</h4>
<h4> 7.【推荐】使用枚举值来指代月份。如果使用数字，注意 Date，Calendar 等日期相关类的月份 month 取 值范围从 0 到 11 之间。</h4>
<p>说明：参考 JDK 原生注释，Month value is 0-based. e.g., 0 for January.</p>
<p>正例：Calendar.JANUARY，Calendar.FEBRUARY，Calendar.MARCH 等来指代相应月份来进行传参或比较。</p>
<h2> (六) 集合处理</h2>
<h4> 1.【强制】关于 hashCode 和 equals 的处理，遵循如下规则：</h4>
<ul>
<li>1）只要覆写 equals，就必须覆写 hashCode。</li>
<li>2）因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。</li>
<li>3）如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。</li>
</ul>
<p>说明：String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。</p>
<h4> 2.【强制】判断所有集合内部的元素是否为空，使用 isEmpty() 方法，而不是 size() == 0 的方式。</h4>
<p>说明：在某些集合中，前者的时间复杂度为 O(1)，而且可读性更好。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.【强制】在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要使用参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key 时会抛出IllegalStateException 异常。</h4>
<p>说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.【强制】在使用 java.util.stream.Collectors 类的 toMap() 方法转为 Map 集合时，一定要注意当 value为 null 时会抛 NPE 异常。</h4>
<p>说明：在 java.util.HashMap 的 merge 方法里会进行如下的判断：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：</h4>
<p>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。</p>
<p>说明：subList() 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于<br>
SubList 的所有操作最终会反映到原列表上。</p>
<h4> 6.【强制】使用 Map 的方法 keySet() / values() / entrySet() 返回集合对象时，不可以对其进行添加元素</h4>
<p>操作，否则会抛出 UnsupportedOperationException 异常。</p>
<h4> 7.【强制】Collections 类返回的对象，如：emptyList() / singletonList() 等都是 immutable list，不可对其进行添加或者删除元素的操作。</h4>
<p>反例：如果查询无结果，返回 Collections.emptyList() 空集合对象，调用方一旦在返回的集合中进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。</p>
<h4> 8.【强制】在 subList 场景中，高度注意对父集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</h4>
<p>说明：抽查表明，90% 的程序员对此知识点都有错误的认知。</p>
<h4> 9.【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一致、长度为0 的空数组。</h4>
<ul>
<li>反例：直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。</li>
<li>正例：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：使用 toArray 带参方法，数组空间大小的 length：</p>
<ul>
<li>1）等于 0，动态创建与 size 相同的数组，性能最好。</li>
<li>2）大于 0 但小于 size，重新创建大小等于 size 的数组，增加 GC 负担。</li>
<li>3）等于 size，在高并发情况下，数组创建完成之后，size 正在变大的情况下，负面影响与 2 相同。</li>
<li>4）大于 size，空间浪费，且在 size 处插入 null 值，存在 NPE 隐患。</li>
</ul>
<h4> 10.【强制】使用 Collection 接口任何实现类的 addAll() 方法时，要对输入的集合参数进行 NPE 判断。</h4>
<p>说明：在 ArrayList#addAll 方法的第一行代码即 Object[] a = c.toArray()；其中 c 为输入集合参数，如果为 null，<br>
则直接抛出异常。</p>
<h4> 11.【强制】使用工具类 Arrays.asList() 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/ remove / clear 方法会抛出 UnsupportedOperationException 异常。</h4>
<p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只<br>
是转换接口，后台的数据仍是数组。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第一种情况：list.add("a"); 运行时异常。</li>
<li>第二种情况：str[0] = "change"; list 中的元素也会随之修改，反之亦然。</li>
</ul>
<h4> 12.【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法， 而&lt;? super T&gt;不能使用 get 方法，两者在接口调用赋值的场景中容易出错。</h4>
<p>说明：扩展说一下 PECS(Producer Extends Consumer Super) 原则，即频繁往外读取内容的，适合用&lt;? extends T&gt;，经常往里插入的，适合用&lt;? super T&gt;</p>
<h4> 13.【强制】在无泛型限制定义的集合赋值给泛型限制的集合时，在使用集合元素时，需要进行instanceof 判断，避免抛出 ClassCastException 异常。</h4>
<p>说明：毕竟泛型是在 JDK5 后才出现，考虑到向前兼容，编译器是允许非泛型集合与泛型集合互相赋值。</p>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 14.【强制】不要在 foreach 循环里进行元素的 remove / add 操作。remove 元素请使用 iterator 方式，</h4>
<p>如果并发操作，需要对 iterator 对象加锁。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：反例中的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”会是同样的结果吗？</p>
<h4> 15.【强制】在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常。</h4>
<p>说明：三个条件如下</p>
<ul>
<li>1）x，y 的比较结果和 y，x 的比较结果相反。</li>
<li>2）x &gt; y，y &gt; z，则 x &gt; z。</li>
<li>3）x = y，则 x，z 比较结果和 y，z 比较结果相同。</li>
</ul>
<p>反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 16.【推荐】泛型集合使用时，在 JDK7 及以上，使用 diamond 语法或全省略。</h4>
<p>说明：菱形泛型，即 diamond，直接使用&lt;&gt;来指代前边已经指定的类型。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 17.【推荐】集合初始化时，指定集合初始值大小。</h4>
<p>说明：HashMap 使用构造方法 HashMap(int initialCapacity) 进行初始化时，如果暂时无法确定集合大小，那么指<br>
定默认值（16）即可。</p>
<ul>
<li>正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。</li>
<li>反例：HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素增加而被迫不断扩容，resize() 方法总共会调用 8 次，反复重建哈希表和数据迁移。当放置的集合元素个数达千万级时会影响程序性能。</li>
</ul>
<h4> 18.【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</h4>
<p>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而<br>
entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.forEach 方法。</p>
<p>正例：values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；<br>
entrySet() 返回的是 K-V 值组合的 Set 集合。</p>
<h4> 19.【推荐】高度注意 Map 类集合 K / V 能不能存储 null 值的情况，如下表格：</h4>
<table>
<thead>
<tr>
<th>集合类</th>
<th>Key</th>
<th>Value</th>
<th>Super</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>Dictionary</td>
<td>线程安全</td>
</tr>
<tr>
<td>TreeMap</td>
<td>不允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>不允许为 null</td>
<td>不允许为 null</td>
<td>AbstractMap</td>
<td>锁分段技术（JDK8:CAS）</td>
</tr>
<tr>
<td>HashMap</td>
<td>允许为 null</td>
<td>允许为 null</td>
<td>AbstractMap</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
<p>反例：由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛<br>
出 NPE 异常。</p>
<h4> 20.【参考】合理利用好集合的有序性（sort）和稳定性（order），避免集合的无序性（unsort）和不稳定性（unorder）带来的负面影响。</h4>
<p>说明：有序性是指遍历的结果是按某种比较规则依次排列的，稳定性指集合每次遍历的元素次序是一定的。如：</p>
<p>ArrayList 是 order / unsort；HashMap 是 unorder / unsort；TreeSet 是 order / sort。</p>
<h4> 21.【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains() 进行遍历去重或者判断包含操作。</h4>
<h2> (七) 并发处理</h2>
<h4> 1.【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</h4>
<p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p>
<h4> 2.【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</h4>
<p>正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</h4>
<p>说明：线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用<br>
线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>
<h4> 4.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</h4>
<p>说明：Executors 返回的线程池对象的弊端如下：</p>
<ul>
<li>1）FixedThreadPool 和 SingleThreadPool：
<ul>
<li>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>
</ul>
</li>
<li>2）CachedThreadPool：
<ul>
<li>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li>
</ul>
</li>
<li>3）ScheduledThreadPool：
<ul>
<li>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>
</ul>
</li>
</ul>
<h4> 5.【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</h4>
<p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替<br>
SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p>
<h4> 6.【强制】必须回收自定义的 ThreadLocal 变量记录的当前线程的值，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。</h4>
<p>尽量在代码中使用 try-finally 块进行回收。<br>
正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 7.【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</h4>
<p>说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p>
<h4> 8.【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</h4>
<p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可<br>
能出现死锁。</p>
<h4> 9.【强制】在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</h4>
<ul>
<li>说明一：在 lock 方法与 try 代码块之间的方法调用抛出异常，无法解锁，造成其它线程无法成功获取锁。</li>
<li>说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock 对未加锁的对象解锁，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），抛出 IllegalMonitorStateException 异常。</li>
<li>说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</li>
</ul>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。</h4>
<p>锁的释放规则与锁的阻塞等待方式相同。<br>
说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不<br>
持有锁，则抛出 IllegalMonitorStateException 异常。<br>
正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 11.【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</h4>
<p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p>
<h4> 12.【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</h4>
<h4> 13.【推荐】资金相关的金融敏感信息，使用悲观锁策略。</h4>
<p>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂<br>
的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p>
<p>正例：悲观锁遵循一锁二判三更新四释放的原则。</p>
<h4> 14.【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至 await 方法，直到超时才返回结果。</h4>
<p>说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p>
<h4> 15.【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。</h4>
<p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式。</p>
<p>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个<br>
单独的 Random 实例。</p>
<h4> 16.【推荐】通过双重检查锁（double-checked locking），实现延迟初始化需要将目标属性声明为volatile 型，（比如修改 helper 的属性声明为 private volatile Helper helper = null;）。</h4>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 17.【参考】volatile 解决多线程内存不可见问题对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</h4>
<p>说明：如果是 count++操作，使用如下类实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p>
<h4> 18.【参考】HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</h4>
<h4> 19.【参考】ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</h4>
<p>说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在<br>
类第一次被使用时装载，只分配一块存储空间，所有此类的对象（只要是这个线程内定义的）都可以操控这个变量。</p>
<h2> (八) 控制语句</h2>
<h4> 1.【强制】在一个 switch 块内，每个 case 要么通过 continue / break / return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。</h4>
<p>说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。</p>
<h4> 2.【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null 判断。</h4>
<p>反例：如下的代码输出是什么？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.【强制】在 if / else / for / while / do 语句中必须使用大括号。</h4>
<p>反例： if (condition) statements;</p>
<p>说明：即使只有一行代码，也要采用大括号的编码方式。 4.【强制】三目运算符 condition ? 表达式 1：表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能<br>
抛出因自动拆箱导致的 NPE 异常。</p>
<p>说明：以下两种场景会触发类型对齐的拆箱操作：</p>
<ul>
<li>1）表达式 1 或 表达式 2 的值只要有一个是原始类型。</li>
<li>2）表达式 1 或 表达式 2 的值的类型不一致，会强制拆箱升级成表示范围更大的那个类型。</li>
</ul>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5.【强制】在高并发场景中，避免使用“等于”判断作为中断或退出的条件。</h4>
<p>说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。</p>
<p>反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，<br>
活动无法终止。</p>
<h4> 6.【推荐】当方法的代码总行数超过 10 行时，return / throw 等中断逻辑的右大括号后需要加一个空行。</h4>
<p>说明：这样做逻辑清晰，有利于代码阅读时重点关注。</p>
<h4> 7.【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，请勿超过 3 层。</p>
<p>正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 8.【推荐】除常用方法（如 getXxx / isXxx）等外不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</h4>
<p>说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋<br>
值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 9.【推荐】不要在其它表达式（尤其是条件表达式）中，插入赋值语句。</h4>
<p>说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。</p>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 10.【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</h4>
<h4> 11.【推荐】避免采用取反逻辑运算符。</h4>
<p>说明：取反逻辑不利于快速理解，并且取反逻辑写法一般都存在对应的正向逻辑写法。</p>
<ul>
<li>正例：使用 if(x &lt; 628) 来表达 x 小于 628。</li>
<li>反例：使用 if(!(x &gt;= 628)) 来表达 x 小于 628。</li>
</ul>
<h4> 12.【推荐】公开接口需要进行入参保护，尤其是批量操作的接口。</h4>
<p>反例：某业务系统，提供一个用户批量查询的接口，API 文档上有说最多查多少个，但接口实现上没做任何保护，导致<br>
调用方传了一个 1000 的用户 id 数组过来后，查询信息后，内存爆了。</p>
<h4> 13.【参考】下列情形，需要进行参数校验：</h4>
<ul>
<li>1）调用频次低的方法。</li>
<li>2）执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。</li>
<li>3）需要极高稳定性和可用性的方法。</li>
<li>4）对外提供的开放接口，不管是 RPC / API / HTTP 接口。</li>
<li>5）敏感权限入口。</li>
</ul>
<h4> 14.【参考】下列情形，不需要进行参数校验：</h4>
<ul>
<li>1）极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查。</li>
<li>2）底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。</li>
<li>3）被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li>
</ul>
<h2> (九) 注释规约</h2>
<h4> 1.【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用 /** 内容 */ 格式，不得使用 // xxx方式。</h4>
<p>说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用<br>
方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
<h4> 2.【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数异常说明外，还必须指出该方法做什么事情，实现什么功能。</h4>
<p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p>
<h4> 3.【强制】所有的类都必须添加创建者和创建日期。</h4>
<p>说明：在设置模板时，注意 IDEA 的@author 为<code>${USER}</code>，而 eclipse 的@author 为<code>${user}</code>，大小写有区别，而日期<br>
的设置统一为 yyyy/MM/dd 的格式。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /* */注释，注意与代码对齐。</h4>
<h4> 5.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</h4>
<h4> 6.【推荐】与其用半吊子英文来注释，不如用中文注释说清楚。专有名词与关键字保持英文原文即可。</h4>
<p>反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p>
<h4> 7.【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等。</h4>
<p>说明：代码与注释更新不同步，就像公路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p>
<h4> 8.【推荐】在类中删除未使用的任何字段和方法、内部类；在方法中删除未使用的参数声明与内部变量。</h4>
<h4> 9.【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</h4>
<p>说明：代码被注释掉有两种可能性：</p>
<ul>
<li>1）后续会恢复此段代码逻辑。</li>
<li>2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉即可，假如需要查阅历史代码，登录代码仓库即可。</li>
</ul>
<h4> 10.【参考】对于注释的要求：</h4>
<ul>
<li>第一、能够准确反映设计思想和代码逻辑；</li>
<li>第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</li>
</ul>
<h4> 11.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的另一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释又是相当大的负担。</h4>
<p>反例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法名 put，加上两个有意义的变量名称 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p>
<h4> 12.【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</h4>
<ul>
<li>1）待办事宜（TODO）：（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。</li>
<li>2）错误，不能工作（FIXME）：（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li>
</ul>
<h2> (十) 前后端规约</h2>
<h4> 1.【强制】前后端交互的 API，需要明确协议、域名、路径、请求方法、请求内容、状态码、响应体。</h4>
<p>说明：</p>
<ul>
<li>1）协议：生产环境必须使用 HTTPS。</li>
<li>2）路径：每一个 API 需对应一个路径，表示 API 具体的请求地址：
<ul>
<li>a）代表一种资源，只能为名词，推荐使用复数，不能为动词，请求方法已经表达动作意义。</li>
<li>b）URL 路径不能使用大写，单词如果需要分隔，统一使用下划线。</li>
<li>c）路径禁止携带表示请求内容类型的后缀，比如".json"，".xml"，通过 accept 头表达即可。</li>
</ul>
</li>
<li>3）请求方法：对具体操作的定义，常见的请求方法如下：
<ul>
<li>a）GET：从服务器取出资源。</li>
<li>b）POST：在服务器新建一个资源。</li>
<li>c）PUT：在服务器更新资源。</li>
<li>d）DELETE：从服务器删除资源。</li>
</ul>
</li>
<li>4）请求内容：URL 带的参数必须无敏感信息或符合安全要求；body 里带参数时必须设置 Content-Type。</li>
<li>5）响应体：响应体 body 可放置多种数据类型，由 Content-Type 头来确定。</li>
</ul>
<h4> 2.【强制】前后端数据列表相关的接口返回，如果为空，则返回空数组[]或空集合{}。</h4>
<p>说明：此条约定有利于数据层面上的协作更加高效，减少前端很多琐碎的 null 判断。</p>
<h4> 3.【强制】服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码，errorCode、errorMessage、用户提示信息四个部分。</h4>
<p>说明：四个部分的涉众对象分别是浏览器、前端开发、错误排查人员、用户。其中输出给用户的提示信息要求：简短清<br>
晰、提示友好，引导用户进行下一步操作或解释错误原因，提示信息可以包括错误原因、上下文环境、推荐操作等。</p>
<p>errorCode：参考 。errorMessage：简要描述后端出错原因，便于错误排查人员快速定位问题，注意不要包含敏 感数据信息。</p>
<p>正例：常见的 HTTP 状态码如下</p>
<ul>
<li>1）200 OK：表明该请求被成功地完成，所请求的资源发送到客户端。</li>
<li>2）401 Unauthorized：请求要求身份验证，常见对于需要登录而用户未登录的情况。</li>
<li>3）403 Forbidden：服务器拒绝请求，常见于机密信息或复制其它登录用户链接访问服务器的情况。</li>
<li>4）404 NotFound：服务器无法取得所请求的网页，请求资源不存在。</li>
<li>5）500 InternalServerError：服务器内部错误。</li>
</ul>
<h4> 4.【强制】在前后端交互的 JSON 格式数据中，所有的 key 必须为小写字母开始的 lowerCamelCase风格，符合英文表达习惯，且表意完整。</h4>
<ul>
<li>正例：errorCode / errorMessage / assetStatus / menuList / orderList / configFlag</li>
<li>反例：ERRORCODE / ERROR_CODE / error_message / error-message / errormessage</li>
</ul>
<h4> 5.【强制】errorMessage 是前后端错误追踪机制的体现，可以在前端输出到 type="hidden" 文字类控件中，或者用户端的日志中，帮助我们快速地定位出问题。</h4>
<h4> 6.【强制】对于需要使用超大整数的场景，服务端一律使用 String 字符串类型返回，禁止使用 Long 类型。</h4>
<p>说明：Java 服务端如果直接返回 Long 整型数据给前端，Javascript 会自动转换为 Number 类型（注：此类型为双精度浮点数，表示原理与取值范围等同于 Java 中的 Double）。Long 类型能表示的最大值是 263-1，在取值范围之内，超过 253<br>
（9007199254740992）的数值转化为 Javascript 的 Number 时，有些数值会产生精度损失。扩展说明，在 Long 取值范围内，任何 2 的指数次的整数都是绝对不会存在精度损失的，所以说精度损失是一个概率问题。若浮点数尾数位与指数位<br>
空间不限，则可以精确表示任何整数，但很不幸，双精度浮点数的尾数位只有 52 位。</p>
<p>反例：通常在订单号或交易号大于等于 16 位，大概率会出现前后端订单数据不一致的情况。</p>
<p>比如，后端传输的 "orderId"：362909601374617692，前端拿到的值却是：362909601374617660</p>
<h4> 7.【强制】HTTP 请求通过 URL 传递参数时，不能超过 2048 字节。</h4>
<p>说明：不同浏览器对于 URL 的最大长度限制略有不同，并且对超出最大长度的处理逻辑也有差异，2048 字节是取所<br>
有浏览器的最小值。</p>
<p>反例：某业务将退货的商品 id 列表放在 URL 中作为参数传递，当一次退货商品数量过多时，URL 参数超长，传递到后端的参数被截断，导致部分商品未能正确退货。</p>
<h4> 8.【强制】HTTP 请求通过 body 传递内容时，必须控制长度，超出最大长度后，后端解析会出错。</h4>
<p>说明：nginx 默认限制是 1MB，tomcat 默认限制为 2MB，当确实有业务需要传较大内容时，可以调大服务器端的限制。</p>
<h4> 9.【强制】在翻页场景中，用户输入参数的小于 1，则前端返回第一页参数给后端；后端发现用户输入的参数大于总页数，直接返回最后一页。</h4>
<h4> 10.【强制】服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL 统一代理模块生成，否 则会因线上采用 HTTPS 协议而导致浏览器提示“不安全”，并且还会带来 URL 维护不一致的问题。</h4>
<h4> 11.【推荐】服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的请求结果。</h4>
<p>说明：缓存有利于减少交互次数，减少交互的平均延迟。</p>
<p>正例：http1.1 中，s-maxage 告诉服务器进行缓存，时间单位为秒，用法如下，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 12.【推荐】服务端返回的数据，使用 JSON 格式而非 XML。</h4>
<p>说明：尽管 HTTP 支持使用不同的输出格式，例如纯文本，JSON，CSV，XML，RSS 甚至 HTML。如果我们使用的面<br>
向用户的服务，应该选择 JSON 作为通信中使用的标准数据交换格式，包括请求和响应。此外，application/JSON 是<br>
一种通用的 MIME 类型，具有实用、精简、易读的特点。</p>
<h4> 13.【推荐】前后端的时间格式统一为"yyyy-MM-dd HH:mm:ss"，统一为 GMT。</h4>
<h4> 14.【参考】在接口路径中不要加入版本号，版本控制在 HTTP 头信息中体现，有利于向前兼容。</h4>
<p>说明：当用户在低版本与高版本之间反复切换工作时，会导致迁移复杂度升高，存在数据错乱风险。</p>
<h2> (十一) 其他</h2>
<h4> 1.【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</h4>
<p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile("规则");</p>
<h4> 2.【强制】避免用 ApacheBeanutils 进行属性的 copy。</h4>
<p>说明：ApacheBeanUtils 性能较差，可以使用其他方案比如 SpringBeanUtils，CglibBeanCopier，注意均是浅拷贝。</p>
<h4> 3.【强制】velocity 调用 POJO 类的属性时，直接使用属性名取值即可，模板引擎会自动按规范调用 POJO的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is 前缀），会自动调 isXxx()方法。</h4>
<p>说明：注意如果是 Boolean 包装类对象，优先调用 getXxx() 的方法。</p>
<h4> 4.【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</h4>
<p>说明：如果 var 等于 null 或者不存在，那么 ${var} 会直接显示在页面上。</p>
<h4> 5.【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0 ≤ x &lt; 1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取</h4>
<p>整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p>
<h4> 6.【强制】枚举 enum（括号内）的属性字段必须是私有且不可变。</h4>
<h4> 7.【推荐】不要在视图模板中加入任何复杂的逻辑运算。</h4>
<p>说明：根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</p>
<h4> 8.【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</h4>
<h4> 9.【推荐】及时清理不再使用的代码段或配置信息。</h4>
<p>说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。</p>
<p>正例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="设计规范"/>
    <published>2023-10-16T11:56:58.000Z</published>
  </entry>
  <entry>
    <title type="text">时间轴</title>
    <id>https://ujava.cn/timeline/</id>
    <link href="https://ujava.cn/timeline/"/>
    <updated>2023-10-09T08:24:44.000Z</updated>
    <summary type="html"><![CDATA[<h2> 目录</h2>
]]></summary>
    <content type="html"><![CDATA[<h2> 目录</h2>
]]></content>
    <category term="思想"/>
    <published>2023-10-09T08:24:44.000Z</published>
  </entry>
  <entry>
    <title type="text">代理模式</title>
    <id>https://ujava.cn/design/create/proxy.html</id>
    <link href="https://ujava.cn/design/create/proxy.html"/>
    <updated>2023-10-12T10:40:39.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这也是它跟装饰器模式最大的不同。</p>
<p><strong>场景</strong>：在需要用比较通用和复杂的对象指针代替简单的指针的时候，也常用在业务系统中开发一些非功能性需求。<code>Spring的面向切面AOP</code>，监控、统计、鉴权、限流、事务、幂等、日志，RPC、缓存。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>1.代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>2.一定程度上<code>降低了系统的耦合度</code>，扩展性好</li>
<li>3.可以起到保护目标对象的作用</li>
<li>4.可以<code>对目标对象的功能增强</code></li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这也是它跟装饰器模式最大的不同。</p>
<p><strong>场景</strong>：在需要用比较通用和复杂的对象指针代替简单的指针的时候，也常用在业务系统中开发一些非功能性需求。<code>Spring的面向切面AOP</code>，监控、统计、鉴权、限流、事务、幂等、日志，RPC、缓存。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>1.代理模式能将代理对象与真实被调用的目标对象分离</li>
<li>2.一定程度上<code>降低了系统的耦合度</code>，扩展性好</li>
<li>3.可以起到保护目标对象的作用</li>
<li>4.可以<code>对目标对象的功能增强</code></li>
</ul>
<p><strong>不足</strong>：</p>
<ul>
<li>1.代理模式<code>会造成系统设计中类的数量增加</code></li>
<li>2.在客户端和目标对象增加一个代理对象，会造成<code>请求处理速度变慢</code></li>
<li>3.增加了系统的复杂度</li>
</ul>
<p>代理模式是项目中常用的一种设计模式。提供了间接访问目标对象的一种方式；即通过代理对象访问目标对象。</p>
<p>这样做的好处是，可以在不改变原有目标对象的基础上，对目标对象增加额外的扩展功能。</p>
<p>代理模式又分为静态代理、jdk动态代理、cglib动态代理三种实现方式。</p>
<p>三种实现方式各有优点，以及适用的场景：</p>
<ul>
<li>静态代理：代理类必须非常明确，所以无法做到通用，但是效率也是最高的</li>
<li>jdk动态代理：必须基于接口代理，有一定局限性；动态生成字节码文件，可以用于通用业务（性能日志等）</li>
<li>cglig动态代理：也是动态生成字节码文件，生成的代理类继承了目标对象</li>
<li>spring aop默认代理策略是：如果目标对象实现了接口，则使用jdk动态代理，否则使用cglib代理</li>
<li>jdk8之后，jdk动态代理效率要高于cglib代理</li>
</ul>
<h2> 1）静态代理</h2>
<p>被代理对象与代理对象需要实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2）jdk动态代理</h2>
<p>jdk动态代理是基于接口的一种代理方式，目标对象一定要实现接口。</p>
<p>原理是，利用反射机制，动态生成匿名类继承Proxy类并且实现了要代理的接口，由于java不支持多继承，所以JDK动态代理不能代理类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3）cglib动态代理</h2>
<p>目标对象可以不用实现接口，不能针对final类进行代理。</p>
<p>原理是，动态生成class继承目标对象。使用cglib必须引入对应的jar包</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content>
    <category term="设计模式"/>
    <published>2023-10-08T08:10:19.000Z</published>
  </entry>
  <entry>
    <title type="text">抽象工厂模式</title>
    <id>https://ujava.cn/design/create/abstractfactory.html</id>
    <link href="https://ujava.cn/design/create/abstractfactory.html"/>
    <updated>2023-10-12T12:18:57.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：</p>
<p>通过定义一个创建对象的接口来创建对象，但将具体实现的决定留给子类来决定。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</strong>。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>1.客户端（应用层）不依赖与产品类示例如何被创建、实现等细节</li>
<li>2.强调一系列相关的产品对象（数据同一产品族）一起使用创建对象需要大量的重复代码</li>
<li>3.提供一个产品类的库，所有的产品以同样的接口出现，使得客户端不依赖于具体实现</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：</p>
<p>通过定义一个创建对象的接口来创建对象，但将具体实现的决定留给子类来决定。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</strong>。</p>
<p><strong>场景</strong>：</p>
<ul>
<li>1.客户端（应用层）不依赖与产品类示例如何被创建、实现等细节</li>
<li>2.强调一系列相关的产品对象（数据同一产品族）一起使用创建对象需要大量的重复代码</li>
<li>3.提供一个产品类的库，所有的产品以同样的接口出现，使得客户端不依赖于具体实现</li>
</ul>
<p>Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类</p>
<p><strong>优点</strong>：</p>
<ul>
<li>1.<strong>具体产品在应用层的代码隔离，无需关系创建的细节</strong></li>
<li>2.将一个系列的产品统一到一起创建</li>
</ul>
<p><strong>不足</strong>：</p>
<ul>
<li>1.规定了所有可能被创建的产品集合，<strong>产品族中扩展新的产品困难</strong></li>
<li>2.增加了系统的抽象性和理解难度</li>
</ul>
]]></content>
    <category term="设计模式"/>
    <published>2023-10-08T07:46:24.000Z</published>
  </entry>
  <entry>
    <title type="text">工厂模式</title>
    <id>https://ujava.cn/design/create/factory.html</id>
    <link href="https://ujava.cn/design/create/factory.html"/>
    <updated>2023-10-12T10:40:39.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>： 通过一个工厂类来实现对象的创建，而无需直接暴露对象的创建逻辑给客户端。 工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。<code>用来创建不同但是相关类型的对象</code>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。简单工厂模式的优点在于客户端无需了解具体产品类的创建细节，只需通过工厂类来创建对象，并且工厂类可以根据客户端的需求来动态创建不同类型的对象。但是缺点也比较明显，如果需要创建的产品类数量较多，则工厂类的代码会变得很臃肿，不便于维护。</p>
<p><strong>场景</strong>：当对象创建逻辑比较复杂，是一个“大工程”的时候，就考虑使用工厂模式，<code>封装对象的创建过程，将对象的创建和使用相分离</code>。Spring IOC、Google Guice就是使用的工厂模式。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>： 通过一个工厂类来实现对象的创建，而无需直接暴露对象的创建逻辑给客户端。 工厂模式包括简单工厂、工厂方法、抽象工厂这3种细分模式。<code>用来创建不同但是相关类型的对象</code>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。简单工厂模式的优点在于客户端无需了解具体产品类的创建细节，只需通过工厂类来创建对象，并且工厂类可以根据客户端的需求来动态创建不同类型的对象。但是缺点也比较明显，如果需要创建的产品类数量较多，则工厂类的代码会变得很臃肿，不便于维护。</p>
<p><strong>场景</strong>：当对象创建逻辑比较复杂，是一个“大工程”的时候，就考虑使用工厂模式，<code>封装对象的创建过程，将对象的创建和使用相分离</code>。Spring IOC、Google Guice就是使用的工厂模式。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>1.<code>封装变化</code>：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明</li>
<li>2.<code>代码复用</code>：创建代码抽离到独立的工厂类之后可以复用</li>
<li>3.<code>隔离复杂性</code>：封装复杂的创建逻辑，调用者无需了解如何创建对象</li>
<li>4.<code>控制复杂度</code>：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁</li>
</ul>
<p><strong>不足</strong>：</p>
<ul>
<li>1.简单工厂，耦合度高，如果有变动就需要修改唯一的工厂</li>
<li>2.工厂方法，优点符合开闭（具体的业务类有具体工厂），缺点是每增加一个产品，相应的也要增加一个子工厂，加大了额外的开发量</li>
</ul>
]]></content>
    <category term="设计模式"/>
    <published>2023-10-08T07:46:24.000Z</published>
  </entry>
  <entry>
    <title type="text">外观模式</title>
    <id>https://ujava.cn/design/structure/facade.html</id>
    <link href="https://ujava.cn/design/structure/facade.html"/>
    <updated>2023-10-12T11:19:18.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个简单的接口来访问复杂系统中的子系统，从而隐藏了子系统的复杂性。外观模式属于对象型模式，它通过创建一个外观类，将客户端与子系统解耦，使得客户端只需要与外观类交互即可完成操作。通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，<code>或者解决性能、分布式事务等问题</code>。当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。<code>如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系</code>。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p><strong>介绍</strong>：外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个简单的接口来访问复杂系统中的子系统，从而隐藏了子系统的复杂性。外观模式属于对象型模式，它通过创建一个外观类，将客户端与子系统解耦，使得客户端只需要与外观类交互即可完成操作。通过封装细粒度的接口，提供组合各个细粒度接口的高层次接口，来提高接口的易用性，<code>或者解决性能、分布式事务等问题</code>。当你需要构建一个层次结构的子系统时，使用facade模式定义子系统中每层的入口点。<code>如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系</code>。</p>
<p><strong>场景</strong>：1.子系统相对独立时可使用，<code>Tomcat源码</code>中有很多不同组件，每个组件要相互通信。<code>mybatis源码</code></p>
<p><strong>优点</strong>：</p>
<ul>
<li>1.<code>松耦合</code>，用户与子系统解耦，屏蔽子系统；可以提高子系统的独立性；</li>
<li>2.<code>使用简单</code>，用户只与门面对接，有统一的入口；不需要知道所有子系统及内部构造；</li>
<li>3.<code>更好的划分访问层次</code></li>
</ul>
<p><strong>不足</strong>：</p>
<ul>
<li>1.<code>没有面向抽象编程</code>，而是通过增加中介层，转换服务提供方的服务接口；</li>
<li>2.<code>不符合开闭原则</code>，如果要改东西很麻烦，<code>继承重写都不合适</code></li>
</ul>
]]></content>
    <category term="设计模式"/>
    <published>2023-10-08T07:46:24.000Z</published>
  </entry>
</feed>