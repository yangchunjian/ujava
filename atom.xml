<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://ujava.cn/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://ujava.cn/</id>
  <title>UJava</title>
  <subtitle> 【Java学习 + Java面试】首选UJava！  </subtitle>
  <icon>https://ujava.cn/favicon.ico</icon>
  <updated>2024-04-22T01:01:56.351Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://ujava.cn/atom.xml"/>
  <link rel="alternate" href="https://ujava.cn/"/>
  <category term="设计组件"/>
  <category term="设计综合"/>
  <category term="设计基础"/>
  <category term="设计算法"/>
  <category term="设计高频"/>
  <category term="设计注意"/>
  <category term="设计模式"/>
  <entry>
    <title type="text">组件Flink</title>
    <id>https://ujava.cn/assembly/flink.html</id>
    <link href="https://ujava.cn/assembly/flink.html"/>
    <updated>2024-04-20T07:53:29.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Flume</title>
    <id>https://ujava.cn/assembly/flume.html</id>
    <link href="https://ujava.cn/assembly/flume.html"/>
    <updated>2024-04-20T07:53:29.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Hadoop</title>
    <id>https://ujava.cn/assembly/hadoop.html</id>
    <link href="https://ujava.cn/assembly/hadoop.html"/>
    <updated>2024-04-20T07:53:29.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Hbase</title>
    <id>https://ujava.cn/assembly/hbase.html</id>
    <link href="https://ujava.cn/assembly/hbase.html"/>
    <updated>2024-04-22T01:01:35.000Z</updated>
    <summary type="html"><![CDATA[<h4> 简介</h4>
<p>Hbase是一种 分布式存储 的数据库，技术上来讲，它更像是分布式存储而不是 分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。</p>
<p>Hbase有如下特性:</p>
<ul>
<li>强读写一致，但是不是“最终一致性”的 数据存储，这使得它非常适合高速的计算聚合</li>
<li>自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配</li>
<li>自动的故障转移</li>
<li>Hadoop/HDFS集成，和HDFS开箱即用</li>
<li>丰富的“简洁，高效”API，Thrift/REST API，Java API</li>
<li>块缓存，布隆过滤器，可以高效的列查询优化</li>
<li>操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h4> 简介</h4>
<p>Hbase是一种 分布式存储 的数据库，技术上来讲，它更像是分布式存储而不是 分布式数据库，它缺少很多RDBMS系统的特性，比如列类型，辅助索引，触发器，和高级查询语言等待。</p>
<p>Hbase有如下特性:</p>
<ul>
<li>强读写一致，但是不是“最终一致性”的 数据存储，这使得它非常适合高速的计算聚合</li>
<li>自动分片，通过Region分散在集群中，当行数增长的时候，Region也会自动的切分和再分配</li>
<li>自动的故障转移</li>
<li>Hadoop/HDFS集成，和HDFS开箱即用</li>
<li>丰富的“简洁，高效”API，Thrift/REST API，Java API</li>
<li>块缓存，布隆过滤器，可以高效的列查询优化</li>
<li>操作管理，Hbase提供了内置的web界面来操作，还可以监控JMX指标</li>
</ul>
<h5> Hbase的使用场景</h5>
<ul>
<li>首先数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>
<li>不需要辅助索引，静态类型的列，事务等特性</li>
<li>保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode</li>
</ul>
<h4> Hbase架构</h4>
<figure><figcaption>img_87.png</figcaption></figure>
<p>Hbase是三层架构体系。</p>
<ul>
<li>其中Hbase表底层是存储在HDFS上，可以分为多个Region， Region分布在Region Server上</li>
<li>Master负责协调Region和负载</li>
<li>Zookeeper负责记录一些元数据</li>
</ul>
<p>HBase中有两张特殊的表： Root和META， META表负责记录Region的分区信息， Root表负责记录META的分区信息， Root表的位置信息则有Hadoop集群的zookeeper来记录。</p>
<p>那么Hbase检索一条数据的流程应该是这样的:<br>
</p>
<h5> 存储结构</h5>
<p>Hbase 是一种专门为半结构化数据和水平扩展性设计的数据库。它把数据存储在表中，表按“行健(rowkey)，列簇，列限定符和时间版本”的四维坐标系来组织。Hbase 是无模式数据库，只需要提前定义列簇，并不需要指定列限定符。同时它也是无类型数据库，所有数据都是按二进制字节方式存储的，对 Hbase 的操作和访问有 5 个基本方式，即 Get、Put、Delete 和 Scan 以及 Increment。Hbase 基于非行健值查询的唯一途径是通过带过滤器的扫描。<br>
</p>
<p>从上图我们可以看出 Hbase 的组成部件，HBase 中的每张表都通过行键按照一定的范围被分割成多个子表（HRegion），由 HRegionServer 管理，管理哪些 HRegion 由 HMaster 分配。</p>
<p>HRegionServer 存取一个子表时，会创建一个 HRegion 对象，然后对表的每个列族 (Column Family) 创建一个 Store 实例，每个 Store 都会有 0 个或多个 StoreFile 与之对应，每个 StoreFile 都会对应一个 HFile，HFile 就是实际的存储文件。因此，一个 HRegion 有多少个列族就有多少个 Store。此外，每个 HRegion 还拥有一个 MemStore 内存缓存实例。</p>
<ul>
<li>HFile：HBase 中 KeyValue 数据的存储格式，HFile 是 Hadoop 的二进制格式文件，实际上 StoreFile 就是对 HFile 做了轻量级包装，即 StoreFile 底层就是 HFile</li>
<li>HLog: HBase记录写入记录，WAL机制保证数据可靠性，即首先写日志再写缓存，即使发生宕机，也可以通过恢复HLog还原出原始数据。该步骤就是将数据构造为WALEdit对象，然后顺序写入HLog中。</li>
<li>MemStore：MemStore 即内存里放着的保存 KEY/VALUE 映射的 MAP，当 MemStore（默认 64MB）写满之后，会开始 flush 到磁盘（即 Hadoop 的 HDFS 上）的操作</li>
</ul>
<h5> HLog之WAL(write ahead log)机制</h5>
<p>WAL(Write-Ahead Logging)是一种高效的日志算法,基本原理是在数据写入之前首先顺序写入日志，然后再写入缓存，等到缓存写满之后统一落盘。之所以能够提升写性能，是因为WAL将一次随机写转化为了一次顺序写加一次内存写。提升写性能的同时，WAL可以保证数据的可靠性，即在任何情况下数据不丢失。假如一次写入完成之后发生了宕机，即使所有缓存中的数据丢失，也可以通过恢复日志还原出丢失的数据。</p>
<h6> HBase写入流程分析</h6>
<ol>
<li>zookeeper中存储了meta表的region信息，从meta表获取相应region信息，然后找到meta表的数据</li>
<li>根据meta表的数据找到写入数据对应的region信息, 找到对应的RegionServer</li>
<li>把数据分别写到HLog和MemStore上一份</li>
<li>MemStore达到一个阈值后则把数据刷成一个StoreFile文件。若MemStore中的数据有丢失，则可以总HLog上恢复</li>
<li>当多个StoreFile文件达到一定的大小后，会触发Compact合并操作，合并为一个StoreFile，这里同时进行版本的合并和数据删除</li>
<li>当Compact后，逐步形成越来越大的StoreFIle后，会触发Split操作，把当前的StoreFile分成两个，这里相当于把一个大的region分割成两个region</li>
</ol>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Hive</title>
    <id>https://ujava.cn/assembly/hive.html</id>
    <link href="https://ujava.cn/assembly/hive.html"/>
    <updated>2024-04-20T07:53:29.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件MongoDB</title>
    <id>https://ujava.cn/assembly/mongodb.html</id>
    <link href="https://ujava.cn/assembly/mongodb.html"/>
    <updated>2024-04-20T07:53:29.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Spark</title>
    <id>https://ujava.cn/assembly/spark.html</id>
    <link href="https://ujava.cn/assembly/spark.html"/>
    <updated>2024-04-21T14:44:40.000Z</updated>
    <summary type="html"><![CDATA[<p><strong>什么是Apache Spark？</strong></p>
<p>答案：Apache Spark是一个快速、通用的集群计算系统，旨在处理大规模数据处理和分析任务。它提供了高级的编程模型和丰富的库，可以在分布式环境中进行数据处理、机器学习、图计算等。</p>
<p><strong>Spark和Hadoop有什么区别？</strong></p>
<p>答案：Spark和Hadoop都是用于大数据处理的框架，但有以下区别：</p>
<ul>
<li>数据处理模型：Spark提供了更灵活和高级的数据处理模型，如RDD（弹性分布式数据集）和DataFrame，而Hadoop使用的是基于MapReduce的批处理模型。</li>
<li>性能：由于Spark的内存计算和任务调度优化，它通常比Hadoop的MapReduce更快。</li>
<li>生态系统：Hadoop拥有更成熟和广泛的生态系统，包括HDFS、YARN和Hive等，而Spark在某些方面的生态系统仍在发展中。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p><strong>什么是Apache Spark？</strong></p>
<p>答案：Apache Spark是一个快速、通用的集群计算系统，旨在处理大规模数据处理和分析任务。它提供了高级的编程模型和丰富的库，可以在分布式环境中进行数据处理、机器学习、图计算等。</p>
<p><strong>Spark和Hadoop有什么区别？</strong></p>
<p>答案：Spark和Hadoop都是用于大数据处理的框架，但有以下区别：</p>
<ul>
<li>数据处理模型：Spark提供了更灵活和高级的数据处理模型，如RDD（弹性分布式数据集）和DataFrame，而Hadoop使用的是基于MapReduce的批处理模型。</li>
<li>性能：由于Spark的内存计算和任务调度优化，它通常比Hadoop的MapReduce更快。</li>
<li>生态系统：Hadoop拥有更成熟和广泛的生态系统，包括HDFS、YARN和Hive等，而Spark在某些方面的生态系统仍在发展中。</li>
</ul>
<p><strong>Spark的核心组件是什么？</strong></p>
<p>答案：Spark的核心组件包括：</p>
<ul>
<li>Spark Core：提供了Spark的基本功能，包括任务调度、内存管理和分布式数据处理等。</li>
<li>Spark SQL：用于处理结构化数据的模块，支持SQL查询和DataFrame API。</li>
<li>Spark Streaming：用于实时数据流处理的模块，支持高吞吐量和低延迟的流处理任务。</li>
<li>MLlib：Spark的机器学习库，提供了常见的机器学习算法和工具。</li>
<li>GraphX：Spark的图计算库，用于图处理和分析任务。</li>
</ul>
<p><strong>Spark的数据处理模型是什么？</strong></p>
<p>答案：Spark的数据处理模型基于RDD（弹性分布式数据集）。RDD是一个可并行操作的、容错的、不可变的数据集合，可以在集群中进行分布式处理。Spark还引入了DataFrame和Dataset等高级抽象，提供了更丰富和优化的数据处理能力。</p>
<p><strong>Spark支持哪些编程语言？</strong></p>
<p>答案：Spark主要支持以下编程语言：</p>
<ul>
<li>Scala：Scala是Spark的主要编程语言，它是一种面向对象和函数式编程的语言，提供了强大的表达能力和丰富的特性。</li>
<li>Java：Spark可以通过Java API进行编程，适用于Java开发者。</li>
<li>Python：Spark提供了Python API（PySpark），可以使用Python语言进行Spark开发。</li>
<li>R：Spark也支持R语言，通过SparkR库可以在R环境中使用Spark。</li>
</ul>
<p><strong>Spark的调度器是什么？</strong></p>
<p>答案：Spark的调度器是负责将任务分配给集群中的执行节点的组件。Spark有两种调度器：</p>
<ul>
<li>FIFO调度器：按照任务提交的顺序依次执行，适用于简单的任务场景。</li>
<li>Fair调度器：根据资源使用情况动态分配资源，以保证每个任务能够公平地获得执行机会。</li>
</ul>
<p><strong>Spark的数据持久化机制是什么？</strong></p>
<p>答案：Spark使用RDD的持久化机制来将数据存储在内存或磁盘中，以加快后续操作的速度。它支持将RDD的数据持久化到内存、磁盘或者序列化到外部存储系统。</p>
<p><strong>Spark的容错机制是什么？</strong></p>
<p>答案：Spark的容错机制基于RDD的不可变性和记录操作的转换日志。当节点发生故障时，Spark可以根据转换日志重新计算丢失的数据，从而保证任务的容错性。</p>
<p><strong>Spark的机器学习库是什么？</strong></p>
<p>答案：Spark的机器学习库称为MLlib，它提供了常见的机器学习算法和工具，如分类、回归、聚类、推荐等。MLlib使用RDD和DataFrame作为数据接口，提供了易于使用和可扩展的机器学习功能。</p>
<p><strong>Spark的图计算库是什么？</strong></p>
<p>答案：Spark的图计算库称为GraphX，它提供了图处理和分析的功能，包括图的创建、遍历、连接等操作。GraphX使用RDD作为图数据的表示形式，并提供了丰富的图算法和操作符。</p>
<p><strong>Spark支持哪些数据源和数据格式？</strong></p>
<p>答案：Spark支持多种数据源和数据格式，包括：</p>
<ul>
<li>文件系统：Spark可以读写各种文件系统，如HDFS、本地文件系统、S3等。</li>
<li>数据库：Spark可以连接和读写关系型数据库，如MySQL、PostgreSQL等，也支持NoSQL数据库，如MongoDB、Cassandra等。</li>
<li>实时数据流：Spark支持读取实时数据流，如Kafka、Flume等。</li>
<li>数据格式：Spark支持常见的数据格式，如CSV、JSON、Parquet、Avro等。</li>
</ul>
<p><strong>Spark的集群部署模式有哪些？</strong></p>
<p>答案：Spark的集群部署模式包括：</p>
<ul>
<li>Standalone模式：在独立的Spark集群上运行，不依赖其他资源管理器。</li>
<li>YARN模式：在Hadoop集群上利用YARN资源管理器进行任务调度和资源分配。</li>
<li>Mesos模式：在Mesos集群上利用Mesos资源管理器进行任务调度和资源分配。</li>
<li>Kubernetes模式：在Kubernetes集群上运行Spark作业，利用Kubernetes进行容器管理和资源分配。</li>
</ul>
<p><strong>Spark的优化技术有哪些？</strong></p>
<p>答案：Spark的优化技术包括：</p>
<ul>
<li>延迟计算：Spark使用惰性求值策略，延迟计算数据，只在需要结果时才执行计算，减少不必要的中间结果。</li>
<li>数据分区和并行度：合理设置数据分区和并行度，使得任务可以并行执行，提高计算效率。</li>
<li>内存管理：通过合理配置内存和缓存策略，将常用的数据存储在内存中，减少磁盘IO，提高性能。</li>
<li>窗口操作：对于窗口操作，使用时间滑动窗口和窗口聚合等技术，减少数据的重复计算。</li>
<li>数据压缩和序列化：使用压缩和序列化技术减小数据的存储空间和传输成本。</li>
</ul>
<p><strong>Spark支持哪些集群调度器？</strong></p>
<p>答案：Spark支持以下集群调度器：</p>
<ul>
<li>Hadoop YARN：Spark可以与Hadoop集群上的YARN资源管理器集成，利用YARN进行任务调度和资源分配。</li>
<li>Apache Mesos：Spark可以与Mesos集群集成，利用Mesos进行任务调度和资源分配。</li>
<li>Kubernetes：Spark可以在Kubernetes集群上运行，利用Kubernetes进行容器管理和资源分配。</li>
</ul>
<p><strong>Spark的数据处理模型中的RDD是什么？</strong></p>
<p>答案：RDD（弹性分布式数据集）是Spark的核心数据结构，代表分布在集群中的不可变的、可分区的数据集合。RDD可以并行操作，支持容错和恢复。它是Spark进行分布式数据处理的基础。</p>
<p><strong>Spark的DataFrame是什么？</strong></p>
<p>答案：DataFrame是Spark提供的高级数据结构，用于处理结构化数据。DataFrame类似于传统数据库中的表格，具有列和行的概念，支持SQL查询和DataFrame API操作。DataFrame提供了更丰富的数据处理能力和优化技术，比原始的RDD更高效。</p>
<p><strong>Spark的机器学习库MLlib有哪些常见的算法？</strong></p>
<p>答案：Spark的机器学习库MLlib包含了多种常见的机器学习算法，包括分类算法（如逻辑回归、决策树、随机森林）、回归算法（如线性回归、岭回归）、聚类算法（如K均值聚类、高斯混合模型）、推荐算法（如协同过滤）、降维算法（如主成分分析）、自然语言处理（如文本分类、词嵌入）等。</p>
<p><strong>Spark的图计算库GraphX支持哪些图算法？</strong></p>
<p>答案：Spark的图计算库GraphX支持多种图算法，包括图的遍历、连接、聚合、PageRank、连通性组件、最短路径等。GraphX提供了丰富的图操作符和API，方便用户进行图处理和分析。</p>
<p><strong>Spark Streaming是什么？</strong></p>
<p>答案：Spark Streaming是Spark提供的实时数据流处理模块。它可以以微批处理的方式处理实时数据，支持高吞吐量和低延迟的数据处理。Spark Streaming可以与Spark的批处理和机器学习库无缝集成，实现批处理与实时处理的统一。</p>
<p><strong>Spark的扩展库和整合工具有哪些？</strong></p>
<p>答案：Spark有丰富的扩展库和整合工具，包括：</p>
<ul>
<li>Spark SQL：用于处理结构化数据，支持SQL查询和DataFrame操作。</li>
<li>Spark Streaming：用于实时数据流处理。</li>
<li>MLlib：Spark的机器学习库。</li>
<li>GraphX：Spark的图计算库。</li>
<li>SparkR：提供在R语言中使用Spark的能力。</li>
<li>PySpark：Spark的Python API。</li>
<li>Spark on Kubernetes：在Kubernetes集群上运行Spark作业。</li>
<li>Spark on Mesos：在Mesos集群上运行Spark作业。</li>
<li>Spark on YARN：在Hadoop YARN集群上运行Spark作业。</li>
</ul>
<p><strong>什么是宽依赖，什么是窄依赖？哪些算子是宽依赖，哪些是窄依赖？</strong><br>
窄依赖就是一个父RDD分区对应一个子RDD分区，如map，filter<br>
或者多个父RDD分区对应一个子RDD分区，如co-partioned join</p>
<p>宽依赖是一个父RDD分区对应非全部的子RDD分区，如groupByKey，ruduceByKey<br>
或者一个父RDD分区对应全部的子RDD分区，如未经协同划分的join</p>
<p><strong>Transformation和action算子有什么区别？举例说明</strong><br>
Transformation 变换/转换：这种变换并不触发提交作业，完成作业中间过程处理。Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算</p>
<blockquote>
<p>map, filter</p>
</blockquote>
<p>Action 行动算子：这类算子会触发 SparkContext 提交 Job 作业。<br>
Action 算子会触发 Spark 提交作业（Job）。</p>
<blockquote>
<p>count</p>
</blockquote>
<p><strong>讲解spark shuffle原理和特性？shuffle write 和 shuffle read过程做些什么？</strong></p>
<p><strong>Shuffle数据块有多少种不同的存储方式？分别是什么</strong></p>
<ol>
<li>RDD数据块：用来存储所缓存的RDD数据。</li>
<li>Shuffle数据块：用来存储持久化的Shuffle数据。</li>
<li>广播变量数据块：用来存储所存储的广播变量数据。</li>
<li>任务返回结果数据块：用来存储在存储管理模块内部的任务返回结果。通常情况下任务返回结果随任务一起通过Akka返回到Driver端。但是当任务返回结果很大时，会引起Akka帧溢出，这时的另一种方案是将返回结果以块的形式放入存储管理模块，然后在Driver端获取该数据块即可，因为存储管理模块内部数据块的传输是通过Socket连接的，因此就不会出现Akka帧溢出了。</li>
<li>流式数据块：只用在Spark Streaming中，用来存储所接收到的流式数据块</li>
</ol>
<p><strong>哪些spark算子会有shuffle？</strong></p>
<ol>
<li>去重，distinct</li>
<li>排序，groupByKey，reduceByKey等</li>
<li>重分区，repartition，coalesce</li>
<li>集合或者表操作，interection，join</li>
</ol>
<p><strong>讲解spark schedule（任务调度）？</strong></p>
<figure><figcaption>img_85.png</figcaption></figure>
<p><strong>Spark stage是如何划分的？</strong></p>
<ol>
<li>从hdfs中读取文件后，创建 RDD 对象</li>
<li>DAGScheduler模块介入运算，计算RDD之间的依赖关系。RDD之间的依赖关系就形成了DAG</li>
<li>每一个JOB被分为多个Stage，划分Stage的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个Stage，避免多个Stage之间的消息传递开销。</li>
</ol>
<p>因此spark划分stage的整体思路是：从后往前推，遇到宽依赖就断开，划分为一个stage；遇到窄依赖就将这个RDD加入该stage中。</p>
<p><strong>Spark cache一定能提升计算性能么？说明原因？</strong><br>
不一定啊，cache是将数据缓存到内存里，当小数据量的时候是能提升效率，但数据大的时候内存放不下就会报溢出。</p>
<p><strong>Cache和persist有什么区别和联系？</strong><br>
cache调用了persist方法，cache只有一个默认的缓存级别MEMORY_ONLY ，而persist可以根据情况设置其它的缓存级别。</p>
<p><strong>RDD是弹性数据集，“弹性”体现在哪里呢？你觉得RDD有哪些缺陷？</strong></p>
<ol>
<li>自动进行内存和磁盘切换</li>
<li>基于lineage的高效容错</li>
<li>task如果失败会特定次数的重试</li>
<li>stage如果失败会自动进行特定次数的重试，而且只会只计算失败的分片</li>
<li>checkpoint【每次对RDD操作都会产生新的RDD，如果链条比较长，计算比较笨重，就把数据放在硬盘中】和persist 【内存或磁盘中对数据进行复用】(检查点、持久化)</li>
<li>数据调度弹性：DAG TASK 和资源管理无关</li>
<li>数据分片的高度弹性repartion</li>
</ol>
<p>缺陷：<br>
惰性计算的缺陷也是明显的：中间数据默认不会保存，每次动作操作都会对数据重复计算，某些计算量比较大的操作可能会影响到系统的运算效率</p>
<p><strong>RDD有多少种持久化方式？memory_only如果内存存储不了，会怎么操作？</strong><br>
cache和persist</p>
<ul>
<li>memory_and_disk，放一部分到磁盘</li>
<li>MEMORY_ONLY_SER:同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销。</li>
<li>MEMORY_AND_DSK_SER:同MEMORY_AND_DSK。但是使用序列化方式持久化Java对象。</li>
<li>DISK_ONLY:使用非序列化Java对象的方式持久化，完全存储到磁盘上。<br>
MEMORY_ONLY_2或者MEMORY_AND_DISK_2等：如果是尾部加了2的持久化级别，表示会将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可。</li>
</ul>
<p><strong>RDD分区和数据块有啥联系？</strong></p>
<p><strong>当GC时间占比很大可能的原因有哪些？对应的优化方法是？</strong><br>
垃圾回收的开销和对象合数成正比，所以减少对象的个数，就能大大减少垃圾回收的开销。序列化存储数据，每个RDD就是一个对象。缓存RDD占用的内存可能跟工作所需的内存打架，需要控制好</p>
<p><strong>Spark中repartition和coalesce异同？coalesce什么时候效果更高，为什么</strong></p>
<div class="language-less line-numbers-mode" data-ext="less"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上为他们的定义，区别就是repartition一定会触发shuffle，而coalesce默认是不触发shuffle的。</p>
<p>他们两个都是RDD的分区进行重新划分，repartition只是coalesce接口中shuffle为true的简易实现，（假设RDD有N个分区，需要重新划分成M个分区）</p>
<p>减少分区提高效率</p>
<p><strong>Groupbykey和reducebykey哪个性能更高，为什么？</strong><br>
reduceByKey性能高，更适合大数据集</p>
<p><strong>你是如何理解caseclass的？</strong></p>
<p><strong>Scala里trait有什么功能，与class有何异同？什么时候用trait什么时候该用class</strong><br>
它可以被继承，而且支持多重继承，其实它更像我们熟悉的接口（interface），但它与接口又有不同之处是：<br>
trait中可以写方法的实现，interface不可以（java8开始支持接口中允许写方法实现代码了），这样看起来trait又很像抽象类</p>
<p><strong>Scala 语法中to 和 until有啥区别</strong><br>
to 包含上界，until不包含上界</p>
<p><strong>讲解Scala伴生对象和伴生类</strong><br>
单例对象与类同名时，这个单例对象被称为这个类的伴生对象，而这个类被称为这个单例对象的伴生类。伴生类和伴生对象要在同一个源文件中定义，伴生对象和伴生类可以互相访问其私有成员。不与伴生类同名的单例对象称为孤立对象。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>spark作业执行流程</strong></p>
<ol>
<li>客户端提交作业</li>
<li>Driver启动流程</li>
<li>Driver申请资源并启动其余Executor(即Container)</li>
<li>Executor启动流程</li>
<li>作业调度，生成stages与tasks。</li>
<li>Task调度到Executor上，Executor启动线程执行Task逻辑</li>
<li>Driver管理Task状态</li>
<li>Task完成，Stage完成，作业完成</li>
</ol>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-20T07:53:29.000Z</published>
  </entry>
  <entry>
    <title type="text">组件MQ</title>
    <id>https://ujava.cn/assembly/mq.html</id>
    <link href="https://ujava.cn/assembly/mq.html"/>
    <updated>2024-04-16T08:43:59.000Z</updated>
    <summary type="html"><![CDATA[<p>想必你在面试或者工作的过程中，被问过以下问题：</p>
<ul>
<li>（1）为什么你们项目要用消息队列？</li>
<li>（2）用了消息队列后有什么好处？</li>
<li>（3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？</li>
<li>（4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？</li>
</ul>
<p>如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。</p>
<p>技术选型是开发工作前最重要的，也是最体现技术的环节。</p>]]></summary>
    <content type="html"><![CDATA[<p>想必你在面试或者工作的过程中，被问过以下问题：</p>
<ul>
<li>（1）为什么你们项目要用消息队列？</li>
<li>（2）用了消息队列后有什么好处？</li>
<li>（3）消息队列有 ActiveMQ、ZeroMQ、MetaMQ、RabbitMQ、RocketMQ、Kafka等，你是怎么选型的？</li>
<li>（4）你能对比下 RabbitMQ、RocketMQ、Kafka 吗？</li>
</ul>
<p>如果你只会回答 ”我只会用这个消息队列“、”公司用的是这个消息队列“ 等等，可以肯定的告诉你将会被 pass 掉。</p>
<p>技术选型是开发工作前最重要的，也是最体现技术的环节。</p>
<p>目前主流的消息队列分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ。</p>
<p>这篇文章重点介绍这四种消息队列的概述、对比和选型，不深入研究每种队列内部的实现原理。</p>
<figure><figcaption>img_7.png</figcaption></figure>
<h2> 消息队列是什么？</h2>
<p>消息队列是在消息的传输过程中保存消息的容器，简单点理解就是传递消息的队列，具备先进先出的特点，一般用于异步、解耦、流量削锋等问题，实现高性能、高可用、高扩展的架构。一个消息队列可以被一个或多个消费者消费，一般包含以下元素：</p>
<ul>
<li>Producer：消息生产者，负责产生和发送消息到 Broker。</li>
<li>Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue。</li>
<li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li>
</ul>
<h2> 消息队列应用场景</h2>
<p>常见的消息队列使用场景有 6 个：</p>
<ul>
<li>应用解耦：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li>
<li>异步处理：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li>
<li>流量削锋：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li>
<li>日志处理：将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li>
<li>消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯，比如实现聊天室等。</li>
<li>消息广播：如果没有消息队列，每当一个新业务方接入，都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁订阅，是下游的事，无疑极大地减少了开发和联调的工作量。<br>
比较核心的有 3 个：解耦、异步、削峰，下面着重讲下：</li>
</ul>
<p>解耦</p>
<p>假设在没有消息队列的情况下，现在有上游服务 A 用来发布消息，下游服务 B、C 用来接收服务 A 的消息。但随着业务需要，现在有服务<br>
D、E、F 需要接收服务 A 的消息，那么就出现问题了，每次新加入服务都要改一次代码，可想而知这是极大的工作量。</p>
<figure><figcaption>img_8.png</figcaption></figure>
<p>如果引入消息队列，那就好办了，只需要下游服务自己订阅消息队列，而无需改动服务 A 的代码。</p>
<figure><figcaption>img_9.png</figcaption></figure>
<p>异步</p>
<p>先来看没有消息队列的场景下。</p>
<p>服务 A 的某个接口接收到请求，分别需要在服务A、服务B、服务C、服务D进行写库。假设用户发起请求到服务 A 耗时 10ms，自己写库需要<br>
50ms，在服务 B 写库需要 250ms，在服务 C 写库需要 300ms，在服务 D 写库需要400ms，在没有消息队列的情况下，也就是同步操作，总耗时会是<br>
10 + 50ms + 250ms + 300ms + 400ms = 1.01s。用户发送个请求，结果感觉有点卡顿，响应的非常慢，任谁都是很难忍受的。</p>
<figure><figcaption>img_10.png</figcaption></figure>
<p>如果使用了消息队列，那么服务 A 只需要把对服务A、B、C、D 进行写库的操作分别放进四个消息队列，假如用户发起请求到服务器耗时是10ms，发送消息到四个消息队列的耗时是10ms，那么总耗时就是<br>
20 ms 。用户点击了按钮后立马返回，没有卡顿现象，体验效果就会有极大的提升了。</p>
<figure><figcaption>img_11.png</figcaption></figure>
<p>一般接口同步处理时间很长，不能通过水平扩容来解决，且业务场景允许异步，就可以使用异步解决，比如文件上传下载受限于用户的网络带宽因素，扩容也无用，以及上述同步操作耗时长等情况，都可以先放进消息队列，等服务再进行拉取消费。</p>
<p>削峰</p>
<p>在淘宝双十一活动日，特别是 0<br>
点的秒杀活动高峰期时，接口流量会飙升，远远高于平时，就像一个山峰，没有做好处理的话，在高峰期数据库就可能被流量打死，从而导致整个服务奔溃。如果为了在高峰期能顶住流量而常备高流量设备，会有极大的成本浪费。如果是在要高峰期前进行临时服务扩容，很可能会出现许多扩容问题，没有那么简单。</p>
<p>使用消息队列的话，就可以将高峰期过多的流量请求放进消息队列，等高峰期过后，服务再慢慢进行处理，就不会出现峰值流量了，而是一个相对平稳的状态。</p>
<p>举个例子：</p>
<ul>
<li>大量的用户在中午高峰期的时候，每秒有 4k 个请求，那么每秒就有 4k 个请求放到 MQ 里。</li>
<li>服务A 每秒只能处理 2k 个请求，因为 Mysql 每秒最多处理 2k 个请求。</li>
<li>服务A 就每秒从 MQ 拉取 2k 个请求进行处理，不会超过自己每秒能处理的最大请求量，所以高峰期服务 A 就不会挂掉。</li>
<li>对于MQ，每秒 4k 个请求进来，但是却只有 2k 个请求出去，导致在高峰期 1h 内可能有几十万的请求积压在 MQ<br>
中。这个短暂的高峰期请求积压是可以接受的，因为过了这个时间点，每秒就 100 个请求进 MQ，但这时服务 A 还是会按照每秒 2k 的速度处理<br>
MQ 积压的请求。</li>
<li>所以，高峰期一过，服务 A 就会快速的将 MQ 积压的消息处理掉。</li>
</ul>
<figure><figcaption>img_12.png</figcaption></figure>
<h2> 消息队列模型</h2>
<p>点对点模式：多个生产者可以向同一个消息队列发送消息，一个消息只能被一个消费者消费，在被消费成功后，这条消息会被移除。如果消费者处理消息失败了，那么这条消息会重新被消费。</p>
<figure><figcaption>img_13.png</figcaption></figure>
<p>发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。多个生产者可以将多个消息写到同一个 Topic 中，被同一个消费者消费。</p>
<figure><figcaption>img_14.png</figcaption></figure>
<h2> 消息队列对比</h2>
<p>消息队列有 ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ、Kafka，其中 ZeroMQ 太过轻量，主要用于学习，实际是不会应用到生产，所以主要对比<br>
Kafka、RocketMQ、RabbitMQ、ActiveMQ 这四种 MQ。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>ActiveMQ</th>
</tr>
</thead>
<tbody>
<tr>
<td>单机吞吐量</td>
<td>10万级别，吞吐量高是kafka最大的优点</td>
<td>10万级，RocketMQ 也是可以支撑高吞吐的 MQ</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
<td>万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td>
</tr>
<tr>
<td>支持主题数</td>
<td>百级，topic 达到百级时吞吐量会大幅度下降，要尽量保证 topic 数量不要过多，否则需要增加更多机器资源</td>
<td>千级，topic 达到千级时吞吐量会有较小幅度的下降。可以支撑大量 topic 是 RocketMQ 的一大优点</td>
<td>百万级</td>
<td>千级</td>
</tr>
<tr>
<td>消息顺序性</td>
<td>分区有序</td>
<td>有序</td>
<td>有序</td>
<td>有序</td>
</tr>
<tr>
<td>消息重复</td>
<td>至少一次，最多一次</td>
<td>至少一次，最多一次</td>
<td>至少一次</td>
<td>至少一次</td>
</tr>
<tr>
<td>时效性</td>
<td>ms级</td>
<td>ms级</td>
<td>微秒级，RabbitMQ的一大优点</td>
<td>ms级</td>
</tr>
<tr>
<td>可用性</td>
<td>非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
<td>非常高，分布式架构</td>
<td>高，基于主从架构实现高可用性</td>
<td>高，基于主从架构实现高可用性</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>经过参数优化配置，理论上消息可以做到0丢失</td>
<td>经过参数优化配置，理论上消息可以做到0丢失</td>
<td>有较低的概率丢失数据</td>
<td>有较低的概率丢失数据</td>
</tr>
<tr>
<td>消息回溯</td>
<td>支持（按offset回溯）</td>
<td>支持（按时间回溯）</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>功能支持</td>
<td>功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td>
<td>MQ功能较为完善，还是分布式的，扩展性好</td>
<td>基于erlang开发，所以并发能力很强，性能极其好，延时很低</td>
<td>MQ领域的功能极其完备</td>
</tr>
<tr>
<td>伸缩性</td>
<td>高伸缩性，每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中</td>
<td>高伸缩性，灵活的分布式横向扩展部署架构，整体架构和 kafka 很像</td>
<td>一般</td>
<td></td>
</tr>
<tr>
<td>管理界面</td>
<td>普通</td>
<td>完善</td>
<td>普通</td>
<td>普通</td>
</tr>
<tr>
<td>持久化</td>
<td>消息可以持久化到磁盘</td>
<td>消息可以持久化到磁盘</td>
<td>持久化不好，可以持久化到内存、文件</td>
<td>可以持久化到内存、文件、数据库</td>
</tr>
<tr>
<td>消息路由</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>语言支持</td>
<td>支持多语言，Java优先</td>
<td>支持Java、C++，但C++不成熟</td>
<td>支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等</td>
<td>支持多语言，Java优先</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2> 消息队列选型</h2>
<p>Kafka 和 RocketMQ 都支持 10w 级别的高吞吐量。</p>
<p>Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用<br>
Kafka 绝对没错，社区活跃度高，业内标准。</p>
<p>RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ<br>
是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用<br>
RocketMQ。</p>
<p>RabbitMQ<br>
适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高，能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用<br>
Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。</p>
<p>ActiveMQ 现在很少有人用，没怎么经过大规模吞吐量场景的考验，社区不怎么活跃，官方社区现在对 ActiveMQ 5.x 维护也越来越少，所以不推荐使用。</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-16T08:43:59.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Dubbo</title>
    <id>https://ujava.cn/assembly/dubbo.html</id>
    <link href="https://ujava.cn/assembly/dubbo.html"/>
    <updated>2024-04-16T09:04:18.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1、Dubbo的基本介绍</h2>
<p>Dubbo 是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h3> 1.1、基本概念</h3>
<figure><figcaption>img_15.png</figcaption></figure>
<ul>
<li><strong>服务提供者</strong>**（<strong><strong>Provider</strong></strong>）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li><strong>服务消费者</strong>**（<strong><strong>Consumer</strong></strong>）**:&nbsp;调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li><strong>注册中心</strong>**（<strong><strong>Registry</strong></strong>）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li>
<li><strong>监控中心</strong>**（<strong><strong>Monitor</strong></strong>）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1、Dubbo的基本介绍</h2>
<p>Dubbo 是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h3> 1.1、基本概念</h3>
<figure><figcaption>img_15.png</figcaption></figure>
<ul>
<li><strong>服务提供者</strong>**（<strong><strong>Provider</strong></strong>）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li><strong>服务消费者</strong>**（<strong><strong>Consumer</strong></strong>）**:&nbsp;调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li><strong>注册中心</strong>**（<strong><strong>Registry</strong></strong>）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li>
<li><strong>监控中心</strong>**（<strong><strong>Monitor</strong></strong>）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</li>
</ul>
<p>调用关系说明：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
</ol>
<h3> 1.2、RPC</h3>
<p>RPC（Remote Procedure Call）是一种进程间通信方式。简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务，可以应用在分布式服务、分布式计算、远程服务调用等许多场景。业界有很多开源的优秀 RPC 框架，例如 Dubbo、Thrift、gRPC、Hprose 等等。</p>
<p>RPC 与 HTTP、RMI、Web Service 都能完成远程调用，但是实现方式和侧重点各有不同。</p>
<p>RPC是一种协议规范，可以把HTTP看作是一种RPC的实现，也可以把HTTP作为RPC的传输协议来应用。与HTTP相比，RPC的缺点就是相对复杂，学习成本稍高。</p>
<h4> 1.2.1、序列化和反序列化</h4>
<ul>
<li>什么是序列化？序列化就是将数据结构或对象转换成二进制串的过程，也就是编码的过程</li>
<li>什么是反序列化？将在序列化过程中所生成的二进制串转换成数据结构或对象的过程</li>
<li>为什么需要序列化？转换为二进制串才好进行网络传输嘛</li>
<li>为什么需要反序列化？将二进制串转换成对象才好进行后续处理嘛</li>
</ul>
<h2> 2、zookeeper（注册中心）</h2>
<p>Zookeeper是一个高性能的，分布式的，开放源码的分布式应用程序协调服务，简称zk。</p>
<h3> 2.1、zookeeper 下载</h3>
<p>下载可在官网下载，如 3.4.11 地址参考：<a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/" target="_blank" rel="noopener noreferrer">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.11/</a></p>
<h3> 2.2、zookeper安装使用（window版）</h3>
<p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<figure><figcaption>img_16.png</figcaption></figure>
<p>zookeeper 下载后直接解压即可。在bin文件下，直接通过命令行执行 zkServer.cmd 即为启动 zookeeper。</p>
<p>第一次启动时可能会有报错，如下：</p>
<figure><figcaption>img_17.png</figcaption></figure>
<p>此时只需在 conf 目录下将 zoo_sample.cfg 文件复制一份，将名字改为 zoo.cfg 即可。打开&nbsp;zoo.cfg 文件，可以看到内容如下：</p>
<figure><figcaption>img_18.png</figcaption></figure>
<p>可以将 dataDir 路径修改为我们想要保存文件的路径，如：../data，然后建立相应的目录即可。</p>
<p>再次启动 zookeeper，可以看到可正常启动，输出如下：</p>
<figure><figcaption>img_19.png</figcaption></figure>
<p>可以运行 zkCli.cmd 连接到zookeeper的服务器，如下：</p>
<figure><figcaption>img_20.png</figcaption></figure>
<h3> 2.3、zookeper安装使用（Linux版）</h3>
<p>ZooKeeper服务器是用Java创建的，它运行在JVM之上。需要安装JDK 7或更高版本。</p>
<figure><figcaption>img_21.png</figcaption></figure>
<p>将下载的ZooKeeper放到/opt/ZooKeeper目录下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将tar包解压到/opt/zookeeper目录下</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置zoo.cfg</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改zoo.cfg</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改存储目录：dataDir=/opt/zookeeper/zkdata<br>
</p>
<p>启动ZooKeeper</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到下图表示ZooKeeper成功启动<br>
</p>
<h4> 2.3.1、查看ZooKeeper状态</h4>
<p>查看ZooKeeper状态</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下图表示zookeeper启动成功。standalone代表zk没有搭建集群，现在是单节点<br>
</p>
<p>下图表示zookeeper没有启动<br>
</p>
<h2> 3、提供者消费者示例</h2>
<p>（建议参考&nbsp;3.2、springboot搭建dubbo示例）</p>
<h3> 3.1、spring搭建dubbo示例</h3>
<p>基于以下图实现服务 提供者、消费者，即以用户服务作为提供者，订单服务作为消费者。<br>
</p>
<p>分别创建 maven 工程 user-service-provider、order-service-consumer，还需要创建一个专门用于存服务接口的工程 dubbo-interface。</p>
<p>提供者工程 user-service-provider 引入以下依赖：（dubbo依赖会自动引入 spring 的相关依赖），另外需要引入 dubbo-interface 工程。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提供者工程添加配置文件 provider.xml，并添加以下配置内容：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>暴露的服务的实现类&nbsp;UserServiceImpl、UserServiceImpl2 代码大概如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动提供者，main 方法如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动提供者后可以在管理控制台看到注册的服务：<br>
</p>
<p>在消费者工程引入依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者工程添加配置文件 consumer.xml，并添加以下配置内容：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费者建一个实现类，直接使用提供者的方法，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动消费者 main 方法，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到输出：<br>
</p>
<p>由此，消费者调用提供者提供的服务即完成。</p>
<p>（上面的示例没有把 dubbo-interface 工程具体写出来，可以参考下面 3.2）</p>
<h3> 3.2、springboot搭建dubbo示例</h3>
<p>创建工程 dubbotest01，在该工程下创建 module：dubbo-interface、dubbo-provider、dubbo-consumer。其中，dubbo-provider 和 dubbo-consumer 创建为 springboot 项目，可用于测试服务调用，dubbo-interface 只需创建为普通 maven 项目即可，只需在里面管理一些公共接口类。dubbo-interface 后面被打成 jar 包，它的作用只是提供接口。<br>
</p>
<h4> 3.2.1、搭建dubbo-interface 模块</h4>
<p>在 dubbo-interface 模块中创建接口类&nbsp;HelloService，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.2、搭建dubbo-provider模块</h4>
<p>dubbo-provider 中添加依赖，包括dubbo 、zookeeper以及 dubbo-interface 的依赖，如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 application.properties 配置文件中配置 dubbo 相关信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现 HelloService 接口，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给启动类加上&nbsp;<code>@EnableDubboConfiguration</code>&nbsp;注解开启Dubbo 的自动配置。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.3、搭建dubbo-consumer模块</h4>
<p>dubbo-consumer 中添加依赖，包括dubbo 、zookeeper以及 dubbo-interface 的依赖，如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 application.properties 配置文件中配置 dubbo 相关信息</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编写一个简单 Controller ，HelloController 来调用远程服务，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给启动类加上&nbsp;<code>@EnableDubboConfiguration</code>&nbsp;注解开启Dubbo 的自动配置。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动 zookeeper，启动 provider 和 consumer 服务，调用 consumer 服务的 HelloController 类，即访问&nbsp;<a href="http://localhost:8330/hello%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%BE%93%E5%87%BA%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="noopener noreferrer">http://localhost:8330/hello，可以看到输出如下：</a><br>
</p>
<p>由此，使用SpringBoot+Dubbo 搭建分布式服务成功。</p>
<h2> 4、zookeeper管理控制台（dubbo-admin）</h2>
<p>dubbo-admin 管理平台，是图形化的服务管理页面。该平台从注册中心中获取到所有的提供者 / 消费者，可进行配置管理 路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能。</p>
<h3> 4.1、dubbo-admin的安装使用</h3>
<h4> 4.1.1、dubbo-admin下载打包</h4>
<p>dubbo-admin 是一个前后端分离的项目，前端使用vue，后端使用springboot。</p>
<p>dubbo-admin下载地址 ：<a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener noreferrer">https://github.com/apache/dubbo-admin</a></p>
<p>下载解压后进入 dubbo-admin-server\src\main\resources 目录，找到&nbsp;<strong>application.properties</strong>&nbsp;配置文件进行配置修改，将 zookeeper 地址修改为正确地址，如：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 dubbo-admin-develop 根目录执行打包命令：mvn clean package -Dmaven.test.skip=true，看到 build success 即打包成功。<br>
</p>
<ol>
<li>或者先在&nbsp;dubbo-admin-server 中打包，使用 mvn package -Dmaven.test.skip=true ，</li>
<li>然后&nbsp;java&nbsp;-jar 启动打包生成的 jar 包，如：java -jar dubbo-admin-server-0.3.0.jar。</li>
<li>然后再去&nbsp;dubbo-admin-ui 里面执行 npm install 等待下载前端的依赖，完毕后启动前端 npm run dev</li>
</ol>
<p>如果 dubbo-admin-server 编译报错，提示 zookeeper server创建失败什么的，可将上面的 admin.registry.address 配置改为：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.1.2、启动前后端</h4>
<p>切换到目录打包后的后端 jar 包目录：dubbo-Admin-develop\dubbo-admin-distribution\target，执行以下命令启动后台：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 dubbo-admin-ui 目录下执行以下命令启动前端：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动完成后即可通过 localhost:8081 看到后台管理页面了，启动结果如下：（默认登录账户密码都是 root）<br>
</p>
<h3> 4.2、dubbo-admin的基本使用</h3>
<p>可以在服务查询中看到已注册的服务，如下：<br>
</p>
<p>点击服务的详情，可以看到该服务的详细信息和该服务的消费者，如下：<br>
<br>
</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-16T01:53:26.000Z</published>
  </entry>
  <entry>
    <title type="text">组件MySQL</title>
    <id>https://ujava.cn/assembly/mysql.html</id>
    <link href="https://ujava.cn/assembly/mysql.html"/>
    <updated>2024-04-17T01:10:40.000Z</updated>
    <summary type="html"><![CDATA[<figure><figcaption>img_36.png</figcaption></figure>
<h2> 一、数据库简介</h2>
<h3> 1. 数据库是什么</h3>
<p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。</p>
<ul>
<li>数据是数据库中存储的基本对象，是按一定顺序排列组合的物理符号。数据有多种表现形式，可以是数字、文字、图像，甚至是音频或视频，它们都可以经过数字化后存入计算机。</li>
<li>数据库是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。</li>
<li>在日常生活中，人们可以直接用中文、英文等自然语言描述客观事物。在计算机中，则要抽象出对这些事物感兴趣的特征，并组成一个记录来描述。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<figure><figcaption>img_36.png</figcaption></figure>
<h2> 一、数据库简介</h2>
<h3> 1. 数据库是什么</h3>
<p>数据库是数据管理的有效技术，是由一批数据构成的有序集合，这些数据被存放在结构化的数据表里。数据表之间相互关联，反映客观事物间的本质联系。数据库能有效地帮助一个组织或企业科学地管理各类信息资源。</p>
<ul>
<li>数据是数据库中存储的基本对象，是按一定顺序排列组合的物理符号。数据有多种表现形式，可以是数字、文字、图像，甚至是音频或视频，它们都可以经过数字化后存入计算机。</li>
<li>数据库是数据的集合，具有统一的结构形式并存放于统一的存储介质内，是多种应用数据的集成，并可被各个应用程序所共享。</li>
<li>在日常生活中，人们可以直接用中文、英文等自然语言描述客观事物。在计算机中，则要抽象出对这些事物感兴趣的特征，并组成一个记录来描述。</li>
</ul>
<h3> 2. 数据库在开发中的作用</h3>
<p>从数据库系统应用角度来看，数据库系统常见的运行与应用结构有：客户端/服务器结构、浏览器/服务器结构。</p>
<ul>
<li>在客户端/服务器（Client/Server，C/S）结构中，数据库的使用者（如 DBA、程序设计者）通过命令行客户端、图形化界面管理工具或应用程序等连接到数据库管理系统，可以通过数据库管理系统查询和处理存储在底层数据库中的各种数据。</li>
<li>数据库使用者与命令行客户端、图形化界面管理工具或应用程序等直接交互，而不与数据库管理系统直接联系。</li>
<li>在这种结构中，命令行客户端、图形化界面管理工具或应用程序等称为“客户端”或“前台”，主要完成与数据库使用者的交互任务；而数据库管理系统则称为“服务器”或“后台”，主要负责数据管理。这种结构经常被称为“C/S”结构。</li>
<li>在客户端/服务器模式中，客户端和服务器可以同时工作在同一台计算机上，这种工作方式称为“单机方式”；也可以“网络方式”运行，即服务器被安装和部署在网络中某一台或多台主机上。</li>
<li>对于客户端应用程序的开发，目前常用的语言工具主要有 Visual C++、Delphi、.NET 框架、Visual Basic、Python 等。</li>
<li>数据库能有效存储数据，读取数据、查找数据更是方便，其实那些管理软件就是通过软件的界面向内部的数据库进行数据的增、删、改、查操作。</li>
</ul>
<h3> 3.常见数据库比较</h3>
<p><strong>3.1 MySQL数据库</strong><br>
<strong>定位</strong><br>
开源、多平台、关系型数据库<br>
目前使用最广泛、流行度最高的的开源数据库。</p>
<p><strong>功能</strong><br>
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据，有插件式存储引擎，支持多种存储引擎格式</p>
<p><strong>部署</strong><br>
用编译安装的方式，或者二进制包的方式，按照“安装软件-创建实例-库表用户初始化”，可以很快完成数据库部署</p>
<p><strong>使用</strong><br>
使用标准的SQL语句进行数据库管理，简单SQL语句的并发和性能较好，对视图、存储过程、函数、触发器等支持的不是太好</p>
<p><strong>监控</strong><br>
在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有比较多的开源监控工具来监控和记录数据库的状态，比如zabbix，nagios，cacti，lepus等</p>
<p><strong>备份</strong><br>
逻辑备份 mysqldump/mysqldumper ，物理备份 用xtrabackup等工具进行备份；</p>
<p><strong>高可用</strong><br>
MySQL高可用有多种方案，官方有基础的master-slave主从复制，新版本的innodb cluster，第三方的有MHA等高可用方案；</p>
<p><strong>扩展</strong><br>
MySQL水平拆分，可以通过水平拆分proxy中间进行逻辑映射和拆分，扩大MySQL数据库的并发能力和吞吐量。</p>
<p><strong>适用场景</strong><br>
默认的innodb存储引擎，支持高并发，简单的绝大部分OLTP场景；<br>
Tokudb存储引擎，使用高并发insert的场景；<br>
Inforbright存储引擎，可以进行列压缩和OLAP统计查询场景；</p>
<p><strong>选择注意</strong><br>
使用MySQL进行OLTP业务时，需要注意数据量级，如果数据量级过大，需要进行水平拆分；<br>
如果有OLAP需求，可以结合其他架构综合考虑。</p>
<p><strong>3.2 SQL Server数据库</strong><br>
<strong>定位</strong><br>
商业、Windows平台、关系型数据库<br>
最早接触、与微软体系结合紧密的的商业数据库，属于“微软技术体系”</p>
<p><strong>功能</strong><br>
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据</p>
<p><strong>部署</strong><br>
在Windows平台，用图形界面进行软件安装；</p>
<p><strong>使用</strong><br>
在Windows平台，使用SQL Server Mangement Studio图形界面进行安装；</p>
<p><strong>监控</strong><br>
一般通过Windows资源管理和SQL server图形工具进行系统和数据库性能显示；</p>
<p><strong>备份</strong><br>
通常用第三方备份恢复软件进行备份恢复；</p>
<p><strong>高可用</strong><br>
通过共享存储和双机热备的方式，可以实现SQL Server数据库的高可用；</p>
<p><strong>扩展</strong><br>
SQL Server数据库集群采用共存存储的方式，通过硬件垂直升级来对数据库集群进行扩展；</p>
<p><strong>适用场景</strong><br>
大多数OLTP场景（与微软体系配合）</p>
<p><strong>选择注意</strong></p>
<ul>
<li>SQL Server与微软技术体系结合比较紧密，绝大多数工作，都是通过图形界面完成，对于习惯使用命令行的DBA可能会有不习惯；</li>
<li>SQL server对双引号，大小写，元信息的管理和处理方式，与其他数据库很不相同，需要注意；</li>
<li>使用SQL Server满足OLTP业务，会有比较好的效果，但对于大数据量的OLAP业务，最好还是选用专门的OLAP架构，不要在同一个SQL Server实例上混用OLTP和OLAP业务；</li>
<li>SQL server属于商业软件，需要注意版权和licence授权费用；</li>
</ul>
<p><strong>3.3 Oracle数据库</strong><br>
<strong>定位</strong><br>
商业、多平台、关系型数据库<br>
功能最强大、最复杂、市场占比最高的商业数据库</p>
<p><strong>功能</strong><br>
支持事务，符合关系型数据库原理，符合ACID，支持多数SQL规范，以二维表方式组织数据</p>
<p><strong>部署</strong><br>
Oracle单实例数据库部署相对容易，但Oracle RAC集群环境，部署的步骤和依赖条件都比较多；</p>
<p><strong>使用</strong><br>
通常使用命令行工具，进行各种数据库的管理，通常也可以用shell脚本和python脚本提高Oracle数据库管理效率；各种管理功能，都比较强大；</p>
<p><strong>监控</strong><br>
Oracle官方有比较全面的监控工具，常用的第三方监控平台，如zabbix,cacti,lepus等都有对Oracle数据库的各项指标的完善监控；</p>
<p><strong>备份</strong><br>
支持冷备份和热备份，可以用 exp/imp , expdp/impdp等进行逻辑备份和恢复，可以使用强大的RMAN工具进行专业的物理热备份和恢复；</p>
<p><strong>高可用</strong><br>
Oracle数据库的高可用架构，可以用第三方双机热备软件，结合Oracle单实例实现；可以使用Oracle Dataguard，实现master和standby的备份；可以使用 Oracle RAC集群实现实例级别的高可用和负载均衡，使用ASM实现存储级别的高可用；</p>
<p><strong>扩展</strong><br>
由于Oracle集群采用共享存储的方式，一般只能通过垂直硬件升级进行升级；</p>
<p><strong>适用场景</strong><br>
绝大多数OLTP场景，部分OLAP</p>
<p><strong>选择注意</strong><br>
Oracle从架构到运维，可以说是最难的数据库，学习和使用难度较高。</p>
<p><strong>3.4 Hbase数据库</strong><br>
<strong>定位</strong></p>
<ul>
<li>开源、Linux平台、列存储nosql数据库</li>
<li>可用于海量数据存储、与Hadoop生态圈结合、定位于“大”的列存储nosql数据库</li>
</ul>
<p><strong>功能</strong><br>
命令执行速度非常看，读写性能可达10万/秒；数据结构是key-value类似字典的功能，可以键过期-缓存，发布订阅-消息系统，简单的事物功能；</p>
<p><strong>部署</strong><br>
相对其他数据库，hbase的部署比较复杂，依赖Hadoop，zookeeper等组件，Hbase集群包括一个mater节点，多个regionServer，zookeeper管理所有regionServer，需要依次部署Hadoop、zookeeper之后，再部署HBASE集群；</p>
<p><strong>使用</strong><br>
用redis-cli客户端连接，一般用简单的 set ,get,del 进行数据管理； 在单实例redis的基础上，进行可以数据持久化，主从复制，高可用和分布式等功能；</p>
<p><strong>监控</strong><br>
在命令行界面有一些常用的命令显示状态和性能，在图形界面方面，有开源监控工具来监控和记录数据库的状态，比如cachecloud；</p>
<p><strong>备份</strong><br>
Hbase一般用作海量数据的仓库，本身通过多层副本来保证数据安全性，不用进行专门的备份</p>
<p><strong>高可用</strong><br>
HBASE集群基于Hadoop，需要依次部署Hadoop单机模式、集群模式、HA模式，通过Hadoop HA实现高可用；</p>
<p><strong>扩展</strong><br>
HBASE以集群形式，依次是单机模式，伪分布模式，完全分布模式，底层基于HDFS，zookeeper可以很好地进行扩展；</p>
<p><strong>适用场景</strong><br>
两大用途：</p>
<ul>
<li>用于简单数据写入和海量、结构简单数据查询的业务场景；</li>
<li>用于成为其他数据库备份和下沉的数据库；</li>
</ul>
<p><strong>选择注意</strong></p>
<ul>
<li>Hbase不适合的场景：对数据分析需求高，需要能够用sql或者简单的MapReduce实现分析需求的业务场景，不适合用Hbase；</li>
<li>单表数据量，不超过千万时，使用Hbase，体现不出Hbase的优势，而且会比较慢，不适合用Hbase。</li>
<li>通过对上面数据库“七种”武器的描述，也可以看到目前常用数据库的使用脉络和选择顺序，对应一个业务，可以优先选择最流行的开源数据库——MySQL；如果出于稳定和商业版考虑，可以选择Oracle数据库，或者SQL Server数据库（与Windows体系结合）；如果想用开源，有想要有足够的功能来应对各种场景，可以使用 postgresql数据库。这四种数据库，都是关系型数据库，可以很好地满足大多数业务场景，解决通用性问题。</li>
<li>对于一些特殊性问题，尤其是想要在扩展性方面有比较高的要求，可以考虑nosql数据库。Mongodb数据库，介于关系型数据库和非关系型数据库之间，兼具两者的特点，是非常流行的文档型nosql数据库；redis定位于内存型键值nosql数据库；hbase是海量文件存储的列式nosql数据库。根据合适的业务场景，选择适合的nosql数据库，可以对某一类，或某几类业务问题有很好的解决，可以作为关系型数据库的一种补充。</li>
<li>换个角度，MySQL，Oracle，SQL Server，Postgresql，mongodb这五种数据库，也是DB-Engines排行榜上最流行的排名前五的五种数据库，从使用量和受欢迎程度，也可以看出这些数据库使用的广泛性。</li>
</ul>
<h3> 4. 数据库常见功能</h3>
<figure><figcaption>img_37.png</figcaption></figure>
<h2> 二、Mysql数据库简介</h2>
<h3> 1. MySQL的优势</h3>
<p>MySQL 使用的 SQL 语言是用于访问数据库的最常用的标准化语言。<br>
  由于 MySQL 数据库体积小、速度快、总体拥有成本低、开放源代码，其有着广泛的应用，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，因此搭配 PHP 和 Apache 服务器可组成良好的开发环境。<br>
  MySQL 数据库管理系统具有以下系统特性：<br>
（1） 使用 C 和 C++ 编写，并使用多种编译器进行测试，保证源代码的可移植性。<br>
（2）支持 AIX、FreeBSD、HP-UX、Linux、Mac OS、NovellNetware、OpenBSD、OS/2 Wrap、Solaris、Windows 等多种操作系统。<br>
（3）为多种编程语言提供了 API。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。<br>
（4）支持多线程，充分利用 CPU 资源。<br>
（5）优化的 SQL 查询算法，有效地提高查询速度。<br>
（6）既能够作为一个单独的应用程序应用在客户端服务器网络环境中，也能够作为一个库而嵌入其他的软件中。<br>
（7）提供多语言支持，常见的编码如中文的 GB 2312、BIG 5，日文的 Shift_JIS 等都可以用作数据表名和数据列名。<br>
（8）提供 TCP/IP、ODBC 和 JDBC 等多种数据库连接途径。<br>
（9）提供用于管理、检查、优化数据库操作的管理工具。<br>
（10）支持大型的数据库。可以处理拥有上千万条记录的大型数据库。<br>
（11）支持多种存储引擎。</p>
<h3> 2. MySQL的版本以及版本号</h3>
<p>针对不同的用户，MySQL分为两个版本：<br>
（1）MySQL Community Server（社区版）：该版本完全免费，但是官方不提供技术支持。<br>
（2）MySQL Enterprise Server（企业版）：该版本能够以很高的性价比为企业提供数据仓库应用，支持 ACID 事物处理，提供完整的提交、回滚、崩溃恢复和行级锁定功能，但是该版本需要付费使用，官方提供电话技术支持。<br>
温馨提示：MySQL Cluster 主要用于架设群服务器，需要在社区服务或企业版的基础上使用。</p>
<p>MySQL 的命名机制由 3 个数字和 1 个后缀组成，例如 mysql-5.7.20：</p>
<ul>
<li>第 1 个数字“5”是主版本号，用于描述文件的格式，所有版本 5 的发行版都有相同的文件夹格式。</li>
<li>第 2 个数字“7”是发行级别，主版本号和发行级别组合在一起便构成了发行序列号。</li>
<li>第 3 个数字“20”是在此发行系列的版本号，随每次新发行的版本递增。通常选择已经发行的最新版本。</li>
</ul>
<p>在 MySQL 开发过程中，同时存在多个发布系列，每个发布系列的成熟度处在不同阶段。</p>
<ul>
<li>MySQL 5.7 是最新开发的稳定（GA）发布系列，是将执行新功能的系列，目前已经可以正常使用。</li>
<li>MySQL 5.6 是比较稳定的（GA）发布系列，只针对漏洞修复重新发布，不增加会影响稳定性的新功能。</li>
<li>MySQL 5.1 是一个稳定的（产品质量）发布系列，只针对严重漏洞修复和安全修复重新发布，不增加影响该系列稳定性的重要功能。</li>
<li>对于 MySQL 4.1 等低于 5.0 的老版本，官方将不再提供支持</li>
</ul>
<h3> 3. MySQL 5.7的新特性</h3>
<p>与 MySQL5.6 相比，MySQL 5.7 具有以下几个方面的新功能。<br>
（1）随机 root 密码<br>
MySQL 5.7 数据库初始化完成后，会自动生成一个 root@localhost 用户，root 用户的密码不为空，而是随机产生一个密码。<br>
（2）自定义 test 数据库<br>
MySQL 5.7 默认安装完成后没有 test 数据库。用户可以自行创建 test 数据库并对其进行权限控制。<br>
（3）默认 SSL 加密<br>
MySQL 5.7 采用了更加简单的 SSL 安全访问机制，默认连接使用 SSL 的加密方式。<br>
（4）密码过期策略<br>
MySQL 5.7 支持用户设置密码过期策略，要求用户在一定时间过后必须修改密码。<br>
（5）用户锁<br>
MySQL 5.7 为管理员提供了暂时禁用某个用户的功能，使被锁定的用户无法访问和使用数据库。<br>
（6）全面支持JSON<br>
MySQL 5.7在服务器端提供了一组便于操作 JSON 的函数。存储的方法是将 JSON 编码成 BLOB 后再由存储引擎进行处理。这样，MySQL 就同时拥有了关系型数据库和非关系型数据库的优点，并且可以提供完整的事务支持。<br>
（7）支持两类生成列（generated column）<br>
生成列是通过数据库中的其他列计算得到的一列。当为生成列创建索引时，可以便捷地加快查询速度。MySQL 5.7 支持虚拟生成列和存储生成列。虚拟生成列仅将数据保存在表的元数据中，作为缺省的生成列类型；存储生成列则是将数据永久保存在磁盘上，需要更多的磁盘空间。<br>
（8）引入系统库（sys schema）<br>
系统库中包含一系列视图、函数和存储过程，通过多线程、多进程、组合事务提交和基于行的优化方式将复制功能提高 5 倍以上，用户向外扩充其跨商品系统的工作负载时，得以大幅提升复制的效能和效率。<br>
与 MySQL5.6 相比，MySQL 5.7 具有以下几个方面的新功能。</p>
<h2> 三、Mysql安装与服务启动（Windows版本）</h2>
<h3> 1. 下载</h3>
<p>用户可以根据自身的操作系统类型，从 MySQL官方下载页面免费下载相应的服务器安装包。本书以 MySQL 5.7.20 为例介绍其在 Windows 10 操作系统下的安装和配置过程。</p>
<p>用户下载 Windows 图形化安装包的步骤如下。</p>
<p>步骤 1)：打开 MySQL 官方网站（<a href="https://www.mysql.com/" target="_blank" rel="noopener noreferrer">http://www.mysql.com</a>），单击 DOWNLOAD，进入 MySQL 产品的下载界面，如图所示。<br>
</p>
<p>步骤 2)：在 MySQL 产品分类中选择 Community 菜单，在下载列表中选择 MySQL Community Server，如图所示。<br>
</p>
<p>步骤3)：在下载页面中，操作系统选择 Microsoft Windows，下载的安装文件为 mysql-installer-community-5.7.20.0.msi，如图所示。<br>
</p>
<h3> 2. 安装教程</h3>
<p>Windows 平台下提供两种安装 MySQL 的方式：</p>
<ul>
<li>MySQL 二进制分发版（.msi 安装文件）。</li>
<li>免安装版（.zip 压缩文件）。</li>
</ul>
<p>用户使用图形化安装包安装 MySQL 的步骤如下：</p>
<p>步骤 1)：双击下载的 MySQL 安装文件，进入 MySQL 安装界面，首先进入“License Agreement（用户许可证协议）”窗口，选中“I accept the license terms（我接受系统协议）”复选框，单击“Next（下一步）”按钮，如图所示。<br>
</p>
<p>进入MySQL安装界面并接受系统协议</p>
<p>步骤 2)：进入“Choosing a Setup Type（安装类型选择）”窗口，根据右侧的安装类型描述文件选择适合自己的安装类型，这里选择默认的安装类型，如图所示。<br>
</p>
<p>选择默认的安装类型</p>
<blockquote>
<p>注意：Developer Default：默认安装类型；Server only：仅作为服务；Client only：仅作为客户端；Full：完全安装；Custom：自定义安装类型。</p>
</blockquote>
<p>步骤 3)：根据所选择的安装类型安装 Windows 系统框架（framework），单击 Execute 按钮，安装程序会自动完成框架的安装，如图所示。<br>
</p>
<p>检查并生成安装所需要的框架列表</p>
<p>当弹出安装程序窗口时，勾选“我同意许可条款和条件”复选框，然后单击“安装”按钮，如图所示。<br>
</p>
<p>同意安装框架的许可条件</p>
<p>弹出“设置成功”的界面，表示该框架已经安装完成，单击“关闭”按钮即可。所有的框架安装均可参考本操作，如图所示。<br>
</p>
<p>安装框架成功</p>
<p>步骤 4)：所需框架均安装成功后，单击 “Next（下一步）”按钮，如图所示。<br>
</p>
<p>所有框架安装完成</p>
<p>步骤 5)：进入安装确认窗口，单击 “Execute（执行）”按钮，开始 MySQL 各个组件的安装，如图所示。<br>
</p>
<p>准备安装MySQL各个组件</p>
<p>步骤 6)：开始安装 MySQL 文件，安装完成后在 “Status（状态）”列表下显示 “Complete（安装成功）”，如图所示。<br>
</p>
<p>MySQL各个组件安装成功</p>
<h3> 3. 判断是否安装成功</h3>
<p><strong>3.1 启动与关闭服务</strong><br>
net start mysql为启动服务，net stop mysql为关闭命令<br>
</p>
<p><strong>3.2 登录数据库</strong><br>
cmd进入数据库的bin文件夹中<br>
</p>
<p>输入mysql -u root -p命令，再输入登录密码，出现以下结果代表登录成功<br>
</p>
<p><strong>3.3 查看数据库名称</strong><br>
登录完成后，输入show databases<br>
</p>
<h2> 四、Mysql图形化工具</h2>
<p>（1）Navicat（重点推荐）<br>
</p>
<p>Navicat是MySQL和MariaDB数据库管理与开发理想的解决方案。它可同时在一个应用程序上连接MySQL和MariaDB数据库。这种兼容前端为数据库提供了一个直观而强大的图形界面管理、开发和维护功能，为初级MySQL和MariaDB开发人员和专业开发人员都提供了一组全面的开发工具。</p>
<p>（2）Induction<br>
</p>
<p>Induction是一款用于理解数据关系的开源管理工具，它可用来探索行/列，运行查询和数据可视化等方面。该工具支持多种数据库，包括PostgreSQL，MySQL，SQLite，Redis以及MongoDB。此外，Induction还可以通过编写添加其他新的适配器。</p>
<p>（3）SqlWave<br>
</p>
<p>SQLWave是一种简单、快速且易用的MySQL客户端。用户可通过该工具轻松地连接到远程主机。SqlWave支持所有MySQL的最新版本，包括它用来管理数据库结构的所有最新功能，如工作表、视图、存储过程、函数、事件、外键和触发器等。</p>
<h2> 五、Mysql存储引擎精讲</h2>
<h3> 1. 存储引擎分类</h3>
<p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。<br>
  提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。</p>
<h3> 2. MySQL 5.7 支持的存储引擎</h3>
<p>MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。<br>
  MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。<br>
  MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。<br>
</p>
<h3> 3. MySQL 默认存储引擎</h3>
<ul>
<li>InnoDB 是系统的默认引擎，支持可靠的事务处理。</li>
<li>使用下面的语句可以修改数据库临时的默认存储引擎</li>
<li>SET default_storage_engine=&lt; 存储引擎名 &gt;<br>
例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。<br>
</li>
</ul>
<p>此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。</p>
<h2> 六、Mysql数据类型介绍</h2>
<h3> 1. 基本介绍</h3>
<p>在 MySQL 中常见的数据类型如下：</p>
<ol>
<li>整数类型<br>
包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型 FLOAT 和 DOUBLE，定点数类型 DECIMAL。</li>
<li>日期/时间类型<br>
包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。</li>
<li>字符串类型<br>
包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。</li>
<li>二进制类型<br>
包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</li>
</ol>
<h3> 2. 整数类型</h3>
<p>MySQL提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。<br>
  MySQL 主要提供的整数类型有 <strong>TINYINT</strong>、<strong>SMALLINT</strong>、<strong>MEDIUMINT</strong>、<strong>INT</strong>、<strong>BIGINT</strong>，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。<br>
</p>
<p>从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。</p>
<p>根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。<br>
</p>
<p>提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。</p>
<h3> 3. 小数类型</h3>
<p>MySQL中使用浮点数和定点数来表示小数。</p>
<ul>
<li>浮点类型有两种，分别是单精度浮点数（<strong>FLOAT</strong>）和双精度浮点数（<strong>DOUBLE</strong>）；定点类型只有一种，就是 <strong>DECIMAL</strong>。</li>
<li>浮点类型和定点类型都可以用<code>(M, D)</code>来表示，其中<code>M</code>称为精度，表示总共的位数；<code>D</code>称为标度，表示小数的位数。</li>
<li>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。</li>
<li>下表中列出了 MySQL 中的小数类型和存储需求。<br>
</li>
</ul>
<p>FLOAT 类型的取值范围如下：</p>
<ul>
<li>有符号的取值范围：-3.402823466E+38～-1.175494351E-38。</li>
<li>无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。</li>
</ul>
<p>DOUBLE 类型的取值范围如下：</p>
<ul>
<li>有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。</li>
<li>无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。</li>
<li>提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</li>
<li>FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。</li>
</ul>
<p>浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。</p>
<p>最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p>
<h3> 4. 日期和时间类型</h3>
<p>MySQL中有多处表示日期的数据类型：<strong>YEAR</strong>、<strong>TIME</strong>、<strong>DATE</strong>、<strong>DTAETIME</strong>、<strong>TIMESTAMP</strong>。当只记录年信息的时候，可以只使用 YEAR 类型。</p>
<ul>
<li>每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。</li>
<li>下表中列出了 MySQL 中的日期与时间类型。<br>
</li>
</ul>
<p><strong>YEAR 类型</strong></p>
<ul>
<li>YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：</li>
<li>以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 '1901'～'2155'。输入格式为 'YYYY' 或者 YYYY，例如，输入 '2010' 或 2010，插入数据库的值均为 2010。</li>
<li>以 2 位字符串格式表示的 YEAR，范围为 '00' 到 '99'。'00'～'69' 和 '70'～'99' 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。'0' 与 '00' 的作用相同。插入超过取值范围的值将被转换为 2000。</li>
<li>以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。</li>
<li>提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 '0' 或 '00'，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。</li>
</ul>
<p><strong>TIME 类型</strong><br>
TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。</p>
<p>TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。</p>
<p>可以使用各种格式指定 TIME 值，如下所示。</p>
<ul>
<li>'D HH：MM：SS' 格式的字符串。还可以使用这些“非严格”的语法：'HH：MM：SS'、'HH：MM'、'D HH' 或 'SS'。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。</li>
<li>'HHMMSS' 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，'101112' 被理解为'10：11：12'，但是 '106112' 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。</li>
<li>提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 '1112' 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 '12' 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，'11：12' 表示 11：12：00，而不是 00：11：12。</li>
</ul>
<p><strong>DATE 类型</strong><br>
DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 'YYYY-MM-DD'，其中 YYYY 表示年，MM 表示月，DD 表示日。</p>
<ul>
<li>在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示：</li>
<li>以 'YYYY-MM-DD' 或者 'YYYYMMDD' 字符中格式表示的日期，取值范围为 '1000-01-01'～'9999-12-3'。例如，输入 '2015-12-31' 或者 '20151231'，插入数据库的日期为2015-12-31。</li>
<li>以 'YY-MM-DD' 或者 'YYMMDD' 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：'00～69' 范围的年值转换为 '20002069'，'7099' 范围的年值转换为 '1970～1999'。例如，输入 '15-12-31'，插入数据库的日期为 2015-12-31；输入 '991231'，插入数据库的日期为 1999-12-31。</li>
<li>以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。</li>
<li>使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。</li>
<li>提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，'98-11-31'、'98.11.31'、'98/11/31'和'98@11@31' 是等价的，这些值也可以正确地插入数据库。</li>
</ul>
<p><strong>DATETIME 类型</strong><br>
DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 'YYYY-MM-DD HH：MM：SS'，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。</p>
<ul>
<li>在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。</li>
<li>以 'YYYY-MM-DD HH：MM：SS' 或者 'YYYYMMDDHHMMSS' 字符串格式表示的日期，取值范围为 '1000-01-01 00：00：00'～'9999-12-3 23：59：59'。例如，输入 '2014-12-31 05：05：05' 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。</li>
<li>以 'YY-MM-DD HH：MM：SS' 或者 'YYMMDDHHMMSS' 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，'00～79' 范围的年值转换为 '2000～2079'，'80～99' 范围的年值转换为 '1980～1999'。例如，输入 '14-12-31 05：05：05'，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。</li>
<li>以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。</li>
<li>提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，'98-12-31 11：30：45'、'98.12.31 11+30+35'、'98/12/31 11_30_45' 和 '98@12@31 113045' 是等价的，这些值都可以正确地插入数据库。</li>
</ul>
<p><strong>TIMESTAMP 类型</strong><br>
TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01'UTC～'2038-01-19 03：14：07'UTC。在插入数据时，要保证在合法的取值范围内。<br>
提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p>
<ul>
<li>TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：</li>
<li>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；</li>
<li>而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。<br>
提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 '00：00：00'，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。</li>
</ul>
<h3> 5. 字符串类型</h3>
<p>字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。</p>
<ul>
<li>MySQL中的字符串类型有 <strong>CHAR</strong>、<strong>VARCHAR</strong>、<strong>TINYTEXT</strong>、<strong>TEXT</strong>、<strong>MEDIUMTEXT</strong>、<strong>LONGTEXT</strong>、<strong>ENUM</strong>、<strong>SET</strong> 等。</li>
<li>下表中列出了 MySQL 中的字符串数据类型，括号中的<code>M</code>表示可以为其指定长度。</li>
</ul>
<p>VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。</p>
<p>例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。</p>
<p>CHAR 和 VARCHAR 类型</p>
<p>CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。</p>
<p>例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。</p>
<p>VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。</p>
<p>例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。</p>
<p>【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。</p>
<p>插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求</p>
<ul>
<li>' ' ' ' 4字节 '' 1字节</li>
<li>'ab' 'ab ' 4字节 'ab' 3字节</li>
<li>'abc' 'abc ' 4字节 'abc' 4字节</li>
<li>'abcd' 'abcd' 4字节 'abcd' 5字节</li>
<li>'abcdef' 'abcd' 4字节 'abcd' 5字节<br>
对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。</li>
</ul>
<p>TEXT 类型</p>
<p>TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。</p>
<ul>
<li>TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。</li>
<li>TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。</li>
<li>TEXT 表示长度为 65535（216-1）字符的 TEXT 列。</li>
<li>MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。</li>
<li>LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。</li>
</ul>
<p><strong>ENUM 类型</strong><br>
ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：</p>
<ul>
<li>&lt;字段名&gt; ENUM( '值1', '值1', …, '值n' )</li>
<li>字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。</li>
</ul>
<p>ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。</p>
<p>ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。</p>
<p>例如，定义 ENUM 类型的列（'first'，'second'，'third'），该列可以取的值和每个值的索引如下表所示。</p>

<p>ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。<br>
提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。</p>
<p><strong>SET 类型</strong><br>
SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：<br>
SET( '值1', '值2', …, '值n' )<br>
与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。</p>
<ul>
<li>但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。</li>
<li>提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。</li>
</ul>
<h2> 七、Mysql主要专业名称介绍</h2>
<h3> 1. 主键</h3>
<p><strong>1.1 什么是主键</strong><br>
“主键（PRIMARY KEY）”的完整称呼是“主键约束”。MySQL主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。</p>
<p><strong>1.2 选取设置主键约束的字段</strong><br>
主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：</p>
<ul>
<li>每个表只能定义一个主键。</li>
<li>主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。</li>
<li>一个列名只能在复合主键列表中出现一次。</li>
<li>复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。</li>
</ul>
<p><strong>1.3 创建主键</strong><br>
语法规则：&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]<br>
</p>
<h3> 2. 外键约束</h3>
<p><strong>2.1 什么是外键约束</strong><br>
  MySQL外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。</p>
<ul>
<li>外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。</li>
<li>外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。</li>
<li>外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。</li>
</ul>
<ul>
<li>主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。</li>
<li>从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。</li>
</ul>
<p><strong>2.2 选取设置 MySQL 外键约束的字段</strong><br>
定义一个外键时，需要遵守下列规则：<br>
（1）父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。<br>
（2）必须为父表定义主键。<br>
（3）主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。<br>
（4）在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。<br>
（5）外键中列的数目必须和父表的主键中列的数目相同。<br>
（6）外键中列的数据类型必须和父表主键中对应列的数据类型相同。</p>
<p><strong>2.3 在创建表时设置外键约束</strong><br>
在数据表中创建外键使用 FOREIGN KEY 关键字，具体的语法规则如下：<br>
[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]<br>
REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]</p>
<p>其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。</p>
<h3> 3. 唯一约束</h3>
<p>MySQL唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。</p>
<h3> 4. 默认值</h3>
<p><strong>4.1 什么是默认值</strong><br>
  “默认值（Default）”的完整称呼是“默认值约束（Default Constraint）”。MySQL默认值约束用来指定某列的默认值。<br>
  例如女性同学较多，性别就可以默认为“女”。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为“女”。</p>
<p><strong>4.2 在创建表时设置默认值约束</strong><br>
创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下：<br>
&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;<br>
</p>
<h3> 5. 非空约束</h3>
<p><strong>5.1 什么是非空约束</strong><br>
  MySQL非空约束（NOT NULL）可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。<br>
  非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。</p>
<p><strong>5.2 在创建表时设置非空约束</strong><br>
创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法规则如下：<br>
&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;<br>
</p>
<h3> 6. 触发器</h3>
<p>触发器（TRIGGER）是由事件来触发某个操作。这些事件包括INSERT语句、UPDATE语句和DELETE语句。当数据库系统执行这些事件时，会激活促发其执行相应的操作。</p>
<h3> 7. DML</h3>
<p>DML（data manipulation language）数据操纵语言：<br>
　　　　就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。</p>
<div class="language-csharp line-numbers-mode" data-ext="cs"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8. DDL</h3>
<p>DDL（data definition language）数据库定义语言：其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上</p>
<div class="language-undefined line-numbers-mode" data-ext="undefined"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9. DCL</h3>
<p>DCL（Data Control Language）数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。在公司呢一般情况下我们用到的是DDL、DML这两种。</p>
<h2> 八、Mysql常见sql语句</h2>
<h3> 1. select语句</h3>
<p>请在资料下载中进行学习</p>
<h3> 2. 函数</h3>
<p>请在资料下载中进行学习</p>
<h3> 3. 多表查询</h3>
<p>请在资料下载中进行学习</p>
<h3> 4. 表的内连与外连‘</h3>
<p>请在资料下载中进行学习’</p>
<h2> 九、Mysql设计与语句优化</h2>
<h3> 1. 数据库创建优化</h3>
<p>请在资料下载中进行学习</p>
<h3> 2. sql语句优化</h3>
<p>请在资料下载中进行学习</p>
<h2> 十、事务介绍</h2>
<h3> 1. 事务概述</h3>
<p>事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p>
<p>严格上来说，事务必须同时满足4个特性，即通常所说事务的ACID特性。虽然理论上定义了严格的事务要求，但是数据库厂商出于各种目的并没有严格满足事务的ACID标准。例如，对于MYSQL的NDB Cluster引擎，虽然支持事务，但是不满足D的要求，即持久性的要求。对于Oracle数据库来说，其默认的事务隔离级别为READ COMMITTED，不满足I的要求，即隔离性的要求。对于InnoDB存储引擎而言，默认的事务隔离级别是READ REPRATABLE，完全遵循和满足事务的ACID特性。</p>
<p>A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到事务前的状态。</p>
<p>C（consistency），一致性。一致性是指事务将数据库从一种状态转变为另一种状态。在事务的开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>
<p>I（isolation），隔离性。隔离性还有其他的称呼，如并发控制、可串行化、锁。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能互相分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。数据库系统中提供了一种粒度锁的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。（如果是全表锁，事务之间基本就无法实现并发，但是如果只锁住表中处理的行，可以提高事务的并发度）</p>
<p>D（durability），持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，持久性只能从事务本身的角度来保证结果的永久性，如事务提交后，所有的变化都是永久的，即使当数据库由于崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。</p>
<p>事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</p>
<h3> 2. 事务分类</h3>
<p>（1）扁平事务，最简单，使用最频繁的事务。在扁平事务中，所有的操作都处于一个层次，其有BEGIN WORK开始，有COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么全部执行，要么全部回滚。<br>
（2）带有保存点的扁平事务，除了扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能有些事务在执行过程中出现的错误并不会对有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。<br>
（3）链事务可视为保存点模式的一个变种。<br>
（4）嵌套事务是一个层次结构框架。<br>
（5）分布式事务</p>
<h3> 3. 事务控制语句</h3>
<p>在MYSQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行COMMIT操作。因此要显示的开启一个事务必须使用命令BEGIN和START TRANSACTION，或者执行命令SET AUTOCOMMIT = 0，以禁用当前会话的自动提交。事务控制语句如下：</p>
<ul>
<li>START TRANSACTION | BEGIN：显示的开启一个事务。在存储过程中，MYSQL数据库的分析器会自动将BEGIN识别为BEGIN...END，因此在存储过程中只能使用START TRANSACTION语句来开启一个事务。</li>
<li>COMMIT：要想使用这个语句的最简形式，只需发出COMMIT。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的。COMMIT和COMMIT WORK语句基本上是一致的，都是用来提交事务。不同的是COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE的。如果是CHAIN方式，那么事务就变成了链事务。用户可以通过参数completion_type来进行控制，默认该参数是0，表示没有任何操作。在这种设置下，COMMIT和COMMIT WORK是完全等价的。当参数值为1时，COMMIT WORK等价于COMMIT AND CHAIN，表示马上自动开启一个相同隔离级别的事务。当参数值为1时，COMMIT WORK等价于COMMIT AND RELEASE。当提交事务后会自动断开与服务器连接。</li>
<li>ROLLBACK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
<li>SAVEPOINT identifiter：SAVEPOINT允许用户在事务中创建一个保存点，一个事务可以有很多个保存点。</li>
<li>RELEASE SAVEPOINT identifier：删除一个事务的保存点，当没有一个保存点执行这语句时，会抛出一个异常。</li>
<li>ROLLBACK to [SAVEPOINT] identifier：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚到此标记点之前的任何工作。注意：虽然有ROLLBACK，但是它并没有真正的结束一个事务，因此即使执行了ROLLBACK TO SAVEPOINT，之后也需要显示的运行COMMIT或ROLLBACK命令。</li>
<li>SET TRANSACTION：这个语句用来设置事务的隔离级别。InnoDB存储引擎提供的事务隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。</li>
</ul>
<h3> 4. 事务的隔离级别</h3>
<p>ANSI SQL标准定义的四个隔离级别为：</p>
<ul>
<li>READ UNCOMMITTED（未提交读），事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。</li>
<li>READ COMMITTED（提交读），一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读，因为两次执行相同的查询，可能会得到不一样的结果。因为在这2次读之间可能有其他事务更改这个数据，每次读到的数据都是已经提交的。</li>
<li>REPEATABLE READ（可重复读），解决了脏读，也保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重读读隔离级别还是无法解决另外一个幻读的问题，指的是当某个事务在读取某个范围内的记录时，另外一个事务也在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，会产生幻行。</li>
<li>SERIALIZABLE（可串行化），它通过强制事务串行执行，避免了前面说的幻读的问题。<br>
1、脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</li>
</ul>
<p>2、不可重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</p>
<p>3、幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。</p>
<p>InnoDB采用MVCC来支持高并发，并实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影的插入。</p>
<p>隔离级别越低，事务请求的锁越少或保持锁的时间就越短。所以很多数据库系统默认的事务隔离级别是READ COMMITTED。质疑SERIALIZABLE隔离级别的性能，但是InnoDB存储引擎认为两者的开销是一样的，所以默认隔离级别使用REPEATABLE READ。</p>
<p>用命令设置当前会话或全局会话的事务隔离级别。</p>
<p>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL<br>
{<br>
READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE<br>
}<br>
如果想启动时就设置事务的默认隔离级别，修改MYSQL的配置文件，在[mysqld]中添加如下行：</p>
<p>[mysqld]<br>
transaction-isolation = READ-COMMITTED</p>
<h2> 十一、Mysql数据库备份与恢复</h2>
<h3> 1. 数据库备份</h3>
<p>数据库备份是指通过导出数据或者复制表文件的方式来制作数据库的副本。当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。</p>
<p>可以使用 SELECT INTO OUTFILE 语句把表数据导出到一个文本文件中进行备份。</p>
<blockquote>
<p>注意：这种方法只能导出或导入数据的内容，而不包括表的结构。若表的结构文件损坏，则必须先设法恢复原来表的结构。</p>
</blockquote>
<p>【实例】将数据库 test_db 的表 tb_students_info 的全部数据备份到 C 盘的数据备份目录下文件名为 file.txt 的文件中，要求每个字段用逗号分开，并且字符用双引号标注，每行以问号结束。</p>
<p>输入的SQL语句和执行结果如下所示。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用记事本查看 MySQL 备份文件夹下的 file.txt 文件，内容如下图所示。<br>
</p>
<h3> 2. MySQL数据库恢复</h3>
<p>数据库恢复是指以备份为基础，与备份相对应的系统维护和管理操作。</p>
<p>系统进行恢复操作时，先执行一些系统安全性的检查，包括检查所要恢复的数据库是否存在、数据库是否变化及数据库文件是否兼容等，然后根据所采用的数据库备份类型采取相应的恢复措施。</p>
<p>数据库恢复机制设计的两个关键问题是：第一，如何建立冗余数据；第二，如何利用这些冗余数据实施数据库恢复。</p>
<p>建立冗余数据最常用的技术是数据转储和登录日志文件。通常在一个数据库系统中，这两种方法是一起使用的。</p>
<p>数据转储是 DBA 定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的版本成为后备副本或后援副本。</p>
<p>可使用 LOAD DATA…INFILE 语句来恢复先前备份的数据。</p>
<p>【实例】将之前导出的数据备份文件 file.txt 导入数据库 test_db 的表 tb_students_copy 中，其中 tb_students_copy 的表结构和 tb_students_info 相同。</p>
<p>首先创建表 tb_students_copy，输入的 SQL 语句和执行结果如下所示：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>导入数据与查询表 tb_students_copy 的过程如下所示：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 十二、Mysql分库分表</h2>
<h3> 1. 分库分表原则</h3>
<p>关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像Web和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为Sharding、分片）。同时，流行的分布式系统中间件（例如MongoDB、ElasticSearch等）均自身友好支持Sharding，其原理和思想都是大同小异的。</p>
<ul>
<li>目前针对海量数据的优化，其分库分表是MySQL永远的话题，一般情况下认为MySQL是个简单的数据库，在数据量大到一定程度之后处理查询的效率降低，如果需要继续保持高性能运转的话，必须分库或者分表了。关于数据量达到多少大是个极限这个事儿，本文先不讨论，研究源码的同学已经证实MySQL或者Innodb内部的锁粒度太大的问题大大限制了MySQL提供QPS的能力或者处理大规模数据的能力。在这点上，一般的使用者只好坐等官方不断推出的优化版本了。</li>
<li>在一般运维的角度来看，我们什么情况下需要考虑分库分表？</li>
<li>首先说明，这里所说的分库分表是指把数据库数据的物理拆分到多个实例或者多台机器上去，而不是类似分区表的原地切分。</li>
</ul>
<p><strong>1.1 能不分就不分</strong><br>
  MySQL 是关系数据库，数据库表之间的关系从一定的角度上映射了业务逻辑。任何分库分表的行为都会在某种程度上提升业务逻辑的复杂度，数据库除了承载数据的存储和访问外，协助业务更好的实现需求和逻辑也是其重要工作之一。分库分表会带来数据的合并，查询或者更新条件的分离，事务的分离等等多种后果，业务实现的复杂程度往往会翻倍或者指数级上升。所以，在分库分表之前，不要为分而分，去做其他力所能及的事情吧，例如升级硬件，升级，升级网络，升级数据库版本，读写分离，负载均衡等等。所有分库分表的前提是，这些你已经尽力了。</p>
<p><strong>1.2 数据量太大，正常的运维影响正常业务访问</strong><br>
这里说的运维，例如：<br>
（1）对数据库的备份。如果单表或者单个实例太大，在做备份的时候需要大量的磁盘IO或者网络IO资源。例如1T的数据，网络传输占用50MB的时候，需要20000秒才能传输完毕，在此整个过程中的维护风险都是高于平时的。我们在Qunar的做法是给所有的数据库机器添加第二块网卡，用来做备份，或者SST，Group Communication等等各种内部的数据传输。1T的数据的备份，也会占用大量的磁盘IO，如果是SSD还好，当然这里忽略某些厂商的产品在集中IO的时候会出一些BUG的问题。如果是普通的物理磁盘，则在不限流的情况下去执行xtrabackup，该实例基本不可用。<br>
（2）对数据表的修改。如果某个表过大，对此表做DDL的时候，MySQL会锁住全表，这个时间可能很长，在这段时间业务不能访问此表，影响甚大。解决的办法有类似腾讯游戏DBA自己改造的可以在线秒改表，不过他们目前也只是能添加字段而已，对别的DDL还是无效；或者使用pt-online-schema-change，当然在使用过程中，它需要建立触发器和影子表，同时也需要很长很长的时间，在此操作过程中的所有时间，都可以看做是风险时间。把数据表切分，总量减小，有助于改善这种风险。<br>
（3）整个表热点，数据访问和更新频繁，经常有锁等待，你又没有能力去修改源码，降低锁的粒度，那么只会把其中的数据物理拆开，用空间换时间，变相降低访问压力。</p>
<p><strong>1.3 某些数据表出现了无穷增长</strong><br>
  例子很好举，各种的评论，消息，日志记录。这个增长不是跟人口成比例的，而是不可控的，例如微博的feed的广播，我发一条消息，会扩散给很多很多人。虽然主体可能只存一份，但不排除一些索引或者路由有这种存储需求。这个时候，增加存储，提升机器配置已经苍白无力了，水平切分是最佳实践。拆分的标准很多，按用户的，按时间的，按用途的，不在一一举例。</p>
<p><strong>1.4 安全性和可用性的考虑</strong><br>
  这个很容易理解，鸡蛋不要放在一个篮子里，我不希望我的数据库出问题，但我希望在出问题的时候不要影响到100%的用户，这个影响的比例越少越好，那么，水平切分可以解决这个问题，把用户，库存，订单等等本来同统一的资源切分掉，每个小的数据库实例承担一小部分业务，这样整体的可用性就会提升。这对Qunar这样的业务还是比较合适的，人与人之间，某些库存与库存之间，关联不太大，可以做一些这样的切分。</p>
<p><strong>1.5 业务耦合性考虑</strong><br>
  这个跟上面有点类似，主要是站在业务的层面上，我们的火车票业务和烤羊腿业务是完全无关的业务，虽然每个业务的数据量可能不太大，放在一个MySQL实例中完全没问题，但是很可能烤羊腿业务的DBA 或者开发人员水平很差，动不动给你出一些幺蛾子，直接把数据库搞挂。这个时候，火车票业务的人员虽然技术很优秀，工作也很努力，照样被老板打屁股。解决的办法很简单:惹不起，躲得起。</p>
<h3> 2. 分库分表方案</h3>
<p><strong>2.1 垂直拆分（垂直分表）</strong><br>
垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：<br>
</p>
<p><strong>2.2 垂直拆分（垂直分库）</strong><br>
垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：<br>
</p>
<p>小结：<br>
系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。<br>
众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。<br>
然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。<br>
优势：降低高并发情况下，对于表的锁定。<br>
不足：对于单表来说，随着数据库的记录增多，读写压力将进一步增大。</p>
<p><strong>2.3 水平拆分（水平分表）</strong><br>
水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：<br>
</p>
<p>如果单表的IO压力大，可以考虑用水平分割，其原理就是通过hash算法，将一张表分为N多页，并通过一个新的表（总表），记录着每个页的的位置。假如一个门户网站，它的数据库表已经达到了1000万条记录，那么此时如果通过select去查询，必定会效率低下（不做索引的前提下）。为了降低单表的读写IO压力，通过水平分割，将这个表分成10个页，同时生成一个总表，记录各个页的信息，那么假如我查询一条id=100的记录，它不再需要全表扫描，而是通过总表找到该记录在哪个对应的页上，然后再去相应的页做检索，这样就降低了IO压力。</p>
<p>当下分表有静态分表和动态分表两种：</p>
<ul>
<li>静态分表：事先估算出表能达到的量，然后根据每一个表需要存多少数据直接算出需要创建表的数量。如：1亿数据每一个表100W条数据那就要建100张表，然后通过一定的hash算法计算每一条数据存放在那张表。其实就有点像是使用partition table一样。静态分表有一个毙命就是当分的那么多表还不满足时，需要再扩展难度和成本就会很高。</li>
<li>动态分表：同样也是对大数据量的表进行拆分，他可以避免静态分表带来的后遗症。当然也需要在设计上多一些东西（这往往是我们能接受的）。<br>
某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）</li>
</ul>
<h3> 3. 分库分表难点</h3>
<p><strong>3.1 跨库join的问题</strong><br>
在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。<br>
跨库Join的几种解决思路：</p>
<ul>
<li>全局表
<ul>
<li>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</li>
</ul>
</li>
<li>字段冗余
<ul>
<li>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。</li>
<li>举个电商业务中很简单的场景：</li>
<li>“订单表”中保存“卖家Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。</li>
<li>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了Name之后，是否需要在订单信息中同步更新呢？</li>
</ul>
</li>
<li>数据同步
<ul>
<li>定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过ETL工具来实施的。</li>
</ul>
</li>
<li>系统层组装
<ul>
<li>在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。具体情况通常会比较复杂。</li>
</ul>
</li>
</ul>
<p><strong>3.2 跨库事务（分布式事务）的问题</strong><br>
按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。想要了解分布式事务，就需要了解“XA接口”和“两阶段提交”。值得提到的是，MySQL5.5x和5.6x中的xa支持是存在问题的，会导致主从数据不一致。直到5.7x版本中才得到修复。Java应用程序可以采用Atomikos框架来实现XA事务（J2EE中JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》</p>
<p>根据系统架构和公司实际情况来，如果你们的系统还是个简单的单体应用，并且没有什么访问量和数据量，那就别着急折腾“垂直分库”了，否则没有任何收益，也很难有好结果。<br>
切记，“过度设计”和“过早优化”是很多架构师和技术人员常犯的毛病。</p>
<h2> 十三、Mysql权限管理</h2>
<h3> 1. MySQL权限简介</h3>
<p>关于mysql的权限简单的理解就是mysql允许你做你全力以内的事情，不可以越界。比如只允许你执行select操作，那么你就不能执行update操作。只允许你从某台机器上连接mysql，那么你就不能从除那台机器以外的其他机器连接mysql。<br>
  那么Mysql的权限是如何实现的呢？这就要说到mysql的两阶段验证，下面详细介绍：第一阶段：服务器首先会检查你是否允许连接。因为创建用户的时候会加上主机限制，可以限制成本地、某个IP、某个IP段、以及任何地方等，只允许你从配置的指定地方登陆。第二阶段：如果你能连接，Mysql会检查你发出的每个请求，看你是否有足够的权限实施它。比如你要更新某个表、或者查询某个表，Mysql会查看你对哪个表或者某个列是否有权限。再比如，你要运行某个存储过程，Mysql会检查你对存储过程是否有执行权限等。</p>
<h3> 2. Mysql权限种类</h3>
<figure><figcaption>img_68.png</figcaption></figure>
<figure><figcaption>img_69.png</figcaption></figure>
<figure><figcaption>img_71.png</figcaption></figure>
<figure><figcaption>img_70.png</figcaption></figure>
<h3> 3. MySQL权限经验原则</h3>
<p>权限控制主要是出于安全因素，因此需要遵循一下几个经验原则：<br>
（1）只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。<br>
（2）创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。<br>
（3）初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码。<br>
（4）为每个用户设置满足密码复杂度的密码。<br>
（5）定期清理不需要的用户。回收权限或者删除用户。</p>
<h2> 十四、Mysql数据库之阿里云</h2>
<h3> 1. 简介</h3>
<p>经过上面的学习，大家已经对mysql数据库的知识有了很深的了解，我们也知道，一个数据库在实际生产环境中，会面临许多的问题，比如Sql语句审计、sql读写分离、sql备份与恢复、数据库的权限管理、数据库的高可用等等，对于创业公司来讲，数据库是非常重要的，但是花费了很多人力物力去满足这个事情，那么还不如直接使用成熟的第三方平台，比如阿里云的mysql数据库产品。</p>
<h3> 2. 阿里云数据库产品功能</h3>
<p><strong>2.1 数据库创建</strong><br>
</p>
<p><strong>2.2 连接管理与读写分离</strong><br>
</p>
<figure><figcaption>img_74.png</figcaption></figure>
<p><strong>2.3 监控与报警</strong></p>
<p>我们可以在线监控到CPU、内存、磁盘、IOPS、网络流量等的使用情况，并设置报警规则<br>
</p>
<p><strong>2.4 白名单</strong></p>
<p>我们可以设置允许连接数据库的IP白名单，以保障数据库连接安全<br>
</p>
<p><strong>2.5 服务可用性</strong><br>
阿里云的数据库可包含高可用，主备切换、主从备份等<br>
</p>
<p><strong>2.6 日志管理</strong><br>
日志管理包括订阅同步、错误日志、慢日志分析、主备切换日志<br>
</p>
<p><strong>2.7 SQL洞察</strong><br>
对sql语句的操作进行记录，包括操作的数据库名、数据库语句、操作时间、客户端IP等信息<br>
</p>
<p><strong>2.8 性能优化</strong><br>
阿里云提供诊断报告、资源分析、SQL分析等服务<br>
</p>
<p><strong>2.9 备份恢复</strong><br>
</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-16T01:53:26.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Redis</title>
    <id>https://ujava.cn/assembly/redis.html</id>
    <link href="https://ujava.cn/assembly/redis.html"/>
    <updated>2024-04-17T03:53:01.000Z</updated>
    <summary type="html"><![CDATA[<p>NoSQL:即Not-OnlySQL(泛指非关系型的数据库)，作为关系型数据库的补充。<br>
作用:应对基于海量用户和海量数据前提下的数据处理问题。</p>
<h2> Redis介绍</h2>
<h4> 概念</h4>
<p>Redis(REmote DlctionaryServer)是用C语言开发的一个开源的高性能键值对(key-value)数据库</p>
<h4> 特征</h4>
<p>1.数据间没有必然的关联关系</p>
<p>2.内部采用单线程机制进行工作</p>
<p>3.高性能</p>
<p>4.支持多种数据类型</p>
<p>5.支持持久化，可以存硬盘。</p>
<h4> 应用</h4>]]></summary>
    <content type="html"><![CDATA[<p>NoSQL:即Not-OnlySQL(泛指非关系型的数据库)，作为关系型数据库的补充。<br>
作用:应对基于海量用户和海量数据前提下的数据处理问题。</p>
<h2> Redis介绍</h2>
<h4> 概念</h4>
<p>Redis(REmote DlctionaryServer)是用C语言开发的一个开源的高性能键值对(key-value)数据库</p>
<h4> 特征</h4>
<p>1.数据间没有必然的关联关系</p>
<p>2.内部采用单线程机制进行工作</p>
<p>3.高性能</p>
<p>4.支持多种数据类型</p>
<p>5.支持持久化，可以存硬盘。</p>
<h4> 应用</h4>
<p>热点信息，时效性信息，分布式数据共享，消息队列，即使信息查询。</p>
<h3> 在虚拟机上启动redis服务</h3>
<p>通过指定的配置文件启动redis服务，</p>
<ol>
<li>查看进程：ps -ef | grep redis</li>
<li>进入配置文件的目录cd /usr/local/redis/bin/</li>
<li>输入 ./redis-server redis.conf</li>
<li>输入 ./redis-cli</li>
<li>关闭服务并退出：shutdown 然后：exit</li>
</ol>
<h3> 键值对</h3>
<p>设置键值对</p>
<p>​ 语法：set key value</p>
<p>获取键值对</p>
<p>​ 语法：get key</p>
<p>判断键是否存在：exist key</p>
<p><strong>设置过期时间</strong>： expire key 时间</p>
<p>查看过期时间： ttl key</p>
<p>查看当前key的数据类型：&gt; type key</p>
<p>删除key：del key</p>
<h3> 库</h3>
<p>redis共有16个库</p>
<h4> 选择数据库</h4>
<p>语法：select 数字</p>
<h4> 查看</h4>
<p>查看大小：dbsize</p>
<p>查看数据库所有的键：keys *</p>
<h4> 清空</h4>
<p>清空当前数据库：flushdb</p>
<p>清空所有：flushall</p>
<h3> 基本数据类型</h3>
<h4> String</h4>
<p>追加字符串，不存在则新建：append key1 "hello"</p>
<p>获取字符串长度：strlen key1</p>
<p>初始浏览量为0 ：set views 0</p>
<p>设置自增1：incr views</p>
<p>设置自减1：decr views</p>
<p>可以设置步长。每次的增长值 : INCRBY views 10 #</p>
<p>获取指定范围的值: GETRANGE key 起始点 结束点</p>
<p>获取所有长度的值: GETRANGE key 0 -1</p>
<p>设置多个值:</p>
<p>mset key value key value ……</p>
<p>mget key key key</p>
<p>msetnx 原子性操作设置多个值</p>
<p><strong>设置过期时间和值:</strong></p>
<p>设置key3 的值为 he11o,30秒后过期: setex key3 30 "he1lo"</p>
<p>先get然后在set: getset</p>
<h2> List</h2>
<p>LPuSH key value</p>
<p>LPUSH list one #将一个值或者多个值，插入到列表头部(左)</p>
<p>RPUSH key value</p>
<p>Rpush list righr #将一个值或者多个值，插入到列表位部(右)</p>
<p>lrange key start end</p>
<p>LRANGE list 0 1 #通过区间获取具体的值!</p>
<p>LROR key #移出并获取列表的第一个元素</p>
<p>lindex list 1 #通过下标获得list 中的某一个值!</p>
<p>Llen list # 返回列表的长度</p>
<p>lrem key count value</p>
<p>lrem list 1 one # 移除list集合中指定个数的value，精确匹配</p>
<p>ltrim list 1 2 #截取指定的长度!</p>
<p>lset 将列表中指定下标的值替换为另外一个值，更新操作</p>
<p>lset list 0 item #如果存在，更新当前下标的值</p>
<p>在指定元素前后插入指定的值</p>
<p>LINSERT mylist after world new</p>
<h2> set</h2>
<p>set集合中添加</p>
<p>sadd key value</p>
<p>sadd myset "hello"</p>
<p>查看指定set的所有值</p>
<p>smembers key</p>
<p>SMEMBERS myset</p>
<p>判断某一个值是不是在set集合中!</p>
<p>sismember key value</p>
<p>SISMEMBER myset hello</p>
<p>查看个数</p>
<p>scard key</p>
<p>scard myset</p>
<p>移除set集合中的指定元素</p>
<p>srem key value</p>
<p>srem myset hello</p>
<p>获取随机</p>
<p>SRANDMEMBER myset</p>
<p>SRANDMEMBER myset 2</p>
<p>smove myset myset2 "kuangshen"# 将一个指定的值，移动到另外一个set集合!</p>
<p>SDIFF key1 key2 差集</p>
<p>SINTER key1 key2 交集</p>
<p>SUNION key1 key2 并集</p>
<h2> hash</h2>
<p>hset 集合名 key value</p>
<p>hset myhash field1 hello</p>
<h1> set一个具体key-vlaue</h1>
<p>获取一个字段值</p>
<p>hget 集合名 key键</p>
<p>hget myhash field1</p>
<p>添加多个 key-vlaue</p>
<p>hmset 集合 key键1 key键2</p>
<p>hmset myhash field1 hello field2 world</p>
<p>获取多个字段值</p>
<p>hmget 集合名 key1 key2</p>
<p>hmget myhash field1 field2</p>
<p>获取全部的数据</p>
<p>hget 集合名</p>
<p>hgetall myhash</p>
<p>删除hash指定key字段!对应的value值也就消失了!</p>
<p>hdel 集合名 key</p>
<p>hdel myhash field1</p>
<p>判断hash中指定字段是否存在!</p>
<p>HEXISTS myhash field1</p>
<p>只获得所有field</p>
<p>hkeys 集合名</p>
<p>hkeys myhash</p>
<p>只获得所有value</p>
<p>hvals 集合名</p>
<p>hvals myhash</p>
<p>设置自动增长</p>
<p>HINCRBY myhash field3 1</p>
<p>HINCRBY myhash field3 -1</p>
<p>如果不存在则可以设置</p>
<p>hsetnx myhash field4 hello</p>
<p>如果存在则不能设置</p>
<p>hsetnx myhash field4 world</p>
<h2> zset</h2>
<p>zset在set的基础上增加了一个值，set k1 v1 zset k1 score1 v1</p>
<p>添加一个值</p>
<p>zadd key score value</p>
<p>zadd myset 1 one</p>
<p>添加多个值</p>
<p>zadd myset 2 two 3 three</p>
<p>获取范围值</p>
<p>zrange key start end</p>
<p>zrange myset 0 -1</p>
<p>显示全部内容从小到大</p>
<p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>
<p>移除元素</p>
<p>zrem key value</p>
<hr>
<h2> 特殊数据类型</h2>
<h3> 地理位置geostital</h3>
<p>创建一个元素</p>
<p>geoadd key 纬度 经度 成员</p>
<p>geoadd city 116.40 39.90 beijing</p>
<p>获取坐标</p>
<p>geopos city beijing</p>
<p>获取两者之间的距离</p>
<p>geodist key value1 value2 单位</p>
<p>geodist city beijing shanghai km</p>
<p>相关范围内的城市</p>
<p>georadius key 纬度 经度 距离 单位 withdist</p>
<p>找出指定位置内的其他元素</p>
<p>georadiusbymember key value 距离 单位</p>
<h3> bitmaps</h3>
<p>位存储</p>
<p>统计用户信息，活跃，不活跃!登录、未登录!打卡，365打卡!两个状态的，都可以使用Bitmaps!</p>
<p>Bitmaps位图，数据结构!都是操作二进制位来进行记录，就只有0和1两个状态!</p>
<p>365天=365 bit 1字节=8bit46个字节左右!</p>
<p>设置一个元素</p>
<p>setbit key offset value</p>
<p>查看</p>
<p>getbit sign offset</p>
<hr>
<h2> 事务</h2>
<p>Redis 事务本质:一组命令的集合!一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行! 一次性、顺序性、排他性!执行一系列的命令!</p>
<p>Redis命令保证原子性，但是事务不保证原子性！</p>
<p>redis事务：</p>
<p>1 开启事务：开启一个事务</p>
<blockquote>
<p>multi</p>
</blockquote>
<p>2 命令入队：将命令放入事务</p>
<blockquote>
<p>set key value</p>
</blockquote>
<p>3 执行事务：执行事务中的命令</p>
<blockquote>
<p>exec</p>
</blockquote>
<p>4 取消事务:事务中的命令都不会被执行</p>
<blockquote>
<p>discard</p>
</blockquote>
<p>eg：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在入队的命令中有错误的命令，</p>
<p>如果是编译时异常，那么所有命令都不会被执行。</p>
<p>如果是运行时异常，那么其他命令正常执行，仅有错误的命令抛出错误信息。</p>
<hr>
<h2> 锁</h2>
<h4> 悲观锁</h4>
<p>很悲观，什么时候都要加锁。</p>
<h4> 乐观锁</h4>
<p>很乐观，认为什么时候都不会出问题，所以不会上锁!更新数据的时候去判断一下，在此期间是否有人修改过这个数据，<br>
获取version<br>
更新的时候比较version</p>
<p>使用watch命令当作redis的乐观锁操作</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>unwatch</p>
</blockquote>
<p>如果发现事务执行失败，就先解锁</p>
<hr>
<h2> jedis</h2>
<p>Jedis是redis的java版本的客户端实现，使用Jedis提供的Java API对Redis进行操作，是Redis官方推崇的方式；并且，使用Jedis提供的对Redis的支持也最为灵活、全面；不足之处，就是编码复杂度较高。</p>
<h4> 导入依赖</h4>
<figure><figcaption>img_84.png</figcaption></figure>
<h4> 简单语法：</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> SpringBoot整合</h2>
<figure><figcaption>img_83.png</figcaption></figure>
<p><strong>修改配置文件：</strong></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>测试：</strong></p>
<p>redisTemplate 操作不同的数据类型，api和我们的指令是一样的<br>
opsForValue 操作字符串 类似String<br>
opsForList 操作List 类似List<br>
opsForSet<br>
opsForHash<br>
opsForzset<br>
opsForGeo<br>
opsForHyperLogLog</p>
<p>除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD</p>
<h4> 获取redis的连接对象</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 配置自己的序列化方式</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> Redis配置文件</h2>
<p>redis里的单位配置，忽略大小写。</p>
<blockquote>
<p><strong>导入其他配置文件：</strong></p>
</blockquote>
<h1> include /path/to/local.conf</h1>
<h1> include /path/to/other.conf</h1>
<blockquote>
<p>网络</p>
</blockquote>
<p>bind 127.0.0.1 #绑定的ip</p>
<p>protected-mode yes #保护模式<br>
port 6379 #端口设置</p>
<blockquote>
<p>通用 general</p>
</blockquote>
<p>daemonize yes #以守护进程的方式运行，默认是no，我们需要自己开启为yes!</p>
<p>pidfile /var/run/redis_6379.pid #如果以后台的方式运行，我们就需要指定一个pid 文件!</p>
<p>#日志</p>
<p>#specify the server verbosity level.</p>
<p>#This can be one of:</p>
<p>#debug (a lot of information, useful for development/testing)</p>
<p>#verbose (many rarely useful info, but not a mess like the debug level)</p>
<p>#notice (moderately verbose, what you want in production probably) #生产环境</p>
<p>#warning (only very important / critical messages are 1ogged)</p>
<p>loglevel notice</p>
<p>logfile,"" #日志的文件位置名</p>
<p>databases 16 #数据库的数量，默认是16个数据库</p>
<p>always-show-logo yes #是否总是显示LOGO</p>
<h2> 持久化</h2>
<p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件.rdb.aof<br>
redis是内存数据库，如果没有持久化，那么数据断电及失!</p>
<blockquote>
<p>RDB配置：</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p><strong>设置密码</strong></p>
</blockquote>
<p>获取当前的密码：config get requirepass</p>
<p>设置redis的密码：config set requirepass "123456"</p>
<p>使用密码进行登录: auth 123456</p>
<blockquote>
<p>客户端</p>
</blockquote>
<p>设置能连接上redis的最大客户端的数量 : maxclients 10000</p>
<p>redis 配置最大的内存容量: maxmemory (bytes)</p>
<p>maxmemory-policy noeviction #内存到达上限之后的处理策略</p>
<p>1、volatile-lru:只对设置了过期时间的key进行LRU(默认值)<br>
2、al1keys-lru:删除1ru算法的key<br>
3、volatile-random:随机删除即将过期key<br>
4、a11keys-random:随机删除<br>
5、volatile-ttl:删除即将过期的<br>
6、noeviction :永不过期，返回错误</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<p>1、save的规则满足的情况下，会自动触发rdb规则<br>
2、执行 flushall命令，也会触发我们的rdb规则!<br>
3、退出redis，也会产生rdb文件!<br>
备份就自动生成一个dump</p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<p>1、只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的内容<br>
2、查看需要存在的位置</p>
<p>config get dir</p>
<p>1)"dir"<br>
2)"/usr/local/bin" # 如果在这个目录下存在dump.rdb 文件，启动就会自动恢复其中的数据</p>
<p>优点:<br>
1、适合大规模的数据恢复!<br>
2、对数据的完整性要不高!<br>
缺点:<br>
1、需要一定的时间间隔进程操作!如果redis意外宕机了，这个最后一次修改数据就没有的了<br>
2、fork进程的时候，会占用一定的内容空间!!</p>
<blockquote>
<p>AOF配置</p>
</blockquote>
<p>appendonly no #默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，rdb完全够用!</p>
<p>appendfilename "appendonly.aof" #持久化的文件的名字</p>
<p>appendfsync always #每次修改都会 sync。消耗性能<br>
appendfsync everysec #每秒执行一次sync，可能会丢失这1s的数据!</p>
<p>appendfsync no #不执行 sync，这个时候操作系统自己同步数据，速度最快!</p>
<blockquote>
<p>搜索配置文件内容：</p>
</blockquote>
<p>vim 文件</p>
<p>:/搜索内容 n下一个</p>
<p>如果这个 aof 文件有错误，这时候redis 是启动不起来的吗，我们需要修复这个aof文件redis 给我们提供了一个工具 redis-check-aof --fix</p>
<h3> 消息订阅</h3>
<p>关注消息后，消息发出者可以发出订阅者都收到的消息。</p>
<blockquote>
<p>发送端：</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>接收端</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> redis主从复制</h2>
<p>主从复制，读写分离!80%的情况下都是在进行读操作!减缓服务器的压力!架构中经常使用!一主二从!</p>
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower);数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave以读为主。</p>
<p>注意：只配从库不配主库</p>
<p>查看当前库的信息： info replication</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以测试：</p>
<p>复制3个配置文件，然后修改对应的信息<br>
1、端口<br>
2、pid 名字<br>
3、log文件名字<br>
4、dump.rdb 名字</p>
<p>默认情况下，每台Redis服务器都是主节点</p>
<p>配置从节点，认老大：</p>
<blockquote>
<p>Slaveof host port</p>
</blockquote>
<p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的!</p>
<p>主机负责写，从机负责读</p>
<p>Slave 启动成功连接到master后会发送一个sync同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送</p>
<p>整个数据文件到slave，并完成一次完全同步。</p>
<p>全量复制:而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p>增量复制:Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步(全量复制)将被自动执行</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-16T01:53:26.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Spring</title>
    <id>https://ujava.cn/assembly/spring.html</id>
    <link href="https://ujava.cn/assembly/spring.html"/>
    <updated>2024-04-16T01:53:26.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-16T01:53:26.000Z</published>
  </entry>
  <entry>
    <title type="text">组件ZooKeeper</title>
    <id>https://ujava.cn/assembly/zookeeper.html</id>
    <link href="https://ujava.cn/assembly/zookeeper.html"/>
    <updated>2024-04-16T01:53:26.000Z</updated>
    <category term="设计组件"/>
    <published>2024-04-16T01:53:26.000Z</published>
  </entry>
  <entry>
    <title type="text">MySQL慢查询</title>
    <id>https://ujava.cn/synthesis/mysqlslow.html</id>
    <link href="https://ujava.cn/synthesis/mysqlslow.html"/>
    <updated>2024-04-15T11:10:22.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>MySQL服务器处理查询请求的整个过程：</p>
<ul>
<li>客户端发送SQL强求给服务器</li>
<li>服务器检查是否可以在查询缓存中命中该SQL</li>
<li>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>根据执行计划，调用存储引擎API来查询数据</li>
<li>将结果返回给客户端<br>
查询性能低下最基本的原因是访问的数据太多。</li>
</ul>
<h2> 一、如何优化慢查询？</h2>
<p>1，首先开启慢查询日志：</p>
<ul>
<li>long_query_time（多长时间视为慢查询）</li>
<li>slow_query_log（是否开启了慢查询日志，off表示未开启）</li>
<li>slow_query_log_file（慢查询日志存放的位置）</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>MySQL服务器处理查询请求的整个过程：</p>
<ul>
<li>客户端发送SQL强求给服务器</li>
<li>服务器检查是否可以在查询缓存中命中该SQL</li>
<li>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划</li>
<li>根据执行计划，调用存储引擎API来查询数据</li>
<li>将结果返回给客户端<br>
查询性能低下最基本的原因是访问的数据太多。</li>
</ul>
<h2> 一、如何优化慢查询？</h2>
<p>1，首先开启慢查询日志：</p>
<ul>
<li>long_query_time（多长时间视为慢查询）</li>
<li>slow_query_log（是否开启了慢查询日志，off表示未开启）</li>
<li>slow_query_log_file（慢查询日志存放的位置）</li>
</ul>
<p>2.慢查询优化思路：<br>
</p>
<figure><figcaption>img_140.png</figcaption></figure>
<figure><figcaption>img_141.png</figcaption></figure>
<figure><figcaption>img_142.png</figcaption></figure>
<p>3，分析慢查询语句，来进行相应的优化</p>
<ul>
<li>①建立索引</li>
<li>②减少表之间的关联</li>
<li>③优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引，把数据量大的表排在前面</li>
<li>④简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>
</ul>
<h2> 二、数据库优化的方法：</h2>
<p>1，SQL语句优化：</p>
<ul>
<li>①应该尽量避免在where子句中使用！=或者&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li>
<li>②应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用而进行全表扫描</li>
<li>③很多时候，用exits代替in是一个很好的选择</li>
<li>④用where子句替代having子句，因为having只会在检索出所有记录之后才对结果集进行过滤</li>
</ul>
<p>2，索引优化：</p>
<ul>
<li>①为经常出现在关键字order by，group by，distinct后面的字段，建立索引</li>
<li>②为经常用作where查询选择的字段，建立索引</li>
<li>③在经常用作表连接的属性上建立索引</li>
<li>④更新非常频繁的字段不适合建立索引</li>
</ul>
<p>3，数据库结构优化：</p>
<ul>
<li>①范式优化（如消除冗余，节省空间）</li>
<li>②反范式化优化（适当增加冗余）</li>
<li>③拆分表（不同分区的数据可以指定保存在处于不同磁盘上的数据文件里）</li>
<li>④拆分又分为垂直拆分和水平拆分</li>
</ul>
<p>4，服务器硬件优化（对花钱）</p>
<h2> 三、MySQL查询优化（0其实这个概念比较偏小，上一道题的概念比较偏大）：</h2>
<ul>
<li>应该尽量避免全表扫描，首先应考虑哎where及order by涉及的列上建索引</li>
<li>尽量避免在where子句中对字段进行null值判断</li>
<li>尽量避免在where子句中使用or来连接条件</li>
<li>尽量避免在where子句中使用！=或&lt;&gt;操作符</li>
<li>in和not in也要慎用</li>
<li>%aa%应尽量避免</li>
<li>尽量避免在where子句中对字段进行表达式操作</li>
<li>在where子句中使用参数慎用</li>
<li>尽量避免在where子句中进行函数操作</li>
<li>不要在where子句中的“=”左边进行函数算术运算或其他表达式运算</li>
<li>若使用复合索引，则必须使用到该索引中的第一个字段作为条件时才能保证系统使用索引</li>
<li>不要写无意义的查询，select…from…where 0=1</li>
<li>用exists代替in是一个很好的选择</li>
<li>建立索引时要慎重（并不是越多越好）</li>
<li>应尽量避免更新cluster（索引数据列）</li>
<li>尽量使用数字型字段（尽量不要设计为字符型）</li>
<li>尽量使用varchar/nvaechar代替char/nchar，因为变长字段存储空间小</li>
<li>尽量避免select * from t</li>
<li>尽量使用表变量来代替临时表</li>
</ul>
<h2> 四、为什么Like以%开头索引会失效 ？</h2>
<p>like失效的原因：</p>
<ul>
<li>%在右：由于B+树的索引顺序，是按照首字母的大小进行排序，%号在右的匹配又是匹配首字母，所以可以在B+树上进行有序的查找，查找首字母符合要求的数据。</li>
<li>%在左：是匹配字符串尾部的数据，我们上面说了排序规则，尾部的字母是没有顺序的，所以不能按照索引顺序查询，就用不到索引。</li>
<li>两个%号：这个查询任意位置的字母满足条件即可，只有首字母是进行索引排序的，其他位置的字母都是相对无序的，所以查找任意位置的字母是用不上索引的。</li>
</ul>
<p>解决%出现在左边索引失效的方法，使用覆盖索引。</p>
<h2> 五、select * 为什么禁止使用？</h2>
<p>为了说明这个问题，我们需要建一个表:</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们创建了一个存储引擎为InnoDB的表user_innodb，并设置id为主键，另外为name和phone创建了联合索引，最后向表中随机初始化了500W+条数据。</p>
<p>InnoDB会自动为主键id创建一棵名为主键索引（又叫做聚簇索引）的B+树，这个B+树的最重要的特点就是叶子节点包含了完整的用户记录，大概长这个样子：</p>
<figure><figcaption>img_143.png</figcaption></figure>
<p>如果我们执行这个语句：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用EXPLAIN查看一下语句的执行计划：</p>
<figure><figcaption>img_144.png</figcaption></figure>
<p>发现这个SQL语句会使用到IDX_NAME_PHONE索引，这是一个二级索引。二级索引的叶子节点长这个样子：</p>
<figure><figcaption>img_145.png</figcaption></figure>
<p>InnoDB存储引擎会根据搜索条件在该二级索引的叶子节点中找到name为蝉沐风的记录，但是二级索引中只记录了name、phone和主键id字段（谁让我们用的是SELECT *呢），因此InnoDB需要拿着主键id去主键索引中查找这一条完整的记录，这个过程叫做回表。</p>
<p>想一下，如果二级索引的叶子节点上有我们想要的所有数据，是不是就不需要回表了呢？是的，这就是覆盖索引。</p>
<p>举个例子，我们恰好只想搜索name、phone以及主键字段。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用EXPLAIN查看一下语句的执行计划：</p>
<figure><figcaption>img_146.png</figcaption></figure>
<p>可以看到Extra一列显示Using index，表示我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是使用了覆盖索引，能够直接摒弃回表操作，大幅度提高查询效率。</p>
<p>小总结及问题：</p>
<p>1.select * from 表 where name = “蝉沐风” 与 select id,name,gender,phone from 表 where name = “蝉沐风” 效率一样吗？</p>
<p>答：一样；因为只是在name和phone建立了联合索引，根据上面的分析，<br>
可以看到二级索引中的树的情况，叶子节点中只有name、phone、id ;<br>
但是叶子节点中没有gender这个字段 ，<br>
想要获得这个gender字段，必须根据二级索引得到id，<br>
然后根据id去查主键索引得到id，name、gender、phone等所有字段。<br>
select * 也是类似的。所以两个的效率是一样的。</p>
]]></content>
    <category term="设计综合"/>
    <published>2024-04-15T11:10:22.000Z</published>
  </entry>
  <entry>
    <title type="text">设计原则</title>
    <id>https://ujava.cn/base/theory.html</id>
    <link href="https://ujava.cn/base/theory.html"/>
    <updated>2024-04-15T07:18:48.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、单一职责原则</h2>
<p>单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。</p>
<p>单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。</p>
<p>单一职责原则的好处：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 一、单一职责原则</h2>
<p>单一职责原则：英文名称是Single Responsiblity Principle，简称是SRP。定义：应该有且仅有一个原因引起类的变更。</p>
<p>单一职责原则要求：一个接口或类只有一个原因引起变化，也就是一个接口或类只有一个职责，它就负责一件事情。</p>
<p>单一职责原则的好处：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li>
<li>可读性提高，复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高，可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<p>注意： 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p>
<p>对于单一职责原则，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。</p>
<h2> 二、里氏替换原则</h2>
<p>里氏替换原则（Liskov Substitution Principle，LSP），有两种定义：</p>
<ul>
<li>
<p>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P<br>
defined in terms of T ,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）</p>
</li>
<li>
<p>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes<br>
without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）</p>
</li>
<li>
<p>第二个定义是最清晰明确的，通俗点讲，只要父类出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道父类还是子类。但是反过来就不行了，有子类出现的地方，父类未必就能适应。</p>
</li>
</ul>
<p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义：</p>
<ul>
<li>子类必须完全实现父类的方法；
<ul>
<li>在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则；</li>
<li>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</li>
</ul>
</li>
<li>子类可以有自己的个性；</li>
<li>覆盖或实现父类的方法时输入参数可以被放大；
<ul>
<li>如果父类的输入参数类型大于子类的输入参数类型，会出现父类存在的地方，子类未必会存在，因为一旦把子类作为参数传入，调用者很可能进入子类的方法范畴；</li>
<li>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。</li>
</ul>
</li>
<li>覆写或实现父类的方法时输出结果可以被缩小。
<ul>
<li>父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类。</li>
</ul>
</li>
</ul>
<p>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续执行。</p>
<h2> 三、依赖倒置原则</h2>
<p>依赖倒置原则（Dependence Inversion Principle,DIP）,原始定义是：High level modules should not depend upon low level<br>
modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon<br>
abstractions.</p>
<p>包含三层含义：</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象。 高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是底层模块，原子逻辑的再组装就是高层模块。</li>
</ul>
<p>在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。依赖倒置原则在Java语言中的表现就是：</p>
<p>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p>
<p>接口或抽象类不依赖于实现类；</p>
<p>实现类依赖接口或抽象类。 更加精简的定义就是“面向接口编程”--OOD（Object-Oriented Design，面向对象设计）的精髓之一。</p>
<p>依赖的三种写法：</p>
<p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D。。。。。。生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p>
<p>对象的依赖关系有三种方式来传递：</p>
<ul>
<li>
<p>构造函数传递依赖对象 --- 在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。</p>
</li>
<li>
<p>Setter方法传递依赖对象 --- 在抽象中设置Setter方法声明依赖关系，依照注入的说法，这是Setter依赖注入。</p>
</li>
<li>
<p>在接口的方法中声明依赖对象，这种方式也叫做接口注入。<br>
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的规则就可以：</p>
</li>
<li>
<p>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备； --- 这是依赖倒置的基本要求，接口或抽象类都是属于抽象的，有了抽象才可能依赖倒置。</p>
</li>
<li>
<p>变量的表面类型尽量是接口或者是抽象类；</p>
</li>
<li>
<p>任何类都不应该从具体类派生；</p>
</li>
<li>
<p>尽量不要覆写基类的方法； --- 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。</p>
</li>
<li>
<p>结合里氏替换原则使用。 --- 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</p>
</li>
</ul>
<h2> 四、接口隔离原则</h2>
<p>接口分为两种：</p>
<ul>
<li>
<p>实例接口（Object Interface），在Java中声明一个类，然后用new关键字产生一个实例，它是对一个类型的食物的描述，这是一种接口。</p>
</li>
<li>
<p>类接口（Class Interface），Java中经常使用的interface关键字定义的接口；</p>
</li>
<li>
<p>Clients should not be forced to depend upon interfaces that they don‘t use。（客户端不应该依赖它不需要的接口。）</p>
</li>
<li>
<p>The dependency of one class to another one should depend on the smallest possible interface。（类间的依赖关系应该建立在最小的接口上。）<br>
接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p>
</li>
<li>
<p>接口要尽量小； --- 这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。</p>
</li>
<li>
<p>接口要高内聚； --- 高内聚就是提高接口、类、模块的处理能力，减少对外的交互。在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也越有利于降低成本。</p>
</li>
<li>
<p>定制服务； ---  一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或单纯的数据交换），我们设计时就需要为各个访问者（即客户端）定制服务。定制服务就是单独为一个个体提供优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务。采用定制服务就必然有一个要求：只提供访问者需要的方法。</p>
</li>
<li>
<p>接口设计是有限度的。 --- 接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断？根据经验和常识判断，没有一个固话或可测量的标准。</p>
</li>
</ul>
<p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：</p>
<ul>
<li>一个接口只服务于一个模块或业务逻辑；</li>
<li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</li>
<li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</li>
<li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</li>
</ul>
<h2> 五、迪米特法则</h2>
<p>迪米特法则（Law of Demeter ，LoD）也称为最少知识原则（Least Knowledge<br>
Principle，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>
<p>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义：</p>
<ul>
<li>只和朋友交流 --- 迪米特法则还有一个英文解释是：Only talk to your immedate<br>
friends（只与直接的朋友通信。）什么叫做直接的朋友？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。注意：一个类只和朋友交流，不与陌生类交流，不要出现getA()<br>
.getB().getC().getD()这种情况（在一种极端的情况下允许出现这种访问，即每一个点后面返回类型都相同），类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK<br>
API提供的类除外。</li>
<li>朋友间也是有距离的 --- 一个类公开的public属性或方法越多，修改时涉及的面积越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected<br>
等访问权限，是否可以加上final关键字等。<br>
注意：迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</li>
<li>是自己的就是自己的 --- 如果一个方法放在本类中，即不增加类间的关系，也对本类不产生负面影响，就放置在本类中。</li>
<li>谨慎使用Serializable</li>
</ul>
<p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。</p>
<p>迪米特法则要求类间解耦，但解耦是有限度的，除非是计算机的最小单元——二进制的0和1。那才是完全解耦，在实际的项目中，需要适度地考虑这个原则，别为了套用原则而做项目。原则只是供参考，如果违背了这个原则，项目也未必会失败，这就需要大家在采用原则时反复度量，不遵循是不对的，严格执行就是“过犹不及”。</p>
<h2> 六、开放封闭原则</h2>
<p>开放封闭原则的定义：Software entities like classes, modules and functions should be open for extension but closed for<br>
modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）其含义是说一个软件实体应该通过扩展来实现变化。软实体包括以下几个部分：</p>
<ul>
<li>项目或软件产品中按照一定的逻辑规则划分的模块；</li>
<li>抽象和类；</li>
<li>方法。</li>
</ul>
<p>一个软件产品只要在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计时尽量适应这些变化，以提高项目的稳定性和灵活性，真正实现“拥抱变化”。开放封闭原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。</p>
<p>开放封闭原则对扩展开放，对修改封闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。我们可以把变化归纳以下三种类型：</p>
<ul>
<li>逻辑变化； -- 只变化一个逻辑，而不涉及其他模块，比如原有的一个算法是 a<em>b+c ，现在需要修改为 a</em>b*c ，可以通过修改原有类中的方法的方式来完成，前提条件是所有依赖关系都按照相同的逻辑处理。</li>
<li>子模块变化； --- 一个模块变化，会对其他的模块产生影响，特别是一个低层次的模块变化必然引起高层次模块的变化，因此在通过扩展完成变化时，高层次的模块修改是必然的。</li>
<li>可见视图变化 --- 可见视图是提供给客户使用的界面，如JSP程序、Swing界面等，该部分的变化一般会引起连锁反应（特别是在国内做项目，做欧美的外包项目一般不会影响太大）。如果仅仅是界面上按钮、文字的重新排列倒是简单，最司空见惯的是业务耦合变化，什么意思？一个展示数据的列表，按照原有的需求是6列，突然有一天要增加1列，而且这一列要跨N张表，处理M个逻辑才能展现出来，这样的变化是比较恐怖的，但还是可以通过扩展来完成变化，这就要看我们原有的设计是否灵活。</li>
</ul>
<p><strong>为什么要采用开放封闭原则</strong>：</p>
<p>每个事物的诞生都有它存在的必要性，存在即合理，那开闭原则的存在也是合理的，为什么这么说呢？</p>
<p>首先，开闭原则是那么地著名，只要是做面向对象编程的，甭管是什么语言，Java也好，C++也好，或者是Smalltalk，在开发时都会提及开闭原则。</p>
<p>其次，开闭原则是最基础的一个原则，前面介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖。换一个角度理解，依照Java语言的称谓，开闭原则是抽象类，其他五大原则是具体的实现类，开闭原则在面向对象设计领域中的地位就类似于牛顿第一定律在力学、勾股定律在几何学、质能方程在狭义相对论中的地位，其地位无人能及。</p>
<p>最后，开闭原则是非常重要的，可通过以下几个方面来理解其重要性。</p>
<p>1、开闭原则对测试的影响</p>
<p>所有已经投产的代码都是有意义的，并且都受系统规则的约束，这样的代码都要经过“千锤百炼”的测试过程，不仅保证逻辑是正确的，还要保证苛刻条件（高压力、异常、错误）下不产生“有毒代码（Poisonous<br>
Code）”，因此有变化提出时，我们就需要考虑一下，原有的健壮代码是否可以不修改，仅仅通过扩展实现变化呢？否则，就需要把原有的测试过程回笼一遍，需要进行单元测试、功能测试、集成测试甚至是验收测试，现在虽然在大力提倡自动化测试工具，但是仍然代替不了人工的测试工作。</p>
<p>2、 开闭原则可以提高复用性</p>
<p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什么要复用呢？减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码，然后发出对开发人员“极度失望”的感概。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。</p>
<p>3、开闭原则可以提高可维护性</p>
<p>一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类，甭管原有的代码写得多么优秀还是多么糟糕，让维护人员读懂代码原有的代码，然后再修改，是一件很痛苦的事情，不要让他在原有的代码海洋里游戈完毕后再修改，那是对维护人员的一种折磨和摧残。</p>
<p>4、面向对象开发的要求</p>
<p>万物皆对象，我们需要把所有的事物都抽象成对象，然后针对对象进行操作，但是万物皆运动，有运动就有变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。</p>
<p><strong>如何使用开闭原则</strong></p>
<p>1、抽象约束</p>
<p>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型，引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。</p>
<p>2、元数据（metadata）控制模块行为</p>
<p>编程时使用元数据来控制程序的行为，减少重复开发。用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据中库中获得。</p>
<p>3、制定项目章程</p>
<p>在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。相信大家都做过项目，会发现一个项目会产生非常多的配置文件。以SSH项目开发为例，一个项目中Bean配置文件就非常多，管理非常麻烦。如果需要扩展，就需要增加子类，并修改SpringContext文件。然而，如果你在项目中指定这样一个章程：所有的Bean都自动注入，使用Annotation进行装配，进行扩展时，甚至只用写一个类，然后由持久层生成对象，其他的都不需要修改，这就需要项目内约束，每个项目成员都必须遵守，该方法需要一个团队有较高的自觉性，需要一个较长时间的磨合，一旦项目成员都熟悉这样的规则，比通过接口或抽象类进行的约束效率更高，而且扩展性一点也没有减少。</p>
<p>4、封装变化</p>
<p>对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protected<br>
variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装，23个设计模式都是从各个不同的角度对变化进行封装的，我们会在各个模式中逐步讲解。</p>
]]></content>
    <published>2024-04-15T07:11:10.000Z</published>
  </entry>
  <entry>
    <title type="text">UML图</title>
    <id>https://ujava.cn/base/uml.html</id>
    <link href="https://ujava.cn/base/uml.html"/>
    <updated>2024-04-15T07:11:10.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。</p>
<p>软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有<br>
7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>
<p>在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>众所周知，软件开发是一个分阶段进行的过程。不同的开发阶段需要使用不同的模型图来描述业务场景和设计思路，在不同的阶段输出不同的设计文档也是必不可少的，例如，在需求分析阶段需要输出领域模型和业务模型，在架构阶段需要输出物理架构设计，在详细设计阶段需要输出数据库设计等。这样做可以更好地实践软件开发，并提高软件开发的实用性。</p>
<p>软件建模与设计过程可以分为三个阶段：需求分析、架构设计和详细设计。在这三个阶段中，大量使用符合 UML 规范的模型图，其中常用的有<br>
7 种，包括类图、序列图、组件图、部署图、用例图、状态图和活动图。</p>
<p>在需求分析阶段，使用用例图和领域模型图描述用户需求和业务场景。在架构设计阶段，使用组件图和部署图描述软件系统的组成部分和部署情况。在详细设计阶段，使用类图、序列图和状态图描述软件系统的实现细节。</p>
<p>下面我们将探讨如何绘制这 7 种模型图，以及如何在不同阶段使用这些模型来生成相应的设计文档。</p>
<h2> 类图</h2>
<p>类图是软件设计中使用最广泛的 UML 图形之一，用来描述类的特性以及类之间的静态关系。在一个类图中，每个类都由三个部分组成：类名、属性列表和方法列表。</p>
<p>除了描述类的基本特征，类图还用来表示类之间的关系，其中包括六种静态关系：</p>
<p>关联（Association）：表示一个类对象与另一个类对象之间的关系，比如订单与客户之间的关系。</p>
<p>依赖（Dependency）：表示一个类对另一个类的使用或调用，比如客户下订单时需要使用订单类。</p>
<p>组合（Composition）：表示一种包含关系，表示一个类对象包含另一个类对象，比如一个订单包含多个商品。</p>
<p>聚合（Aggregation）：也表示一种包含关系，但是聚合关系中包含的类对象可以被多个类共享，比如一个学校包含多个班级。</p>
<p>继承（Inheritance）：表示一个类继承自另一个类，可以从父类中继承属性和方法，并且可以添加新的属性和方法。</p>
<p>泛化（Generalization）：与继承关系相似，但泛化关系可以用来表示更抽象的关系，比如多个类都实现了一个接口。</p>
<p>通过绘制类图，我们可以清晰地描述一个软件系统中的类及其之间的关系，帮助开发人员更好地理解软件系统的结构和功能。</p>
<p>在UML工具中把相关的一组类及其关系用一张图画出来，就是类图。</p>
<p><br>
如上图所示，描述的就是一个典型的责任链模式的实现类图。</p>
<p>类图主要是在 详细设计<br>
阶段画，一旦类图设计完成，开发工程师可以根据类图来实现代码。只要类方法的逻辑不是太复杂，不同工程师实现的代码几乎是一样的，这有利于保证软件的规范和统一性。在实际应用中，通常不需要画出所有类的类图，只需要画出核心、代表性、技术难度较高的类图即可。</p>
<p><br>
除了在详细设计阶段绘制类图外，还可以在需求分析阶段使用类图来表示关键领域模型对象。在这个阶段中，我们不要将注意力集中在属性或行为上，而应该专注于识别领域对象及其之间的关系。因此，可以使用简化的类图来描述，只需要绘制类的名称和它们之间的关系即可。</p>
<p>如上所示描述的是在需求分析阶段挖掘出SIM卡、运营商、手机、手机厂商等模型对象之间的关系。</p>
<h2> 序列图</h2>
<p>类图之外，另一种常用的图形是序列图。</p>
<p>类图描述类之间的静态关系，而序列图用于描述参与者之间的动态调用关系。每个参与者都有一条垂直向下的生命线，该生命线用虚线表示。参与者之间的消息按照从上到下的顺序表示它们的调用顺序关系，这就是序列图这个词的来源。每个生命线都有一个激活条，它是图中的细长矩形条，只有在参与者活动时才是激活的。</p>
<figure><figcaption>3.png</figcaption></figure>
<p>通常使用序列图表示对象之间的交互，这些对象可以是类对象，也可以是更大的参与者，如组件、服务器、子系统等。总之，只要涉及到不同参与者之间的交互，都可以使用序列图，比如下面这张图就是业务分析阶段，系统建设后完成后的业务流程。</p>
<figure><figcaption>4.png</figcaption></figure>
<p>记住，在软件设计的不同阶段都可以使用序列图。</p>
<h2> 组件图</h2>
<p>组件是比类更大粒度的设计元素，通常一个组件中包含多个类。组件图有时与包图的用途相似，通常用于描述物理组件，如JAR、DLL等。在实践中，我们更多地使用组件图进行模块设计。</p>
<figure><figcaption>5.png</figcaption></figure>
<p>组件图描述组件之间的静态关系，主要是依赖关系。如果想要描述组件之间的动态调用关系，可以使用组件序列图，以组件作为参与者，描述组件之间的消息调用关系。</p>
<p>由于组件的粒度较大，通常用于描述和设计软件的模块及其之间的关系。因此，在设计的早期阶段就需要画出组件图，一般用于架构设计阶段。</p>
<h2> 部署图</h2>
<p>部署图描述的是软件系统最终的物理部署情况，包括需要部署的服务器数量、关键组件的部署位置等。它是软件系统最终呈现的物理蓝图，能够让客户、老板和工程师清晰地了解系统的最终运行状态，以及与现有系统和第三方服务器的关系。通过部署图，可以预估服务器和第三方软件的采购成本。</p>
<p>因此，部署图是整个软件设计模型中相当宏观的一种图，需要在设计早期就绘制。各方可以根据部署图讨论是否认可该方案，只有对部署图达成共识，才能继续后面的细节设计。部署图主要用于架构设计阶段，并且与组件图要彼此呼应。<br>
</p>
<h2> 用例图</h2>
<p>用例图分为业务用例和系统用例，业务用例图主要体现在 业务分析阶段， 描述一个承建系统的组织对外提供的能力，系统用例体现在需求分析阶段描述系统对外提供的能力。</p>
<figure><figcaption>7.png</figcaption></figure>
<p>这张图中，左边是业务用例图，右边是系统用例图。虽然它们的画法相似，但它们本质上有很大的区别，具体可以查看我之前写的这篇文章。</p>
<p>图中的人形元素称为角色，角色可以是人也可以是其他系统。由于系统的功能可能很复杂，用例图可能仅包含其中的一小部分功能，这些功能被画在一个矩形框内，这个矩形框是用例边界。矩形框里面的椭圆表示单个功能，它们可以相互依赖或需要扩展。因为用例图中的功能描述相对简单，所以通常需要配以文字说明以形成需求文档。</p>
<h2> 状态图</h2>
<p>状态图用来展现单个对象生命周期中的状态变迁。</p>
<p>在业务系统中，许多重要的领域对象都有相当复杂的状态变化，比如订单，它们可以有待付款、待审核、待发货、待收货、交易关闭和交易完成等各种状态。</p>
<p>这些状态变化可以在用例图中用文本形式描述，并随着各个用户的不同操作而改变。但是，使用这种方法描述状态时，状态会分散到不同的地方，这样可能会导致开发错误以及产品经理在设计时的困惑。</p>
<p>采用UML状态图可以有效地解决这些问题，因为它可以在一张图表中展示对象的整个生命周期以及各个状态和变迁之间的关系。比如下面的图表展示了一个订单从创建到交易完成的状态变化。</p>
<figure><figcaption>8.png</figcaption></figure>
<p>状态图要在需求分析阶段画，描述状态变迁的逻辑关系，在详细设计阶段也要画，这个时候，状态要用枚举值表示，以指导具体的开发。</p>
<h2> 活动图</h2>
<p>活动图常用于描述系统或业务流程中的动态行为。它可以清晰地展现从一个活动到另一个活动的控制流，描绘出系统或业务流程的逻辑和流程，让开发人员更好地了解整个系统的运作方式。</p>
<p>在活动图中，实心圆表示流程的开始，空心圆表示流程的结束，圆角矩形表示活动，菱形表示分支判断。这些符号的使用能够使活动图更加规范化和可读性，有助于提高系统开发的效率和质量。</p>
<figure><figcaption>9.png</figcaption></figure>
<p>此外，活动图引入了一个重要的概念——泳道。活动图可以根据活动的范围，将活动根据领域、系统和角色等划分到不同的泳道中，使流程边界更加清晰。</p>
<p>流程图也比较有普适性，可以在需求分析阶段描述业务流程，也可以在架构设计阶段描述子系统和组件的交互，还可以在详细设计阶段描述一个类方法内部的计算流程。</p>
<p>使用合适的 UML 模型构建一个设计文档<br>
UML 模型图本身并不难掌握，但如何在正确的场合下用适当的 UML 模型表达设计意图，形成一套清晰且详细的软件模型，并在团队内外达成共识的设计文档则需要注意。</p>
<p>根据软件设计不同阶段的需要，我们可以使用不同的模型图进行建模。</p>
<p>在需求分析阶段，我们可以使用用例图、活动图、时序图和简化的类图进行领域模型抽象和关系描述。</p>
<p>在架构设计阶段，通过组件图、组件时序图和部署图描述系统物理蓝图和模块关系。</p>
<p>在详细设计阶段，主要侧重于类图和类的时序图，而对于复杂的方法逻辑，可以使用方法的活动图进行描述。</p>
<h2> 小结</h2>
<p>掌握类图、时序图、组件图、部署图、用例图、状态图、活动图这七种UML模型图，根据实际场景，在需求分析、架构设计和详细设计阶段选择并巧妙应用对应的模型图，有助于有效地进行软件建模和系统设计，成为一个掌控大局、指导技术团队的优秀架构师。</p>
<p>要注意模型图的规范和注释，遵循命名规范，对模型元素进行命名，注释模型元素的关系和属性等，简洁明了。此外，UML模型图只是设计文档的一部分，需要与其他文档相结合，如需求文档、设计文档、测试文档等，形成一个完整的设计文档，指导软件开发。</p>
<p>对于画UML的工具，有收费的专业软件设计工具像EA(Enterprise Architect)、Astah和亿图，<a href="http://xn--draw-955fn1koi57ny3ibkg51n9w4beb3a3cyhe2c.io" target="_blank" rel="noopener noreferrer">以及免费的在线工具比如draw.io</a>，processon等，建议可以根据自身需要选择合适的工具，同时也建议从简单易用的工具入手。</p>
]]></content>
    <category term="设计基础"/>
    <published>2024-04-15T07:11:10.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Netty</title>
    <id>https://ujava.cn/assembly/netty.html</id>
    <link href="https://ujava.cn/assembly/netty.html"/>
    <updated>2024-04-15T06:08:01.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、Netty 简介</h2>
<p>Netty 是基于 Java NIO 的异步事件驱动的网络应用框架，使用 Netty 可以快速开发网络应用，Netty 提供了高层次的抽象来简化 TCP 和 UDP 服务器的编程，但是你仍然可以使用底层的 API。</p>
<p>Netty 的内部实现是很复杂的，但是 Netty 提供了简单易用的API从网络处理代码中解耦业务逻辑。Netty 是完全基于 NIO 实现的，所以整个 Netty 都是异步的。</p>
<p>Netty 是最流行的 NIO 框架，它已经得到成百上千的商业、商用项目验证，许多框架和开源组件的底层 rpc 都是使用的 Netty，如 Dubbo、Elasticsearch 等等。下面是官网给出的一些 Netty 的特性：</p>]]></summary>
    <content type="html"><![CDATA[<h2> 一、Netty 简介</h2>
<p>Netty 是基于 Java NIO 的异步事件驱动的网络应用框架，使用 Netty 可以快速开发网络应用，Netty 提供了高层次的抽象来简化 TCP 和 UDP 服务器的编程，但是你仍然可以使用底层的 API。</p>
<p>Netty 的内部实现是很复杂的，但是 Netty 提供了简单易用的API从网络处理代码中解耦业务逻辑。Netty 是完全基于 NIO 实现的，所以整个 Netty 都是异步的。</p>
<p>Netty 是最流行的 NIO 框架，它已经得到成百上千的商业、商用项目验证，许多框架和开源组件的底层 rpc 都是使用的 Netty，如 Dubbo、Elasticsearch 等等。下面是官网给出的一些 Netty 的特性：</p>
<p>设计方面</p>
<ul>
<li>
<p>对各种传输协议提供统一的 API（使用阻塞和非阻塞套接字时候使用的是同一个 API，只是需要设置的参数不一样）。</p>
</li>
<li>
<p>基于一个灵活、可扩展的事件模型来实现关注点清晰分离。</p>
</li>
<li>
<p>高度可定制的线程模型——单线程、一个或多个线程池。</p>
</li>
<li>
<p>真正的无数据报套接字（UDP）的支持（since 3.1）。<br>
易用性</p>
</li>
<li>
<p>完善的 Javadoc 文档和示例代码。</p>
</li>
<li>
<p>不需要额外的依赖，JDK 5 (Netty 3.x) 或者 JDK 6 (Netty 4.x) 已经足够。<br>
性能</p>
</li>
<li>
<p>更好的吞吐量，更低的等待延迟。</p>
</li>
<li>
<p>更少的资源消耗。</p>
</li>
<li>
<p>最小化不必要的内存拷贝。<br>
安全性</p>
</li>
<li>
<p>完整的 SSL/TLS 和 StartTLS 支持</p>
</li>
<li>
<p>对于初学者，上面的特性我们在脑中有个简单了解和印象即可， 下面开始我们的实战部分。</p>
</li>
</ul>
<h2> 二、一个简单 Http 服务器</h2>
<p>开始前说明下我这里使用的开发环境是 IDEA+Gradle+Netty4，当然你使用 Eclipse 和 Maven 都是可以的，然后在 Gradle 的 build 文件中添加依赖 compile 'io.netty:netty-all:4.1.26.Final'，这样就可以编写我们的 Netty 程序了，正如在前面介绍 Netty 特性中提到的，Netty 不需要额外的依赖。</p>
<p>第一个示例我们使用 Netty 编写一个 Http 服务器的程序，启动服务我们在浏览器输入网址来访问我们的服务，便会得到服务端的响应。功能很简单，下面我们看看具体怎么做？</p>
<p>首先编写服务启动类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在编写 Netty 程序时，一开始都会生成 NioEventLoopGroup 的两个实例，分别是 bossGroup 和 workerGroup，也可以称为 parentGroup 和 childGroup，为什么创建这两个实例，作用是什么？可以这么理解，bossGroup 和 workerGroup 是两个线程池, 它们默认线程数为 CPU 核心数乘以 2，bossGroup 用于接收客户端传过来的请求，接收到请求后将后续操作交由 workerGroup 处理。</p>
<p>接下来我们生成了一个服务启动辅助类的实例 bootstrap，boostrap 用来为 Netty 程序的启动组装配置一些必须要组件，例如上面的创建的两个线程组。channel 方法用于指定服务器端监听套接字通道 NioServerSocketChannel，其内部管理了一个 Java NIO 中的ServerSocketChannel实例。</p>
<p>channelHandler 方法用于设置业务职责链，责任链是我们下面要编写的，责任链具体是什么，它其实就是由一个个的 ChannelHandler 串联而成，形成的链式结构。正是这一个个的 ChannelHandler 帮我们完成了要处理的事情。</p>
<p>接着我们调用了 bootstrap 的 bind 方法将服务绑定到 8080 端口上，bind 方法内部会执行端口绑定等一系列操，使得前面的配置都各就各位各司其职，sync 方法用于阻塞当前 Thread，一直到端口绑定操作完成。接下来一句是应用程序将会阻塞等待直到服务器的 Channel 关闭。</p>
<p>启动类的编写大体就是这样了，下面要编写的就是上面提到的责任链了。如何构建一个链，在 Netty 中很简单，不需要我们做太多，代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们自定义一个类 HttpServerInitializer 继承 ChannelInitializer 并实现其中的 initChannel方法。</p>
<p>ChannelInitializer 继承 ChannelInboundHandlerAdapter，用于初始化 Channel 的 ChannelPipeline。通过 initChannel 方法参数 sc 得到 ChannelPipeline 的一个实例。</p>
<p>当一个新的连接被接受时， 一个新的 Channel 将被创建，同时它会被自动地分配到它专属的 ChannelPipeline。</p>
<p>ChannelPipeline 提供了 ChannelHandler 链的容器，推荐读者仔细自己看看 ChannelPipeline 的 Javadoc，文章后面也会继续说明 ChannelPipeline 的内容。</p>
<p>Netty 是一个高性能网络通信框架，同时它也是比较底层的框架，想要 Netty 支持 Http（超文本传输协议），必须要给它提供相应的编解码器。</p>
<p>所以我们这里使用 Netty 自带的 Http 编解码组件 HttpServerCodec 对通信数据进行编解码，HttpServerCodec 是 HttpRequestDecoder 和 HttpResponseEncoder 的组合，因为在处理 Http 请求时这两个类是经常使用的，所以 Netty 直接将他们合并在一起更加方便使用。所以对于上面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们替换成如下两行也是可以的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 addLast 方法将一个一个的 ChannelHandler 添加到责任链上并给它们取个名称（不取也可以，Netty 会给它个默认名称），这样就形成了链式结构。在请求进来或者响应出去时都会经过链上这些 ChannelHandler 的处理。</p>
<p>最后再向链上加入我们自定义的 ChannelHandler 组件，处理自定义的业务逻辑。下面就是我们自定义的 ChannelHandler。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>至此一个简单的 Http 服务器就完成了。首先我们来看看效果怎样，我们运行 HttpServer 中的 main 方法。让后使用 Postman 这个工具来测试下，使用 post 请求方式（也可以 get，但没有请求体），并一个 json 格式数据作为请求体发送给服务端，服务端返回给我们一个hello world字符串。</p>
<figure><figcaption>img.png</figcaption></figure>
<p>服务端控制台打印如下：</p>
<figure><figcaption>img_1.png</figcaption></figure>
<p>对于自定义的 ChannelHandler， 一般会继承 Netty 提供的SimpleChannelInboundHandler类，并且对于 Http 请求我们可以给它设置泛型参数为 HttpOjbect 类，然后覆写 channelRead0 方法，在 channelRead0 方法中编写我们的业务逻辑代码，此方法会在接收到服务器数据后被系统调用。</p>
<p>Netty 的设计中把 Http 请求分为了 HttpRequest 和 HttpContent 两个部分，HttpRequest 主要包含请求头、请求方法等信息，HttpContent 主要包含请求体的信息。</p>
<p>所以上面的代码我们分两块来处理。在 HttpContent 部分，首先输出客户端传过来的字符，然后通过 Unpooled 提供的静态辅助方法来创建未池化的 ByteBuf 实例， Java NIO 提供了 ByteBuffer 作为它的字节容器，Netty 的 ByteBuffer 替代品是 ByteBuf。</p>
<p>接着构建一个 FullHttpResponse 的实例，并为它设置一些响应参数，最后通过 writeAndFlush 方法将它写回给客户端。</p>
<p>上面这样获取请求和消息体则相当不方便，Netty 又提供了另一个类 FullHttpRequest，FullHttpRequest 包含请求的所有信息，它是一个接口，直接或者间接继承了 HttpRequest 和 HttpContent，它的实现类是 DefalutFullHttpRequest。</p>
<p>因此我们可以修改自定义的 ChannelHandler 如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样修改就可以了吗，如果你去启动程序运行看看，是会抛异常的。前面说过 Netty 是一个很底层的框架，对于将请求合并为一个 FullRequest 是需要代码实现的，然而这里我们并不需要我们自己动手去实现，Netty 为我们提供了一个 HttpObjectAggregator 类，这个 ChannelHandler作用就是将请求转换为单一的 FullHttpReques。</p>
<p>所以在我们的 ChannelPipeline 中添加一个 HttpObjectAggregator 的实例即可。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动程序运行，一切都顺畅了，好了，这个简单 Http 的例子就 OK 了。</p>
<h2> 三、编写 Netty 客户端</h2>
<p>上面的两个示例中我们都是以 Netty 做为服务端，接下来看看如何编写 Netty 客户端，以第一个 Http 服务的例子为基础，编写一个访问 Http 服务的客户端。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端启动类编写基本和服务端类似，在客户端我们只用到了一个线程池，服务端使用了两个，因为服务端要处理 n 条连接，而客户端相对来说只处理一条，因此一个线程池足以。</p>
<p>然后服务端启动辅助类使用的是 ServerBootstrap，而客户端换成了 Bootstrap。通过 Bootstrap 组织一些必要的组件，为了方便，在 handler 方法中我们使用匿名内部类的方式来构建 ChannelPipeline 链容器。最后通过 connect 方法连接服务端。</p>
<p>接着编写 HttpClientHandler 类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 HttpClientHandler 类中，我们覆写了 channelActive 方法，当连接建立时，此方法会被调用，我们在方法中构建了一个 FullHttpRequest 对象，并且通过 writeAndFlush 方法将请求发送出去。</p>
<p>channelRead0 方法用于处理服务端返回给我们的响应，打印服务端返回给客户端的信息。至此，Netty 客户端的编写就完成了，我们先开启服务端，然后开启客户端就可以看到效果了。</p>
<p>希望通过前面介绍的几个例子能让大家基本知道如何编写 Netty 客户端和服务端，下面我们来说说 Netty 程序为什么是这样编写的，这也是 Netty 中最为重要的一部分知识，可以让你在编写 netty 程序时做到心中有数。</p>
<h2> 四、Channel、ChannelPipeline、ChannelHandler、ChannelHandlerContext 之间的关系</h2>
<p>在编写 Netty 程序时，经常跟我们打交道的是上面这几个对象，这也是 Netty 中几个重要的对象，下面我们来看看它们之间有什么样的关系。</p>
<p>Netty 中的 Channel 是框架自己定义的一个通道接口，Netty 实现的客户端 NIO 套接字通道是 NioSocketChannel，提供的服务器端 NIO 套接字通道是 NioServerSocketChannel。</p>
<p>当服务端和客户端建立一个新的连接时， 一个新的 Channel 将被创建，同时它会被自动地分配到它专属的 ChannelPipeline。</p>
<p>ChannelPipeline 是一个拦截流经 Channel 的入站和出站事件的 ChannelHandler 实例链，并定义了用于在该链上传播入站和出站事件流的 API。那么就很容易看出这些 ChannelHandler 之间的交互是组成一个应用程序数据和事件处理逻辑的核心。</p>
<figure><figcaption>img_2.png</figcaption></figure>
<p>上图描述了 IO 事件如何被一个 ChannelPipeline 的 ChannelHandler 处理的。</p>
<p>ChannelHandler分为 ChannelInBoundHandler 和 ChannelOutboundHandler 两种，如果一个入站 IO 事件被触发，这个事件会从第一个开始依次通过 ChannelPipeline中的 ChannelInBoundHandler，先添加的先执行。</p>
<p>若是一个出站 I/O 事件，则会从最后一个开始依次通过 ChannelPipeline 中的 ChannelOutboundHandler，后添加的先执行，然后通过调用在 ChannelHandlerContext 中定义的事件传播方法传递给最近的 ChannelHandler。</p>
<p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。</p>
<p>如果某个ChannelHandler不能处理则会跳过，并将事件传递到下一个ChannelHandler，直到它找到和该事件所期望的方向相匹配的为止。</p>
<p>假设我们创建下面这样一个 pipeline：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面示例代码中，inbound 开头的 handler 意味着它是一个ChannelInBoundHandler。outbound 开头的 handler 意味着它是一个 ChannelOutboundHandler。</p>
<p>当一个事件进入 inbound 时 handler 的顺序是 1，2，3，4，5；当一个事件进入 outbound 时，handler 的顺序是 5，4，3，2，1。在这个最高准则下，ChannelPipeline 跳过特定 ChannelHandler 的处理：</p>
<ul>
<li>3，4 没有实现 ChannelInboundHandler，因而一个 inbound 事件的处理顺序是 1，2，5。</li>
<li>1，2 没有实现 ChannelOutBoundhandler，因而一个 outbound 事件的处理顺序是 5，4，3。</li>
<li>5 同时实现了 ChannelInboundHandler 和 channelOutBoundHandler，所以它同时可以处理 inbound 和 outbound 事件。<br>
ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。</li>
</ul>
<p>（它也可以将它自己从 ChannelPipeline 中移除。）这是 ChannelHandler 最重要的能力之一。</p>
<p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。</p>
<p>ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。事件从一个 ChannelHandler 到下一个 ChannelHandler 的移动是由 ChannelHandlerContext 上的调用完成的。</p>
<figure><figcaption>img_3.png</figcaption></figure>
<p>但是有些时候不希望总是从 ChannelPipeline 的第一个 ChannelHandler 开始事件，我们希望从一个特定的 ChannelHandler 开始处理。</p>
<p>你必须引用于此 ChannelHandler 的前一个 ChannelHandler 关联的 ChannelHandlerContext，利用它调用与自身关联的 ChannelHandler 的下一个 ChannelHandler。</p>
<p>如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们想有一些事件流全部通过 ChannelPipeline，有两个不同的方法可以做到：</p>
<ul>
<li>
<p>调用 Channel 的方法</p>
</li>
<li>
<p>调用 ChannelPipeline 的方法</p>
</li>
<li>
<p>这两个方法都可以让事件流全部通过 ChannelPipeline，无论从头部还是尾部开始，因为它主要依赖于事件的性质。如果是一个 “ 入站 ” 事件，它开始于头部；若是一个 “ 出站 ” 事件，则开始于尾部。<br>
那为什么你可能会需要在 ChannelPipeline 某个特定的位置开始传递事件呢？</p>
</li>
<li>
<p>减少因为让事件穿过那些对它不感兴趣的 ChannelHandler 而带来的开销</p>
</li>
<li>
<p>避免事件被那些可能对它感兴趣的 ChannlHandler 处理</p>
</li>
</ul>
<h2> 五、Netty 线程模型</h2>
<p>在前面的示例中我们程序一开始都会生成两个 NioEventLoopGroup 的实例，为什么需要这两个实例呢？这两个实例可以说是 Netty 程序的源头，其背后是由 Netty 线程模型决定的。</p>
<p>Netty 线程模型是典型的 Reactor 模型结构，其中常用的 Reactor 线程模型有三种，分别为：Reactor 单线程模型、Reactor 多线程模型和主从 Reactor 多线程模型。</p>
<p>而在 Netty 的线程模型并非固定不变，通过在启动辅助类中创建不同的 EventLoopGroup 实例并通过适当的参数配置，就可以支持上述三种 Reactor 线程模型。</p>
<p>Reactor 线程模型</p>
<h3> Reactor 单线程模型</h3>
<p>Reactor 单线程模型指的是所有的 IO 操作都在同一个 NIO 线程上面完成。作为 NIO 服务端接收客户端的 TCP 连接，作为 NIO 客户端向服务端发起 TCP 连接，读取通信对端的请求或向通信对端发送消息请求或者应答消息。</p>
<p>由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。</p>
<figure><figcaption>img_4.png</figcaption></figure>
<p>Netty 使用单线程模型的的方式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在实例化 NioEventLoopGroup 时，构造器参数是 1，表示 NioEventLoopGroup 的线程池大小是 1。然后接着我们调用 b.group(bossGroup) 设置了服务器端的 EventLoopGroup，因此 bossGroup和 workerGroup 就是同一个 NioEventLoopGroup 了。</p>
<h3> Reactor 多线程模型</h3>
<p>对于一些小容量应用场景，可以使用单线程模型，但是对于高负载、大并发的应用却不合适，需要对该模型进行改进，演进为 Reactor 多线程模型。</p>
<p>Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。</p>
<p>在该模型中有专门一个 NIO 线程 -Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；而 1 个 NIO 线程可以同时处理N条链路，但是 1 个链路只对应 1 个 NIO 线程，防止发生并发操作问题。</p>
<p>网络 IO 操作-读、写等由一个 NIO 线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送。</p>
<figure><figcaption>img_5.png</figcaption></figure>
<p>Netty 中实现多线程模型的方式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>bossGroup 中只有一个线程，而 workerGroup 中的线程是 CPU 核心数乘以 2，那么就对应 Recator 的多线程模型。</p>
<h3> 主从 Reactor 多线程模型</h3>
<p>在并发极高的情况单独一个 Acceptor 线程可能会存在性能不足问题，为了解决性能问题，产生主从 Reactor 多线程模型。</p>
<p>主从 Reactor 线程模型的特点是：服务端用于接收客户端连接的不再是 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。</p>
<p>Acceptor 接收到客户端 TCP 连接请求处理完成后，将新创建的 SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。</p>
<p>Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</p>
<figure><figcaption>img_6.png</figcaption></figure>
<p>根据前面所讲的两个线程模型，很容想到 Netty 实现多线程的方式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，在 Netty 的服务器端的 acceptor 阶段，没有使用到多线程, 因此上面的主从多线程模型在 Netty 的实现是有误的。</p>
<p>服务器端的 ServerSocketChannel 只绑定到了 bossGroup 中的一个线程，因此在调用 Java NIO 的 Selector.select 处理客户端的连接请求时，实际上是在一个线程中的，所以对只有一个服务的应用来说，bossGroup 设置多个线程是没有什么作用的，反而还会造成资源浪费。</p>
<p>至于 Netty 中的 bossGroup 为什么使用线程池，我在 stackoverflow 找到一个对于此问题的讨论 。</p>
<p>the creator of Netty says multiple boss threads are useful if we share NioEventLoopGroup between different server bootstraps</p>
<p>EventLoopGroup 和 EventLoop</p>
<p>当系统在运行过程中，如果频繁的进行线程上下文切换，会带来额外的性能损耗。多线程并发执行某个业务流程，业务开发者还需要时刻对线程安全保持警惕，哪些数据可能会被并发修改，如何保护？这不仅降低了开发效率，也会带来额外的性能损耗。</p>
<p>为了解决上述问题，Netty采用了串行化设计理念，从消息的读取、编码以及后续 ChannelHandler 的执行，始终都由 IO 线程 EventLoop 负责，这就意外着整个流程不会进行线程上下文的切换，数据也不会面临被并发修改的风险。</p>
<p>EventLoopGroup 是一组 EventLoop 的抽象，一个 EventLoopGroup 当中会包含一个或多个 EventLoop，EventLoopGroup 提供 next 接口，可以从一组 EventLoop 里面按照一定规则获取其中一个 EventLoop 来处理任务。</p>
<p>在 Netty 服务器端编程中我们需要 BossEventLoopGroup 和 WorkerEventLoopGroup 两个 EventLoopGroup 来进行工作。</p>
<p>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了 ServerSocketChannel 的 Selector 实例，EventLoop 的实现涵盖 IO 事件的分离，和分发（Dispatcher），EventLoop 的实现充当 Reactor 模式中的分发（Dispatcher）的角色。</p>
<p>所以通常可以将 BossEventLoopGroup 的线程数参数为 1。</p>
<p>BossEventLoop 只负责处理连接，故开销非常小，连接到来，马上按照策略将 SocketChannel 转发给 WorkerEventLoopGroup，WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop 来将这 个SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理。</p>
<p>ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生严重的负面影响。但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。</p>
<p>对于这种情况， ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add() 方法。如果一个事件被传递给一个自定义的 EventExecutorGroup， DefaultEventExecutorGroup 的默认实现。</p>
<p>就是在把 ChannelHanders 添加到 ChannelPipeline 的时候，指定一个 EventExecutorGroup，ChannelHandler 中所有的方法都将会在这个指定的 EventExecutorGroup 中运行。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>NioEventLoopGroup 实际上就是个线程池，一个 EventLoopGroup 包含一个或者多个 EventLoop；</li>
<li>一个 EventLoop 在它的生命周期内只和一个 Thread 绑定；</li>
<li>所有有 EnventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理；</li>
<li>一个 Channel 在它的生命周期内只注册于一个 EventLoop；</li>
<li>每一个 EventLoop 负责处理一个或多个 Channel；</li>
</ul>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T06:08:01.000Z</published>
  </entry>
  <entry>
    <title type="text">算法试题</title>
    <id>https://ujava.cn/algorithm/program.html</id>
    <link href="https://ujava.cn/algorithm/program.html"/>
    <updated>2024-04-15T04:22:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> <a href="https://javainterview.cn/categories/?category=algorithm" target="_blank" rel="noopener noreferrer">算法试题</a></h2>
]]></summary>
    <content type="html"><![CDATA[<h2> <a href="https://javainterview.cn/categories/?category=algorithm" target="_blank" rel="noopener noreferrer">算法试题</a></h2>
]]></content>
    <category term="设计算法"/>
    <published>2024-04-15T04:22:41.000Z</published>
  </entry>
  <entry>
    <title type="text">一文搞懂业务架构、技术架构、数据架构、运维架构、物理架构理清不同视角的架构</title>
    <id>https://ujava.cn/synthesis/business.html</id>
    <link href="https://ujava.cn/synthesis/business.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
<h2> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在学习架构时，我认为首先要理清楚架构的视角，因为你所认知的架构和别人所说的架构可能是两码事。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
<h2> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>
<p>很多时候架构的视角/分类没有明显的边界，通常是交叉的；<br>
有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</p>
<h2> 业务架构</h2>
<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>
<p><br>
看看京东业务架构（网上分享图）：<br>
</p>
<h2> 应用/技术架构</h2>
<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>
<p>不限于如下视角，主要表示应用开发中的软件架构视角...</p>
<h3> 视角：功能视角</h3>
<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>
<h3> 视角：技术视角-总体</h3>
<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。<br>
</p>
<h3> 视角：技术视角-数据架构</h3>
<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>
<h3> 视角：技术视角-基础架构</h3>
<p>PAAS，IAAS...</p>
<figure><figcaption>img_35.png</figcaption></figure>
<h3> 视角：技术视角-运维架构</h3>
<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>
<figure><figcaption>img_36.png</figcaption></figure>
<h2> 物理架构</h2>
<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>
<p>以一个银行系统为例</p>
<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。<br>
</p>
<p>物理部署架构设计说明：</p>
<ul>
<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>
<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>
<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>
<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>
<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>
<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。<br>
下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。<br>
</li>
</ul>
<p>物理部署架构设计说明：</p>
<ul>
<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>
<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>
<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>
</ul>
<h2> DDD到各种架构</h2>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<p>统一语言，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</p>
<p>面向领域，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</p>
<p>职责划分，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</p>
<figure><figcaption>img_39.png</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计缓存</title>
    <id>https://ujava.cn/synthesis/cache.html</id>
    <link href="https://ujava.cn/synthesis/cache.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p>
<p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p>
<ul>
<li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li>
<li>虚拟主存： 作为磁盘数据的缓存。</li>
<li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li>
<li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br>
本文总结互联网技术体系中尤为重要的缓存技术。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>实际应用中，一些数据在短期内会反复多次访问。比如循环访问、热点畅销商品、爆热优惠活动。在一次下单中，提交中的订单基本信息会被反复访问、刚创建的订单很快会被查询多次。</p>
<p>数据在短期内被反复访问的场景下，缓存可用来提升查询性能。缓存是用一个小而快的存储来存放一个大而慢的存储的数据子集，在查询时通过缓存命中而提升性能。缓存是最基本的计算思想之一。在计算机系统的各个层次结构上，缓存无处不在。</p>
<ul>
<li>CPU 高速缓存：位于 CPU 芯片上。L1,L2,L3 缓存。 L1 - 4 个时钟；L2 - 10 个时钟；L3 - 50 个时钟。</li>
<li>虚拟主存： 作为磁盘数据的缓存。</li>
<li>磁盘缓存： 难以装进主存的大对象、网络内容的本地缓存</li>
<li>网络缓存： 浏览器缓存、HTTP 代理缓存、负载均衡缓存、CDN。<br>
本文总结互联网技术体系中尤为重要的缓存技术。</li>
</ul>
<h2> 基本思想</h2>
<ul>
<li>缓存是以空间换时间，提升查询性能。缓存遵循“近水楼台先得月”法则：邻近 CPU 优先，邻近用户优先（CDN）。</li>
<li>缓存依据：访问局部性原理。时间局部性 - 某个存储器位置在短时间内被再次访问；空间局部性 -<br>
若某个存储器位置被访问，则邻近存储器位置也很可能会被访问。重复引用相同变量的程序具有良好的时间局部性。步长为 1<br>
的引用模式的程序具有良好的空间局部性。一个典型例子是数组求和。求和变量体现了时间局部性，数组访问体现了空间局部性。可以用缓存命中率来衡量局部性。</li>
<li>顺序引用模式：顺序地每隔 k 个元素地访问一个连续向量中的每个元素，称为步长为 k 的顺序引用模式 。 k 越大，空间局部性越差。步长为<br>
1 的顺序引用模式是局部性原理的重要应用之一。高效访问顺序与存储结构设计及存储细节是紧密关联的。数组和列表是连续存储结构，因此顺序引用模式很吃香。</li>
<li>存储器层次结构：对于每个 k, 位于第 k 层的更快更小的存储设备作为位于第 k+1 层的更慢更大的存储设备的缓存。数据总是以块为传送单元，在第<br>
k 层和第 k+1 层之间进行复制的。层次结构中，相邻的两层的块大小是一样的；不同层次的块大小可以不同。越靠近慢而大的存储层次，块大小越大。</li>
</ul>
<h2> 缓存问题</h2>
<p>缓存问题主要包括缓存结构设计、缓存一致性分析、缓存策略（热身/替换/清理）、缓存保护（击穿/雪崩/穿透）。<br>
一致性问题涉及准确性；缓存策略涉及性能（缓存命中率及主存占用）；而缓存保护涉及稳定性（在大并发请求下且缓存未能命中时保护原始数据源不被压倒）。</p>
<h4> 缓存结构设计</h4>
<p>缓存数据结构主要包括记录型和哈希型。记录型的缓存，是一个连续存储阵列，可简化为多维数组；哈希型的缓存，是基于哈希表。 CPU<br>
高速缓存是基于记录型的，因为硬件上不宜做复杂的运算；应用缓存通常是基于哈希型的，比如 Redis 缓存。</p>
<h4> CPU高速缓存</h4>
<p>CPU 高速缓存可使用 (S, E, B, m) 来表示组织结构。m 位存储器具有 2^m 个存储器地址，其对应的高速缓存组织划分为 S = 2^s 个组，每组<br>
E 个缓存行，每个缓存行包括一个有效位、t 个标记位、B = 2^b 个字节，缓存大小 C = S * E * B。 其中 s<br>
是组索引，标识缓存块在哪个组里；t = m-s-b 标识缓存块在缓存组的哪个缓存行里；b 是字节在缓存行里的偏移量。[s,t,b]<br>
标识了缓存字节在缓存结构里的位置。发生缓存替换时，替换的是某个组里的某个缓存行。</p>
<p>E = 1 时，DMC Directed-Map Cache ；1 &lt; E &lt; C/B 时，SAC Set Associative Cache ；E = C/B 时 Full Associative Cache FAC。 DMC<br>
每组只有一个缓存行，在组中查找缓存行没有开销，但容易发生组的冲突不命中； SAC 在组中查找缓存行有一定开销，但可以减少组的冲突不命中概率；<br>
FAC 只有一个组，在定位组时无开销，替换缓存行时有更大的选择，但在查找缓存行时开销比较大。在硬件层，搜索和匹配标记位是昂贵的操作，因此<br>
FAC 一般应用在搜索和匹配操作代价不高的地方，比如虚拟主存或应用缓存。</p>
<p>高速缓存定位字的步骤是：首先从 m 中拿到 s 位组索引，找到缓存行所在的组；再根据 t 位标记位找到匹配的组内的缓存行；最后，根据 b<br>
位偏移量找到字在缓存块中的位置。如果有效位未置位，则可能是过期缓存；如果 t 位标记位无法匹配所有的组，则是缓存未命中。</p>
<figure><figcaption>img.png</figcaption></figure>
<p>CPU 写主存时可采用两种方式：直写和回写。直写会在更新缓存是直接写入缓存，而回写在更新缓存时只是标记缓存块的缓存状态，只有在替换缓存块时才会写回主存。这就导致了<br>
CPU 缓存与主存的一致性问题。这个问题是通过 MESI 协议来解决的。</p>
<h4> MESI协议</h4>
<p>MESI 协议是 SMP 体系结构的 CPU 缓存一致性协议，涉及读写时多个 CPU 高速缓存如何与主存保持一致<br>
。主要设计思想包括：缓存条目状态的状态转换自动机、写缓冲器、总线事务定义及缓存控制、操作异步化队列、操作屏障。</p>
<h4> 一致性概念</h4>
<p>多处理器存储系统是一致的，如果某个程序的任何执行结果都满足下列条件：对于任何单元，有可能建立一个假想的操作序列（将所有进程的读写操作排成一个全序），此序列与执行结果一致，并且在此序列中：</p>
<ul>
<li>任何特定进程发出的操作，所表现出的序和该进程向存储系统发出他们的序相同；</li>
<li>每个读操作返回的值是对相应单元按串行顺序写入的最后一个值。</li>
</ul>
<h4> 一致性前提</h4>
<ul>
<li>系统总线上的所有事务对所有处理器的高速缓存控制器可见，且以相同顺序可见。</li>
<li>为响应存储的所有必要事务都出现在总线上，且缓存控制器采取适当的措施。</li>
<li>当高速缓存监听到与之相关的写操作事务时，要么使缓存块拷贝作废，要么更新它。处理器随后的访问，要么缓存不命中而加载新的值，要么直接看到新的值。</li>
</ul>
<h4> CPU宏观结构</h4>
<p>CPU 宏观结构主要包括：CPU Core, Store Buffer , CPU Cache , System BUS 。 CPU Cache 和 Store Buffer 是 CPU 专有的，System<br>
BUS 是共享的消息通道。 CPU Cache 是一个缓存条目的阵列（多维数组），每个缓存条目有 tag, data, flag 三个值，tag 表示主存地址，flag<br>
表示缓存条目的状态。flag 定义了如下值：</p>
<ul>
<li>Modified(M)：已修改状态。某个处理器缓存副本拥有已修改的值, 主存里的是过期的；</li>
<li>Exclusive(E)：干净独占状态。仅有该处理器缓存副本与主存一致且主存状态是最新的，独占控制权，缓存能够写操作并转移到 M<br>
状态，却不产生总线事务;</li>
<li>Shared(S)：至少两个处理器缓存副本与主存一致，主存有最新的值，其他处理器可能有最新的或者过期的值;</li>
<li>Invalid(I)：初始状态，缓存无效状态。</li>
</ul>
<p>缓存条目状态简称为 CES。CES 的状态转换图可以定位为一个有限状态自动机。理解 CES 的有限状态转换机是关键。如下图所示，A/B 表示当观察<br>
A 事件时，将产生一个 B 总线事务。Flush’ 表示清除相应的存储块，前提是使用了缓存到缓存的共享，且清除是由提供数据的缓存。BusRd(<br>
S) 表示由共享信号 S 生成的总线读事务。缓存控制器通过共享信号 S 在地址阶段确定是否有其它缓存拥有同样的缓存拷贝。如果一个缓存确定自己拥有同样的存储块拷贝，就会发出<br>
S 信号。</p>
<p>MESI 协议定义了一些总线事务（总线读事务、总线排它读事务、总线写事务、回写事务）。结合 CES 状态转换图、总线事务及 CPU<br>
缓存读写控制来实现一致性。</p>
<h4> 缓存读</h4>
<p>读是指拿到变量的最新值并读取到 CPU 寄存器。假设处理器 P1 和 P2 均拥有变量 x 的副本。如果 P1 发现 x 的 CES 为 M/E/S，则直接获取副本<br>
x 的值。若 P1 发现变量 x 的 CES 为 I，则遵循如下步骤：</p>
<ul>
<li>STEP1 -- 发送 BUS Read 事务；</li>
<li>STEP2 -- P2 拥有变量 x 的最新副本（ CES 为 M），嗅探到 x Read 事务，就会将 x 的最新副本写入主存，构造 Read Response 发送到<br>
BUS 上，并将 CES 更新为 S ；如果有多个处理器缓存都拥有变量 x 的最新副本，则通过某种策略来选择从某个高速缓存来提供新值还是直接由主存来提供新值。</li>
<li>STEP3 -- P1 嗅探到到 x Read Response ，将 CES 更新为 S，写入相应的缓存块。<br>
注意：任何一个处理器在嗅探到缓存块的 BUS Read 事务，且相应缓存块为 M 状态时，都会执行 STEP2 操作。</li>
</ul>
<h4> 缓存写</h4>
<p>写是指将变量 x 的最新值写到缓存块。对一个处于 E 或 I 状态的缓存块的写操作，将其置为 M<br>
状态之前，所有其他处理器缓存拷贝都必须通过一个排它读总线事务将自己的缓存作废。如果缓存状态是 M/E ，则不发送总线事务；遵循如下步骤：</p>
<ul>
<li>STEP1：P1 发送总线排它读事务；</li>
<li>STEP2：其他处理器嗅探到总线排它读事务，更新 CES 为 I，再发送 Invalidate Acknowledge ；后续读会产生一次缓存不命中，从而通过一次总线读事务读取最新值。</li>
<li>STEP3：P1 收到所有 Invalidate Acknowledge ，将 CES 更新为 E，获得数据控制权。然后写入缓存行，将 CES 更新为 M。CPU<br>
写需要等待其他处理器都发送 Invalidate Acknowledge 消息，此时会有写等待问题。</li>
</ul>
<h4> 缓存替换</h4>
<p>当一个缓存块被替换时：</p>
<ul>
<li>如果缓存块处于 S 或 I, 则逻辑上直接更新为 I; 如果缓存块处于 M 状态，则从 M 到 I 的状态转换会触发一次回写事务，将缓存块的状态写入主存。</li>
</ul>
<h4> 写等待问题</h4>
<p>写缓冲器（Store Buffer）、无效化队列（Invalidate Queue）。CPU 会直接先写 Store Buffer ，再同步缓存。其他处理器则会将消息存入<br>
Invalidate Queue 就发送 Invalidate Acknowledge ，异步去更新 CES 。 写缓冲器和无效化队列将 CPU<br>
缓存副本更新变成异步处理。读则采用存储转发，先查询写缓冲器，再查询高速缓存。相当于写缓冲器又加了一层缓存。写缓存异步化又会带来一致性问题。</p>
<h4> 主存屏障</h4>
<p>Store Barrier 和 Load Barrier 。Store Barrier 将 Store Buffer 的数据写入缓存； Load Barrier 根据 Invalidate Queue<br>
的主存地址，将相应的 CES 更新为 I。</p>
<h2> 缓存读写一致性</h2>
<p>要正确使用缓存，必然要保证缓存并发读写的一致性。缓存读写一致性需要保证：</p>
<ul>
<li>源数据与缓存的同一数据达成一致性（或者达成不一致时延可接受的最终一致性）。</li>
<li>以源数据的数据为准。<br>
可以采用 [ xC, xDB, yC, yDB ] 操作序列分析读写一致性问题，x,y 是读、更新、删除，C 表示缓存，DB 表示数据库（源数据）。</li>
</ul>
<p>首先框定讨论范围：两个线程 A, B，一个变量 x ，数据源 DB 和 缓存 C ，其中 C 从 DB 中获取，需要与 DB 保持一致， A,B 有读写操作，读为<br>
RD， 写可以进一步分为更新值 UP 和删除值操作 DE，读写时序不确定。</p>
<p>缓存读模式是确定的：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读 DB。这点无异议。如果 A, B<br>
并发读，均直接从 C 中获取当前值即可。如果 C 中没有值，那么 A, B 可能都会从 DB 获取。在大并发的情形下，会有缓存击穿/穿透的问题。缓存击穿和穿透的问题在后面讨论。</p>
<p>当两个线程处于并发读-并发写，或者并发写-并发写的时候，可以有两种方案：加锁和不加锁。</p>
<ul>
<li>对更新 DB 和更新 C 进行加分布式锁，使之原子化。加锁会更简单，但吞吐量会比较低；</li>
<li>对更新 DB 和 更新 C 不加锁，保证合理的执行顺序，使之达到最终一致性（业务可接受一定的不一致时延）。<br>
以下主要讨论不加锁的方案。分情形讨论：</li>
</ul>
<h4> A写-B读</h4>
<p>先指明期望结果：</p>
<ul>
<li>
<p>如果 B 在 A 写之前读，那么 B 读到的是写之前的值，直接从 C 中获取即可。没问题。</p>
</li>
<li>
<p>如果 B 在 A 写之后读，那么 B 读到的应该是写之后的值。<br>
那么 A 该如何写，才能保证 B 读到最新的值？</p>
</li>
<li>
<p>A 先更新 C，再写 DB。会有什么问题 ？ 如果 A 先更新了 C ，然后更新 DB 失败了，那么 C 与 DB 就不一致了。DB 里是旧值。不符合一致性保证。当然，读<br>
C 会读到新值。可以有一种思路，就是缓存作为读写的前置环节，负责缓存与 DB 的最终一致性。这种方案也是可以接受的。这是 Write<br>
Behind Caching Pattern 模式。</p>
</li>
<li>
<p>A 先删除 C， 再写 DB。会有什么问题？ 如果操作时序是 [ A 删除 C， B 读 C，A 更新 DB ]， 那么在 A 更新 DB 之前，B 读 C 未命中，从<br>
DB 读到旧值，而 A 更新 DB， DB 与 C 的值不一致。不符合一致性保证。</p>
</li>
<li>
<p>A 先写 DB ，再更新 C。会有什么问题？ 1. 更新缓存可能是代价昂贵的操作，频繁更新缓存会导致吞吐量降低；在更新 C<br>
之前读到的是旧值，如果更新操作比较耗时，那么 DB 和 C 的不一致时延会比较大，会影响业务。</p>
</li>
<li>
<p>A 先写 DB ，再删除 C。 会有什么问题？ 避免了更新代价高的问题，在删除 C 之前读到的是旧值，在删除 C<br>
之后读到新值。由于删除缓存往往代价很小，不一致时延通常可接受。这是 Cache Aside Pattern 模式。</p>
</li>
</ul>
<h4> A写-B写</h4>
<ul>
<li>期望结果：无论 A 先写还是 B 先写，最终写入的 DB 和 C 的值应当一致。</li>
<li>A 先更新 C，再写 DB。 会有什么问题？如果操作时序是 [ A 写 C x， B 写 C y， B 写 DB y， A 写 DB x]，会导致 C 是 y , DB 是 x<br>
，DB 与 C 中的数据不一致。</li>
<li>A 先写 DB， 再更新 C。会有什么问题？[ A 写 DB x， B 写 DB y， B 写 C y， A 写 C x]，会导致 C 是 x , DB 是 y ，DB 与 C 中的数据不一致。<br>
从上述分析可知：1. 更新缓存操作可能是一个代价昂贵的操作，会导致 DB 与 C 达到最终一致性的不一致时延较长，对业务有影响； 2.<br>
在并发写-写模式下，DB 和 C 的数据会不一致，从而读到不一致的数据。因此，一般不采用更新缓存的方式，而是直接删除缓存。</li>
</ul>
<p>常见的缓存读写模式有 Cache Aside Pattern 和 Write Behind Caching Pattern 。</p>
<ul>
<li>Cache Aside Pattern：读取数据时，先读缓存，缓存命中则直接返回（查询性能提升体现在这里），未命中再去读<br>
DB。读更写删。读模式基本是固定的；写入数据时，先更新 DB ，再删除缓存。可以采集 DB binlog 异步删除缓存。如果是主从<br>
DB，则必须采集最后一个从库 binlog （最终一致性）。</li>
<li>Write Behind Caching Pattern --- 写入时只更新缓存，异步去更新 DB 。牺牲短暂的一致性来获得高吞吐量。</li>
</ul>
<h2> 缓存热身</h2>
<p>空缓存会直接导致不命中，从而影响第一次读的性能。如果大并发访问空缓存（类似缓存雪崩），很容易导致大量并发请求直接打到 DB 上，使得<br>
DB 压力陡增。</p>
<p>缓存热身即是预先把一些数据加载到缓存，提升第一次访问的性能，同时防止第一次访问面临大并发时会将后台打出问题。比如在应用启动后，可以将一些<br>
TOPN 商品异步加载到缓存（不能影响应用启动）；商家做活动前，把一些活动商品和活动信息数据加载到缓存（可配置化）；把一些极少变动的静态数据加载到缓存。加载缓存可以使用应用通知机制，比如实现<br>
ApplicationListener 的<br>
onApplicationEvent 方法。</p>
<h2> 缓存替换策略</h2>
<p>缓存总有未命中的情况：</p>
<ul>
<li>空不命中：总是不会命中，亦称冷缓存。避免冷缓存的方法是进行“缓存热身”。将 k+1 层的缓存块放到第 k<br>
层的策略称为放置策略。通常采用取模的方式: j = i Mod N ，即：将第 k+1 层的第 i 个块对 N 取模后，放到第 k 层的第 i 个块里。</li>
<li>冲突不命中：比如按取模的放置策略，有可能在缓存未满的情况下，总是对第 k 层的同一个块进行替换。比如 j mod 4 ，当 j=0,4,8,12<br>
时，总是会放在到第 0 块上。缓存抖动是一种特殊的冲突不命中，指高速缓存反复加载或驱逐相同的高速缓存块/组/行。</li>
<li>容量不命中：缓存容量满了。</li>
</ul>
<p>缓存替换策略是指当缓存未命中，且缓存容量已满时，判断要替换哪个块的缓存数据。原则上，应该淘汰：1. 只访问过一次的数据； 2.<br>
相比其他数据更少访问的； 3. 在一段时间内没有再访问的。</p>
<p>缓存替换策略主要有 FIFO, LRU, LFU。</p>
<ul>
<li>FIFO ： 最先进入缓存的首先被淘汰。队列实现。或者使用双向链表，新进入元素添加到链表尾，丢弃链表头的元素。FIFO适合丢弃那些只有一次访问的数据。</li>
<li>LRU ：最近最少使用淘汰。使用链表实现，若缓存命中，则将节点移至首部，淘汰尾部节点。 LRU 适合热点数据访问。LRU<br>
无法识别哪些缓存是最多被访问的。偶发性、周期性的批量操作可能导致缓存被大量替换，造成缓存污染，使得 LRU 的效率大幅下降。实际采用<br>
LRU-K 算法，将缓存分为两级，数据在较短时间被访问 K 次以上，则进入二级缓存。两级都采用 LRU 策略。</li>
<li>LFU ： 最少次数使用淘汰。引用计数 + 优先级队列（堆）。</li>
</ul>
<h2> 缓存清理策略</h2>
<p>当缓存对应的原始数据更新后，缓存里的数据就与原始数据不一致了，即缓存失效了。这时候需要及时清理缓存，避免读到过期数据以及过期数据占用过大的内存。缓存清理策略是指什么时候清理过期或失效缓存。</p>
<ul>
<li>TTL： 设置过期时间。 TTL 一般以数据变化频繁度为依据来设置。不同业务数据的过期时间不一样。</li>
<li>写时失效： 写失效、写更新。写失效 - 标记缓存数据已过期，读时清理或替换；写更新 - 在更新数据时就替换缓存项。</li>
<li>读时失效：写时只标注失效信息，读时判断是否失效并加载最新数据。如果有大量缓存对象要更新，可以采用读时失效将写更新成本分摊到每一个读上。缓存对象时，同时存储相应的版本号或时间戳。需要展示数据时，通过对比版本号来判断是否缓存已失效。</li>
</ul>
<h2> 缓存击穿/雪崩/穿透</h2>
<ul>
<li>缓存击穿【重点】。 热点问题。大并发集中对热点 key 进行访问，当这个 key<br>
在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。基本方案：多级缓存（不同失效时间）+<br>
热点散列 + 热点识别、熔断降级、互斥锁、不过期+异步更新。</li>
<li>缓存雪崩。 大量 key 同时失效，导致大量请求打到 DB，造成巨大 DB 压力和系统不稳定。基本方案：过期时间+随机化。</li>
<li>缓存穿透。大量不存在的 key 的非法访问请求，同样会使得大量请求打到 DB。使用布隆过滤器过滤大量非法请求。还有一种方法是空值缓存，失效时间设置小一些，应对短时间内无效重复<br>
key 的大量查询。</li>
<li>缓存命中统计、缓存监控。</li>
<li>注意
<ul>
<li>缓存穿透：请求Key是大量数据，不存在于缓存，也不存在于数据库</li>
<li>缓存击穿：请求Key是热点数据，不存在于缓存（缓存过期），存在于数据库</li>
<li>缓存雪崩：请求Key是大量数据，缓存大面积失效，打到数据库</li>
</ul>
</li>
</ul>
<h2> 缓存实现</h2>
<p>以本地缓存为例，来分析缓存实现。本地缓存通常在单机共享范围内：某个进程内的被多次访问的主存数据；单机范围内的多进程共享的主存数据。要实现缓存功能，通常需要考虑如下因素：</p>
<ul>
<li>
<p>缓存的规格指定，会影响缓存的创建和性能。</p>
</li>
<li>
<p>缓存的值的计算和迟加载。</p>
</li>
<li>
<p>缓存策略的配置。</p>
</li>
<li>
<p>缓存对并发的支持。</p>
</li>
<li>
<p>缓存更新的通知与监听。</p>
</li>
<li>
<p>缓存的监控与统计。<br>
Guava.Cache 是本地缓存的一个实现。核心类是 CacheBuilderSpec (规格指定)、CacheBuilder (根据缓存规格创建缓存)、LocalCache (<br>
缓存功能的核心实现类)。 LocalCache 的底层是一个哈希表，支持并发访问，实现了 ConcurrentMap 接口。实现要点如下：</p>
</li>
<li>
<p>缓存数据的读写与 ConcurrentHashMap 类似。</p>
</li>
<li>
<p>有两个用双向链表实现的优先级队列： writeQueue 和 accessQueue ，用来控制缓存何时过期。writeQueue 按写时间排序，accessQueue<br>
按访问时间排序。在每次写入或更新或清理操作的时候，会执行清理操作，根据这两个队列来判断缓存数据是否过期，如果过期则从缓存数据哈希表中移除。</p>
</li>
</ul>
<h2> 高效应用缓存</h2>
<h4> 缓存友好的代码</h4>
<p>针对连续型存储的高速缓存，编写对缓存友好的代码。比如聚焦核心函数的循环；减少循环内部不命中的数量；对局部变量的反复引用；步长为<br>
1 的顺序引用模式；多重循环中的循环变量的次序。</p>
<p>换言之，每个循环都会在高速缓存上产生很大的影响，进而影响程序运行性能。对于上层应用可能感知不明显，但是对于底层却很重要。</p>
<figure><figcaption>img_1.png</figcaption></figure>
<h4> 服务实例缓存</h4>
<p>凡是将数据进行变换后存储起来，在将来的计算中重复多次使用，都是缓存的实现形式。最常见的就是服务单例缓存。比如在类<br>
DefaultSingletonBeanRegistry 中的 singletonObjects 单例缓存，可用来解决循环引用依赖问题 ：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 缓存与动态规划</h4>
<p>动态规划法通常会复用到子问题的解，因此可以使用缓存来存储子问题的解。一个简单的例子如下，计算阶乘：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> HTTP缓存</h4>
<ul>
<li>HTTP 缓存原理：HTTP 缓存服务器上会保存原始服务器上的文档副本。当 HTTP 请求到来时，若缓存命中，则直接返回文档副本，而无需再与原始服务器通信。</li>
<li>缓存再验证：HTTP<br>
缓存服务器会发送特殊请求（无需取整个文档对象），与原始服务器的文档比较，检测缓存副本是否过期；如果检测到未过期 ,<br>
缓存服务器会获取到新的首部和新的过期时间，更新缓存首部，再将文档副本标识为“未过期”的；若检测到缓存副本过期了，则从原始服务器取最新的文档并生成新的文档副本。</li>
<li>缓存命中统计：缓存请求命中占比；缓存字节命中占比。</li>
<li>缓存层次结构：可以使用多级缓存。可分为私有缓存和公有缓存，私有缓存通常是用户浏览器缓存，存放在本地磁盘上；公有缓存则是 HTTP<br>
缓存服务器（可能是代理服务器、CDN服务器）。私有缓存可以作为第一级缓存，公有缓存作为第二级或第 N 级缓存。</li>
<li>缓存过期标识：可使用 Cache-Control 和 Expires 来标明缓存副本何时过期，是否需要做缓存再验证。缓存服务器从 HTTP<br>
请求中解析出首部，并与缓存里的 Cache-Control ( max-age 从生成文档到过期的生存时间，秒为单位 ) 和 Expires (<br>
过期绝对日期 ) 配置进行比较，如果已经超过指定期限，则要做缓存再验证操作。由于时钟不准确，一般不推荐使用 Expires 首部。</li>
<li>条件再验证：将缓存再验证与获取新的缓存副本合为一个请求。主要有 If-Modified-Since 和 If-None-Match。</li>
<li>If-Modified-Since 首部：将 If-Modified-Since 首部添加的 GET 请求中，告知原始服务器，仅当其内容已经修改，才返回修改后的文档对象。若原始服务器文档没有修改，则返回<br>
304 Not Modified ；若文档已修改，返回完整的对象；若文档已删除，则返回 404 Not Found ，缓存服务器会将副本删除。If-Modified-Since<br>
可以与 Last-Modified 配合使用。</li>
<li>If-None-Match:Etags: 当日期不足以区分文档的过期时，可以使用 If-None-Match:Etags 。实际上类似一个版本号。</li>
<li>Cache-Control: no-store （禁止缓存复制响应）, no-cache ( 在进行再验证之前不可提供缓存副本 ), must-revalidation (<br>
必须进行缓存再验证), max-age ( 在指定秒数之后进行缓存再验证 ), max-stale, min-fresh</li>
<li>试探性过期算法：如果 If-Modified-Since 和 If-None-Match<br>
都没有提供，则根据最近修改时间，智能推断需要缓存的时间。若最近修改时间很久，则认为文档稳定，可以缓存更长时间，若最近修改时间很近，则认为文档易变，将缓存时间改下一点。有点自适应缓存的意味。LM-Factor<br>
是一种常用的试探性过期算法。<code>$time_since_modify = max(0, $server_Date - $server_Last_Modified); $server_freshness_limit = int($time_since_modify * $lm_factor);</code></li>
<li>设置缓存的工具： Apache web 服务器 ( mod_headers, mod_expires )，META HTTP-EQUIV 标签。</li>
</ul>
<h4> 分布式缓存</h4>
<p>一般采用 Redis 来做多机共享的分布式缓存。一些有效做法：</p>
<ul>
<li>命名空间规范和隔离，部署隔离，避免业务相互影响和耦合。</li>
<li>采用批量获取缓存数据的方法提升查询性能，减少网络传输开销。</li>
<li>尽量使用 O(1) 的命令，避免使用遍历性命令。</li>
<li>单个 key 的 value 不超过 10KB, list, set, map 等不超过 1000 个元素。</li>
<li>设置合理的定期删除/惰性删除/缓存替换策略。</li>
<li>测量缓存的命中率及性能提升情况；若数据不理想，则要仔细分析原因并优化。</li>
<li>监控大对象缓存。</li>
</ul>
<p>要避免的坑：</p>
<ul>
<li>内存占用和缓存同步要特别注意，避免内存占用大、同步慢影响了业务。</li>
<li>缓存主要用来提升性能，不要当做持久化存储使用，避免数据丢失的风险。</li>
<li>避免滥用和浪费缓存资源。主存缓存是比较昂贵的资源。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计考量</title>
    <id>https://ujava.cn/synthesis/consider.html</id>
    <link href="https://ujava.cn/synthesis/consider.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> 1、系统拆分</h2>
<p>有句古话 “牵一发而动全身”。</p>
<p>面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。</p>
<p>万物相通，回到我们的软件架构。</p>
<p>早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。</p>
<p>“鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。</p>
<p>因此，系统拆分 成了更多人的选择。</p>
<p>慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> 1、系统拆分</h2>
<p>有句古话 “牵一发而动全身”。</p>
<p>面对一个庞然大物，如果没有一个合理的分工分层。任何一个小小失误都会被无限放大，酿成巨大灾难。</p>
<p>万物相通，回到我们的软件架构。</p>
<p>早前的系统都是单体系统，比如电商业务，会员、商品、订单、物流、营销等模块都堆积在一个系统。每到节假日搞个大促活动，系统扩容时，一扩全扩，一挂全挂。只要一个接口出了问题，整个系统都不可用。</p>
<p>“鸡蛋不能放在一个篮子里”，这种连带风险换谁都承受不起。</p>
<p>因此，系统拆分 成了更多人的选择。</p>
<p>慢慢的就有了我们现在看到的微服务架构，将一个复杂的业务域按核心边缘业务/DDD的思想拆分成若干子系统，每个子系统负责专属的业务功能，做好垂直化建设，各个子系统之间做好边界隔离，降低风险蔓延。</p>
<h2> 2、解耦</h2>
<p>软件开发有个重要原则“高内聚、低耦合”。</p>
<p>小到接口抽象、MVC 分层，大到 SOLID 原则、23种设计模式。核心都是降低不同模块间的耦合度，避免一处错误改动影响到整个系统。</p>
<p>就以开闭原则为例，对扩展是开放的，对修改是关闭的。随着业务功能迭代，如何做到每次改动不对原来的旧代码产生影响。</p>
<p>高内聚，低耦合方案（解耦方案）：</p>
<p>动态代理技术，通过对字节码进行增强，在方法调用的时候进行拦截，以便于在方法调用前后，增加我们需要的额外处理逻辑。</p>
<p>事件机制，通过发布订阅模式，新增的需求，只需要订阅对应的事件通知，针对性消费即可。不会对原来的代码侵入性修改，是不是会好很多。</p>
<p>队列，将消息丢往队列，消费者消费消息，提高可扩展性，性能</p>
<h2> 3、异步</h2>
<p>同步指一个进程在执行请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</p>
<p>效率会大大降低，聪明的人想到了 异步 方式。</p>
<p>如果是非实时响应的动作可以采用异步来完成，线程不需要一直等待，而是继续执行后面的逻辑。</p>
<p>如：线程池（ThreadPoolExecutor）、规则推送、消息队列 等都是这个原理</p>
<p>比如一个用户在淘宝下了一笔购物订单，关心的是订单是否创建成功，能否进行后续的付款流程</p>
<p>至于其他业务动作，如短信通知、邮件通知、生成订单快照、创建超时任务记录，这些非核心动作用户并不是特别关心。</p>
<p>我们可以采用消息队列的发布/订阅 机制，数据库插入订单记录后，发布一条消息到 MQ，然后就可以告知用户下单成功。</p>
<p>其他事情，由不同的 Task 任务订阅消息异步处理，彼此间互不干扰。</p>
<h2> 4、重试</h2>
<p>重试主要是体现在远程的RPC调用，受 网络抖动、线程资源阻塞 等因素影响，请求无法及时响应。</p>
<p>为了提升用户体验，调用方可以通过 重试 方式再次发送请求，尝试获取结果。比过：浏览器的 F5 刷新机制就是类似道理。</p>
<p>接口重试是一把双刃剑，虽然客户端收到了响应超时结果，但是我们无法确定，服务端是否已经执行完成。如果盲目地重试，可能会带来严重后果。比如：银行转账。</p>
<p>重试通常跟幂等组合使用，如果一个接口支持了 幂等，那你就可以随便重试</p>
<p>1、幂等性概念</p>
<p>顾名思义，所谓幂等就是对于数据的操作不论多少次，但始终操作的结果是一致的。也就是说，无论相同的查询操作多少次，得到结果始终只是一次的结果和影响。</p>
<p><strong>保证幂等方案</strong></p>
<h4> 1、查询操作：查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作；</h4>
<h4> 2、删除操作：删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个) ；</h4>
<h4> 3、唯一索引：防止新增脏数据。比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录。要点：唯一索引或唯一组合索引来防止新增数据存在脏数据（当表存在唯一索引，并发时新增报错时，再查询一次就可以了，数据应该已经存在了，返回结果即可）；</h4>
<h4> 4、token机制（防止重复提交）</h4>
<p>方式一：</p>
<p>原理上通过session token来实现的(也可以通过redis来实现)<br>
。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。</p>
<p>服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p>
<p>方式二：</p>
<p>调用方在调用接口时候先向后端请求一个全局ID（Token），请求的时候携带全局ID一起请求，后端需要用这个Token作为Key，用户信息作为Value到Redis中进行键值内容校验，如果Key存在且Value匹配就执行删除命令，然后执行后面的业务逻辑。如果不存在对应的Key或者Value不匹配就返回执行错误的信息。</p>
<p><br>
方式三：</p>
<p>请求每次访问时候，会记录当前请求相同参数，url的信息，访问时间，到期时间等放入redis，定义一个一定时间内防止重复处理的时间间隔，如果下次请求来的时候，通过url，参数等信息获取redis中的请求信息，如果redis中记录的访问时间小于上次请求时间+固定的时间间隔，就不允许访问。</p>
<h4> 5、乐观锁</h4>
<p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。乐观锁的实现方式多种多样可以通过version或者其他状态条件：<br>
</p>
<h4> 6、分布式锁</h4>
<p>如果是分布式系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(<br>
redis或zookeeper)<br>
，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(<br>
用户ID+后缀等)<br>
获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(<br>
分布式锁要第三方系统提供)；</p>
<h4> 7、select + insert</h4>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法；</p>
<h4> 8、状态机幂等</h4>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)<br>
，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。注意：订单等单据类业务，存在很长的状态流转，一定要深刻理解状态机，对业务系统设计能力提高有很大帮助</p>
<h4> 9、对外提供接口的api如何保证幂等</h4>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号；source+seq在数据库里面做唯一索引，防止多次付款(<br>
并发时，只能处理一个请求) 。</p>
<p>重点：对外提供接口为了支持幂等调用，接口有两个字段必须传，一个是来源source，一个是来源方序列号seq，这个两个字段在提供方系统里面做联合唯一索引，这样当第三方调用时，先在本方系统里面查询一下，是否已经处理过，返回相应处理结果；没有处理过，进行相应处理，返回结果。注意，为了幂等友好，一定要先查询一下，是否处理过该笔业务，不查询直接插入业务系统，会报错，但实际已经处理了。</p>
<h2> 5、补偿</h2>
<p>我们知道不是所有的请求都能收到成功响应。除了上面的 重试 机制外，我们还可以采用补偿玩法，实现数据最终一致性。</p>
<p>业务补偿根据处理的方向分为两部分：</p>
<ul>
<li>正向。多个操作构成一个分布式事务，如果部分成功、部分失败，我们会通过最大努力机制将失败的任务推进到成功状态</li>
<li>逆向。同上道理，我们也可以采用反向操作，将部分成功任务恢复到初始状态</li>
</ul>
<p>注意：补偿操作有个重要前提，业务能接受短时间内的数据不一致。</p>
<p>补偿有很多的实现方式：</p>
<p>1、本地建表方式，存储相关数据，然后通过定时任务扫描提取，并借助反射机制触发执行</p>
<p>2、也可以采用简单的消息中间件，构建业务消息体，由下游的的消费任务执行。如果失败，可以借助MQ的重试机制，多次重试</p>
<h2> 6、备份</h2>
<p>任何服务器都有宕机的可能性，一旦存储了数据，带上状态，如果发生故障，数据丢失，后果是我们无法承受的。</p>
<p>所以，容灾备份也就变成了互联网的基本能力。</p>
<p>那如何备份，不同的框架有不用的玩法。我们以 Redis 为例：</p>
<p>Redis 借助 RDB 和 AOF 来实现两台服务器间的数据同步</p>
<ul>
<li>RDB，全量数据同步</li>
<li>AOF，增量数据同步，回放日志</li>
</ul>
<p>一旦主节点挂了怎么办？</p>
<p>这里引入哨兵机制。哨兵机制可以实现主从库的自动切换，有效解决了故障转移。整个过程分为三个阶段：监控、选主、通知。</p>
<p>除了 Redis 中间件外，其他常见的 MySQL、Kafka 消息中间件、HBase 、ES 等 ，凡是涉及到数据存储的介质，都有备份机制，一旦主节点挂了，会启用备份节点，保证数据不会丢失。</p>
<h2> 7、多活策略</h2>
<p>虽然有了上面的备份策略，那是不是就万事大吉呢？</p>
<p>在一些极端情况，如：机房断电、机房火灾、地震、山洪等不可抗力因素，所有的服务器都可能出现故障，无法对外提供服务，导致整体业务瘫痪。</p>
<p>为了降低风险，保证服务的24小时可用性，我们会采用 多活策略。</p>
<p>常见的多活方案有，同城双活、两地三中心、三地五中心、异地双活、异地多活</p>
<p>不同的方案技术要求、建设成本、运维成本也都不一样。</p>
<p>多活的技术方案复杂，需要考虑的问题点也非常多，这里只是抛砖引玉就不过多展开</p>
<h2> 8、隔离</h2>
<p>隔离属于物理层面的分割，将若干的系统低耦合设计，独立部署，从物理上隔开。</p>
<p>每个子系统有自己独立的代码库，独立开发，独立发布。一旦出现故障，也不会相互干扰。当然如果不同子系统间有相互依赖，这种情况比较特殊，需要有默认值或者异常特殊处理，这属于业务层面解决方案。</p>
<p>隔离属于分布式技术的衍生产物，我们最常见的微服务解决方案。</p>
<p>将一个大型的复杂系统拆分成若干个微服务系统，这些微服务子系统通常由不同的团队开发、维护，独立部署，服务之间通过 RPC 远程调用。</p>
<p>隔离使得系统间边界更加清晰，故障可以更加隔离开来，问题的发现与解决也更加快速，系统的可用性也更高。</p>
<h2> 9、限流</h2>
<p>高并发系统，如果遇到流量洪峰，超过了当前系统的承载能力。我们要怎么办？</p>
<p>一种方案，照单全收，CPU、内存、Load负载飚的很高，最后处理不过来，所有请求都超时无法正常响应。</p>
<p>另一种解决方案，“舍得，有舍有得”，多余的流量我们直接丢弃。</p>
<p>限流定义：</p>
<p>限制到达系统的并发请求数量，保证系统能够正常响应部分用户请求，而对于超过限制的流量，则通过拒绝服务的方式保证整体系统的可用性。</p>
<p>根据作用范围：限流分为单机版限流、分布式限流</p>
<p>1、单机版限流</p>
<p>主要借助于本机内存来实现计数器，比如通过AtomicLong#incrementAndGet()，但是要注意之前不用的key定期做清理，释放内存。</p>
<p>纯内存实现，无需和其他节点统计汇总，性能最高。但是优点也是缺点，无法做到全局统一化的限流。</p>
<p>2、分布式限流</p>
<p>单机版限流仅能保护自身节点，但无法保护应用依赖的各种服务，并且在进行节点扩容、缩容时也无法准确控制整个服务的请求限制。而分布式限流，以集群为维度，可以方便的控制这个集群的请求限制，从而保护下游依赖的各种服务资源。</p>
<p>限流支持多个维度：</p>
<ul>
<li>整个系统一定时间内（比如每分钟）处理多少请求</li>
<li>单个接口一定时间内处理多少流量</li>
<li>单个IP、城市、渠道、设备id、用户id等在一定时间内发送的请求数</li>
<li>如果是开放平台，则为每个appkey设置独立的访问速率规则</li>
</ul>
<p>常见的限流算法：</p>
<ul>
<li>计数器限流(固定窗口限流)</li>
<li>滑动窗口限流</li>
<li>漏桶限流</li>
<li>令牌桶限流</li>
</ul>
<h2> 10、熔断</h2>
<p>熔断，其实是对调用链路中某个资源出现不稳定状态时（如：调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p>
<p>熔断的主要方式是使用断路器阻断对故障服务器的调用</p>
<p>断路器有三种状态，关闭、打开、半打开。</p>
<ul>
<li>1、关闭（Closed）状态：在这个状态下，请求都会被转发给后端服务。同时会记录请求失败的次数，当请求失败次数在一段时间超过一定次数就会进入打开状态。</li>
<li>2、打开（Open）状态：在这个状态下，熔断器会直接拒绝请求，返回错误，而不去调用后端服务。同时，会有一个定时器，时间到的时候会变成半打开状态。目的是假设服务会在一段时间内恢复正常。</li>
<li>3、半打开（Half Open）状态：在这个状态下，熔断器会尝试把部分请求转发给后端服务，目的是为了探测后端服务是否恢复。如果请求失败会进入打开状态，成功情况下会进入关闭状态，同时重置计数。</li>
</ul>
<h2> 11、降级</h2>
<p>降级是系统保护的一种重要手段。</p>
<p>正如 “好钢用在刀刃上”，为了使有限资源发挥最大价值，我们会临时关闭一些非核心功能，减轻系统压力，并将有限资源留给核心业务。</p>
<p>比如电商大促，业务在峰值时刻，系统抵挡不住全部的流量时，系统的负载、CPU<br>
的使用率都超过了预警水位，可以对一些非核心的功能进行降级，降低系统压力，比如把商品评价、成交记录等功能临时关掉。弃车保帅，保证<br>
创建订单、订单支付 等核心功能的正常使用。</p>
<p>当然，不同业务、不同公司，处理方式也各不相同，需要结合实际场景，和业务方同学一块讨论，最后达成一个统一认可的降级方案。</p>
<p>总结下来：降级是通过暂时关闭某些非核心服务或者组件从而保护核心系统的可用性。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计数据库索引</title>
    <id>https://ujava.cn/synthesis/databaseindex.html</id>
    <link href="https://ujava.cn/synthesis/databaseindex.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。</p>
<h2> 基本知识</h2>
<p>InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。</p>
<p>索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>建立最优的数据库索引是提升数据库查询性能的重要手段。在某种意义上，索引就是磁盘记录在内存中的缓存。索引要做的事情，就是快速找到匹配条件的记录行，并尽可能减少磁盘读写次数。本文总结数据库索引相关的知识及实践。</p>
<h2> 基本知识</h2>
<p>InnoDB 里表数据是按照主键顺序存放的。InnoDB 会按照表定义的第一个非空索引（按索引定义顺序）作为主键。 索引（在 MySQL 中）是由存储引擎实现的。索引类型主要有顺序索引和哈希索引。顺序索引的底层结构是 B+Tree ，哈希索引的底层结构是哈希表。</p>
<p>索引是以空间换时间，减少了要扫描的数据量、避免排序、将随机IO变成顺序IO。使用索引的代价是：空间占用更大、插入和更新成本更大。顺序索引可支持：全值匹配、最左顺序匹配、列前缀匹配、范围匹配、精确匹配数列并范围匹配一列、只访问索引的查询、索引扫描排序。哈希索引可支持：全值匹配。</p>
<h4> 顺序索引</h4>
<p>InnoDB 的顺序索引是将主键列表构建成一棵 B+ 树。内节点存放的是均是主键值，叶子节点存放的是整张表的行数据。这样，可以让节点尽可能存放更多的主键值，从而降低树的高度。B+ 树是有序查找平衡树，高度通常在 2-4 之间，因为要尽可能减少磁盘读写次数。B+ 树的插入操作在节点关键数满的情况下，会分裂成两个子节点。理解 B+ 树对于理解顺序索引非常关键。</p>
<p>顺序索引可以分为聚簇索引和非聚簇索引。</p>
<p>聚簇索引：在叶子节点中保存了 B-Tree 索引和数据行。将索引列放在内节点上，而将行数据放在叶子节点上。聚簇索引可以极大提升 IO 密集型的性能。一个表只能有一个聚簇索引，通常用主键列。聚簇索引的最优插入顺序是按照主键值顺序插入。如果是随机插入，更新聚簇索引的代价较高：更多的查找操作、频繁的“页分裂”、移动大量数据、产生碎片。<br>
非聚簇索引：非聚簇索引的内节点存放的是非聚簇索引列的值，叶子节点存储的是对应数据行的主键值。因此，根据非聚簇索引需要两次索引查找。先从叶子节点找到主键值，再根据主键值在聚簇索引里找到数据行。非聚簇索引因为不存储数据行的信息，因此占用空间会比聚簇索引更小。</p>
<h4> 哈希索引</h4>
<p>使用哈希原理实现，性能很高，只能等值匹配，按索引整列匹配、不支持范围查找、不能用于排序。哈希函数可以选择 crc32 或者 md5 的一部分。哈希索引要避免大量冲突同时不占用过多空间。哈希索引的选择性取决于该列哈希列值的冲突度。Memory 引擎支持哈希索引，也支持 B+Tree 索引。可以为较长的字符串（比如 URL）创建哈希索引，在条件中必须同时带上哈希值条件和列值条件。where url = xxx and hashed_url = yyy 。</p>
<p>InnoDB 为某些非常频繁的索引值在 B+ 上在内存中再创建一个哈希索引，称为自适应哈希索引。</p>
<h2> 开发事项</h2>
<h4> 适合做索引的列</h4>
<p>选择性高原则。如果所有行在该列上的“不重复值数量/所有值数量”的比率越高，则选择性越高，越适合做索引。列的选择性：count(distinct(col)) / count(col) 。唯一索引的选择性是 1。使用 show index from tablename ，Cardinality 的值展示了索引列的不重复值的预估值。可以用来判断这个索引是否合适。如果 Cardinality 的值接近于表的记录总数，则是选择性高的。</p>
<p>注意，在单列索引的时候，这个值对应指定索引列的 Cardinality 值，而在联合索引中，这个值对应联合列的 Cardinality 值。如下所示: sid_index 的值为 41659 , tid_index 的值是 101 , sid_index 的选择性高于 tid_index ； stc_id_index.t_id 的值是 3443139 ，是指 (s_id, t_id) 联合索引的值，高于 sid_index 单列索引的选择性。</p>
<p>如何找到高选择性的列呢？</p>
<ul>
<li>定性分析：值比较倾向于唯一的，是高选择性的；而值域在某个有限集合的，是低选择性的。比如 ID 值通常是高选择性的，而 age 值则是低选择性的。</li>
<li>测量分析：使用 count(distinct(col)) / count(col) 来计算，值越接近于 1 的是高选择性的。测量分析通常用于验证或否定。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 构建索引</h4>
<p>先列出所有可能的搜索语句，找到出现的列，将选择性高的列放在最左边，有范围查找的列尽可能放最右边。从左开始逐个将列添加到联合索引里，尽可能覆盖所有搜索语句。可能需要建立多个联合索引来覆盖。最后，要考虑选择语句和排序语句的列，尽可能使用索引覆盖获取列数据，使用索引扫描来排序。</p>
<h4> 联合索引</h4>
<p>联合索引也是一棵 B+ 树，关键字是一个元组。类似索引的多级搜索，逐步大幅减少需要扫描和匹配的行。联合索引搜索遵循最左匹配原则。联合索引需要建立最优索引列顺序。注意，在每个需要搜索的列上建立单列索引，不是联合索引（搜索的时候只能单列搜索后，再用到索引合并来合并结果）。</p>
<p>联合索引匹配遵循最左匹配原则。匹配终止条件：将搜索条件按照联合索引顺序重排列，遇到等值查询（包括 IN 查询）继续，遇到范围查询、BETWEEN、LIKE 查询则终止。无法使用索引的情况：在 where 条件中，索引列在表达式中或对索引列使用函数。</p>
<p>实践中，需要用相同的列但顺序不同的联合索引来满足不同的查询需求。</p>
<h4> 前缀索引</h4>
<p>为长字符串建立索引。使用指定长度的字符串的前缀来建立索引。对于 BLOB, TEXT, 很长的 VARCHAR 列，必须使用前缀索引。前缀索引要选择一个合适的长度：选择性与整列的选择性接近，同时不占用过多空间。前缀索引无法使用 GROUP BY 和 ORDER BY，无法做覆盖扫描。如果字符串后缀或某个部分的选择性更高，也可以做一些预处理转化为前缀索引。思想是相同的。</p>
<p>寻找前缀索引最佳长度的步骤：</p>
<ul>
<li>STEP1 - 先找到该列所有值的 TOPN，可以使用 count as c, col from table group by col order by c desc limit N 语句；</li>
<li>STEP2 - 从一个比较合适的值（比如 3）开始，测试选择性，直到 TOPN 绝大部分列的 c 的数量与 TOPN 的 c 比较接近。</li>
</ul>
<h4> 覆盖索引</h4>
<p>覆盖索引的列包含了所有需要查询的列，可以减少大量的磁盘读，大幅提升性能。如果某个列在 select cols 字句中频繁出现，也可以考虑放在联合索引里，利用覆盖索引来优化性能。延迟关联技术可以使用覆盖索引能力。</p>
<h4> 索引扫描排序</h4>
<p>只有当索引的列顺序与 ORDER BY 字句的顺序完全一致，并且所有列的排序方向都一样时，才能使用索引对结果做排序。有一个例外，就是前导列条件指定为常数。比如 (date, fans_id) 对于 where date = 'xxx' order by fans_id desc 也可以使用索引扫描排序。</p>
<h4> 索引提示</h4>
<p>可以使用 FORCE INDEX(a) 强制指定 SQL 语句要使用的索引。</p>
<h4> MRR</h4>
<p>Multi-Range Read。针对范围查询的优化。MRR 会将查询到的辅助索引键放到缓存里，然后按照主键排序（将随机 IO 转换为顺序 IO，可以减少页替换），再根据排序后主键来顺序来访问实际数据。适用于 range, ref, eq_ref 的查询。</p>
<p>MRR 默认开启。使用 optimizer_switch 的标记来控制是否使用MRR.设置mrr=on时，表示启用MRR优化。<br>
SET @@optimizer_switch='mrr=on,mrr_cost_based=on';</p>
<h4> “系统账号”问题</h4>
<p>索引列的某个值出现次数非常多。应避免使用系统账号值出现在查询语句里。</p>
<h2> 索引实验</h2>
<h4> 准备工作</h4>
<h4> 准备表</h4>
<p>假设有个学生选课表。如下所示：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 准备数据</h4>
<p>写个 groovy 脚本生成 800w 条选课数据。批量插入的效率更高。单个插入，每刷新一次，几千的插入；批量插入，每刷新一次，20w 的插入。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>生成的样例数据如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以查看表空间大小：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 开始试验</h2>
<h4> 给裸表添加索引</h4>
<p>假设什么索引都不建，裸表一个，通过 s_id 搜索需要 2.94s; 添加 sid_index 索引后，同样的搜索不到 0.01s 。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 explain 解释下：</p>
<ul>
<li>select_type：查询类型， SIMPLE 表示这是一个简单的 SELECT 查询；</li>
<li>type: 表的连接类型。 const 表示匹配最多一行，通常是根据主键查询；ref 表示使用非主键/唯一索引匹配少量行； range 表示范围查询，&lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, IN, BETWEEN, LIKE ； index 扫描索引树，但数量太大，相当于全表扫描；ALL 全表扫描。</li>
<li>possible_keys 和 key : 可能使用的索引以及实际使用的索引。</li>
<li>ref: 对于 key 给出的列，哪些列或哪些常量被用来比较了。</li>
<li>rows: 为了找到满足条件的行要扫描的预计行数。</li>
<li>filtered: 被过滤行数的比例。</li>
<li>Extra: 索引使用的额外信息。 Using Where 需要使用 where 字句条件来过滤记录; Using Index 要获取的列信息可以从索引树上拿到; Using filesort 文件排序; Using MRR 是否使用了 MRR 优化范围查询.</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对索引列使用了函数不会使用索引：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假设有如下语句，可以看到使用了索引 sid_index ，从 194 条过滤到最终 3 条。因为 sid_index 已经过滤了绝大多数记录，因此添加 t_id 索引看上去没有必要。不过，这里只是某个 s_id 值的查询结果，不代表其它的 s_id 查询结果。不能仅仅据此就断定不需要加 (s_id, t_id) 联合索引。可以 count group by s_id 看看 s_id 的重复数量，进一步判断。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在删除 sid_index 索引，添加 tid_index 索引。看看情况如何。由于 t_id 选择性较低，添加 tid_index 过滤后仍然有 8w+ 条记录，两条搜索语句耗时 0.4s 左右。计算一下 s_id 和 t_id 的不重复行数量， s_id 更大，选择性更高。这说明：添加选择性高的索引，性能提升更优。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 联合索引</h4>
<p>考虑如下语句。仍然使用 tid_index ，耗时 0.4s 。如果使用联合索引 (tid_index, cid_index) , 则耗时 0.03s 。相当于做了两次索引查找，当然比一次要快。代价是，索引占用空间更高。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合情形一，通常会将多个业务 ID 建成联合索引 (s_id, t_id, c_id) ，这样，(s_id), (s_id, t_id), (s_id, t_id, c_id) 的联合等值查询都可以应用到这个索引。由于 s_id 选择性非常大，可以单独建一个索引（节省索引占用空间）；而 (t_id, c_id) 需要建一个联合索引，因为 (s_id, t_id, c_id) 无法匹配 t_id 和 c_id 联合查询的情况。根据最左匹配原则，s_id 必须出现。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>联合索引是应对多条件查询的性能提升的关键。最左匹配原则是应用联合索引的最重要的原则之一。将查询条件按照联合索引定义的顺序 (a,b,c,d,e) 重新排列，逐个比较：</p>
<ul>
<li>如果查询条件均是等值查询，则出现顺序没有关系，按照联合索引定义顺序重新排列即可。比如 a=1 and b=2 与 b=2 and a=1 是等同的。顺序可以不同，但必须出现。如果 b=2 and c=3 就无法应用联合索引 (a,b,c,d,e) 了，因为 a 没出现。</li>
<li>如果联合索引里没有出现该列，则匹配到此终止。比如 b=2 and a=1 and d = 4 只能应用 (a,b)，因为 c 没出现。</li>
<li>如果联合索引里出现了范围匹配的列，则匹配到该列终止，后面的条件无法应用索引。比如 b=2 and a=1 and d=4 and c in (2,3) 只能应用 (a,b,c) ，因为 c 出现了范围匹配。<br>
在 explain 命令中，可以看 ref , filter 来判断应用了哪些索引。如果没有应用到某个列的索引，也可以删除相应的查询条件，用 explain 命令的 ref 和 rows 来对比是否有变化。如果只应用到了某个索引，则 Extra = Using index condition 。 假设现在只建立了 (s_id, t_id, c_id) 联合索引。可以用 show index from student_courses; 查看建立了哪些索引。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是各语句以及应用联合索引的情况：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 索引覆盖</h4>
<p>索引覆盖是指 select 中的列均出现在联合索引列中。如下两个语句，后面那个语句应用了索引覆盖，Extra = Using index ，取列数据时可以直接从索引中获取，而不需要去读磁盘。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 索引扫描排序</h4>
<p>索引可以用来排序，从而减少随机 IO，提升排序性能。如下三种情况可以应用索引排序：</p>
<ul>
<li>索引列顺序与 ORDER BY 子句的顺序完全一致时，并且所有列的排序方向都相同；如果要关联多张表，则 ORDER BY 引用的排序字段都为第一张表的字段时；</li>
<li>如果前导列为等值查询，后续的 ORDER BY 子句的字段顺序与索引列顺序一致。<br>
如果使用了索引排序，则 type = index ； 如果未能引用索引排序，那么 Extra 会提示 Using filesort 。</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> MRR</h4>
<p>如果使用 MRR 导致的开销过高，也不会开启 MRR。此时，可以使用强制索引，或者设置无论如何都开启 MRR。如下所示，t_id &lt; 'T24' 会开启 MRR，但 t_id &lt; 'T32' 则不会开启。此时，可以强制使用索引 tc_index， 这样，就会使用 MRR。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>数据库是开发人员最常打交道的软件，而索引是高效访问数据库的重中之重。深入理解索引的原理，合理设计适配查询的索引，是有必要下功夫的。</p>
<p>索引基本功：</p>
<ul>
<li>根据查询条件创建高效的索引；</li>
<li>理解最左匹配原则并定义最优的联合索引；</li>
<li>尽可能用好覆盖索引和索引扫描。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">系统设计原则</title>
    <id>https://ujava.cn/synthesis/design.html</id>
    <link href="https://ujava.cn/synthesis/design.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>
<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>
<p>在设计系统时，应该多思考墨菲定律:</p>
<ul>
<li>任何事情都没有表面看起来那么简单</li>
<li>所有的事情都会比你预计的时间长</li>
<li>可能会出错的事一定会出错</li>
<li>如果你担心某种情况发生，那么它就更有可能发生</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>好的系统是迭代出来的。先解决核心问题，预测未来可能出现的问题，对现有的问题有方案，对未来的问题有预案。不是一上来就按1亿用户量设计，也不要过度复杂化系统。</p>
<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是总是有一些原则是可以通用的。</p>
<p>在设计系统时，应该多思考墨菲定律:</p>
<ul>
<li>任何事情都没有表面看起来那么简单</li>
<li>所有的事情都会比你预计的时间长</li>
<li>可能会出错的事一定会出错</li>
<li>如果你担心某种情况发生，那么它就更有可能发生</li>
</ul>
<p>在系统划分时，也要思考康威定律:</p>
<ul>
<li>系统架构是公司组织架构的反映</li>
<li>应该按照业务闭环进行系统拆分/组织架构划分，实现闭环/高内聚/低耦合，减少沟通成本</li>
<li>如果沟通出现问题，那么就应该考虑进行系统和组织架构的调整</li>
<li>在合适时机进行系统拆分，不要一开始就把系统/服务拆得非常细，虽然闭环，但是每个人维护的系统多，维护成本高该处使用的url网络请求的数据。</li>
</ul>
<h2> 一、系统的技术设计原则</h2>
<h3> 1.1.高并发原则</h3>
<h4> 1.1.1.无状态</h4>
<p>如果设计的是无状态的，那么应用比较容易进行水平扩展。</p>
<p>实际生产环境可能是这样的：应用无状态，配置文件有状态。比如，不同的机房需要读取不同的数据源，此时，就需要通过配置文件或配置中心指定。比如后台系统使用session共享机制保证分布式部署。</p>
<h4> 1.1.2.拆分</h4>
<p>在系统设计时，要考虑到系统是否做拆分。如果资源有限，并且用户并没有那么多，可以做一个大而全的系统。</p>
<p>而高并发的应用，通常是要做拆分的。拆分可以依据多个维度：</p>
<ul>
<li>系统维度 ：如订单、库存、商品系统等</li>
<li>功能维度 ：如，对登录系统再拆分，划分为 ：验证码登录、微信登录、密码登录等功能。</li>
<li>读写维度 ：针对读写再做分离，读服务可以使用缓存、写服务使用分库分表。</li>
</ul>
<h4> 1.1.3.服务化</h4>
<p>首先判断单点服务是否可以满足。如果不能满足，集群可以吗？使用Nginx做负载均衡是否可以解决？</p>
<p>服务越来越多，是否要使用服务自动注册与发现？某些服务访问量太大，导致整个系统不可用，要不要上服务降级和限流？哪些是主要服务？</p>
<h4> 1.1.4.消息队列</h4>
<p>消息队列的作用有三个 ：削峰、解耦、异步。</p>
<p>使用消息队列可以实现服务解耦（一对多消费）、异步处理、流量削峰/缓冲等。但是订阅者太多，那么订阅单个消息队列就会成为瓶颈，此时需要考虑对消息队列进行多个镜像复制。</p>
<p>使用消息队列时，需要注意消息丢失、重复接收的场景。这对于不能容忍生产失败的业务场景来说，一定要做好后续的数据处理工作，比如持久化数据同时要增加日志、报警等，或者在生产失败后发送http请求来保证成功。还有消息重复问题，特别是一些分布式消息队列，出于对性能和开销的考虑，在一些场景下会发送消息重复接收，需要在代码层面进行防重处理。</p>
<h4> 1.1.5.缓存</h4>
<p>缓存对读服务来说，是扛流量的必选技术。不同的场景缓存不同的信息，以解决不同的问题：</p>
<ul>
<li>浏览器端缓存</li>
<li>客户端缓存</li>
<li>CDN缓存</li>
<li>接入层缓存: 使用Nginx做一层缓存</li>
<li>应用层缓存</li>
<li>分布式缓存</li>
<li>异步与并发:某些资源实时性没那么高，可以考虑使用异步加载，如用户评价、商品打分这种。获取多个资源时，采用并发的方式获取，可以大大的加快访问速度。</li>
</ul>
<h4> 1.1.6.数据异构</h4>
<p>所谓数据异构，是把数据按需（数据结构、存取方式、存取形式）异地构建存储。比如将mysql里面的数据缓存到redis里面去，就是一种数据异构的方式。</p>
<p>分库分表中有一个最为常见的场景，为了提升数据库的查询能力，我们都会对数据库做分库分表操作。比如订单库，开始的时候是按照订单ID维度去分库分表，那么后来的业务需求按照商家维度去查询。相同的数据需要做多种异构可以使用MQ机制接收数据的变更，然后存储到合适的存储引擎，如订单id纬度的分库分表、商家纬度的分库分表、用户纬度的分库分表、redis、Elasticsearch等。</p>
<p>另外，还需要考虑对历史订单数据进行归档处理，以提升服务的性能和稳定性。而有些数据异构的意义不大，如库存架构，可以考虑异步加载，或者合并并发请求。</p>
<p>总结起来大概有以下几种场景：</p>
<ul>
<li>
<p>数据库镜像</p>
</li>
<li>
<p>数据库实时备份</p>
</li>
<li>
<p>多级索引</p>
</li>
<li>
<p>search build（比如分库分表后的多维度数据查询）</p>
</li>
<li>
<p>业务cache刷新</p>
</li>
<li>
<p>价格、库存变化等重要业务消息<br>
常见的异构方式：</p>
</li>
<li>
<p>完全克隆。做数据备份。将数据库A，全部拷贝一份到数据库B，这样的使用场景是离线统计跑任务脚本的时候可以。缺点也很突出，不适用于持续增长的数据。</p>
</li>
<li>
<p>binlog方式。比如使用比较广泛的canal是基于mysql数据库binlog的增量订阅和消费组件。订阅mysql的binlog日志，消费这些日志做主从同步、缓存更新。</p>
</li>
<li>
<p>MQ方式。业务数据写入DB的同时，也发送MQ一份，也就是业务里面实现双写，消费MQ的数据做各种异构处理。这种方式比较简单，但也很难保证数据一致性，对简单的业务场景可以采用这种方式。</p>
</li>
</ul>
<h3> 1.2.高可用原则</h3>
<h4> 1.2.1.降级</h4>
<p>对于一个高可用服务，很重要的一个设计就是降级开关，提前写好降级逻辑。</p>
<p>可以手动降级，也可以自动降级。自动降级触发的条件可以使用：超时的请求数超过阈值、异常的请求数超过阈值时。阈值具体设置为多少，通过压测初步确认，上线观察后，再次调整。</p>
<p>降级的手段：停止读数据库、准确结果转为近似结果、使用静态结果、同步转异步、功能裁剪、禁止写（高峰期减少不必要的写）、分用户降级、工作量证明POW(<br>
验证码、数学题、拼图、滑块)。</p>
<p>主要依据如下思路：</p>
<ul>
<li>开关集中化管理：通过推送机制把开关推送到各个应用。</li>
<li>可降级的多级读服务：可以指定服务调用降级为只读本地缓存、只读分布式缓存、只读默认数据。</li>
<li>开关前置化: 如架构是Nginx—&gt;Apache，可以将开关前置到Nginx接入层，在Nginx层做开关，请求流量汇源后端应用或者只是一小部分流量回源</li>
<li>业务降级：当高并发流量来袭，保证核心业务是正常的，并保障数据最终一致性即可。这样就把一些同步调用改成异步调用，优先处理高优先级数据或特殊特征的数据，合理分配进入系统的流量，以保障系统可用。</li>
</ul>
<h4> 1.2.2.限流</h4>
<p>当监控发现外部流量超过阈值或内部资源使用达到阈值（通过压测、上线观察、调整）时，告知各系统限流打开。</p>
<p>限流的目的是防止恶意请求流量，或者防止流量超出系统峰值。思路如下：</p>
<ul>
<li>
<p>基于请求的限流：</p>
<ul>
<li>限制请求总量。如腾讯会议最多500人。</li>
<li>限制时间量。如一个时间窗口内最多接受100个请求。</li>
</ul>
</li>
<li>
<p>基于关键资源的限流：</p>
<ul>
<li>统计连接数、线程数、cup等硬件参数。难点是如何确定哪些是关键资源、阈值是多少。</li>
<li>使用池化技术：线程池、连接池；使用队列排队；</li>
</ul>
</li>
</ul>
<p>相关限流的算法：</p>
<ul>
<li>滑动时间窗口：有突刺</li>
<li>漏桶: 请求进入队列的速度不受限制，但是超过队列的大小就拒绝，请求出队列的速度固定。请求会匀速出队列。</li>
<li>令牌桶：系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。有突刺。<br>
有些大流量是正常的用户，这种是要临时的水平扩容。</li>
</ul>
<p>原则是限制流量穿透到后端薄弱的应用层</p>
<h4> 1.2.3.熔断</h4>
<p>熔断发生的三个必要条件，缺一不可，必须全部满足才能开启 hystrix 的熔断功能：</p>
<ul>
<li>
<p>有一个统计的时间周期，滚动窗口；如1000毫秒</p>
</li>
<li>
<p>请求次数必须达到一定数量；如20次</p>
</li>
<li>
<p>失败率达到阈值；如50%<br>
熔断器的三个状态：</p>
</li>
<li>
<p>关闭状态。关闭状态时用户请求是可以到达服务提供方的。</p>
</li>
<li>
<p>开启状态。开启状态时用户请求是不能到达服务提供方的，直接会走降级方法。</p>
</li>
<li></li>
</ul>
<p>半开状态。当熔断器开启时，过一段时间后，熔断器就会由开启状态变成半开状态。半开状态的熔断器是可以接受用户请求并把请求传递给服务提供方的，这时候如果远程调用返回成功，那么熔断器就会有半开状态变成关闭状态，反之，如果调用失败，熔断器就会有半开状态变成开启状态。<br>
Hystrix功能建议在并发比较高的方法上使用，并不是所有方法都得使用的。</p>
<p>Sentinel的熔断策略是根据响应时间，响应时间超过阈值，熔断开关打开。</p>
<h4> 1.2.4.恢复</h4>
<p>撤出限流、消除降级、关闭熔断</p>
<p>熔断使用半开状态，完成吞吐量爬升、缓存预热。</p>
<p>灰度发布，限流阈值逐步提升。</p>
<h4> 1.2.5.隔离</h4>
<ul>
<li>数据隔离：数据按照重要性排序、分库</li>
<li>机器隔离：给重要的用户单独配置服务器，用用户标识去路由</li>
<li>线程池隔离：线程池分配。hystrix</li>
<li>信号量隔离：计数器。hystrix</li>
<li>集群隔离：服务分组（注册中心）、秒杀</li>
<li>机房隔离：3个服务。局域网IP、路由。</li>
<li>读写隔离：主从</li>
<li>动静隔离：识别静态资源。nginx CDN</li>
<li>爬虫隔离：对IP的访问频率</li>
<li>冷热隔离：秒杀、抢购。读：缓存；写：缓存+队列</li>
</ul>
<h4> 1.2.6.异地多活</h4>
<p>异地机房部署相同的服务，同时对外提供服务（不是备份）。防止因为停电、火灾、水灾、地震、战争等问题导致服务不可用。</p>
<p>异地多活通常考虑RTT(round trip time):网络请求一个来回消耗的传输时间。光纤光速计算 300000 KM/s，两个机房如果一个在上海，一个在新疆，隔5000KM，<br>
rtt = 300000 / 5000 * 2 = 120毫秒的往返时延。</p>
<p>多活要求：</p>
<ul>
<li>
<p>请求任何一个节点，都能正常响应</p>
</li>
<li>
<p>某些系统故障，用户访问其他系统也能访问<br>
分类：</p>
</li>
<li>
<p>同城异区：距离较近，可以防止停电、机房起火</p>
</li>
<li>
<p>跨域异地：距离较近，可以防止停电、机房起火、火灾、水灾、地震。</p>
</li>
<li>
<p>跨国异地（隔离）：延迟，已经无法让系统提供服务了。通常在异国开展业务，数据和服务就放在异国，和国内数据是隔离的。<br>
异地多活容易出现数据不一致问题，要保证核心业务的多活。如用户系统有注册、登陆、修改用户信息等功能，保证正常注册、登陆多活，修改用户信息可以根据时间合并数据。</p>
</li>
</ul>
<h4> 1.2.7.可回滚</h4>
<p>灰度发布。版本化机制，当程序出错时，回滚到上一个版本。</p>
<h2> 二、业务设计原则</h2>
<h3> 2.1.防重、幂等</h3>
<p>重复提交业务，消息中间件重复消费消息。使用分布式锁、数据库唯一键等保证。</p>
<h3> 2.2.模块复用</h3>
<p>相同的功能只开发一次，模块化。不要到处拷贝相同的代码。</p>
<h3> 2.3.可追溯</h3>
<p>可以快速追踪到问题涉及的这个数据链路，快速定位问题。traceId</p>
<h3> 2.4.反馈原则</h3>
<p>给出精确友好的结果反馈。如http接口调用异常时尽量给出精确的异常原因，降低内外部沟通成本。</p>
<h3> 2.5.流程可定义</h3>
<p>相关工作有明确的流程规范</p>
<h3> 2.6.系统审批化</h3>
<p>系统变更需要审批</p>
<h3> 2.7.文档和注释</h3>
<p>完善文档和注释</p>
<h3> 2.8.备份</h3>
<ul>
<li>代码备份：git、分支</li>
<li>数据备份：运维备份，操作记录备份。</li>
<li>人员备份：不因个人离职导致项目停滞。</li>
</ul>
<h3> 2.9.规范</h3>
<p>制定规范，定期review。</p>
<h2> 三、系统性能常见指标</h2>
<h3> 3.1.响应时间（Response time）</h3>
<p>响应时间就是用户感受软件系统为其服务所耗费的时间，对于网站系统来说，响应时间就是从点击了一个页面计时开始，到这个页面完全在浏览器里展现计时结束的这一段时间间隔，看起来很简单，但其实在这段响应时间内，软件系统在幕后经过了一系列的处理工作，贯穿了整个系统节点。</p>
<p>根据“管辖区域”不同，响应时间可以细分为：</p>
<ul>
<li>服务器端响应时间这个时间指的是服务器完成交易请求执行的时间，不包括客户端到服务器端的反应（请求和耗费在网络上的通信时间），这个服务器端响应时间可以度量服务器的处理能力。</li>
<li>网络响应时间，这是网络硬件传输交易请求和交易结果所耗费的时间。</li>
<li>客户端响应时间，这是客户端在构建请求和展现交易结果时所耗费的时间，对于普通的瘦客户端Web应用来说，这个时间很短，通常可以忽略不计；但是对于胖客户端Web应用来说，比如Java<br>
applet、AJAX，由于客户端内嵌了大量的逻辑处理，耗费的时间有可能很长，从而成为系统的瓶颈，这是要注意的一个地方。<br>
那么客户感受的响应时间其实是等于客户端响应时间+服务器端响应时间+网络响应时间。细分的目的是为了方便定位性能瓶颈出现在哪个节点上。</li>
</ul>
<h3> 3.2.吞吐量（Throughput）</h3>
<p>吞吐量是我们常见的一个软件性能指标，对于软件系统来说，“吞”进去的是请求，“吐”出来的是结果，而吞吐量反映的就是软件系统的“饭量”，也就是系统的处理能力，具体说来，就是指软件系统在每单位时间内能处理多少个事务/请求/单位数据等。但它的定义比较灵活，在不同的场景下有不同的诠释，比如数据库的吞吐量指的是单位时间内，不同SQL语句的执行数量；而网络的吞吐量指的是单位时间内在网络上传输的数据流量。吞吐量的大小由负载（如用户的数量）或行为方式来决定。举个例子，下载文件比浏览网页需要更高的网络吞吐量。</p>
<h3> 3.3.资源使用率（Resource utilization）</h3>
<p>常见的资源有：CPU占用率、内存使用率、磁盘I/O、网络I/O。</p>
<h3> 3.4.点击数（Hits per second）</h3>
<p>点击数是衡量Web Server处理能力的一个很有用的指标。需要明确的是：点击数不是我们通常理解的用户鼠标点击次数，而是按照客户端向Web<br>
Server发起了多少次http请求计算的，一次鼠标可能触发多个http请求，这需要结合具体的Web系统实现来计算。</p>
<h3> 3.3.并发用户数（Concurrent users）</h3>
<p>并发用户数用来度量服务器并发容量和同步协调能力。在客户端指一批用户同时执行一个操作。并发数反映了软件系统的并发处理能力，和吞吐量不同的是，它大多是占用套接字、句柄等操作系统资源。</p>
<p>另外，度量软件系统的性能指标还有系统恢复时间等，其实凡是用户有关资源和时间的要求都可以被视作性能指标，都可以作为软件系统的度量，而性能测试就是为了验证这些性能指标是否被满足。</p>
<h2> 四、总结</h2>
<p>一个系统的设计，不仅需要考虑实现业务功能，还要保证系统高并发、高可用等。在系统容量规划（流量、容量等）、SLA制定（吞吐量、响应时间、可用性、降级方案等）、压测方案（线上、test等）、监控报警（机器负载、响应时间、可用率等）、应急预案（容灾、降级、限流、隔离、切流量、可回滚）等方面，也要有一些原则来进行设计。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">影响项目的要素及经验总结</title>
    <id>https://ujava.cn/synthesis/effect.html</id>
    <link href="https://ujava.cn/synthesis/effect.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>项目失败的因素主要分为以下几类</p>
<h2> 技术原因</h2>
<p>1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足；</p>
<p>2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善；</p>
<p>3、为非技术问题提供了技术解决方案，没有认真思考问题的本质；</p>
<p>4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性；</p>
<p>5、在开发生命周期过程中没有充分利用工具；</p>
<p>6、以技术为导向进行开发，而不是需求导向；</p>
<h2> 人为因素</h2>
<p>1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>项目失败的因素主要分为以下几类</p>
<h2> 技术原因</h2>
<p>1、领先技术的诱惑，对新潮技术的尝鲜，但技术基础储备不足；</p>
<p>2、不完善的技术设计，基础技术架构没有搭建好，或者是设计不完善；</p>
<p>3、为非技术问题提供了技术解决方案，没有认真思考问题的本质；</p>
<p>4、依赖软件包（JDK）来满足需求，过分依赖会影响扩展性；</p>
<p>5、在开发生命周期过程中没有充分利用工具；</p>
<p>6、以技术为导向进行开发，而不是需求导向；</p>
<h2> 人为因素</h2>
<p>1、缺少行政人员的支持，一般是指项目相关的部门，如服务器采购需要采购部配合，也有时候是指主导项目发起的领导；</p>
<p>2、缺少领导，团队内部多头领导；</p>
<p>3、没有敬业精神的项目团队；</p>
<p>4、功能不全的项目团队，人员配比缺失；</p>
<p>5、管理第三方的因素，如技术外包的项目；</p>
<p>6、缺少一个项目精英，如专职的项目经理；</p>
<p>7、缺少项目所有权；</p>
<p>8、相关人员冲突，指人员配比失衡；</p>
<p>9、拒绝变更，无法面对需求的变化；</p>
<p>10、不友好的组织文化；</p>
<p>11、经验不足的项目经理；</p>
<p>12、缺少商业理由，项目的价值较低；</p>
<p>13、不清晰或模棱两可的优先级；</p>
<p>14、缺少培训，项目执行过程中状况百出；</p>
<p>15、相关人员动机不一致，缺乏向心力；</p>
<h2> 过程管理因素</h2>
<p>1、 缺少项目管理方法体系；</p>
<p>2、 缺少系统开发方法体系；</p>
<p>3、缺少收益管理方法体系；</p>
<p>4、缺少质量管理方法体系；</p>
<p>5、未能确定和转移项目风险；</p>
<p>6、未能管理好需求；</p>
<p>7、过长的项目时间表；</p>
<p>8、测试覆盖不足；</p>
<p>9、计算机化的”爆炸“方法</p>
<p>从失败中吸取教训是不断改进过程的重要组成部分，下面罗列一些主要的经验教训。</p>
<h2> 管理用户预期</h2>
<p>即项目人员要从一开始就明白需要交付什么以及不要交付什么，要在项目中确定用户的需求和建立尽可能清晰的所有权。即使在最好的情况下，用户以前收到的信息也是有限的。通常情况下，我们很难确定能够提供反馈信息的合适用户。在项目一开始就需要确定主要的用户需求，并且为主要用户提供时间，以便他们确定所有的需求，同时他们也有责任提供和验证信息并投入相应的资源。</p>
<h2> 项目规格说明书中必须考虑价值和用户需求</h2>
<p>第一，项目是因为可确定且可测量的用户需求而产生并发展的。在项目初期确定的清晰目标将随着项目的进展而逐渐变得模糊，这是交付期限过长的项目所共有的特点。因此在项目开始之前，需要确定最终用户，以便在项目的设计和开发过程中充分考虑到他们的需求，同时用户也有责任而且需要采取相应的行动来帮助项目获得成功，这一点非常重要。用户需求构成了项目分析和设计阶段中一个至关重要的环节。需求确定后，就要为这些需求确定基线，并将它们引入到项目管理系统中，同时使用变更控制对其进行管理。如果这些需求出现了变更或添加了新需求，则需要对项目进行影响分析，并对项目计划进行相应的修正。</p>
<p>第二，项目规格说明书必须关注项目价值而不是技术解决方案。因此，即使从技术上讲已经存在明确的解决方案，但在进行项目评审时仍需将重点放在与项目价值相关的方面。</p>
<h2> 在确定资源前测量和评估项目的规模和复杂度（重视实现性）</h2>
<p>技术力量的发展带来了一个不好的后果，就是让我们相信，许多以前不可能实现的目标如今不但可以实现了，而且可以轻而易举地实现。有时候这种想法在项目的早期阶段通常表现为对项目的潜在收益过分夸大、过于庞大的项目范围定义以及过分乐观却相当危险且不够详细的项目规划。项目的规模和复杂度是项目成功与否的一个决定性因素，因此我们需要明确确定的是</p>
<p>a、提议的项目进度表是否现实可行；</p>
<p>b、项目的需求案例是否可行；</p>
<p>c、解决方案在技术上是否可行；</p>
<h2> 新技术的引入必须安排相应的培训</h2>
<p>新技术或者一些开源工具会给项目带来的不少影响，容易导致有关程序员角色和责任的不明确。因此在项目计划中纳入培训成本和时间进度以确保员工知道如何使用和维护系统是至关重要的。没有合理的培训就是永远不可能实现软件投资的全部潜在收益。更重要的是，缺少培训可能会为项目带来实现风险和运作风险，这些风险可能会最终威胁项目的长期可用性。</p>
<h2> 清晰可见的项目管理结构</h2>
<p>在管理结构中必须存在定义清楚的角色、责任和义务，明确各个项目成员自身所处的角色及相应的职责。在项目的开始阶段就应该确定正式的组织结构以及与高级管理层交流的途径，同时在项目的整个过程中予以保持。</p>
<h2> 处理好人员问题</h2>
<p>人才永远是项目成功的最重要因素。人员开发计划必须与组织中的项目管理框架同步进行，从而提供培训、业绩评估、分派工作和职位晋升相关的机制。谁都希望项目团队里都是高度主动性和熟练技能的员工，但现实往往很残酷，如果应届生较多的话，还是早点安排老员工带一下，这样能尽快的上手。</p>
<h2> 接受风险，但要严格管理风险</h2>
<p>项目的成功实现需要有有效的风险管理所支持的创造性思维。要及时对一些影响项目进度的功能模块进行调查并重新进行风险分析工作以及后续的风险管理工作，从而对需求进行重新评估并相应的调整计划。</p>
<p>项目管理是一门学问，需要一定时间的工作经验积累，并不是去考个PMP回来就能当项目经理的，真正注重的还是实践，照搬理论那一套的话，很多公司内部的现状都不足以支撑PMP所要求的完善体系，大型公司可以试下。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计实践经验</title>
    <id>https://ujava.cn/synthesis/experience.html</id>
    <link href="https://ujava.cn/synthesis/experience.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<ul>
<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>
<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>
<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>
<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>
<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>
OAuth2.0 协议来实现多渠道认证。
<ul>
<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>
<li>合并登录方式 登录方式以手机号为中心 合并。</li>
<li>渠道分组，按渠道分组分区分服。</li>
</ul>
</li>
<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>
<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>
<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>
<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>
<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>
<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>
<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>
<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>
例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<ul>
<li>记录道具来源等的 source 字段时，可以使用（类名+方法名） / （包名+方法名）的组合，可以清晰地区分来源。并且可以灵活地增加新的渠道/动作。</li>
<li>涉及金额、钱的字段，使用整型，以分为单位。也可以考虑使用 Decimal 类型来存储金额字段，避免因为精度问题导致计算错误。同时也可以考虑使用货币格式化库，方便对金额进行格式化显示。</li>
<li>使用 HTTP DELETE 方法来实现删除单条数据，这样更符合 RESTful 风格，同时也可以考虑使用 HTTP POST 方法来实现批量删除、复杂请求。</li>
<li>使用异步日志组件来进行日志记录，避免在主进程中进行日志记录导致性能问题。</li>
<li>将账号系统与认证系统进行分离，避免账号系统变得复杂。同时可以考虑使用第三方认证平台来进行认证，避免自行开发认证系统的复杂度。另外，可以考虑使用<br>
OAuth2.0 协议来实现多渠道认证。
<ul>
<li>账号系统在设计维度上一般主要有 登录方式、渠道。</li>
<li>合并登录方式 登录方式以手机号为中心 合并。</li>
<li>渠道分组，按渠道分组分区分服。</li>
</ul>
</li>
<li>事务的开启，根据等级不同，会对数据进行不同范围的上锁；使用行级锁来实现事务控制，避免对整个表进行锁定导致性能问题。</li>
<li>go的每一个err都需要进行处理，不处理就会跳过。json解析、mysql查询等，使用错误处理库来统一处理错误，避免在代码中到处返回错误。同时可以考虑使用日志库来记录错误信息，方便进行错误追踪和问题定位。</li>
<li>业务逻辑分离不错乱，上层交给下层方法统一处理的业务，上层业务不要再另外处理下层的业务；将不同业务模块的代码分离开来，通过模块化的方式进行统一处理和管理，以避免代码重复和混乱。</li>
<li>使用Redis分布式锁时，加入重试机制以及超时机制，以确保锁的获取和释放能够及时有效。</li>
<li>一个事务要整体一致，比如一个物品的购买和多个物品的购买，最后只进行一次账户扣减操作，只分为余额充足和余额不足两种情况；根据具体业务需求进行设计和优化，以确保事务的原子性、一致性和持久性。</li>
<li>如果需要对redis中设置了过期时间的数据进行修改，要考虑到修改途中数据过期的情况。这时候可以给key带上一些标识，比如每天领取次数限制的数据，设置key时带上日期，避免因为临界值时间出现的数据错乱。</li>
<li>业务价值不强但消耗性能相对大的功能，这样的情况往往不需要性能优秀，一般有较大的容忍性。要在尽可能保证主业务稳定运行的情况下，实现此类功能的运行：比如一个消息存储的业务，所需要的读写性能可能都非常大，这时候可以尽量不引入新的存储介质，使用分库分表加分布式文件存储持久化来实现。</li>
<li>mysql的delete操作，是不释放表空间的。只是做了逻辑上的标记删除，在磁盘上数据并没有被真正删除。这样的设计是因为：如果在磁盘上移除之后，很多其它的记录需要在磁盘上重新排列，这会消耗大量的性能。(<br>
例如：一个大表，存在索引，删除了其中一行，那么整个索引结构就会发生变化，随之而来的改变索引结构，必将带来磁盘 IO)。这时候想要释放可以选择</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个操作相对比较耗费性能，要谨慎操作。在数据量超千万的表中进行释放，一定要保证cpu核数至少大于等于2。因为这时候会占用1core的资源全部用来处理。时长可能超过5min。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计容错</title>
    <id>https://ujava.cn/synthesis/faulttolerant.html</id>
    <link href="https://ujava.cn/synthesis/faulttolerant.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。</p>
<h2> 错误源</h2>
<p>要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。</p>
<p>要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。</p>
<h4> 机器节点</h4>
<ul>
<li>磁盘故障、内存耗尽、CPU 100% 占用、掉电；</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在某种程度上来说，软件的复杂性是应对无处不在的错误所带来的。要想在不可靠的硬件、软件和网络的基础上构建可靠的系统，容错是必不可少的。</p>
<h2> 错误源</h2>
<p>要做到更好的容错、健壮和可靠，首先需要全面的梳理可能导致错误的源头和可能性。</p>
<p>要分析错误源头，则要首先分析应用及流程锁依赖的要素和环节。针对每一个要素和环节，推敲会出错的地方；要了解可预料到的错误，可以看看 Java 库或框架里的各种 Exception 。</p>
<h4> 机器节点</h4>
<ul>
<li>磁盘故障、内存耗尽、CPU 100% 占用、掉电；</li>
</ul>
<h4> 网络</h4>
<ul>
<li>DNS 故障、机架故障、路由器故障、设备故障、电缆故障；</li>
<li>连接中断、请求排队（延迟）、网络丢包、网络重传、网络拥塞、网络分区。</li>
</ul>
<h4> 时间</h4>
<ul>
<li>很多监控统计依赖于时钟；</li>
<li>数据最终一致性的操作依赖于到达先后顺序；</li>
<li>同一台机器的时钟晶振可能受温度影响而波动；</li>
<li>不同机器上的时钟是不一致的，通过 NTP 协议同步；</li>
<li>NTP 协议是经过网络的，这意味着网络的不稳定会影响时钟的同步；</li>
<li>“跳秒”现象：1 分钟有 59s 或 61s ；</li>
<li>任务耗时过长，对外部来说就是无响应。</li>
</ul>
<h4> 资源</h4>
<ul>
<li>资源不存在，比如文件不存在；</li>
<li>资源暂时不可用，比如端口已占用；</li>
<li>没有可用资源，比如连接池满；</li>
<li>资源路径已经被移动；</li>
<li>资源访问时的同步死锁。</li>
</ul>
<h4> 数据</h4>
<ul>
<li>不符合预期格式的数据；</li>
<li>脏数据引起解析错误；</li>
<li>不一致的数据引起后继行为错误；</li>
<li>大对象数据引起 FullGC 导致响应不稳定；</li>
<li>错误配置；</li>
<li>非法请求获得正常资源；</li>
<li>恶意代码。</li>
</ul>
<h4> 计算</h4>
<ul>
<li>溢出，不符合运算法则；</li>
<li>除零，无值可表示；</li>
<li>有限精度，浮点计算错误；</li>
<li>逻辑错误，比如越界、不正确的算法。</li>
</ul>
<h4> 设计</h4>
<ul>
<li>设计不足或不合理，容易令人疏忽而导致误操作；</li>
<li>危险操作无确认、无提示，容易造成损失；</li>
<li>少数服从多数原则，达不到多数；</li>
<li>Leader 的消息无法被其它节点接收，被其它节点判定为下线。</li>
</ul>
<h4> 流程</h4>
<ul>
<li>中途取消操作；</li>
<li>逆向操作。</li>
</ul>
<h4> 负荷</h4>
<ul>
<li>大流量超出应用承受负荷。</li>
</ul>
<h4> 安全</h4>
<ul>
<li>非授权访问；</li>
<li>数据泄露；</li>
<li>数据被篡改；</li>
<li>访问拒绝。</li>
</ul>
<h4> 并发</h4>
<ul>
<li>数据覆写：访问一个共享资源时，进程 A 获取锁，然后进入了 stop-the-world GC pause ； 进程 B 发现锁已过期，然后申请获得锁，进行数据写操作，接着释放锁；进程 A 结束 GC，进行数据写操作。 进程 A 将 进程 B 的写数据覆盖了。</li>
</ul>
<h4> 拜占庭错误</h4>
<ul>
<li>当分布式系统里的节点要达成共识时，少数节点故意发送错误消息迷惑其它节点，以造成整体错误决策。比如航天领域防电子辐射干扰、多参与者协作和决策。</li>
</ul>
<h2> 健壮性</h2>
<p>健壮性是极为重要的程序质量属性。分为代码健壮性和业务健壮性。健壮性体现在代码和业务上的错误和异常处理上，避免整体失败、数据泄露、不一致、资损等故障。要做出健壮性好的设计和程序，就要预先思考清楚：流程中有哪些可能的错误和异常，每一种对应的处理措施是什么 ？ 这样，才能让逻辑思维更加缜密，也是锻炼逻辑思维的一种有效之法。</p>
<ul>
<li>代码健壮性体现在避免局部失败导致整体失败。常见考虑：参数校验以拦截不合法请求、越界异常捕获、JSON 脏数据异常捕获、类型转换异常捕获、底层异常捕获（连接异常、DB 异常、网络超时异常等）。</li>
<li>业务健壮性体现在业务的闭合环。在整个业务过程中会发生什么异常，导致什么问题（体验或资损问题），如何处理。比如同城异常检测要考虑商家同城呼叫失败后又快递发货的情形。</li>
</ul>
<h2> 容错机制</h2>
<h4> 思路与方法</h4>
<ul>
<li>设定系统假定，检测系统假定是否成立，然后在系统假定上构建系统；</li>
<li>聚焦高频错误：磁盘故障 &gt; 服务器单机故障 &gt; DNS 故障 &gt; 机架故障 &gt; 路由器重启；</li>
<li>错误提示规范：定义规范一致的错误码和错误消息；</li>
<li>快速失败并记录日志：适用于“请求检测，请求中含有错误或非法数据”的场景；</li>
<li>忽略失败并记录日志：适用于“不影响整体输出且不造成负面影响的极次要地方有点小问题”的场景；</li>
<li>确认机制：设计一种确认机制，确保交互的多方参与者满足某种契约或约束；</li>
<li>预防策略：避免容易导致错误的做法；</li>
<li>冗余策略：冗余、替换、路由，见高可用部分；</li>
<li>降级策略：当核心服务出现问题时，提供有损服务来维持稍低质量的服务，保证服务的可用性；</li>
<li>重试策略：幂等；完全重试；补偿重试；</li>
<li>回滚策略：中途取消，重续执行很容易导致脏数据，考虑回滚操作；</li>
<li>故障恢复：监控、检测错误和故障、自动恢复；</li>
<li>乐观锁：递增的 fencing token ，防止过期写操作覆盖已经完成的写操作；</li>
</ul>
<h4> 系统假定</h4>
<ul>
<li>同步模型假定：任何网络延迟、进程暂停、时钟错误都不可能超出某个上限值。即：有限的网络延迟；有限的进程暂停；有限的时钟错误。</li>
<li>部分同步模型假定：在同步模型假定的基础上，允许极少数的无法预测的超上限的网络延迟、进程暂停、时钟错误。</li>
<li>异步模型假定：对时序不做假定，难以预料事件何时发生和动作何时执行。</li>
<li>节点崩溃假定：节点突然失去响应，再也无法正常运行；</li>
<li>节点崩溃-恢复假定：节点可能在任何时候失去响应，在一段时间之后自动恢复并正常运行；易失性存储（比如内存）中的数据丢失，而持久性存储（比如磁盘）中的数据完好；</li>
<li>拜占庭假定：部分节点通过虚假消息欺骗其它节点，从而诱导作出错误的整体决策。</li>
</ul>
<p>最常见的系统假定：部分同步模型假定 + 节点崩溃-恢复假定。</p>
<h4> 算法的正确性</h4>
<ul>
<li>正确性假定：算法满足某些指定性质。</li>
<li>达成预期结果、安全、活性。</li>
</ul>
<h4> 重试</h4>
<ul>
<li>使操作满足幂等性质；</li>
<li>可以使用失败队列来记录失败的操作及失败信息、失败现场；</li>
<li>完全重试策略：整个操作从头开始执行，适合多读少写的长事务；</li>
<li>补偿重试策略：从失败现场的地方重续执行，适合多写且回滚代价昂贵的长事务；‘</li>
<li>完全重试策略，可指定重试次数；</li>
<li>可采用定时任务重试。</li>
<li>幂等：唯一索引、Token 机制（防页面重复提交）、分布式锁、select+insert、状态机幂等、查询/删除天然幂等。</li>
</ul>
<h4> 故障检测与恢复</h4>
<ul>
<li>故障检测主要靠监控。服务器监控（CPU、内存利用率、Load、IO RW、Net RW）、服务监控（RT、QPS、消费速率</li>
<li>、延迟、网络连接；来源、TOPN）、Java 监控（ThreadPool、Heap、GC 等）、异常监控（失败次数、失败比例；超时，消费堆积或不均）、业务监控（瞬时峰值、瞬时下跌、同比上涨或下跌、大数据对象）、对账监控（数据一致性检测，尤其资金相关）。</li>
<li>心跳机制：心跳机制用于故障检测。每台工作机每隔指定时间将自己的CPU、内存、磁盘、网络、IO读写、负载等情况上报给 Master， Master 会判断服务器是否正常，以决定是否分发流量给该服务器。每台服务器与 Master 有个超时设置，如果达到超时没有收到该服务器的心跳信息，则会判断服务器出现问题。心跳机制需要 KeepAlive （连接最大空闲时间） 属性，使用 MQTT 协议。</li>
<li>租约机制：每台工作机向 Master 申请具有一定租约期限的服务时间。当服务时间快到时，再向 Master 继续申请延长租约的有效期。如果因为网络或工作机故障导致租约无法响应，则会将该工作机隔离，不再提供服务。</li>
<li>WAL（Write Ahead Log）： 预写日志，恢复日志。基本机理是复制状态机、备忘录、备份。关系数据库系统中用于提供原子性和持久性。in-place 和 shadow paging 。提升磁盘写性能：随机读写改顺序读写、缓冲单条读写改批量读写、单线程读写改并发读写。同步 WAL 文件和数据库文件的行为被称为 checkpoint（检查点）。实现方法：DB - undo, redo 机制；ES - fsync 机制；ZK - 先写 WAL，再更新内存，最后通知客户端；定期将内存中的目录树进行 Snapshot，落磁盘； ETCD - wal 和 snap 目录； HBase - 更新数据前写 WAL， 且写 WAL 与数据更新在同一事务。</li>
<li>检查点（CheckPoint）：系统定期将内存状态以检查点文件的形式dump到磁盘中，并记录检查点时刻对应的操作日志回放点。 检查点可以快速提升故障恢复的速度。</li>
<li>备份。备份是应对数据故障（丢失、不一致）的重要保障。备份只是实现数据的恢复，并不能完全实现故障恢复。故障恢复是指服务或服务器回到正常可用状态。</li>
</ul>
<h4> MySQL备份</h4>
<ul>
<li>逻辑备份和物理备份。逻辑备份是可读文件、恢复简单灵活（恢复工具及选项）、在不同机器上运行、与存储引擎无关、避免物理环境导致的数据损坏，但恢复时间较长，需要<br>
MySQL 来完成、需要测试恢复；物理备份通常是不可读的二进制文件，恢复更简单（只要拷贝文件到目的路径）、恢复时间很短，但 InnoDB<br>
的原始文件通常比逻辑备份的文件更大。两种方式可混合。</li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">一致性Hash算法</title>
    <id>https://ujava.cn/synthesis/hash.html</id>
    <link href="https://ujava.cn/synthesis/hash.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>
<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>
<h2> 产生背景</h2>
<p>考虑这么一种场景：</p>
<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>在分布式系统中，数据的存储和访问是很重要的问题。为了提高系统的可用性和扩展性，常常需要将数据分布到不同的节点上，而且这些节点也可能会动态地加入或离开集群。一致性哈希算法就是一种常用的解决方案，它可以解决节点的动态变化和负载均衡的问题。</p>
<p>本文将深入探讨一致性哈希算法的底层原理，包括其基本思想、关键步骤以及优缺点等，同时结合实际场景进行举例说明。</p>
<h2> 产生背景</h2>
<p>考虑这么一种场景：</p>
<p>我们有三台缓存服务器编号node0、node1、node2，现在有 3000 万个key，希望可以将这些个 key 均匀的缓存到三台机器上，你会想到什么方案呢？</p>
<p>我们可能首先想到的方案是：取模算法hash（key）% N，即：对 key 进行 hash 运算后取模，N 是机器的数量；</p>
<p>这样，对 key 进行 hash 后的结果对 3 取模，得到的结果一定是 0、1 或者 2，正好对应服务器node0、node1、node2，存取数据直接找对应的服务器即可，简单粗暴，完全可以解决上述的问题；</p>
<figure><figcaption>img_7.png</figcaption></figure>
<p>取模算法虽然使用简单，但对机器数量取模，在集群扩容和收缩时却有一定的局限性：因为在生产环境中根据业务量的大小，调整服务器数量是常有的事；</p>
<p>而服务器数量 N 发生变化后hash（key）% N计算的结果也会随之变化！</p>
<figure><figcaption>img_8.png</figcaption></figure>
<p>比如：一个服务器节点挂了，计算公式从hash（key）% 3变成了hash（key）% 2，结果会发生变化，此时想要访问一个 key，这个 key 的缓存位置大概率会发生改变，那么之前缓存 key 的数据也会失去作用与意义；</p>
<p>大量缓存在同一时间失效，造成缓存的雪崩，进而导致整个缓存系统的不可用，这基本上是不能接受的；</p>
<p>为了解决优化上述情况，一致性 hash 算法应运而生~</p>
<h2> 什么是一致性哈希算法</h2>
<p>一致性哈希算法是一种用于分布式系统中的数据分片和负载均衡的算法。它将整个哈希空间划分为一个环，并且每个节点在这个环上都有一个对应的位置。当需要读写某个数据时，先将其进行哈希运算得到一个哈希值，然后根据这个哈希值在环上找到对应的节点，从而实现数据的定位。</p>
<p>一致性哈希算法的优点在于：当新增或删除节点时，只会影响到环上的一小部分节点，因此不会像传统的哈希算法那样造成大量的数据迁移和重新分片。同时，由于节点数较多，请求可以被更好地平均分配，从而实现了负载均衡的效果。</p>
<p>另外，一致性哈希算法还可以通过增加虚拟节点来解决节点不均衡的问题，从而进一步提高负载均衡的效果。</p>
<h2> 一致性哈希算法原理</h2>
<p>一致性哈希算法在 1997 年由麻省理工学院提出，是一种特殊的哈希算法，在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系；</p>
<p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题；</p>
<p>一致性 hash 算法本质上也是一种取模算法；</p>
<p>不过，不同于上边按服务器数量取模，一致性 hash 是对固定值 2^32 取模；</p>
<p>IPv4 的地址是 4 组 8 位 2 进制数组成，所以用 2^32 可以保证每个 IP 地址会有唯一的映射；</p>
<ol>
<li>hash 环<br>
我们可以将这2^32个值抽象成一个圆环 ⭕️，圆环的正上方的点代表 0，顺时针排列，以此类推：1、2、3…直到2^32-1，而这个由 2 的 32 次方个点组成的圆环统称为hash环；</li>
</ol>
<figure><figcaption>img_9.png</figcaption></figure>
<ol start="2">
<li>服务器映射到 hash 环<br>
在对服务器进行映射时，使用hash（服务器ip）% 2^32，即：</li>
</ol>
<p>使用服务器 IP 地址进行 hash 计算，用哈希后的结果对2^32取模，结果一定是一个 0 到2^32-1之间的整数；</p>
<p>而这个整数映射在 hash 环上的位置代表了一个服务器，依次将node0、node1、node2三个缓存服务器映射到 hash 环上；</p>
<figure><figcaption>img_10.png</figcaption></figure>
<ol start="3">
<li>对象 key 映射到服务器<br>
在对对应的 Key 映射到具体的服务器时，需要首先计算 Key 的 Hash 值：hash（key）% 2^32；</li>
</ol>
<p>注：此处的 Hash 函数可以和之前计算服务器映射至 Hash 环的函数不同，只要保证取值范围和 Hash 环的范围相同即可（即：2^32）；</p>
<p>将 Key 映射至服务器遵循下面的逻辑：</p>
<p>从缓存对象 key 的位置开始，沿顺时针方向遇到的第一个服务器，便是当前对象将要缓存到的服务器；</p>
<p>假设我们有 “semlinker”、“kakuqo”、“lolo”、“fer” 四个对象，分别简写为 o1、o2、o3 和 o4；</p>
<p>首先，使用哈希函数计算这个对象的 hash 值，值的范围是 [0, 2^32-1]：</p>
<figure><figcaption>img_11.png</figcaption></figure>
<p>图中对象的映射关系如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时 3 台缓存服务器，分别为 CS1、CS2 和 CS3：</p>
<figure><figcaption>img_12.png</figcaption></figure>
<p>则可知，各对象和服务器的映射关系如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即：</p>
<figure><figcaption>img_13.png</figcaption></figure>
<p>以上便是一致性 Hash 的工作原理；</p>
<blockquote>
<p>可以看到，一致性 Hash 就是：将原本单个点的 Hash 映射，转变为了在一个环上的某个片段上的映射！</p>
</blockquote>
<h2> 服务器扩缩容场景</h2>
<ol>
<li>服务器减少</li>
</ol>
<p>假设 CS3 服务器出现故障导致服务下线，这时原本存储于 CS3 服务器的对象 o4，需要被重新分配至 CS2 服务器，其它对象仍存储在原有的机器上：</p>
<figure><figcaption>img_14.png</figcaption></figure>
<p>此时受影响的数据只有 CS2 和 CS3 服务器之间的部分数据！</p>
<ol start="2">
<li>服务器增加</li>
</ol>
<p>假如业务量激增，我们需要增加一台服务器 CS4，经过同样的 hash 运算，该服务器最终落于 t1 和 t2 服务器之间，具体如下图所示：</p>
<figure><figcaption>img_15.png</figcaption></figure>
<p>此时，只有 t1 和 t2 服务器之间的部分对象需要重新分配；</p>
<p>在以上示例中只有 o3 对象需要重新分配，即它被重新到 CS4 服务器；</p>
<p>在前面我们已经说过：如果使用简单的取模方法，当新添加服务器时可能会导致大部分缓存失效，而使用一致性哈希算法后，这种情况得到了较大的改善，因为只有少部分对象需要重新分配！</p>
<h2> 数据偏斜&amp;服务器性能平衡问题</h2>
<ol>
<li>引出问题</li>
</ol>
<p>在上面给出的例子中，各个服务器几乎是平均被均摊到 Hash 环上；</p>
<p>但是在实际场景中很难选取到一个 Hash 函数这么完美的将各个服务器散列到 Hash 环上；</p>
<p>此时，在服务器节点数量太少的情况下，很容易因为节点分布不均匀而造成数据倾斜问题；</p>
<p>如下图被缓存的对象大部分缓存在node-4服务器上，导致其他节点资源浪费，系统压力大部分集中在node-4节点上，这样的集群是非常不健康的：</p>
<figure><figcaption>img_16.png</figcaption></figure>
<p>同时，还有另一个问题：</p>
<p>在上面新增服务器 CS4 时，CS4 只分担了 CS1 服务器的负载，服务器 CS2 和 CS3 并没有因为 CS4 服务器的加入而减少负载压力；如果 CS4 服务器的性能与原有服务器的性能一致甚至可能更高，那么这种结果并不是我们所期望的；</p>
<ol start="2">
<li>虚拟节点</li>
</ol>
<p>针对上面的问题，我们可以通过：引入虚拟节点来解决负载不均衡的问题：</p>
<p>即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器；</p>
<p>如下图所示：</p>
<figure><figcaption>img_17.png</figcaption></figure>
<p>在图中：o1 和 o2 表示对象，v1 ~ v6 表示虚拟服务器，s1 ~ s3 表示实际的物理服务器；</p>
<ol start="3">
<li>虚拟节点的计算</li>
</ol>
<p>虚拟节点的 hash 计算通常可以采用：对应节点的 IP 地址加数字编号后缀 hash（10.24.23.227#1) 的方式；</p>
<p>举个例子，node-1 节点 IP 为 10.24.23.227，正常计算node-1的 hash 值：</p>
<ul>
<li>
<p>hash（10.24.23.227#1）% 2^32<br>
假设我们给 node-1 设置三个虚拟节点，node-1#1、node-1#2、node-1#3，对它们进行 hash 后取模：</p>
</li>
<li>
<p>hash（10.24.23.227#1）% 2^32</p>
</li>
<li>
<p>hash（10.24.23.227#2）% 2^32</p>
</li>
<li>
<p>hash（10.24.23.227#3）% 2^32</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li>分配的虚拟节点个数越多，映射在 hash 环上才会越趋于均匀，节点太少的话很难看出效果；</li>
<li>引入虚拟节点的同时也增加了新的问题，要做虚拟节点和真实节点间的映射，对象key-&gt;虚拟节点-&gt;实际节点之间的转换；</li>
</ul>
<h2> 使用场景</h2>
<p>一致性 hash 在分布式系统中应该是实现负载均衡的首选算法，它的实现比较灵活，既可以在客户端实现，也可以在中间件上实现，比如日常使用较多的缓存中间件memcached和redis集群都有用到它；</p>
<p>memcached 的集群比较特殊，严格来说它只能算是伪集群，因为它的服务器之间不能通信，请求的分发路由完全靠客户端来的计算出缓存对象应该落在哪个服务器上，而它的路由算法用的就是一致性 hash；</p>
<p>还有 redis 集群中 hash 槽的概念，虽然实现不尽相同，但思想万变不离其宗，看完本篇的一致性 hash，你再去理解 redis 槽位就轻松多了；</p>
<p>其它的应用场景还有很多：</p>
<ul>
<li>RPC框架Dubbo用来选择服务提供者</li>
<li>分布式关系数据库分库分表：数据与节点的映射关系</li>
<li>LVS负载均衡调度器</li>
<li>……</li>
</ul>
<h2> 小结</h2>
<p>一致性哈希是一种用于分布式系统中数据负载均衡的算法。在分布式系统中，多个服务器节点需要负责处理不同的请求，但由于每个请求的负载大小不同，因此会导致服务器节点的负载不平衡，一些节点可能会过度负载，而另一些节点则占用较少的资源。这就需要一种算法来平衡各个节点之间的负载。</p>
<p>一致性哈希算法通过将服务器节点和请求都映射到一个固定的哈希环上，使得每个请求可以被映射到一个特定的服务器节点上。同时，在哈希环上沿顺时针方向查找离该请求最近的服务器节点，并将该请求路由到该节点上，从而实现了负载均衡。一致性哈希算法还支持添加或删除服务器节点，同时保持大部分请求仍然能够映射到原来的节点上，以避免数据迁移带来的复杂性和成本。</p>
<p>总之，一致性哈希算法可以提高分布式系统的可扩展性和可靠性，减少系统崩溃等问题的风险，从而更好地满足大规模应用所需的高吞吐量和低延迟要求。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">微服务架构和分布式架构的区别</title>
    <id>https://ujava.cn/synthesis/microservice.html</id>
    <link href="https://ujava.cn/synthesis/microservice.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<blockquote>
<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>
</blockquote>
<h2> 1、含义不同</h2>
<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>]]></summary>
    <content type="html"><![CDATA[<blockquote>
<p><strong>微服务架构和分布式架构的区别</strong>有：1、含义不同；2、概念层面不同；3、解决问题不同；4、部署方式不同；5、耦合度不同。其中，含义不同指微服务架构是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，而分布式系统是若干独立计算机的集合。</p>
</blockquote>
<h2> 1、含义不同</h2>
<p><strong>微服务架构</strong>：微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制(通常用HTTP资源API)。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p>
<p><strong>分布式架构</strong>：分布式系统是若干独立计算机的集合，这些计算机对用户来说就像单个相关系统，即整个系统是由不同的计算机组成，而用户是无感知的，就像访问一台计算机一样。这里强调的是系统由不同物理上分离的计算机（服务器）组成。</p>
<h2> 2、概念层面不同</h2>
<p><strong>微服务架构</strong>：微服务是设计层面的东西，一般考虑如何将系统从逻辑上进行拆分，也就是垂直拆分。微服务可以是分布式的，即可以将不同服务部署在不同计算机上，当然如果量小也可以部署在单机上。</p>
<p><strong>分布式架构</strong>：分布式是部署层面的东西，即强调物理层面的组成，即系统的各子系统部署在不同计算机上。</p>
<h2> 3、解决问题不同</h2>
<p><strong>微服务架构</strong>：微服务解决的是系统复杂度问题： 一般来说是业务问题，即在一个系统中承担职责太多了，需要打散，便于理解和维护，进而提升系统的开发效率和运行效率，微服务一般来说是针对应用层面的。微服务如果用在其它系统，如存储系统感觉怪怪的，就像说Mysql集群是微服务的，总觉得哪里不舒服。</p>
<p><strong>分布式架构</strong>：分布式解决的是系统性能问题： 即解决系统部署上单点的问题，尽量让组成系统的子系统分散在不同的机器上进而提高系统的吞吐能力。</p>
<h2> 4、部署方式不同</h2>
<p><strong>微服务架构</strong>：微服务的应用可以部署在是同一个服务器，不一定是分散在多个服务器上。微服务架构是一项在云中部署应用和服务的新技术。微服务架构是一种架构模式，它将一个复杂的大型应用程序划分成多个微服务，这些小型服务都在各自独立的进程中运行。</p>
<p><strong>分布式架构</strong>：分布式是将一个大的系统划分为多个业务模块,这些业务模块会分别部署到不同的机器上，通过接口进行数据交互。</p>
<h2> 5、耦合度不同</h2>
<p>微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势，不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难。</p>
<h3> 拓展阅读</h3>
<h2> 分布式是否属于微服务？</h2>
<p>答案是属于。微服务的意思也就是将模块拆分成一个独立的服务单元通过接口来实现数据的交互。但是微服务不一定是分布式，因为微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。这也是分布式和微服务的一个细微差别。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">企业级架构带来的模式改变</title>
    <id>https://ujava.cn/synthesis/modelchange.html</id>
    <link href="https://ujava.cn/synthesis/modelchange.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>
<h2> 一、价值评估有章可循</h2>
<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>]]></summary>
    <content type="html"><![CDATA[<p>数字化转型背景下，银行业务和IT技术融合发展的趋势愈发明显。企业级架构通过统一的方法论进行企业级分析、设计、规划和实施，有助于将业务和技术更好地结合在一起，建立一整套基于操作模型的标准化流程，进而成功执行和实现战略转型。企业级架构主要可分为业务架构与IT架构两大部分，其核心作用包括贯彻企业战略、促进业务和科技融合、消除部门竖井，以及统一方法、统一语言、统一标准等，最终潜移默化地持续提升整体效率。针对这一趋势，笔者结合价值评估、数据治理、业技融合、方法实践等视角，尝试分析了实施企业级架构所能带来的模式改变与价值提升。</p>
<h2> 一、价值评估有章可循</h2>
<p>近年来，金融科技与银行业务的依存关系愈发紧密，特别是各类新技术、新场景的不断涌现，推动用户体验持续完善、风控水平快速提升。然而，面对金融业务的快速发展，尽管科技部门采用了敏捷模式、外协模式不断提高产能，却依然很难达到需求方的期望。在此背景下，为有效缓解供需矛盾，需求价值评估环节应需而生，即当改造范围及工作量评估完成后，业务部门和科技部门在需求排期会再次进行沟通，以保证高优先级需求优先开发。但事实上，需求方大多以本部门利益为上，排期结论往往很难达成一致，其根本原因即在于价值评估没有贯穿在需求产生的过程中。</p>
<p>企业级架构建设循着企业价值创造的链条，可面向业务领域逐步开展需求识别和定义。对于业务领域而言，其主要职责是创造业务价值，承接战略分析成果，进行产品研发。实践中，业务领域需要清晰定义本领域应具备的能力，提出能力建设方案，并在领域范畴内，按照计划—执行—监督的完整价值流，识别出业务活动。业务活动是指创造端对端业务价值的具体工作，其价值交付主要以产品为载体，包括产品服务的客户、产品提供的渠道、产品所需的合作伙伴等，在流程模型中需要进行全面辨识。基于企业级架构方法论形成的业务需求和业务模型，有助于业务价值的体现和评估：</p>
<p>一是基于企业级架构的全局视角，可以减少个别部门的短期促销行为，同时避免不规范需求引发的产品定价、业务流程不一致等问题。二是企业级架构承接业务战略，始终围绕着价值创造建设，而需求在经过“战略解析—能力主题—产品设计—流程设计—能力实现”的工作模型检验后，将能够更好地满足战略需要，有利于提高核心竞争力。三是需求的业务价值更容易量化，基于企业级架构，可建立产品、客户、渠道、合作方贡献度评价体系，对需求带来的效益进行数字化评估。四是业务需求价值评估能力提高，可以使科技产能更好地倾向于重点需求开发，快速形成竞争力。</p>
<h2> 二、数据治理追本溯源</h2>
<p>如果说价值交付是建设企业级架构的核心，那么业务信息则是构成企业级架构的基础，内容涉及业务架构的业务对象以及业务模型的实体模型等。对此，IT架构的数据架构进一步从数据定义、数据管理、数据服务等方向，规定了数据生命周期中各种形态的管理原则。数据架构组成示意如图1所示。例如，针对实体建模，该架构详细描述定义了业务实体和实体属性；针对数据定义，要求开发数据结构准确继承实体模型；针对元数据管理，要求建立企业级数据字典，保证数据能被正确描述和使用。此外，在数据质量管控方面，则是要求在组织、办法和流程等维度进行全面统筹。</p>
<figure><figcaption>数据架构组成示意</figcaption></figure>
<p>实践证明，如果不能全面梳理数据脉络，数据治理的结果往往是事倍功半。对此，企业级架构有助于为全面实施数据治理打开局面：一是在需求的业务建模阶段，业务流程的数据需求和实体模型需要进行相互验证，并通过企业级数据字典进行定义，在源头保证数据准确性。二是从架构设计到实施工艺，从实体建模到数据结构设计，借助企业级架构可形成全面的数据管理办法，保证数据在产生、传输、存储、服务各个环节的一致性。三是基于企业级架构，可将内部能力按业务组件归集，并依照业务组件开发应用组件，同时加强数据副本管理，进而避免因同类业务被不同应用系统承接导致的管理复杂化问题。综上，数据治理是数字化转型的一项基础性工作，而企业级架构恰好提供了一枚“金钥匙”。</p>
<h2> 三、业务与技术更好衔接</h2>
<p>在瀑布式开发模式下，标准化需求确认需要经历多个不同阶段的准入门禁，需求响应缓慢。与之相比，敏捷开发模式强调客户参与，更有助于加速需求交付进程，例如将开发过程前移到需求提出阶段，或是请业务人员加入开发团队等。除此之外，企业级架构也为业务与技术融合提供了一种新的途径：</p>
<ul>
<li>一是在提交业务需求前，通过对活动进行流程建模，以及对业务对象进行实体建模，并采用结构化、标准化语言(如流程建模的BPMN图和实体建模的ER图等)消弭理解歧义，可基于业务模型团队构建衔接业务和技术的桥梁。</li>
<li>二是企业级架构结合内部视角，可从业务流程、职责划分等维度映射业务组件与应用组件的对应关系，进而实现业务和技术的完美对应。</li>
<li>三是企业级架构的流程建模需要勾连相关实体，而建模产出物结合面向对象的设计方法，将能方便地识别出符合客观世界的对象，对象拥有实体属性，并具备流程模型描述的处理能力。</li>
<li>四是企业级架构在进行实体建模时，可对实体进行归类，定义出主实体，并与周边的多个实体组成业务对象(子主题域)。在开发阶段，通过将业务建模的业务对象(子主题域)设计成相应的数据聚合，可有效保证技术和业务理解一致，使用“共同语言”。</li>
</ul>
<p>总体而言，业务模型通过以业务视角来描述战术层和运营层的业务架构，可为IT架构提供高效输入，而善于使用业务架构和业务模型，也将使业务与技术衔接得更好，加快需求响应速度。业务架构基础模型如图2所示。</p>
<figure><figcaption>业务架构基础模型</figcaption></figure>
<h2> 四、方法实践潜移默化</h2>
<p>从实践角度发出，企业级架构不仅是对业务架构和IT架构进行全局设计，还提供了精确描述企业的统一方法论，如可灵活应用在日常工作中，将产生潜移默化的积极影响：</p>
<ul>
<li>一是价值链分析。企业级架构进行企业层面的流程模型设计，遵循价值创造的链条识别业务领域，并在业务领域通过各类活动实现业务价值，接着就是将活动下的任务按能力类别聚合成业务组件。在IT实施阶段，可沿用同样的分析方法，按价值维度将业务组件进一步细分为子域，最后将能力进行聚合，开发出高内聚的微服务。</li>
<li>二是架构视图绘制。企业级架构的IT架构通常包含了四个维度，即安全架构、技术架构、数据架构和应用架构。其中，应用架构可进一步划分为三个阶段，即分层架构、逻辑架构、物理架构，并从功能视图、接口视图、剖面视图等多个维度进行描述。实践中，上述建模方法不仅可用于搭建企业级总体架构，在描述应用系统的内部架构时也同样适用。</li>
<li>三是名词术语。基于企业级架构建设，有助于统一名词术语，改善概念混淆的状况，进而减少沟通成本。例如，在旧文档中信息系统有时被称作“系统”，也有称作“产品”或“应用”的情况。而结合企业级架构建设，可将业务领域下各类活动的系统统一称为“应用”，负责承接业务组件的系统称为“应用组件”，名称更加准确、明白。</li>
<li>四是建模方法。业界常用的建模方法一般指业务建模采用的BPMN图和实体建模采用的ER图，两者作为通用的建模语言，在开发阶段也常被使用。而企业级架构借助建模过程可将上述方法进一步推广到整个组织，进而可大幅提高描述能力和沟通效率。</li>
<li>五是职责定义。企业级架构对工作职责的定义往往是从目标(WHY)、定义(WHAT)、范围(WHERE)等三个维度进行描述，不仅言简意赅，且广泛适用于各种场景。</li>
</ul>
<p>综上，数字化转型是银行机构践行高质量发展的必由之路。自2018年提出数字化转型总体框架以来，中国银行于2019年全面启动数据治理，并在2020年启动了企业级架构建设，通过自上而下对业务架构、技术架构、工艺方法等进行全面整合，数据治理各环节工作变得更加顺畅，需求开发变得更加敏捷，数字化转型目标也愈发清晰可见!</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">企业级架构建模之浅谈三大模型关系</title>
    <id>https://ujava.cn/synthesis/modelrelation.html</id>
    <link href="https://ujava.cn/synthesis/modelrelation.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>
<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>
产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>
<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>
<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>
从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>]]></summary>
    <content type="html"><![CDATA[<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。</p>
<p>企业级架构三大模型从不同视角描述整个业务体系，将企业战略分解细化到各个业务领域的具体环节，对原本分割的部分进行系统化表达，同时弥补了产品、流程及数据间信息的不一致。<br>
产品模型是企业定制化产品的集合，阐述企业提供的服务是什么</p>
<p>流程模型展现可复用的业务环节，表达企业提供的服务怎么做</p>
<p>数据模型扮演高度集合的资源池，用统一的语言和视图支撑产品和流程模型。<br>
从结构上看，产品模型和数据模型分别通过挂接流程模型进而产生关联，三者协同便可清晰、系统化地呈现企业最终为客户提供的服务。模型间联动产出物有效指导开发，实现业务能力的复用以及业务组件的灵活配置。</p>
<h2> 01、三大模型概述</h2>
<p><br>
1.企架三大模型之——产品模型</p>
<p>通俗来说，产品泛指银行销售给客户的服务，并通过与客户签订具体产品合约获取利益。产品模型站在企业视角，确定与产品相关的业务规则、限额、约束、期限、价格等要素，形成自上而下以产品线、产品组、基础产品、产品组件和产品条件的结构化模型表达。顶层的产品线可以理解为银行业务条线，可包含多个产品组，每一个产品组是对其唯一归属的产品线下具有相似业务性质基础产品的聚合。基础产品包含了聚类可售产品所有可能的特征，为对基础产品进一步划分，可创建不同的产品组件。产品组件的存在不仅能对基础产品做出细分，同时也是最底层产品特征相同或相似的产品条件的归类。产品条件表达产品对金额、利率、期限、数量等业务特征的限制规则，可用于对属性和逻辑的控制参数。</p>
<p>2.企架三大模型之——流程模型</p>
<p>流程模型用标准化的方式表达业务流程结构，可分为五层，逐层把企业业务能力分解为业务领域、价值流、活动、任务和步骤，并通过与产品模型和数据模型协同关系，精准刻画业务需求。顶层的业务领域是紧密相关业务的集合。价值流是一组互不相同、界限分明，但相互关联的生产经营活动，是构成价值创造的动态过程，如存款和贷款的界限分明但共同存在为银行创造价值。这里的活动由不同的事件触发，比如外部事件、时间或条件触发的内部事件，活动的存在是为了达成具体的业务目的，企业执行端到端的行为序列集合；活动也是从用户角度看到的执行业务流程。具体来讲，我们可用任务来表达从银行内部执行的操作。活动和任务具备明确目的性，要求产生可观测、有价值的结果。流程模型中最底层的步骤则涵盖所有最细化的业务规则和业务信息。</p>
<p>3.企架三大模型之——数据模型</p>
<p>数据模型是企业范围内统一的数据视图，通过一系列规范和相关图表反映数据需求和设计。根据规则从企业的视角对业务概念进行逻辑化、一致性的表述，用数据语言表达业务需求并展现业务规则，是联接业务和技术的桥梁，也是业务模型的主要组成部分。具体来看，顶层的业务对象是一组关联实体的集合，要求高内聚松耦合；关联的实体不允许重复或缺失。业务实体可视为以业务视角抽象表示一种客观存在于现实世界并且可以跟其他物体区分开，用一系列业务属性来描述的事物。</p>
<p>因此业务实体所具有的某一业务特性，我们称之为实体属性。若干个属性可共同刻画同一实体。向下延申，属性域值对属性取值范围进行规范，每个属性都有需要遵循的值的范围，通过域明确属性的取值规则。属性域实例只与代码类的域关联，用于进一步明确每一个取值下的规范。一个实例组会有多个取值，每个取值称为实例组的一个实例。业务组件是独立的业务模块，指具有相似资源、人和专业技能的任务组合，通过将标准化的任务按照业务对象聚类形成业务组件。</p>
<h2> 02、模型间协同关系</h2>
<p>第一部分概述中已经对每个模型划分层级，比如产品模型自上而下分别是产品线、产品组、基础产品、产品组件和产品条件。三大模型间的协同关系主要也是讨论模型层级与层级间的联动，下面将分类剖析：</p>
<p>1.产品模型对接流程模型</p>
<p><br>
基础产品与活动（多对多） 基础产品仅关联与产品有关的活动。活动可以看作是某个基础产品在提供服务有哪些环节划分，比如任何与贷款相关的基础产品需要有申请贷款额度、审核客户背景等环节共同搭建贷款服务体系。这些环节我们就可以说是这个基础产品对应的活动。在填写流程模型活动表单时，会体现活动编号、名称、详情等信息，也会专门有一列“产品信息”来体现活动对应到哪些具体的基础产品。基础产品与任务（多对多） 刚才提到活动是环节划分，而任务则是某环节衍生出来要做的事，因此任务与其上层活动所关联的基础产品范围上是一致的。延续”申请贷款额度“这个活动案例，银行方面需要完成的任务就是“受理额度申请”等一系列为了完成客户申请贷款额度而做的工作。我们也可以理解为活动是客户角度看到的环节，而任务是从我们服务提供方内部角度对活动拆解出来需要完成的事项。当活动关联了基础产品，才会建立该活动下层任务与基础产品的关系。产品条件与步骤（多对多） 步骤则是呈现任务中的事项具体如何去操作，是环节最细致的拆分。因此当活动和任务关联了基础产品，步骤作为最底层的拆分理应映射产品模型最下层的参数-产品条件。通常一个步骤需要关联至少一个产品条件，同时每个产品条件需要被至少一个步骤使用。对“受理额度申请”这个任务来说，其中一个“检查账户信息”的具体步骤，在流程模型步骤表单“与产品模型映射”列就可以映射“开户银行类型”这一产品条件，表示对某账户开户银行具体类型的选择。</p>
<p>2.数据模型对接流程模型</p>
<p><br>
任务与业务实体（多对多） 数据模型中的实体由流程模型的任务创建而来。流程模型任务表单有专门一列“业务实体”来呈现关系。比如终止某产品协议就可以关联到“产品协议”这个实体。终止某产品协议是要做的事，要把这件事说清楚便需要创建一个产品协议实体去承接，且实体名称需与数据模型的实体精确匹配。步骤与业务实体（多对多） 步骤是任务的细化，和任务一样可以去操作实体。在实际工作中，会遇到步骤牵扯到多个实体的情况，比如“调查客户背景”这个任务，其中有一个步骤是“核实客户基本信息”，涉及操作“账户”实体和“客户信息”实体，这时可根据业务含义判断是否可拆分步骤，拆至最小颗粒度便于业务和技术人员清晰理解流程。步骤与实体属性（多对多） 实体属性用于描述业务实体。流程模型中的“业务规则”列需要体现涉及业务实体下的属性。主要体现对业务规则有影响的关键属性及对应的取值描述和使用规则。还是举“核实客户基本信息”这个步骤，在创建“客户信息”实体的同时会在业务规则中体现是对公客户还是对私客户，因此属性“客户公私类型”便会建立在数据模型与其做映射，属性的取值也直接影响到该步骤最终的结果。</p>
<p>3.业务组件对接业务对象和任务</p>
<figure><figcaption>img_43.png</figcaption></figure>
<p>业务组件与任务（一对多）</p>
<p>业务组件可视为业务分类器，作为独立的业务模块归集具有相似业务目的的任务。这里的相似主要是领域和数据使用的相似。比如“调查客户背景”和“识别客户风险”两项任务都是为了更好了解和识别客户信息和行为，涉及的数据都可以有账户实体下的所有属性字段。因此我们可以将它们归集在“客户管理”业务组件。一个任务只归属一个业务组件，一个业务组件下可包含多个紧密相关的任务。</p>
<p>业务组件与业务对象（一对一/多）</p>
<figure><figcaption>img_44.png</figcaption></figure>
<p>业务组件归集具有相似业务目的的任务，业务对象归集互相关联的实体，而实体由任务来创建。因此业务组件与业务对象的关联具体体现在业务组件下任务对业务对象下实体的操作。以最基本的存款业务举例，“存款”是业务组件，具体任务有“记录存款信息”和“更换存单”，这两项任务便可操作“存款账户”这个业务对象下的“存款合约”和“存单”两个实体。</p>
<p>3.业务事件承接业务领域和活动</p>
<p><br>
业务领域对业务划分主题类型，其具体发生的行为操作称之为业务事件。围绕业务事件所产生的两条关系可总结为业务领域包含业务事件，而事件会触发一系列活动。比如贷款这个业务领域，我们能想到发生的业务事件包括申请住房贷款、购车贷款、助学贷款等贷款额度，这些事件便可触发申请个人贷款额度的活动，这个活动下面的任务和步骤则是对其需要做的事更细致的划分。一个领域涵盖多个事件，每个活动必由一个或多个业务事件触发。在实际建模工作中，三大模型分别建立再做关联映射大大提升建模难度，为了映射而映射，导致模型质量降低。因此，从建模初期保持三大建模的“实时”匹配尤其重要。无论是顶层领域划分规则还是底层参数设定，三个建模组通过完善的沟通机制共同协商而定，是企业级建模结果能够有效应用于全领域业务的基石。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">系统总体结构设计</title>
    <id>https://ujava.cn/synthesis/overall.html</id>
    <link href="https://ujava.cn/synthesis/overall.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>
<h2> 一、系统设计的任务</h2>
<ol>
<li>系统设计的概念</li>
</ol>
<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>系统设计工作应该自顶向下地进行。首先设计总体结构，然后再逐层深入，直至进行每一个模块的设计。总体设计主要是指在系统分析的基础上，对整个系统的划分（子系统）、机器设备（包括软、硬设备）的配置、数据的存贮规律以及整个系统实现规划等方面进行合理的安排。</p>
<h2> 一、系统设计的任务</h2>
<ol>
<li>系统设计的概念</li>
</ol>
<p>系统设计又称为物理设计，是开发管理信息系统的第二阶段，系统设计通常可分为两个阶段进行，首先是总体设计，其任务是设计系统的框架和概貌，并向用户单位和领导部门作详细报告并认可，在此基础上进行第二阶段――详细设计，这两部分工作是互相联系的，需要交叉进行，本章将这两个部分内容结合起来进行介绍。</p>
<p>系统设计是开发人员进行的工作，他们将系统设计阶段得到的目标系统的逻辑模型转换为目标系统的物理模型，该阶段得到工作成果――系统设计说明书是下一个阶段系统实施的工作依据。</p>
<ol start="2">
<li>系统设计的主要内容</li>
</ol>
<p>系统设计的主要任务是进行总体设计和详细设计。下面分别说明它们的具体内容。</p>
<p>(1) 总体设计</p>
<p>总体设计包括系统模块结构设计和计算机物理系统的配置方案设计。</p>
<ol>
<li>系统模块结构设计</li>
</ol>
<p>系统模块结构设计的任务是划分子系统，然后确定子系统的模块结构，并画出模块结构图。在这个过程中必须考虑以下几个问题：</p>
<p>如何将一个系统划分成多个子系统；</p>
<p>每个子系统如何划分成多个模块；</p>
<p>如何确定子系统之间、模块之间传送的数据及其调用关系；</p>
<p>如何评价并改进模块结构的质量。</p>
<ol start="2">
<li>计算机物理系统配置方案设计</li>
</ol>
<p>在进行总体设计时，还要进行计算机物理系统具体配置方案的设计，要解决计算机软硬件系统的配置、通信网络系统的配置、机房设备的配置等问题。计算机物理系统具体配置方案要经过用户单位和领导部门的同意才可进行实施。</p>
<p>开发管理信息系统的大量经验教训说明，选择计算机软硬件设备不能光看广告或资料介绍，必须进行充分的调查研究，最好应向使用过该软硬件设备的单位了解运行情况及优缺点，并征求有关专家的意见，然后进行论证，最后写出计算机物理系统配置方案报告。</p>
<p>从我国的实际情况看，不少单位是先买计算机然后决定开发。这种不科学的、盲目的做法是不可取的，它会造成极大浪费。因为，计算机更新换代是非常快的，就是在开发初期和在开发的中后期系统实施阶段购买计算机设备，价格差别就会很大。因此，在开发管理信息系统过程中应在系统设计的总体设计阶段才具体设计计算机物理系统的配置方案。</p>
<p>(2) 详细设计</p>
<p>在总体设计基础上，第二步进行的是详细设计，主要有处理过程设计以确定每个模块内部的详细执行过程，包括局部数据组织、控制流、每一步的具体加工要求等，一般来说，处理过程模块详细设计的难度已不太大，关键是用一种合适的方式来描述每个模块的执行过程，常用的有流程图、问题分析图、IPO图和过程设计语言等；除了处理过程设计，还有代码设计、界面设计、数据库设计、输入输出设计等。</p>
<p>(3) 编写系统设计说明书</p>
<p>系统设计阶段的结果是系统设计说明书，它主要由模块结构图、模块说明书和其它详细设计的内容组成。</p>
<h2> 系统设计的方法与工具</h2>
<p>系统设计的工作复杂又细致，总体设计阶段需要进行系统模块结构设计，要将一个大系统分解成不同层次、多个模块组成的系统，在详细设计阶段要在模块结构设计的基础上，给出每个模块实现方法的细节，并对模块的输入、输出和处理过程作详细描述，以便在系统实施阶段进行程序设计时可以把这个描述直接“翻译”成用某种程序设计语言书写的程序。系统设计在技术上有相当的难度，为此需要有一定的设计方法和设计工具来指导。70年代以来，出现了多种设计方法，其中结构化设计方法是较为典型的方法，本章将对该设计方法进行论述并介绍几个常用的设计工具。</p>
<h2> 一、结构化设计的方法</h2>
<p>结构化设计（STRUCTURED DESIGN, 简称SD)<br>
方法是使用最广的一种设计方法，由美国IBM公司的W·STEVENS、G·MYERS和·CONSTANTINE等人提出。该方法适合于软件系统的总体设计和详细设计，特别是将一个复杂的系统转换成模块化结构系统，该方法具有它的优势。在使用过程中可将结构化设计方法与结构化分析（SA)<br>
方法及编程阶段的结构化程序设计方法(SP)前后衔接起来，SD方法具有以下特点：</p>
<p>1．相对独立、功能单一的模块结构</p>
<p>结构化设计的基本思想是将系统设计成由多个相对独立、功能单一的模块组成的结构。由于模块之间相对独立，每一模块就可以单独地被理解、编写、测试、排错和修改,从而有效地防止错误在模块之间扩散蔓延，提高了系统的质量(<br>
可维护性、可靠性等)。因此，大大简化了系统研制开发的工作。</p>
<p>2．“块内联系大、块间联系小”的模块性能标准</p>
<p>“模块内部联系要大，模块之间联系要小”，这是结构化设计中衡量模块“相对独立”性能的标准。事实上，块内联系和块间联系是同一件事的两个方面。系统中各组成成分之间是有联系的，若把联系密切的成分组织在同一模块中，块内联系高了，块间联系自然就少了。反之，若把密切相关的一些组成成分分散在各个模块中，势必造成很高的块间联系，这将影响系统的可维护性。所以，在系统设计过程中一定要以结构化设计的模块性能标准为指导。</p>
<p>3．采用模块结构图的描述方式</p>
<p>结构化设计方法使用的描述方式是模块结构图。</p>
<h2> 系统模块结构设计</h2>
<p>总体设计的另外一个主要内容是合理地进行系统模块结构的分析和定义，将一个复杂的系统设计转为若干个子系统和一系列基本模块的设计，并通过模块结构图把分解的子系统和一个个模块按层次结构联系起来。下面来介绍如何进行模块的分解、如何从数据流图导出模块结构图以及模块结构图的改进。</p>
<h4> 一、模块分解的原则和依据</h4>
<p>系统逻辑模型中数据流图中的模块是逻辑处理模块，模型中没有说明模块的物理构成和实现途径，同时也看不出模块的层次分解关系，为此在系统结构设计中要将数据流图上的各个逻辑处理模块进一步分解，用模块结构图确定系统的层次结构关系，并将系统的逻辑模型转变为物理模型。</p>
<ol>
<li>“耦合小，内聚大”的基本原则</li>
</ol>
<p>在结构化设计中，采用自顶向下，逐步细化的方法将系统分解成为一些相对独立、功能单一的模块。如何度量模块之间的独立性呢？</p>
<p>在一个管理信息系统中，系统的各组成部分之间总是存在着各种联系的，将系统或子系统划分成若干模块，则一个模块内部的联系就是块内联系，而穿越模块边界的联系就是块间联系。由于模块之间的互相联系越多，模块的独立性就越少，因此，引入模块耦合和内聚的概念。</p>
<p>耦合表示模块之间联系的程度。紧密耦合表示模块之间联系非常强，松散耦合表示模块之间联系比较弱，非耦合则表示模块之间无任何联系，是完全独立的。</p>
<p>内聚表示模块内部各成分之间的联系程度。</p>
<p>一般说来，在系统中各模块的内聚越大，则模块间的耦合越小。但这种关系并不是绝对的。耦合小使得模块间尽可能相对独立，从而各模块可以单独开发和维护。内聚大使得模块的可理解性和维护性大大增强。因此，在模块的分解中应尽量减少模块的耦合，力求增加模块的内聚。</p>
<ol start="2">
<li>对子系统或模块进行划分的依据</li>
</ol>
<p>一个合理的子系统或模块划分，应该是内部联系强，子系统或模块间尽可能独立，接口明确、简单，尽量适应用户的组织体系，有适当的共用性。也就是上面所说的“耦合小，内聚大”。按照结构化设计的思想，对模块或子系统进行划分的依据通常有以下几种：</p>
<p>(1)按逻辑划分，把相类似的处理逻辑功能放在一个子系统或模块里。例如，把“对所有业务输入数据进行编辑”的功能放在一个子系统或模块里。那么不管是库存、还是财务，只要有业务输入数据都由这个子系统或模块来校错、编辑。</p>
<p>(2)按时间划分，把要在同一时间段执行的各种处理结合成一个子系统或模块。</p>
<p>(3)按过程划分，即按工作流程划分。从控制流程的角度看，同一子系统或模块的许多功能都应该是相关的。</p>
<p>(4)按通信划分，把相互需要较多通讯的处理结合成一个子系统或模块。这样可减少子系统间或模块间的通讯，使接口简单。</p>
<p>(5)按职能划分，即按管理的功能。例如，财务、物资、销售子系统，或输入记帐凭证、计算机优解子系统或模块等等。</p>
<p>一般来说，按职能划分子系统，按逻辑划分模块的方式是比较合理和方便的</p>
<h2> 详细设计</h2>
<p>进行了系统的总体设计后即可在此基础上进行系统的详细设计了，即各种输入、输出、处理和数据存储等的详细设计。下面分别介绍详细设计的内容。</p>
<h4> 一、代码设计</h4>
<p>代码是用来表示事物名称、属性和状态等的符号。在管理信息系统中，代码是人和机器的共同语言，是系统进行信息分类、校对、统计和检索的依据。代码设计就是要设计出一套能为系统各部门公用的、优化的代码系统，这是实现计算机管理的一个前提条件。</p>
<ol>
<li>代码设计的原则</li>
</ol>
<p>代码设计是一项重要的工作，合理的编码结构是使管理信息系统具有生命力的重要因素。设计代码的基本原则是：</p>
<p>(1) 具备唯一确定性。每一个代码都仅代表唯一的实体或属性。</p>
<p>(2) 标准化与通用性。凡国家和主管部门对某些信息分类和代码有统一规定和要求的，则应采用标准形式的代码，以使其通用化。</p>
<p>(3) 可扩充且易修改。要考虑今后的发展，为增加新代码留有余地。当某个代码在条件或代表的实体改变时，容易进行变更。</p>
<p>(4) 短小精悍即选择最小值代码。代码的长度会影响所占据的内存空间、处理速度以及输入时的出错概率，因此要尽量短小。</p>
<p>(5) 具有规律性、便于编码和识别。代码应具有逻辑性强，直观性好的特点，便于用户识别和记忆。</p>
<ol start="2">
<li>分类方法</li>
</ol>
<p>目前最常用的分类方案有两种，一种是线分类方法，一种是面分类方法。在实际应用中根据具体情况各有其不同的用途。</p>
<p>线分类方法：首先给定母项，然后下分若干子项，由对象的母项分大集合，由大集合确定小集合，最后落实到具体对象</p>
<p>特点：结构清晰，容易识别和记忆，易查找；适应于手工系统；</p>
<p>缺点：结构不灵活，柔性差。</p>
<p>线分类时要掌握两个原则：唯一性和不交叉性。</p>
<p>例：公司生产组织结构。</p>
<p>面分类方法：它主要从面的角度来考虑分类</p>
<p>面分类的特点：</p>
<p>柔性好，面上的增、删、改很容易；</p>
<p>可实现按任意组配面的信息检索，对机器处理有良好的适应性；</p>
<p>缺点是不易直观识别，不便于记忆。</p>
<p>系统设计报告</p>
<p>系统设计阶段的成果是系统设计报告， 其主要是各种设计方案和设计图表，它是下一步系统实现的基础。</p>
<h4> 一、系统设计的成果</h4>
<p>系统设计阶段的成果归纳起来一般有 (点击这里观看“各开发环节之间的关系”动画演示)：</p>
<p>1.系统总体结构图（包括总体结构图，子系统结构图，计算机流程图等）。</p>
<p>2.系统设备配置图（系统设备配置图： 主要是计算机系统图，设备在各生产岗位的分布图，主机、网络、终端联系图等）。</p>
<p>3.系统分布编码方案（分类方案、编码系统）。</p>
<p>4.数据库结构图（DB的结构，主要指表与表之间的结构，表内部结构（字段、域、数据字典等）。</p>
<p>5.HIPO图（层次化模块控制图、IPO图等等）。</p>
<p>6.系统详细设计方案说明书。</p>
<h2> 二、系统设计说明书的组成</h2>
<ol>
<li>引言</li>
</ol>
<p>(1) 摘要 系统的目标名称和功能等的说明</p>
<p>(2) 背景</p>
<ul>
<li>项目开发者</li>
<li>用户</li>
<li>本项目和其它系统或机构的关系和联系</li>
</ul>
<p>(3) 系统环境与限制</p>
<ul>
<li>硬件、软件和运行环境方面的限制</li>
<li>保密和安全的限制</li>
<li>有关系统软件文本</li>
<li>有关网络协议标准文本</li>
</ul>
<p>(4) 参考资料和专门术语说明</p>
<h2> 2.系统设计方案</h2>
<p>(1) 模块设计</p>
<ul>
<li>系统的模块结构图</li>
<li>各个模块的IPO图(包括各模块的名称、功能、调用关系、局部数据项和详细的算法说明等)</li>
</ul>
<p>(2) 代码设计</p>
<p>各类代码的类型、名称、功能、使用范围和使用要求等的设计说明书</p>
<p>(3) 输入设计</p>
<p>输入项目</p>
<p>输入人员(指出所要求的输入操作人员的水平与技术专长，说明与输入数据有关的接口软件及其来源)</p>
<p>主要功能要求(从满足正确、迅速、简单、经济、方便使用者等方面达到要求的说明)</p>
<p>输入校验(关于各类输入数据的校验方法的说明)</p>
<p>(4) 输出设计</p>
<p>输出项目</p>
<p>输出接受者</p>
<p>输出要求(所用设备介质、输出格式、数值范围和精度要求等)</p>
<p>(5) 文件(数据库)设计说明</p>
<p>概述(目标、主要功能)</p>
<p>需求规定(精度、有效性、时间要求及其它专门要求)</p>
<p>运行环境要求(设备支撑软件，安全保密等要求)</p>
<p>逻辑结构设计(有关文件及其记录、数据项的标识、定义、长度和它们之间的关系)</p>
<p>物理结构设计(有关文件的存贮要求、访问方法、存贮单位、设计考虑和保密处理等)</p>
<p>(6) 模型库和方法库设计(本系统所选用的数学模型和方法以及简要说明)</p>
<p>(7) 安全保密设计</p>
<p>(8) 物理系统配置方案报告</p>
<p>硬件配置设计</p>
<p>通信与网络配置设计</p>
<p>软件配置设计</p>
<p>机房配置设计</p>
<p>(9) 系统实施方案及说明</p>
<p>实施方案</p>
<p>实施计划(包括工作任务的分解、进度安排和经费预算)</p>
<p>实施方案的审批(说明经过审批的实施方案概况和审批人员的姓名)</p>
<p>3.案例</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>模块名称</th>
<th>主要用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>无线寻呼管理信息系统-系统设计说明书</td>
<td>研究开发5-10万用户寻呼机管理信息系统，它可以进行普通寻呼服务；漫游寻呼服务；群呼服务；试机服务；定时服务；系统管理；运行管理。</td>
</tr>
<tr>
<td>2</td>
<td>库存管理系统-系统设计说明书</td>
<td>研发库存控制系统的主要目的:1）为顾客订货提供更好的服务；2）控制库存水平；3）决定向厂家订货的时间和批量。</td>
</tr>
<tr>
<td>3</td>
<td>百货商店业务管理信息系统-系统设计</td>
<td>实现登记、整理数据，处理核对顾客订货单；向经理提供各种业务统计报表；提供各级查询；销售、采购、会计各部门的业务数据处理实现自动化。</td>
</tr>
<tr>
<td>4</td>
<td>铁道财务会计管理信息系统-系统设计</td>
<td>运用系统的方法以计算机和现代通信技术为基本信息处理手段和工具的，能为全国铁道财务会计核算、管理、决策提供信息服务的人—机系统。</td>
</tr>
<tr>
<td>5</td>
<td>高校选课辅助决策</td>
<td>本选课系统能够使学生在INTERNET上自主、便捷、准确地进行全校性课程选择的一种软件。学生在选择选修课前，可以上网进行查询，当学生输入其学号与密码后，系统便调出其所有相关信息，包括已修课程、已修课程的成绩、专业培养计划、全校性可选课程，系统进行综合分析后，得到一些可行的方案，供选课学生参考，并提出合理建议。</td>
</tr>
<tr>
<td>6</td>
<td>条形材料选材优化</td>
<td>要制造器件,必须先制造一定的零件,而这些零件又由某种原材料截取而得到。例如：用某一种条形材料锯成数种需要的零件，求最少的用料数量。使用运筹学线性规划的思想和解决方法。</td>
</tr>
</tbody>
</table>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">高并发场景下如何优化微服务的性能</title>
    <id>https://ujava.cn/synthesis/performance.html</id>
    <link href="https://ujava.cn/synthesis/performance.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1.背景介绍</h2>
<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>
<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>
<h2> 2.核心概念与联系</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 1.背景介绍</h2>
<p>随着互联网和大数据时代的到来，数据量的增长和计算需求的提高对传统计算方法的压力日益大。微服务架构在分布式系统中发挥着越来越重要的作用，它将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。然而，微服务架构中的计算性能是一个关键问题，需要进行重构来提高性能。</p>
<p>在这篇文章中，我们将探讨如何在微服务架构中实现高性能的重构计算方法。我们将从背景介绍、核心概念与联系、核心算法原理和具体操作步骤以及数学模型公式详细讲解，到具体代码实例和详细解释说明，再到未来发展趋势与挑战，最后附录常见问题与解答。</p>
<h2> 2.核心概念与联系</h2>
<p>在微服务架构中，计算性能的重构主要包括以下几个方面：</p>
<p>分布式计算：将计算任务分散到多个节点上，通过网络间通信实现数据交换和任务协同。<br>
并发处理：利用多核处理器和多线程技术，实现并发处理，提高计算效率。<br>
数据分区：将数据划分为多个部分，每个服务只处理自己的数据，减少通信开销。<br>
负载均衡：将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>
这些概念和技术在微服务架构中相互联系，共同实现高性能计算。</p>
<h2> 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解</h2>
<p>在微服务架构中，重构计算的核心算法原理包括以下几个方面：</p>
<h1> 分布式计算：使用MapReduce算法实现分布式计算，将大型数据集划分为多个子任务，每个子任务在多个节点上并行执行，最后通过reduce阶段将结果聚合到一个最终结果中。<br>
MapReduce=(Map,Shuffle,Reduce)<br>
MapReduce</h1>
<h1> (<br>
Map<br>
,<br>
Shuffle<br>
,<br>
Reduce<br>
)<br>
并发处理：使用线程池技术实现并发处理，将任务分配到多个线程中执行，提高计算效率。<br>
线程池=(核心线程数,最大线程数,工作队列)<br>
线程池</h1>
<h1> (<br>
核心线程数<br>
,<br>
最大线程数<br>
,<br>
工作队列<br>
)<br>
数据分区：使用哈希分区算法实现数据分区，将数据按照某个关键字划分为多个部分，每个服务只处理自己的数据。<br>
哈希分区=(关键字,哈希函数,分区数)<br>
哈希分区</h1>
<h1> (<br>
关键字<br>
,<br>
哈希函数<br>
,<br>
分区数<br>
)<br>
负载均衡：使用Consistent Hashing算法实现负载均衡，将计算任务分配到多个节点上，实现资源共享和负载均衡。<br>
一致性哈希=(虚拟节点,哈希函数,节点集)<br>
一致性哈希</h1>
<p>(<br>
虚拟节点<br>
,<br>
哈希函数<br>
,<br>
节点集<br>
)</p>
<h2> 4.具体代码实例和详细解释说明</h2>
<p>在这里，我们以一个简单的Word Count示例来展示如何在微服务架构中实现高性能计算。</p>
<p>使用MapReduce算法实现分布式计算：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用线程池技术实现并发处理：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用哈希分区算法实现数据分区：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用一致性哈希算法实现负载均衡：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5.未来发展趋势与挑战</h2>
<p>随着大数据和人工智能的发展，微服务架构在计算性能方面面临着越来越大的挑战。未来的发展趋势包括：</p>
<ul>
<li>
<p>更高性能的分布式计算：通过优化算法和数据结构，提高分布式计算的性能。</p>
</li>
<li>
<p>更智能的负载均衡：通过学习算法和自适应机制，实现更智能的负载均衡。</p>
</li>
<li>
<p>更高效的数据存储和处理：通过新的存储技术和处理方法，提高数据存储和处理的效率。<br>
挑战包括：</p>
</li>
<li>
<p>系统复杂性：微服务架构的系统复杂性增加，导致开发、测试和维护的难度增加。</p>
</li>
<li>
<p>数据一致性：在分布式计算中，保证数据的一致性变得越来越难以实现。</p>
</li>
<li>
<p>安全性和隐私：在大数据时代，数据安全性和隐私保护成为关键问题。</p>
</li>
</ul>
<h2> 6.附录常见问题与解答</h2>
<p>Q: 微服务架构与传统架构有什么区别？</p>
<p>A: 微服务架构将单个应用程序拆分成多个小服务，每个服务运行在自己的进程中，通过网络间通信进行数据交换。而传统架构通常是基于大型应用程序和单个进程结构的。</p>
<p>Q: 如何选择合适的算法和数据结构？</p>
<p>A: 在选择算法和数据结构时，需要考虑问题的特点，如问题规模、时间复杂度、空间复杂度等。同时，也需要考虑算法和数据结构的实现难度和性能。</p>
<p>Q: 如何保证微服务架构的高性能？</p>
<p>A: 要保证微服务架构的高性能，需要关注分布式计算、并发处理、数据分区和负载均衡等方面。同时，还需要关注系统的设计和优化，如选择合适的算法和数据结构、减少通信开销、提高系统可扩展性等。</p>
<p>Q: 如何处理微服务架构中的数据一致性问题？</p>
<p>A: 在微服务架构中，数据一致性问题可以通过使用分布式事务、版本控制和幂等性等方法来解决。同时，还可以通过设计合理的系统架构和算法来减少数据一致性问题的影响。</p>
<p>Q: 如何保证微服务架构的安全性和隐私？</p>
<p>A: 保证微服务架构的安全性和隐私需要关注多方面，如身份验证、授权、加密、审计等。同时，还需要关注数据存储和处理的安全性，如使用安全的存储技术和处理方法。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">微服务架构构建之微服务拆分</title>
    <id>https://ujava.cn/synthesis/split.html</id>
    <link href="https://ujava.cn/synthesis/split.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>
<h2> 一、微服务拆分的原则</h2>
<p>微服务拆分原则有以下几个：</p>
<p>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</p>
<p>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>微服务架构是将一个单体应用程序拆分为一个个独立且保持松耦合的服务的一种架构方式，每个服务有着独立的数据库并且能独立运行部署。微服务架构的构建过程中，第一步也是最为重要的一步是进行服务拆分。只有将微服务按照合理的方式进行拆分，才能确保整个项目能够高效而正确地运行。</p>
<h2> 一、微服务拆分的原则</h2>
<p>微服务拆分原则有以下几个：</p>
<p>单一职责原则：每个微服务应该有一个明确的职责范围，只负责自己的一部分业务功能，不涉及其他职责。</p>
<p>服务自治原则：每个微服务应该具备自我管理、独立部署、独立伸缩、独立运维的能力，不与其他服务强依赖。</p>
<p>服务可复用原则：每个微服务应该是可复用的，可以为其他服务提供通用的服务功能。</p>
<p>服务粒度原则：微服务应该按照业务功能划分，而不是按照技术、数据结构等因素划分，保持服务规模适度。</p>
<p>服务高内聚、低耦合原则：微服务内部业务功能高度内聚，与其他服务之间耦合度低，便于分布式部署和独立开发、维护。</p>
<p>服务易于测试原则：每个微服务应该具备自我测试的能力，包括单元测试、接口测试、集成测试等多种形式，确保服务质量。</p>
<p>服务可扩展原则：每个微服务应该能够按照业务需求进行扩展，包括水平扩展和垂直扩展两种方式，以应对高并发、大流量等场景。</p>
<p>同样，也可以参考一下，这篇文章对服务拆分原则的理解。以下摘自该文章。</p>
<p>使用有界上下文。</p>
<p>确定核心域并保持竞争优势。</p>
<p>对通用域进行成本优化。</p>
<p>考虑支持领域。</p>
<p>引入反腐层。</p>
<p>识别数据通信模式。</p>
<p>引入事件驱动架构。</p>
<p>使API简洁明了。</p>
<p>将相关的微服务合并为更大的服务。</p>
<p>引入无缝开发支持工具。</p>
<p>不管是哪种拆分原则，目标都是需要将相同或相似的服务聚合在一起，形成一个独立的自治服务。</p>
<h2> 二、微服务拆分的时机</h2>
<p>通过《02-微服务架构的概念与优缺点》可以了解到微服务架构具备很多的优点，能够有效解决项目业务扩大所带来的问题。然而，并非所有公司都适合采用微服务架构，尤其是规模较小且业务相对固定的公司。对于这些公司来说，从服务层面，他们不会有更多变化，通过优化现有服务即可满足需求。从成本方面，构建微服务架构，需要很多资源和配套的中间件。因此，对于那些规模较大，业务服务复杂度高，同时业务也在不断更新或新增的项目，微服务架构则是非常适合的选择。</p>
<p>在确定使用微服务架构后，服务的拆分是一项重要任务。根据拆分原则，我们可以在恰当的时机进行服务拆分。然而，根据行业经验来看，并不建议在项目构建初期进行服务拆分。主要原因有以下几点：</p>
<p>项目构建初期，服务单一，数据量较少，及时是单体系统都可以支撑业务。</p>
<p>项目构建初期，服务没有形成体系，更没有规模服务，很难做到微服务的单一职责和服务自治。</p>
<p>业务架构不够成熟，目前提供的服务，很有可能会优化，甚至更改技术栈重构。</p>
<p>因此，项目构建初期无需将其拆分，因为强行拆分此时可能会产生适得其反的效果。而遇到下面这些情况就可以进行服务拆分了。</p>
<p>项目足够成熟并且业务稳定，团队成员不断扩大并且目前的服务想要扩展很难。只有在项目成熟的情况下，业务专家才可以从精确的划分出业务领域，进而将各个服务分解到业务领域内，最终形成各自独立的微服务。</p>
<p>项目要求CI/CD（持续集成/持续交付）。尤其是很多新兴的互联网公司，要求系统在尽可能不停机的情况下，还需要持续上线新的功能。使用敏捷开发，可以更好地让开发者在完成周期形的业务交付，而DevOps则可以将这些代码，进行自动化测试、构建和集成，不断的完成新的需求提交，并保证代码的质量和稳定性。</p>
<p>正式运行的项目，部分服务需要停机。当上线一些有问题的服务时，将该部分服务停机，这个情况对单体应用是非常有困难的。而微服务架构中，可以对存在问题的微服务进行下线处理，从而达到快速解决问题的目的。</p>
<h2> 三、微服务拆分的方法</h2>
<p>在掌握了准确的微服务拆分时机和有了强有力的拆分原则后，拆分方法将成为下一个关键环节。现在微服务拆分的方法有很多种，常见的包括：</p>
<p>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。</p>
<p>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>
<p>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。</p>
<p>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。</p>
<p>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。</p>
<p>从行业经验来看，可以确定领域驱动设计（Domain Driven Design，简称DDD）在微服务拆分方面具有显著优势。</p>
<p>DDD是一种软件开发方法论，它强调将软件划分为不同的领域，每个领域都由一个核心模型驱动。 微服务架构的核心概念是将单一的应用程序拆分为一组小型、自治的服务。而DDD则提供了一种方法来设计这些微服务的边界和交互。 领域驱动设计引入了领域模型的概念，该模型描述了业务领域的核心概念和实体，而不关注技术实现细节。这使得团队可以专注于业务逻辑，而不被底层技术细节所干扰。 通过将领域模型作为微服务拆分的基础，可以确保每个微服务都是高内聚的，并且只关注自己领域内的业务逻辑。这种拆分方式使得每个微服务都能够独立开发、部署和维护，从而提高了系统的可伸缩性和可靠性。 此外，DDD还强调了领域驱动设计的语言在业务团队和开发团队之间的沟通和理解的重要性。通过共享统一的语言和概念，可以确保业务需求能够准确地传达给开发团队，并且开发团队能够将其转化为可行的技术解决方案。 因此，DDD是一种非常适合成为微服务拆分的方法论。它能够帮助开发人员更好地理解业务需求，找到合适的服务边界，构建高质量的领域模型和微服务。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">概要设计和详细设计</title>
    <id>https://ujava.cn/synthesis/summary.html</id>
    <link href="https://ujava.cn/synthesis/summary.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概要设计和详细设计</h2>
<p>在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？</p>
<p>一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。<br>
结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。</p>
<p>这样一来，设计可以明显地划分成两个阶段：</p>
<ul>
<li>概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。</li>
<li>详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 概要设计和详细设计</h2>
<p>在软件设计中，大家经常问到的一个问题是：概要设计应该怎样一个概要法，详细设计应该怎样一个详细法？</p>
<p>一般公司的研发流程是瀑布型的，这个模型中的分析、设计阶段是基于经典的结构化方法。<br>
结构化设计方法的基本思路是：按照问题域，将软件逐级细化，分解为不必再分解的的模块，每个模块完成一定的功能，为一个或多个父模块服务（即接受调用），也接受一个或多个子模块的服务（即调用子模块）。模块的概念，和编程语言中的子程序或函数是对应的。</p>
<p>这样一来，设计可以明显地划分成两个阶段：</p>
<ul>
<li>概要（结构）设计阶段：把软件按照一定的原则分解为模块层次，赋予每个模块一定的任务，并确定模块间调用关系和接口。</li>
<li>详细设计阶段：依据概要设计阶段的分解，设计每个模块内的算法、流程等。</li>
</ul>
<h2> 一、概要设计阶段</h2>
<p>在这个阶段，设计者会大致考虑并照顾模块的内部实现，但不过多纠缠于此。主要集中于划分模块、分配任务、定义调用关系。模块间的接口与传参在这个阶段要定得<br>
十分细致明确，应编写严谨的数据字典，避免后续设计产生不解或误解。概要设计一般不是一次就能做到位，而是反复地进行结构调整。典型的调整是合并功能重复的模块，或者进一步分解出可以复用的模块。在概要设计阶段，应最大限度地提取可以重用的模块，建立合理的结构体系，节省后续环节的工作量。</p>
<p>概要设计文档最重要的部分是分层数据流图、结构图、数据字典以及相应的文字说明等。以概要设计文档为依据，各个模块的详细设计就可以并行展开了。</p>
<h2> 二、详细设计阶段</h2>
<ul>
<li>在这个阶段，各个模块可以分给不同的人去并行设计。在详细设计阶段，设计者的工作对象是一个模块，根据概要设计赋予的局部任务和对外接口，设计并表达出模块的算法、流程、状态转换等内容。这里要注意，如果发现有结构调整（如分解出子模块等）的必要，必须返回到概要设计阶段，将调整反应到概要设计文档中，而不能就地解决，不打招呼。</li>
<li>详细设计文档最重要的部分是模块的流程图、状态图、局部变量及相应的文字说明等。一个模块一篇详细设计文档。</li>
<li>概要设计文档相当于机械设计中的装配图，而详细设计文档相当于机械设计中的零件图。文档的编排、装订方式也可以参考机械图纸的方法。</li>
<li>概要设计中较顶层的部分便是所谓的方案。方案文档的作用是在宏观的角度上保持设计的合理性。</li>
</ul>
<p>有的项目采用面向对象的分析、设计方法。可能在概要设计、详细设计的分工上疑问更多。其实，面向对象的分析、设计方法并没有强调结构化方法那样的阶段性，因此一般不引入概要、详细设计的概念。如果按照公司的文档体系，非要有这种分工的话，可以将包的划分、类及对象间的关系、类的对外属性、方法及协作设计看做</p>
<ul>
<li>概要设计；类属性、方法的内部实现看做详细设计。</li>
<li>需求分析--产生软件功能规格说明书,需要确定用户对软件的需求,要作到明确、无歧义。不涉及具体实现方法。用户能看得明白，开发人员也可据此进行下面的工作（概要设计）。</li>
<li>概要设计--产生软件概要设计说明书，说明系统模块划分、选择的技术路线等，整体说明软件的实现思路。并且需要指出关键技术难点等。</li>
<li>详细设计--产生软件详细设计说明书，对概要设计的进一步细化，一般由各部分的担当人员依据概要设计分别完成，然后在集成，是具体的实现细节。理论上要求可以照此编码。</li>
</ul>
<h2> 三、概要设计和详细设计的区别与联系</h2>
<ul>
<li>概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。</li>
<li>详细设计阶段就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。</li>
<li>概要设计阶段通常得到软件结构图，详细设计阶段常用的描述方式有：流程图、N-S图、PAD图、伪代码等。</li>
<li>软件设计采用自顶向下、逐次功能展开的设计方法，首先完成总体设计，然后完成各有机组成部分的设计。根据工作性质和内容的不同，软件设计分为概要设计和详细设计。概要设计实现软件的总体设计、模块划分、用户界面设计、数据库设计等等；详细设计则根据概要设计所做的模块划分，实现各模块的算法设计，实现用户界面设计、数据结构设计的细化，等等。</li>
<li>概要设计是详细设计的基础，必须在详细设计之前完成，概要设计经复查确认后才可以开始详细设计。概要设计，必须完成概要设计文档，包括系统的总体设计文档、以及各个模块的概要设计文档。每个模块的设计文档都应该独立成册。</li>
<li>详细设计必须遵循概要设计来进行。详细设计方案的更改，不得影响到概要设计方案；如果需要更改概要设计，必须经过项目经理的同意。详细设计，应该完成详细设计文档，主要是模块的详细设计方案说明。和概要设计一样，每个模块的详细设计文档都应该独立成册。</li>
<li>概要设计里面的数据库设计应该重点在描述数据关系上，说明数据的来龙去脉，在这里应该结合我们的一下结果数据，说明这些结果数据的源点，我们这样设计的目的和原因。详细设计里的数据库设计就应该是一份完善的数据结构文档，就是一个包括类型、命名、精度、字段说明、表说明等内容的数据字典。</li>
<li>概要设计里的功能应该是重点在功能描述，对需求的解释和整合，整体划分功能模块，并对各功能模块进行详细的图文描述，应该让读者大致了解系统作完后大体的结构和操作模式。详细设计则是重点在描述系统的实现方式，各模块详细说明实现功能所需的类及具体的方法函数，包括涉及到的sql语句等。</li>
</ul>
<h2> 四、软件设计的过程</h2>
<p>1、制定规范</p>
<p>在软件开发组设计标准，规定编码的信息格式，命名规则</p>
<p>2、软件系统结构的总体设计</p>
<p>基于功能层次，划分模块，采用抽象、分层、模块分解</p>
<p>3、处理方式设计</p>
<p>确定为实现功能的需求所必须的算法，评估算法的性能。</p>
<p>4、数据结构设计</p>
<p>确定数据的模式，子模式，安全性，整体性，输入输出文件的结构和模式</p>
<p>5、可靠性设计（质量设计）</p>
<p>运行期间为了使用要求，保证可靠的运行</p>
<p>6、编写概要设计阶段的文档</p>
<p>概要设计说明书，数据库的说明书，进一步完善用户手册，制定初步的测试计划</p>
<p>7、概要设计评审</p>
<p>概要设计说明书，评审的要点：可追溯性、接口、</p>
<p>模块的内部，高内聚、低耦合</p>
<p>模块的作用于是否在控制范围内，实用性，技术清晰性</p>
<p>其他的选择方案，</p>
<p>8、详细设计阶段</p>
<p>确定软件各个组成部分的算法，</p>
<p>选定某种过程的表达形式，</p>
<p>进行详细设计的评审，</p>
<h2> 五、软件设计的基础</h2>
<p>自定下下，逐步细化</p>
<p>将软件的体系结构按自定向下方式，对各个层次的过程细节和数据细节逐层细化</p>
<p>软件结构</p>
<p>软件的结构包括两部分。程序的模块结构和数据的结构。</p>
<p>程序结构</p>
<p>树状结构、网状结构、</p>
<p>结构图</p>
<p>反应程序中模块中模块之间的层次调用关系和联系</p>
<p>模块</p>
<p>模块的调用关系和接口</p>
<p>模块之间的信息传递</p>
<p>表示模块A有条件地调用另一个模块</p>
<p>模块化</p>
<p>能够把一个大而复杂的软件系统划分成易于理解的比较单纯的模块结构。</p>
<p>抽象化</p>
<p>软件系统进行模块设计时，可以有不同的抽象层次。</p>
<p>功能抽象：</p>
<p>抽象层次1（高层次的抽象）：用问题所处环境的术语来描述这个软件。</p>
<p>抽象层次2：任务需求的描述。</p>
<p>抽象层次3：程序过程表示。</p>
<p>数据抽象：在不同层次上描述数据对象的细节，定义与该数据对象相关的操作。</p>
<p>模块独立性：</p>
<p>模块：一般具有如下三个基本属性：功能、逻辑、状态、模块的独立性、采用耦合和内聚</p>
<h2> 六、概要设计说明书：</h2>
<p>1、引言</p>
<p>1.1编写目的</p>
<p>1.2项目背景</p>
<p>1.3定义</p>
<p>1.4参考资料</p>
<p>2、任务概述</p>
<p>2.1目标</p>
<p>2.2运行环境</p>
<p>2.3需求概述</p>
<p>2.4条件与限制</p>
<p>3、总体设计</p>
<p>3.1处理流程</p>
<p>3.2总体结构和模块外部设计</p>
<p>3.3功能分配</p>
<p>4、接口设计</p>
<p>4.1外部接口</p>
<p>4.2内部接口</p>
<p>5、数据结构设计</p>
<p>5.1逻辑结构设计</p>
<p>5.2物理结构设计</p>
<p>5.3数据结构与程序的关系</p>
<p>6、运行设计</p>
<p>6.1运行模块的组合</p>
<p>6.2运行控制</p>
<p>6.3运行时间</p>
<p>7、出错处理设计</p>
<p>7.1出错输出信息</p>
<p>7.2出错处理对策</p>
<p>8、安全保密设计</p>
<p>9、维护设计</p>
<h2> 详细设计说明书</h2>
<p>1、引言</p>
<p>1.1编写目的</p>
<p>1.2项目背景</p>
<p>1.3定义</p>
<p>1.4参考资料</p>
<p>2、总体设计</p>
<p>2.1需求概述</p>
<p>2.2软件结构</p>
<p>3、程序描述</p>
<p>3.1功能</p>
<p>3.2性能</p>
<p>3.3输入项目</p>
<p>3.4输出项目</p>
<p>3.5算法</p>
<p>3.6程序逻辑</p>
<p>3.7接口</p>
<p>3.8存储分配</p>
<p>3.9限制条件</p>
<p>3.10测试要点</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">4种MySQL同步ES方案</title>
    <id>https://ujava.cn/synthesis/synchronousdata.html</id>
    <link href="https://ujava.cn/synthesis/synchronousdata.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>
<figure><figcaption>img_129.png</figcaption></figure>
<h1> <strong>1.前言</strong></h1>
<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>
这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>
我们先看看下面 4 种常用的数据同步方案。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具</p>
<figure><figcaption>img_129.png</figcaption></figure>
<h1> <strong>1.前言</strong></h1>
<p>在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。<br>
这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。<br>
我们先看看下面 4 种常用的数据同步方案。</p>
<h1> <strong>2.数据同步方案</strong></h1>
<h2> <strong>2.1同步双写</strong></h2>
<p>这是一种最为简单的方式，在将数据写到 MySQL 时，同时将数据写到 ES。</p>
<figure><figcaption>img_130.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>业务逻辑简单；</li>
<li>实时性高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>硬编码，有需要写入 MySQL 的地方都需要添加写入 ES 的代码；</li>
<li>业务强耦合；</li>
<li>存在双写失败丢数据风险；</li>
<li>性能较差，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。</li>
</ul>
<h2> <strong>2.2异写同步</strong></h2>
<p>针对多数据源写入的场景，可以借助 MQ 实现异步的多源写入。</p>
<figure><figcaption>img_131.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>性能高；</li>
<li>不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息；</li>
<li>多源写入之间相互隔离，便于扩展更多的数据源写入。</li>
</ul>
<p>缺点：</p>
<ul>
<li>硬编码问题，接入新的数据源需要实现新的消费者代码；</li>
<li>系统复杂度增加，引入了消息中间件；</li>
<li>MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时。</li>
</ul>
<h2> <strong>2.3基于SQL抽取</strong></h2>
<p>上面两种方案中都存在硬编码问题，代码的侵入性太强，如果对实时性要求不高的情况下，可以考虑用定时器来处理：</p>
<ol>
<li>数据库的相关表中增加一个字段为 timestamp 的字段，任何 CURD 操作都会导致该字段的时间发生变化；</li>
<li>原来程序中的 CURD 操作不做任何变化；</li>
<li>增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；</li>
<li>逐条写入到 ES 中。</li>
</ol>
<figure><figcaption>img_132.png</figcaption></figure>
<p>优点：</p>
<ul>
<li>不改变原来代码，没有侵入性、没有硬编码；</li>
<li>没有业务强耦合，不改变原来程序的性能；</li>
<li>Worker 代码编写简单不需要考虑增删改查。</li>
</ul>
<p>缺点：</p>
<ul>
<li>时效性较差，由于是采用定时器根据固定频率查询表来同步数据，尽管将同步周期设置到秒级，也还是会存在一定时间的延迟；</li>
<li>对数据库有一定的轮询压力，一种改进方法是将轮询放到压力不大的从库上。</li>
</ul>
<p><strong>经典方案：借助 Logstash 实现数据同步，其底层实现原理就是根据配置定期使用 SQL 查询新增的数据写入 ES 中，实现数据的增量同步。</strong></p>
<h2> <strong>2.4基于Binlog实现同步</strong></h2>
<p>上面三种方案要么有代码侵入，要么有硬编码，要么有延迟，那么有没有一种方案既能保证数据同步的实时性又没有代入侵入呢？</p>
<p>当然有，可以利用 MySQL 的 Binlog 来进行同步。</p>
<figure><figcaption>img_133.png</figcaption></figure>
<p>具体步骤如下：</p>
<ul>
<li>读取 MySQL 的 Binlog 日志，获取指定表的日志信息；</li>
<li>将读取的信息转为 MQ；</li>
<li>编写一个 MQ 消费程序；</li>
<li>不断消费 MQ，每消费完一条消息，将消息写入到 ES 中。</li>
</ul>
<p>优点：</p>
<ul>
<li>没有代码侵入、没有硬编码；</li>
<li>原有系统不需要任何变化，没有感知；</li>
<li>性能高；</li>
<li>业务解耦，不需要关注原来系统的业务逻辑。</li>
</ul>
<p>缺点：</p>
<ul>
<li>构建 Binlog 系统复杂；</li>
<li>如果采用 MQ 消费解析的 Binlog 信息，也会像方案二一样存在 MQ 延时的风险。</li>
</ul>
<h1> <strong>3.数据迁移工具</strong></h1>
<p>对于上面 4 种数据同步方案，“基于 Binlog 实时同步”方案是目前最常用的，也诞生了很多优秀的数据迁移工具，这里主要对这些迁移工具进行介绍。</p>
<p>这些数据迁移工具，很多都是基于 Binlog 订阅的方式实现，<strong>模拟一个 MySQL Slave 订阅 Binlog 日志，从而实现 CDC</strong>（Change Data Capture），将已提交的更改发送到下游，包括 INSERT、DELETE、UPDATE。</p>
<p>至于如何伪装？大家需要先了解 MySQL 的主从复制原理，需要学习这块知识的同学，可以看我之前写的高并发教程，里面有详细讲解。</p>
<h2> <strong>3.1Canal</strong></h2>
<p>基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持 MySQL。</p>
<p>Canal 原理就是伪装成 MySQL 的从节点，从而订阅 master 节点的 Binlog 日志，主要流程为：</p>
<ol>
<li>Canal 服务端向 MySQL 的 master 节点传输 dump 协议；</li>
<li>MySQL 的 master 节点接收到 dump 请求后推送 Binlog 日志给 Canal 服务端，解析 Binlog 对象（原始为 byte 流）转成 Json 格式；</li>
<li>Canal 客户端通过 TCP 协议或 MQ 形式监听 Canal 服务端，同步数据到 ES。</li>
</ol>
<figure><figcaption>img_134.png</figcaption></figure>
<h2> <strong>3.2阿里DTS</strong></h2>
<p>数据传输服务 DTS（Data Transmission Service）支持 RDBMS、NoSQL、OLAP 等多种数据源之间的数据传输。</p>
<p>它提供了数据迁移、实时数据订阅及数据实时同步等多种数据传输方式。相对于第三方数据流工具，DTS 提供丰富多样、高性能、高安全可靠的传输链路，同时它提供了诸多便利功能，极大方便了传输链路的创建及管理。</p>
<p>特点：</p>
<ul>
<li>多数据源：支持 RDBMS、NoSQL、OLAP 等多种数据源间的数据传输；</li>
<li>多传输方式：支持多种传输方式，包括数据迁移、实时数据订阅及数据实时同步；</li>
<li>高性能：底层采用了多种性能优化措施，全量数据迁移高峰期时性能可以达到70MB/s，20万的TPS，使用高规格服务器来保证每条迁移或同步链路都能拥有良好的传输性能；</li>
<li>高可用：底层为服务集群，如果集群内任何一个节点宕机或发生故障，控制中心都能够将这个节点上的所有任务快速切换到其他节点上，链路稳定性高；</li>
<li>简单易用：提供可视化管理界面，提供向导式的链路创建流程，用户可以在其控制台简单轻松地创建传输链路；</li>
<li>需要付费。</li>
</ul>
<h2> <strong>3.3Databus</strong></h2>
<p>Databus 是一个低延迟、可靠的、支持事务的、保持一致性的数据变更抓取系统。由 LinkedIn 于 2013 年开源。</p>
<p>Databus 通过挖掘数据库日志的方式，将数据库变更实时、可靠的从数据库拉取出来，业务可以通过定制化 client 实时获取变更并进行其他业务逻辑。</p>
<p>特点：</p>
<ul>
<li>多数据源：Databus 支持多种数据来源的变更抓取，包括 Oracle 和 MySQL。</li>
<li>可扩展、高度可用：Databus 能扩展到支持数千消费者和事务数据来源，同时保持高度可用性。</li>
<li>事务按序提交：Databus 能保持来源数据库中的事务完整性，并按照事务分组和来源的提交顺寻交付变更事件。</li>
<li>低延迟、支持多种订阅机制：数据源变更完成后，Databus 能在毫秒级内将事务提交给消费者。同时，消费者使用D atabus 中的服务器端过滤功能，可以只获取自己需要的特定数据。</li>
<li>无限回溯：对消费者支持无限回溯能力，例如当消费者需要产生数据的完整拷贝时，它不会对数据库产生任何额外负担。当消费者的数据大大落后于来源数据库时，也可以使用该功能。</li>
</ul>
<h2> <strong>3.4其他</strong></h2>
<p><strong>Flink</strong></p>
<ul>
<li>有界数据流和无界数据流上进行有状态计算分布式处理引擎和框架。</li>
<li>官网地址：<a href="https://flink.apache.org" target="_blank" rel="noopener noreferrer">https://flink.apache.org</a></li>
</ul>
<p><strong>CloudCanal</strong></p>
<ul>
<li>数据同步迁移系统，商业产品。</li>
<li>官网地址：<a href="https://www.clougence.com/?utm_source=wwek" target="_blank" rel="noopener noreferrer">https://www.clougence.com/?utm_source=wwek</a></li>
</ul>
<p><strong>Maxwell</strong></p>
<ul>
<li>使用简单，直接将数据变更输出为json字符串，不需要再编写客户端。</li>
<li>官网地址：<a href="http://maxwells-daemon.io" target="_blank" rel="noopener noreferrer">http://maxwells-daemon.io</a></li>
</ul>
<p><strong>DRD</strong></p>
<ul>
<li>阿里巴巴集团自主研发的分布式数据库中间件产品，专注于解决单机关系型数据库扩展性问题，具备轻量(无状态)、灵活、稳定、高效等特性。</li>
<li>官方地址：<a href="https://www.aliyun.com/product/drds" target="_blank" rel="noopener noreferrer">https://www.aliyun.com/product/drds</a></li>
</ul>
<p><strong>yugong</strong></p>
<ul>
<li>帮助用户完成从 Oracle 数据迁移到 MySQL。</li>
<li>访问地址：<a href="https://github.com/alibaba/yugong" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/yugong</a></li>
</ul>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">服务器高并发之提高TCP连接数</title>
    <id>https://ujava.cn/synthesis/tcpcount.html</id>
    <link href="https://ujava.cn/synthesis/tcpcount.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 前言</h2>
<ul>
<li>测试服务器系统：ubuntu server 20.04.3</li>
<li>nginx负载均衡服务器：centos 7</li>
<li>服务器上我放了一个web系统用来测试连接数：<a href="https://github.com/yedf/handy" target="_blank" rel="noopener noreferrer">开源的支持高并发的服务器</a></li>
<li>发出请求的是我的电脑，电脑系统：win7</li>
<li>发出请求用的是python的压测工具：locust</li>
</ul>
<h2> TCP连接能连接多少</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 前言</h2>
<ul>
<li>测试服务器系统：ubuntu server 20.04.3</li>
<li>nginx负载均衡服务器：centos 7</li>
<li>服务器上我放了一个web系统用来测试连接数：<a href="https://github.com/yedf/handy" target="_blank" rel="noopener noreferrer">开源的支持高并发的服务器</a></li>
<li>发出请求的是我的电脑，电脑系统：win7</li>
<li>发出请求用的是python的压测工具：locust</li>
</ul>
<h2> TCP连接能连接多少</h2>
<p>要想弄清楚一个服务器能接受多少连接数，就需要根据socket五元组来看，即源IP+源端口+目标IP+目标端口+类型（TCP/UDP）。只要五元组不重复，就可以新增tcp连接。不过由于测试的时候一般类型都是相同的，所有大多数都是称为四元组。<br>
由于服务器的IP和web系统的端口一般是固定的，每个客户端的IP又不相同，那么照这样看连接数应该基本上相当于没限制才对。其实不然，实际上每个连接还要占用一定的内存和一个文件描述符。</p>
<p><strong>那么一个TCP socket占用多少内存呢？</strong><br>
大约是3K多，当然如果有发送或者接收的缓存区文件存在则另算，在响应较快、缓存文件不大的情况下内存应该不会成为瓶颈。</p>
<p><strong>服务器又能打开多少文件描述符呢？</strong><br>
可以通过以下命令查看<br>
系统级：当前系统可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/file-max</code>&nbsp;查看<br>
用户级：指定用户可打开的最大数量，通过&nbsp;<code>cat /etc/security/limits.conf</code>&nbsp;查看<br>
进程级：单个进程可打开的最大数量，通过&nbsp;<code>cat /proc/sys/fs/nr_open</code>&nbsp;查看</p>
<p>修改方式<br>
修改单个进程可打开的最大文件描述符为10000，即可打开10000个连接：<code>echo 10000 &gt; /proc/sys/fs/nr_open</code><br>
用户级修改：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，每创建一个tcp连接，还需要消耗一个线程来处理（也可以采用IO多路复用的方式，一个线程管理多个TCP连接），所以和CPU也有关系，不能通过单纯的提高内存的方式来增加连接数。<br>
常用查看连接数命令：<br>
<code>netstat -nat | grep -i "8085" | wc -l # 查询指定端口的连接数</code><br>
<code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}' # 查看TCP连接数及状态命令</code></p>
<h2> 实际测试</h2>
<p>此时是使用我的电脑向nginx负载均衡服务器发送请求，然后转发给web服务器。</p>
<h3> 测试1 未调整的情况下测试</h3>
<p><strong>客户端情况：</strong><br>
初始：可用端口55000个，性能够用<br>
结果：本地性能未达瓶颈，但是设置的1000并发人数，请求数平均只有437.3。<br>
</p>
<p><strong>nginx服务器情况：</strong><br>
初始：可用端口60000个，用户级65535，性能够用<br>
结果：本地性能未达瓶颈，但是出现很多TIME_WAIT数，最高时8000多。<br>
</p>
<p><strong>服务器情况：</strong><br>
初始：用户级65535。<br>
结果：最高连接数23，平均2.<br>
</p>
<h3> 测试1分析</h3>
<p>先分析一下TIME_WAIT、CLOSE_WAIT出现的原因及解决方法<br>
分析这里，就必须要简短回顾一下四次挥手（当client发起结束请求时）<br>
<br>
简短来说：<br>
1、一端没有close，那么另一端将有大量的close_wait状态；<br>
2、主动close的一端，在量特别大的情况下将造成大量的time_wait状态（由于Linux中一般默认的2msl为60s，那么正常情况下每秒1000的请求会造成60*1000=60000个time_wait记录，几百几千问题不大）</p>
<p>既然主动close的一方才会有time_wait记录，那么这里就说明nginx服务器是主动关闭的一方，那nginx服务器关闭的对象又是谁呢？<br>
在仅修改了nginx的代理地址，未改变其他配置情况下，通过wireshark抓包得知：</p>
<ul>
<li>客户端与nginx端相互通信都是http/1.1的链接，这里是nginx端先发起的fin请求；</li>
<li>nginx端到服务器端的请求是http/1.0，服务器端返回的请求是http/1.1，这里是nginx端先发起的fin请求。</li>
</ul>
<h3> 测试1优化</h3>
<p>依上面的场景分析，如果要减少time_wait数，提高连接数，则需要从以下方面来解决</p>
<ol>
<li>调整负载均衡服务器和web服务器/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，修改成&nbsp;<code>net.ipv4.ip_local_port_range=1024 65535</code>，保证至少可以使用6万个随机端口，就算保留1分钟，也能支持每秒1000的并发；</li>
<li>加多负载均衡服务器的ip，直接翻番；</li>
<li>负载均衡与服务器端也建立长连接，不关闭就不会有等待；</li>
<li>扩大nginx的keep-alive超时时间，最大请求数，使得长连接不会这么早关闭；</li>
<li>在nginx服务器上调整time_wait参数net.ipv4.tcp_tw_reuse=1，尽可能去复用连接（另外net.ipv4.tcp_tw_recycle参数在4.10以上内核中被移除了）。</li>
</ol>
<p>另外还有一些参数可以调整，不过一般默认是够用的</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>待优化测试验证</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计限流</title>
    <id>https://ujava.cn/synthesis/throttling.html</id>
    <link href="https://ujava.cn/synthesis/throttling.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>漏桶和令牌桶的区别</p>
<h2> 漏桶</h2>
<figure><figcaption>漏桶</figcaption></figure>
<h2> 令牌桶</h2>
<figure><figcaption>令牌桶</figcaption></figure>
]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>漏桶和令牌桶的区别</p>
<h2> 漏桶</h2>
<figure><figcaption>漏桶</figcaption></figure>
<h2> 令牌桶</h2>
<figure><figcaption>令牌桶</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">企业架构TOGAF内容框架</title>
    <id>https://ujava.cn/synthesis/togaf.html</id>
    <link href="https://ujava.cn/synthesis/togaf.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<figure><figcaption>img_24.png</figcaption></figure>
<h2> 一、内容框架概述</h2>
<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>
<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>]]></summary>
    <content type="html"><![CDATA[<figure><figcaption>img_24.png</figcaption></figure>
<h2> 一、内容框架概述</h2>
<p>TOGAF 9之前的版本中没有企业架构的具体内容相关的论述，需要与其他具有企业架构内容描述的框架（例如Zachman框架）进行配合。随着内容框架（Content Framework）的引入，以及企业架构开发方法与该内容框架的相互结合，TOGAF已经成为一个独立完备的企业架构框架标准。</p>
<p>企业架构开发方法描述了一个流程，使得企业从一个基线状态过渡到符合其战略目标的目标状态。这个流程是一个动态的过程，具有对外界环境变化的自适应特性，从而保证企业能够按照一种适应性很强的方式进行有序、透明的演进。架构开发方法过程中的每个阶段都需要一定的信息作为输入，并通过一定的开发步骤产生一系列具有特定意义的输出。这些输入与输出信息通过内容框架进行定义、组织和表达。内容框架为这些信息的结构化组织、定义和表达提供了一套完备的框架，使用者能够清楚地理解企业架构的内容。</p>
<p>内容框架对企业架构开发方法中各阶段的输入和输出信息进行了分类总结，并通过内容元模型（Content MetaModel）对构成企业架构内容的各个元素（即企业架构中的各个构建块的类型）以及他们之间的关系进行了定义。内容框架中针对其内容的描述采用了一种与架构开发方法的各阶段相映射的方式进行组织，即对架构开发方法的各个阶段所产出的企业架构内容具体是什么进行描述。</p>
<p>虽然针对企业架构内容的定义非常重要，但是同样重要的还有如何对企业架构的内容进行利用。企业架构的核心目标是为具有不同视角的干系人根据其关注点提供准确的视图，从而使得不同的干系人虽然采用了不同的观察角度和描述方式，但的确是在为共同的目标而进行着无障碍沟通和协作。为了达到这一目标，内容框架对于各种视角（ViewPoint）从表现形式和内容方面都进行了归纳总结，并对一些视图的开发也提供了建议和指南。TOGAF是一个通用性的标准，它的内容不可能涵盖企业中所有的视角，因而在具体实践中，各个企业完全可以根据自身需要对这些视角进行引用、修改和组合，从而总结出适合的视角，并借此开发出相应的视图，从而满足企业中具体干系人的需要。</p>
<p>下图展示了内容框架中各方面内容与企业中客观存在的各种资源之间关系，以及企业架构的内容是如何在内容框架的组织下为各个干系人提供帮助的：</p>
<figure><figcaption>img_25.png</figcaption></figure>
<h2> 二、企业架构工作产品分类</h2>
<p>在内容框架中，企业架构开发方法过程中所涉及到的各种工作产品被归纳为如下几种：</p>
<p>1、架构交付物（Architecture Deliverables）：架构交付物是由合同指定并被相关干系人轮流进行正式的审查和签字认可的工作产品。这些交付物代表着架构项目的输出，以及那些在一个项目完结时以文档形式进行交付的，或者作为参考模型、标准或在某一时点的架构情景快照（snapshot of the Architecture Landscape）被过渡到架构资源库中的工作产品。</p>
<p>2、架构制品（Architectural Artifacts）：与架构交付物相比，架构制品是一个从某个特定视角进行架构描述并具备更细粒度的工作产品。例如，网络图、服务器说明、用例说明、架构需求列表以及业务交互矩阵等。就表现形式来讲，架构制品的内容可以通过目录、矩阵和图形这三种方式来表述。通常情况下，一个架构交付物可以包含多个架构制品，而架构制品也可能会出现在多个架构交付物之中，并且架构制品也将会形成架构资源库的内容。</p>
<p>3、构建块（Building Blocks）：构建块代表着业务、IT或者架构能力的一个组件，并且可以与其他构建块组合在一起来对各种架构和解决方案进行交付。根据所处的架构开发阶段的不同，构建块能够在多个详细度层次上进行定义。例如，在架构开发的早期阶段，一个构建块可能仅仅包含一个名字或一个概要描述，而随着架构开发过程的演进，此构建块可能会被进一步分解为若干具有详尽描述的支持性构建块。从内容和所面对的问题上看，构建块可以被进一步分为如下两种：</p>
<p>架构构建块（ABBs：Architecture Building Blocks）：此种类型的构建块一般用于描述各种需要的能力，并对其后的解决方案构建块的轮廓进行了勾勒。例如，企业中的一个客户服务定义了实现这项能力的各种需求，而对于它的真正落实就需要若干解决方案构建块在各方面（流程、数据以及应用软件等）将这些需求映射到具体的实现技术之上。<br>
解决方案构建块（SBBs：Solution Building Blocks）：此种类型的构建块代表了用于实现各种需求（由架构构建块定义）的具体组件。<br>
<br>
以上三种工作产物虽然在内容和产生背景上有着很大的不同，但是他们之间却有着非常紧密的联系。构建块可以说是企业架构资源库的核心内容，并且也是企业架构过程的终极目标产物，因而把其称为企业的模型也并不为过，而架构制品则可以看成此模型在某个角度的各种视图，属于架构描述的范畴。架构交付物比较特殊，它与架构开发方法各阶段紧密相连，并作为各个阶段的输入与输出载体而存在。</p>
<h2> 三、架构交付物（Architecture Deliverables）</h2>
<p>架构交付物是在整个架构开发方法循环过程中所产生或被使用的契约性、正规化的企业架构内容。它与企业架构开发方法有着紧密的联系。本节将针对这些架构交付物以及它们与架构开发方法各阶段之间的关系进行阐述。需要注意的是，本节的内容只提供了一个关于架构交付物的内容概括。由于企业中可能存在着符合其自身需要的项目和过程管理方法，所以企业也可以根据自己的实际情况对这些交付物进行改造和定制。</p>
<p>架构交付物与企业架构开发方法各阶段之间的对应关系（注意，下表采用了简称来标示各企业架构开发方法阶段）：<br>
</p>
<figure><figcaption>img_28.png</figcaption></figure>
<h3> 1、架构构建块</h3>
<p>构建块是企业架构过程的最终目标之一，它是企业对于各个层面上（业务、应用、数据以及技术等）的可重用部件的抽象。架构构建块的内容侧重于对构建块的需求进行描述，就像软件开发中的接口一样，架构构建块并不涉及具体的实现方式，而只是描述了构建块所需要达成的功能。用于描述架构构建块的文档和模型存储在企业架构资源库之中，企业架构开发过程正是对企业中各种客观存在的或计划中的可重用模块进行抽象建模，并最终将这些内容存储到企业架构资源库之中（或对其内容进行更新）。</p>
<h3> 2、架构合同</h3>
<p>目标</p>
<p>架构合同是企业架构开发团队与赞助团队之间关于架构的交付、质量和适用性的联合协定。为了成功实现这一协定则需要企业进行有效的架构治理。通过实现一个用于合同管理的治理方法，企业将会确保：</p>
<ul>
<li>对组织中所有架构相关活动的完整性检查、变更、决策和审计进行持续监督。</li>
<li>现存或正在开发的架构得以贯彻组织的原则、标准和需求。</li>
<li>明确架构在开发和实现的各个方面中的风险，这些方面涵盖了关于可接受的标准、策略、技术和产品的内部开发，以及架构的运营层面，从而使得组织可以在一个具有弹性的环境中继续其业务。</li>
<li>一系列流程和实践，用于确定关于所有架构制品的开发和使用的责任和规则。</li>
<li>对于为合同负责的治理组织，他们的权限级别及其治理之下的架构范围有一个正式的理解。</li>
</ul>
<p>内容</p>
<p>架构设计和开发合同的内容一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>架构范围</li>
<li>架构以及战略原则和需求</li>
<li>一致性需求</li>
<li>架构开发和管理流程，以及相关角色</li>
<li>目标架构评测标准</li>
<li>定义的交付阶段</li>
<li>按照优先级排序的联合工作计划</li>
<li>时间窗口（Time windows）</li>
<li>架构交付和业务指标</li>
</ul>
<p>业务用户的架构合同一般包括：</p>
<ul>
<li>介绍和背景</li>
<li>协议性质</li>
<li>范围</li>
<li>战略需求</li>
<li>一致性需求</li>
<li>架构采用者</li>
<li>时间窗口</li>
<li>架构业务指标</li>
<li>服务架构（包括服务水平协议（SLA：Service Level Agreement））</li>
</ul>
<h3> 3、架构定义文档</h3>
<p>目标</p>
<p>架构定义文档是一个包含在整个项目中所产生的各种制品的可交付容器。它跨越所有的架构领域（业务、数据、应用和技术），并可用于检阅架构的所有相关状态（当前态、中间态和目标态）。架构定义文档对架构需求文档在如下方面进行互补：</p>
<ul>
<li>架构定义文档提供了一个解决方案的定性视图，用于沟通架构师的意图。</li>
<li>架构需求说明提供了一个解决方案的定量视图，用于声明在架构实现过程中必须遵守的可测量的标准。<br>
内容</li>
</ul>
<p>架构定义文档内容一般包括：</p>
<ul>
<li>范围</li>
<li>目标、阶段目标和约束</li>
<li>架构原则</li>
<li>基线架构</li>
<li>架构模型（针对每个被建模的状态）：业务架构模型、数据架构模型、应用架构模型、技术架构模型</li>
<li>架构方法的基本原理和理由</li>
<li>架构资源库内容映射：架构情景映射、参考模型映射、标准映射、重用评估</li>
<li>差距分析结果</li>
<li>影响评估</li>
</ul>
<h3> 4、架构原则</h3>
<p>目标</p>
<p>通用的规则和指南，一般是不会进行更改的。这些原则知会并支持一个组织用以实现其任务的方法。它是用于定义和指导组织从价值到行为和结果的一系列结构化思路中的一员。</p>
<p>内容</p>
<p>架构原则一般包括如下几个层面的内容（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>业务原则</li>
<li>数据原则</li>
<li>应用原则</li>
<li>技术原则</li>
</ul>
<h3> 5、架构资源库</h3>
<p>目标</p>
<p>架构资源库在企业中充当了对于所有架构相关项目进行存储的区域。它允许各个项目管理它们的交付物，定位可重用资产，并对干系人以及其他有兴趣者进行信息发布。</p>
<p>内容</p>
<p>架构资源库的内容包括如下几个方面（其具体内容请参看TOGAF标准相关内容）：</p>
<ul>
<li>架构框架</li>
<li>标准信息库</li>
<li>架构情景</li>
<li>参考架构</li>
<li>治理日志</li>
</ul>
<h3> 6、架构需求说明</h3>
<p>目标</p>
<p>架构需求说明提供了一组量化的描述，用于概括一个项目的实现与架构相符合所必须做的事情。架构需求说明一般会形成一个实施契约，或是更详细的架构定义契约中的主要组件。</p>
<p>内容</p>
<p>架构需求说明的内容通常包括：</p>
<ul>
<li>成功评测标准</li>
<li>架构需求描述</li>
<li>业务服务契约</li>
<li>应用服务契约</li>
<li>实施导则</li>
<li>实施说明</li>
<li>实施标准</li>
<li>互操作需求</li>
<li>约束</li>
<li>假设</li>
</ul>
<h3> 7、架构路线图</h3>
<p>目标</p>
<p>架构路线图列举出各个变化增量，并把他们放到时间轴之上，从而展示了从当前架构到目标架构的演进过程。架构路线图是迁移架构的重要组件，并在架构开发方法的B、C、D、E、F阶段中以增量的方式开发出来。</p>
<p>内容</p>
<p>架构路线图的内容包括：</p>
<ul>
<li>项目列表：每个涉及到的项目的名称、描述和目标，用于实现所建议的架构的项目列表，并按照优先级进行了排序。</li>
<li>基于时间的迁移规划：迁移的效益、针对各种迁移选择的成本估算。</li>
<li>实施建议：用于衡量项目有效性的评估准则、风险和问题、解决方案构建块的描述和模型。</li>
</ul>
<h3> 8、架构愿景</h3>
<p>目标</p>
<p>架构愿景是在项目生命周期早期创建的，它提供了一个高阶的对于最终架构产品的期望视图。目的是为了在一开始就对架构应该达到的期望结果形成一致意见，从而使得在之后的过程中架构师能够关注于切实可行的关键领域。通过提供一份关于整体架构定义的内容摘要，架构愿景对于干系人之间按沟通也提供了一定的支持。</p>
<p>内容</p>
<p>架构愿景的内容通常包括：</p>
<ul>
<li>问题描述：干系人以及他们的关注点，需要解决的问题/场景列表。</li>
<li>详细目标描述</li>
<li>环境和流程模型：流程描述、涉及到环境的流程步骤、涉及到人员的流程步骤、信息流</li>
<li>执行者以及他们担当的角色和责任：人员方面的执行者和角色、计算机方面的执行者和角色、需求</li>
<li>所产生的架构模型：约束、IT原则、支持流程的架构、映射到架构之上的需求。</li>
</ul>
<h3> 9、业务原则、目标和驱动力</h3>
<p>目标</p>
<p>业务原则、目标和驱动力通过描述企业的需要和工作方式为架构工作提供了背景。此外，许多处于架构原则考虑之外的因素对架构的开发也有着重要的影响。</p>
<p>内容</p>
<p>于不同的组织有着不同的特性，因而关于架构业务背景的内容将会各不相同，企业应该根据各自的情况定义这部分内容。</p>
<h3> 10、能力评估</h3>
<p>目标</p>
<p>在做一份详细的架构定义之前，对企业的当前和目标的能力水平有一个清晰的认识是非常有价值的。对于能力评估，我们可以在如下几个层面进行考虑：</p>
<ul>
<li>企业整体的能力水平是什么？企业希望在何处增强或优化其能力？用于支持企业期望发展的架构关注领域是什么？</li>
<li>企业中的IT功能的能力或成熟度水平是什么？就设计管理、操作管理、技术和组织架构而言，进行架构项目最可能的影响都有哪些？为了与企业文化和IT部门的能力相适应，架构项目所需的正规化和详细度的最适宜水平是什么？</li>
<li>企业架构功能的能力和成熟度是什么？当前存在的架构资产有哪些？这些资产是否被一直维护，并且是否还准确？什么样的标准和参考模型需要被考虑进去？是否在这些在架构项目中有可能创建可重用资产？</li>
<li>能力欠缺存在于何处？为了达成目标能力而需要进行转型的业务范围是什么？在对基本能力欠缺考虑之上的转换风险、文化壁垒以及其他方面考虑都有哪些？<br>
内容</li>
</ul>
<p>能力评估的内容通常包括：</p>
<ul>
<li>业务能力评估：业务能力、针对每项能力性能水平的基线状态评估、针对每项能力性能水平的未来状态期望、针对每项能力如何实现的基线状态评估、针对每项能力将会被如何实现的期望</li>
<li>IT能力评估：变更流程的基线和目标成熟度水平、运营流程的基线和目标成熟度水平、基线能力以及容量评估、针对由于架构项目的执行而对IT组织所可能产生的影响的评估</li>
<li>架构成熟度评估：架构治理流程/组织/角色和责任、架构技能评估、架构资源库中的情景定义的深度/广度/质量、架构资源库中的标准定义的深度/广度/质量、架构资源库中的参考模型的深度/广度/质量、针对可重用潜力的评估。</li>
<li>业务转型准备度评估：准备度因素、对于每个准备度因素的愿景、针对当前和目标准备度的评级、与准备度相关的风险。</li>
</ul>
<h3> 11、变更请求</h3>
<p>目标</p>
<p>在架构的实现过程中，在一切清晰之前，原来的架构定义和需求很可能不适合或不足以达成解决方案的实现。在这种情况下，对实施项目进行调整使之与建议的架构方法发生偏离，或请求架构范围扩展是必需的行为。另外，很多外部因素（例如，市场因素、业务策略变化以及新技术机会）也会为扩展及优化架构提供新的机会。在以上这些环境下，一个变更请求可以被提出，用以开始一个新的架构工作周期。</p>
<p>内容</p>
<p>变更请求的内容通常包括：</p>
<ul>
<li>对于所建议的变更的描述</li>
<li>对于所建议的变更的理由</li>
<li>对于所建议的变更的影响评估：针对相关特定需求的引用、迄今需求所涉及的干系人的优先级、重新审视这些需求的各阶段描述、对需求优先级进行排序的阶段、调查和修正需求的优先级阶段的结果、对于需求管理的建议。</li>
<li>资源库引用编号</li>
</ul>
<h3> 12、 沟通计划</h3>
<p>目标</p>
<p>企业架构包含大量的复杂且相互关联的信息。有效地与适当的人在适当的时间针对目标信息进行交流是成功建设企业架构的重要因素。开发沟通计划可以使这些交流通过一种可计划、可管理的方式进行。</p>
<p>内容</p>
<p>沟通计划的内容通常包括：</p>
<ul>
<li>针对干系人的识别，并根据沟通需求进行分组</li>
<li>明确沟通需求、与架构愿景相关的关键消息、沟通风险和关键成功因素（CSFs：Critical Success Factors）</li>
<li>明确用来与干系人进行沟通的机制，并允许其对架构信息的访问</li>
<li>制定沟通时间表。该时间表展示了沟通将在何时何地进行，以及在何种干系人组之间进行</li>
</ul>
<h3> 13、 合规评估</h3>
<p>目标</p>
<p>一旦一个架构被定义了出来，就必须在整个实施过程中对其进行治理，从而保证原先的架构愿景可以被适当的实现，并且实现中的经验教训也可以反馈到架构过程中。针对实施项目进行周期性的合规检查为重新审核项目过程，并保证设计和实施符合企业策略和架构目标，提供了一种有益的机制。</p>
<p>内容</p>
<p>合规评估的内容通常包括：</p>
<ul>
<li>项目进程和状态的概览</li>
<li>项目架构/设计概览</li>
<li>完整的架构清单：硬件和操作系统清单、软件服务和中间件清单、应用清单、信息管理清单、安全清单、系统管理清单、系统工程清单、方法和工具清单。</li>
</ul>
<h3> 14、实施和迁移计划</h3>
<p>目标</p>
<p>通过过渡框架的描述为解决方案的实施提供一个日程表，包括实施的时间、成本、资源、收益和里程碑。</p>
<p>内容</p>
<p>实施和迁移计划的内容通常包括：</p>
<ul>
<li>实施和迁移战略：战略实施方向、实施排序方法</li>
<li>与其他管理框架的交互：架构与业务规划相协调的方法、整合架构的方法、架构与项目管理相协调的方法、架构与运营管理相协调的方法。</li>
<li>项目章程：项目所能交付的能力、所包含的工作包、业务价值、风险、问题、假设和依赖关系</li>
<li>实施规划：由实施分解出来的各个阶段和工作流、为各阶段和工作流进行工作包分配、里程碑和时间要求、工作分解结构、资源需求和成本</li>
</ul>
<h3> 15、实施治理模型</h3>
<p>目标</p>
<p>一旦一个架构被定义，在整个实施过程中就需要对用于实现架构的过渡框架进行治理。在已经建立了架构功能的组织中可能已经存在了一个治理框架，但是对于特定的过程、组织、角色、责任和度量来说，需要根据项目进行具体的定义。</p>
<p>内容</p>
<p>实施治理模型的内容通常包括：</p>
<ul>
<li>治理流程</li>
<li>治理组织结构</li>
<li>治理角色和相应职责</li>
<li>治理检查点和成功与失败标准</li>
</ul>
<h3> 16、 企业组织架构模型</h3>
<p>目标</p>
<p>为了一个架构框架能够被成功地使用，它必须在企业中获得正确的组织、角色和责任的支持。特别重要的是，对不同企业架构参与者之间边界的定义，以及针对跨边界关系的治理。</p>
<p>内容</p>
<p>企业组织架构模型的内容通常包括：</p>
<ul>
<li>受影响的组织的范围</li>
<li>成熟度评估、差距和决议方法</li>
<li>架构团队的角色和责任</li>
<li>针对架构工作的约束</li>
<li>资金预算需求</li>
<li>治理和支持策略</li>
</ul>
<h3> 17、架构工作要求书</h3>
<p>目标</p>
<p>由赞助组织交付给架构组织的用于启动架构开发工作的文档。架构工作要求书可以产生于预备阶段，可以是经过批准的架构变化请求的结果，或者是源于迁移计划对架构工作的参考。</p>
<p>内容</p>
<p>架构工作要求书的内容通常包括：</p>
<ul>
<li>组织赞助者</li>
<li>组织的任务说明</li>
<li>业务目标（以及变更）</li>
<li>业务的战略规划</li>
<li>时间限制</li>
<li>业务环境的变化</li>
<li>组织方面的约束</li>
<li>预算信息以及财务约束</li>
<li>外部约束以及业务约束</li>
<li>当前业务系统描述</li>
<li>当前架构/IT系统描述</li>
<li>开发组织的描述</li>
<li>开发组织可用资源的描述</li>
</ul>
<h3> 18、需求影响评估</h3>
<p>目标</p>
<p>在整个架构开发方法过程中，总会有新的与架构相关的信息被收集起来。当这些信息被收集后，对架构在当前某方面有影响的新因素也经常会显现出来。需求影响评估就是用来对当前架构需求进行评估，阐明需要进行的变更以及这些变更所带来的影响。</p>
<p>内容</p>
<p>需求影响评估的内容通常包括：</p>
<ul>
<li>对于具体需求的引用</li>
<li>迄今需求的相关干系人优先级</li>
<li>进行重审的各个阶段</li>
<li>进行需求优先级排序的阶段</li>
<li>调查和修正需求的优先级阶段的结果</li>
<li>关于需求管理的建议</li>
<li>资源库引用编号</li>
</ul>
<h3> 19、解决方案构建块</h3>
<p>与架构构建块相类似，解决方案构建块也是存储于架构资源库中的构建块的一种，不过它的内容更倾向于在实现层面对企业中的可重用构建块进行描述。可以说，架构构建块定义了构建块的需求，而解决方案构建块则是此需求在具体实现技术层面的映射。关于解决方案构建块的具体内容请参阅后面的内容。</p>
<h3> 20、架构工作说明书</h3>
<p>目标</p>
<p>架构工作说明书定义了用于完成一个架构项目的方法和范围，它也是用于评测架构项目是否被成功执行的典型文档，并且它也形成了架构服务提供者和使用者之间的合同协议的基础。</p>
<p>内容</p>
<p>架构工作说明书的内容通常包括：</p>
<ul>
<li>架构工作标题说明</li>
<li>项目申请和背景</li>
<li>项目描述和范围</li>
<li>架构愿景的概括</li>
<li>管理办法</li>
<li>范围变更程序</li>
<li>角色、责任和交付物</li>
<li>验收标准和程序</li>
<li>项目计划和日程安排</li>
<li>针对架构连续体的支持</li>
<li>签字批准</li>
</ul>
<h3> 21、定制的架构框架</h3>
<p>目标</p>
<p>TOGAF提供了一个行业的标准架构框架，但是要在一个架构项目中对其进行有效地使用，则必须在两个层面上进行定制。首先，需要对TOGAF模型进行定制，使得它可以融入到企业之中。此种定制包括将TOGAF模型整合入企业的项目和过程管理框架、术语定制、展示方式开发、架构工具的选择、配置和部署等方面之中。任何被采用的框架的形式和详细程度应该与企业的其他背景元素相适应，例如文化、干系人、企业架构的商业模型以及当前架构能力的水平。一旦针对框架完成了上面的定制，企业就需要为具体的架构项目做进一步的框架定制，而在这一层面的定制中，企业需要选择适当的架构交付物和架构制品来满足项目和干系人的需要。</p>
<p>内容</p>
<p>定制的架构框架的内容通常包括：</p>
<ul>
<li>定制架构的方法</li>
<li>定制架构的内容（架构交付物和架构制品）</li>
<li>配置和部署工具</li>
<li>治理模型和其他框架的接口：企业架构管理框架、能力管理框架、项目组合管理框架、项目管理框架、运营管理框架。</li>
</ul>
<h3> 22、过渡架构</h3>
<p>目标</p>
<p>过渡架构展示了企业的增量状态，并反映从当前架构到目标架构的过渡过程。过渡架构被用来将单独的工作包和项目组合为可管理的项目组合和程序，用于描述每个阶段的业务价值。</p>
<p>内容</p>
<p>过渡架构的内容通常包括：</p>
<ul>
<li>机会组合描述：综合的差距、解决方案和依赖关系评估、机会描述、收益评估、能力和能力增量、互操作性和共存的需求</li>
<li>工作包组合描述：工作包描述（名称、描述、目标和交付物）、功能性需求、依赖关系、与机会之间的关系、与架构定义文档和架构需求说明之间的关系。</li>
<li>里程碑和里程碑过渡架构：过渡状态描述、每个过渡状态的业务架构、每个过渡状态的数据架构、每个过渡状态的应用架构、每个过渡状态的技术架构。</li>
<li>实施因素评估和推导矩阵（ImplementationFactor Assessment and Deduction Matrix：用于记录将会影响架构实施和迁移计划的各个因素。此矩阵包括在制定迁移计划时需要考虑的各个因素、它们的描述，以及由此而推断出的在制定计划时需要考虑的行动或约束）：风险、问题、假设、依赖、行动。</li>
<li>综合差距、解决方案和依赖矩阵（Consolidated Gaps，Solutions，and Dependencies matrix：此矩阵使架构师可以对在各领域架构差距分析结果中明确的差距进行分组，并评估潜在的解决方案，以及这些方案与差距之间的依赖关系）：架构领域、差距、潜在解决方案、依赖关系。</li>
</ul>
<h2> 四、架构制品（Architectural Artifacts）</h2>
<p>架构制品是针对某个系统或解决方案的模型描述，与架构交付物和构建块相比，架构制品既不是架构开发方法过程各阶段的合约性产物，亦不是企业中客观存在的各种可重用解决方案，而是针对包括这些构建块在内的企业客观现实的描述，并以解答不同干系人的关注点为其最终目标。可以说，架构交付物面向于企业架构的产生，架构构建块倾向于企业架构的结果，而架构制品则注重于针对企业架构的应用（虽然架构交付物可以包含若干架构制品，但是架构制品在本质上还是被用来为不同的干系人按照其视角提供相应的企业客观视图，况且架构交付物对架构制品的包含本身也是架构制品的应用之一，其目的也是为了在架构开发过程中所涉及的不同干系人之间达成共识）。</p>
<p>企业架构并不是一个静态的过程，不能将建设一个包含企业架构内容的信息资源库当作唯一目标。对于任何企业来说，企业架构的意义都应该在于将其自身的战略决策、业务和信息技术资源联系为一个有机整体，并且不同的干系人从企业架构中获得其所需的关于企业的自上而下（自业务至用于支持各项业务实现的解决方案）的视图，而这方面的内容属于针对企业架构内容的使用范畴。在这一范畴之中，所有的企业架构框架理论，哪怕是几乎不涉及企业架构内容的框架，都会关注于两个概念：视角与视图。其中视角是针对不同干系人企业架构内容的需求描述，而视图是基于某一视角的具体架构内容描述，因而也可以说视角是视图的元类型定义。在这两个概念中，视图比较好理解，亦即根据视角的定义而对企业客观现状的某一侧面描述，相比之下，用于对视图进行定义的视角概念则更为关键。视角是不同干系人对于企业架构内容需求的体现，亦即其采用何种角度对企业客观存在或计划存在的自顶层战略、业务至底层解决方案而进行观察。这些角度的定义基本上应该包括如下几个方面：</p>
<p>1、目标需求：不同的干系人担当着不同的角色及责任，其看问题的角度与担当的任务也因此有着非常紧密的联系。一般来讲，目标需求大体可以分为：</p>
<ul>
<li>设计层面：包括了用于指导和支持与设计决策相关的各种制品。例如架构师、开发人员以及业务流程建模人员等干系人经常会用到的UML图、流程建模图（例如BPMN图）、以及用于描述数据的关系-实体图等制品都属于这一范畴。</li>
<li>决策层面：包括了用于支持高层决策的制品（例如，交叉引用表、情景图、以及各种报告等制品），适用于企业中处于管理高层的各种决策人，例如CEO、CIO等。</li>
<li>告知层面：包括了用于为相关干系人进行解释、说服以及获得其承诺方面的制品（流程概述、图表、宣讲动画等）。这些干系人可能会是一般职工、客户，或者其他在企业中从业务到解决方案这条线上虽不占关键位置却需要对企业架构进行了解的干系人。<br>
2、抽象级别需求：上面描述了不同干系人由于其担负任务的不同，因而对于企业的观察也具有着不同的角度，从而对不同的制品产生兴趣。然而，即使不同的干系人针对企业的相同侧面有着共同的兴趣，但是他们对于描述的抽象级别或详细程度也可能有着不同的要求。例如，对于相同的业务流程来说，可能对于高层管理人员来说需要关注的仅是此流程的输入、输出，而对于其实现细节并不一定关心，而对于流程建模人员来说此业务流程恐怕就需要被细化为粒度更加细小的业务功能组合，而对于软件开发人员来讲，可能还要为某个具体业务行为而考虑其相关的数据结构和实现方案。</li>
</ul>
<p>3、展示需求：上述两点可以说是依据干系人所持的角度在内容方面所进行的分类，而除此之外，由于不同的干系人由于各自的偏好不同，他们可能会对视图的展示也有着非常不同的要求。虽然在TOGAF中，架构制品的描述方式被定义为目录、矩阵和图形三种方式，但就其具体展示方式来说，不同的干系人还可能具有不同的要求和偏好。例如，对于组织结构的展示，有的干系人可能偏好于采用简单的树形结构的展示，而其他干系人则可能更加倾向于图形化的结构图。这种展示需求在图形展示方面尤其突出，某些干系人（特别是来自于内部的干系人，例如领域专家等）可能习惯于采用某种标准的标注体系来对架构内容进行展示，而对于其他干系人来讲（例如客户或非专业的干系人）采用如此方式可能并不能取得很好的效果，而采用更加贴近现实的图标来代替标准图标（通常是若干简单的形状、连线和颜色的组合）则更加友好。虽然展示需求也是视角定义所需靠虑的元素之一，但是在大多数情况下这一层面的定义往往可以采用松耦合的方式来进行描述，即将视角的定义分为内容和展示两个层面，并在两者之间建立关联（通常一个内容定义可以包含若干展示定义）。</p>
<p>上述关于视角分类的定义很容易让人产生非此即彼的感觉，即视角是为干系人服务的，因而应该仅从属于某种干系人。这样的思想除了源于思想的惯性，最主要的还是由于忽视了企业架构的核心精神—在组织中创建无障碍的沟通信息流。作为企业架构的核心概念，如果只把视角看作为企业架构描述用的约束和定义，而忽视了沟通这一本质则是违反企业架构最终目标的。每种干系人对于视角的采用都要着自己的要求，但反过来讲，视角却不一定从属于某种干系人，不同的干系人之间可以共享同样的视角，也只有这样才能保证不同干系人之间的顺畅沟通。正像TOGAF中所举的例子一样，飞机的飞行员和航空管制员对于飞行的视角各具特点，并采用不同的语言和元素来对“飞行”进行描述，但是他们同时也采用一种通用的语言（高度、速度等）来进行沟通。在这个例子中，飞行员和航空管制员在自己的领域内分别采用了自己的视角来对“飞行”进行理解和描述，不过作为沟通用的通用语言却形成了第三个，并且是他们所共享的视角。</p>
<p>企业架构开发过程的结果可以说是在架构资源库中按照架构元模型定义而填充的各种实体元素，这也方便了在对企业架构的使用中按照各个干系人的视角为其提供相应的视图。针对架构的使用需要自动化工具的支持，该工具需要支持视角的定义和管理，并能够从企业架构资源库中根据选定的视角生成相应的视图。</p>
<figure><figcaption>img_29.png</figcaption></figure>
<p>不同的企业架构开发框架对于架构制品、视角和视图的定义，有着不同的描述。例如在Zachman框架中，每一个单元格所代表的是某一种干系人视角针对系统某个方面的描述，而在TOGAF中，The Open Group则采用了一种独特的方式对视角进行了组织和定义。与其他框架理论不同，TOGAF定义了一系列原子架构制品，并倡议在企业架构过程中根据不同干系人的需要对这些原子架构制品进行组合，从而生成对于视角的定义。这些原子架构制品业可被看为原子级的视角定义，实际上在TOGAF中也正是用视角（ViewPoint）这个词来称呼各个架构开发阶段相关的原子架构制品。TOGAF并不强制其用户遵循这些原子架构制品，用户可以根据自己的需要增加新的原子架构制品，或对已经定义的原子架构制品进行修订。根据架构制品的描述形式，TOGAF将这些原子架构制品分为以下三类：</p>
<ul>
<li>目录（Catalogs）：此类型的原子架构制品（视角）以列表的形式对各种构建块进行列举。</li>
<li>矩阵（Matrices）：此类型的原子架构制品（视角）用于展示特定构建块之间的关系。</li>
<li>图形（Diagrams）：此类型的原子架构制品（视角）采用了一种具有丰富表现力的方式对构建块以及他们之间的关系进行了展示。此种方式特别适合用于在干系人之间进行沟通的场合。</li>
</ul>
<h3> 1、架构开发过程与架构制品</h3>
<p>表面上架构制品并不像架构交付物那样与架构开发方法的各个阶段有着很强的契约性关联，但是做为架构交付物的重要组成部分，架构制品与架构开发方法之间也有着非常紧密的联系。在TOGAF中，针对架构制品的组织和描述也是以架构开发方法各阶段为基础的，它详尽展示了在每个架构开发方法阶段中所产生的各个原子架构制品，以及这些架构制品与架构内容元模型各扩展之间的关系。</p>
<figure><figcaption>img_30.png</figcaption></figure>
<h3> 2、架构制品定义</h3>
<p>原则目录（Principles catalog）</p>
<p>原则目录对各项业务原则及架构原则进行列举，用以表明一个好的解决方案或架构看起来应该是什么样子。原则用于对各架构决策点的输出进行评估和认可。原则也可在针对变更举措的架构治理中充当辅助工具。</p>
<p>干系人映射矩阵（Stakeholder Map Matrix）</p>
<p>干系人映射矩阵用于明确参与架构活动的各个干系人、他们的影响、他们的主要问题，以及架构框架所必须解答的关注点。通过对于干系人的识别，并对他们的需求进行理解，架构师可以将注意力集中在能够满足干系人需求的各个领域之中。</p>
<p>价值链图（Value Chain Diagram）</p>
<p>价值链表提供了一张面向高层的企业视图，用于表示企业如何与外界环境交互。与在业务架构阶段中开发出来的更加正式的功能解构图相比较，价值链表更着重于表象上的影响。价值链表的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使得所有参与者能够对架构所涉及到的高层次功能性和组织性环境进行理解。</p>
<p>解决方案概念图（Solution Concept Diagram）</p>
<p>解决方案概念图提供了一个解决方案的高层次方向，用于达成架构所涉及的各个目标。与后续架构开发方法阶段开发出来的、更正式且更详细的架构图相比较，解决方案概念图更像是在一开始阶段关于期望解决方案的一张草图。这张图体现了关键的目标、需求和约束，并对将采用正式架构模型来进行更详细描述的各个工作区域进行了标明。解决方案概念图的目标是使一个特定的变更主张能够快速地在干系人中获得一致性认识，从而使所有的参与者能够理解架构所需要的究竟是什么，以及一个特定的解决方案被期望以何种方式来满足企业的需求。</p>
<p>组织/执行者目录（Organization/Actor Catalog）</p>
<p>该目录的目标是得到一份明确的包括用户和IT系统所有者在内的所有与IT有互动的参与者列表。该列表可以在开发需求时作为完备性检测的参考。例如，针对于一个对客户进行服务支持的应用的需求，我们可以通过如下几个方面对其进行完备性检测：</p>
<ul>
<li>
<p>需要对何种类型的客户进行支持。</p>
</li>
<li>
<p>是否某种类型的用户存在特定需求或约束。</p>
</li>
<li>
<p>此目录所涉及到的内容元模型实体包括：</p>
</li>
<li>
<p>组织单位</p>
</li>
<li>
<p>执行者</p>
</li>
<li>
<p>位置（如果一个单独的位置目录并不存在，则关于位置的信息就需要在这个目录中加以维护）</p>
</li>
</ul>
<p>驱动力/目标/阶段目标目录（Driver/Goal/Objective Catalog）</p>
<p>该目录的目标是描述组织如何通过目标、工作目标和评测（可选内容）来满足其驱动力的需要，并为此提供一份跨越组织的参考。通过针对驱动力、目标和阶段目标的层层分解，各个变更举措可以采用一种跨越组织边界的方式进行协同，并在随后的活动中使得各个干系人得以被明确，此外，相关的变更举措也能够被整合或协调起来。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单元</li>
<li>驱动力</li>
<li>目标</li>
<li>阶段目标</li>
<li>评测（可选内容）</li>
</ul>
<p>角色目录（Role Catalog）</p>
<p>角色目录的目标是为企业中所有的授权级别或区域提供一份列表。一般情况下，应用的安全或行为应该按照其对授权概念的理解而分别进行定义，但在与用户的计算机相绑定时却造成了复杂且不被期望的后果。如果角色在整个组织和所有应用中都得到了定义、理解和共识，那么更加安全并能够提供更加无缝的用户体验的应用将会出现，因为管理员无需通过迂回的解决方法来使用户执行他们的工作。除了对企业的安全定义进行支持，角色目录还可以是明确组织变更管理影响、定义工作职能，以及执行最终用户培训这些方面的关键输入。</p>
<p>由于每个角色都暗含着关于一系列业务功能的访问，如果这些功能被影响到，那么变更管理将必不可少，组织的职责也需要被重新定义，同时新的培训可能也是需要的。</p>
<p>业务服务/功能目录（Business Service/Function Catalog）</p>
<p>业务服务功能目录的目标是提供一份功能性的解构，使得各种功能可以被过滤、汇报和查询，并能够作为功能结构图的一个有力补充。服务功能目录可以被用来对组织中的各项能力进行明确，并对组织中施加到各种功能上的治理水平加以理解。通过功能解构，用于支持业务变化所需要的各种新能力能够被识别出来，或者对变更措施、应用以及技术组件的范围进行确定。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织单位</li>
<li>业务功能</li>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
</ul>
<p>位置目录（Location Catalog）</p>
<p>位置目录为企业的业务运营或房屋建筑相关的资产（例如数据中心或终端用户计算设备）所处位置提供了一份列表。针对此位置列表的维护，各个变更举措的位置范围得以被快速地定义出来，并且针对当前情况和建议的目标解决方案进行评估时，完备性测试也得以被执行。例如，一个用于更新台式计算机操作系统的项目需要识别出这些系统所部署的位置。与此相似，当实施一个新的系统时，一张关于位置的图形描述对于开发适当的部署策略是非常关键的，该部署策略被用于对用户和应用的位置进行了解，并且各个与位置相关的问题（例如，国际化、本地化、针对可用性的时区影响、延时距离影响、网络带宽影响和访问）也得以被明确。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>位置</li>
</ul>
<p>流程/事件/控制/产品目录（Process/Event/Control/Product Catalog）</p>
<p>流程/事件/控制/产品目录为流程、触发流程的事件、流程的输出和施加到流程执行之上的控制提供了一份层次结构，并可被用来作为流程图（Process Flow diagram）的一个有力的补充，这些流程图使得企业可以进行跨越组织和流程的过滤、汇报和查询操作，从而对其范围、通用性或影响进行明确。例如，流程/事件/控制/产品目录使得企业可以查看流程与各子流程之间的关系，从而明确源自于一个高层流程的变更所能带来的影响链。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>流程</li>
<li>事件</li>
<li>控制</li>
<li>产品</li>
</ul>
<p>合同/评测目录（Contract/Measure Catalog）</p>
<p>此目录提供了一份关于所有经过批准的服务合同以及与此相关的评测的列表，从而形成了在整个企业内获得批准的服务水平的主列表。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>业务服务</li>
<li>信息系统服务（可选内容）</li>
<li>合同</li>
<li>评测</li>
</ul>
<p>业务交互矩阵（Business Interaction Matrix）</p>
<p>此矩阵用于描述企业中各组织与业务功能之间的交互关系。理解企业中的业务交互是很重要的，因为它有助于突出整个组织中的价值链以及相互依赖关系。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>组织</li>
<li>业务功能</li>
<li>业务服务</li>
<li>业务服务之间的通信关系</li>
<li>业务服务之间的依赖关系</li>
</ul>
<p>执行者/角色矩阵（Actor/Role Matrix）</p>
<p>此矩阵用于展示哪些执行者扮演何种角色，并支持对安全性和技能需求的定义。理解执行者与角色之间的关系对定义培训需求、用户安全设置和组织变更管理具有关键性作用。此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>执行者</li>
<li>角色</li>
<li>执行者与角色之间的担当关系</li>
</ul>
<p>务足迹图（Business Footprint Diagram）</p>
<p>业务足迹图描述了业务目标、组织单元、业务功能和服务之间的关联，并将这些功能映射到各个提供了所需能力的技术组件之上。它在从技术组件到业务目标的映射中提供了清晰的可追溯性，同时还对已经明确的服务的所有权进行了阐述。业务功能图仅对联系组织单元功能与交付服务的关键因素进行描述，并且还可被用来作为与高层次干系人（CIO、CEO等）进行沟通的平台。</p>
<p>业务服务/信息图（Business Service/Information Diagram）</p>
<p>业务服务/信息图展示了用于对一个或多个业务服务进行支持的信息，包括了由业务服务使用或者产生的数据及其信息源。服务/信息图对信息在架构中的最初表现形式进行了展现，因此为数据架构阶段的进一步描述打下了基础。</p>
<p>功能分解图（Functional Decomposition Diagram）</p>
<p>功能分解图的目标是将组织中与架构相关的各项能力展现在一张图纸之上。通过从功能的视角检视组织的各项能力，企业可以快速针对组织所做的事情进行建模，而不用陷入针对组织如何做所进行的额外讨论之中。</p>
<p>产品生命周期图（Product Lifecycle Diagram）</p>
<p>产品生命周期图的目标是对企业中关键实体的理解进行辅助。就关于产品从生产到撤销过程中所必须遵守的环境的关注、立法和规章来说，理解产品生命周期变得越来越重要。与此相同，在为了保证在控制、流程和程序的设计严谨而进行的业务架构开发过程中，创建涉及个人或敏感信息产品的组织必须对产品生命周期具有一个详尽的理解，例如信用卡、借记卡、智能卡以及用户身份认证等信息。</p>
<p>目标/阶段目标/服务图（Goal/Objective/Ser viceDiagram）</p>
<p>此图的目标是为服务对业务愿景或策略的达成而定义方法。通过将服务与驱动力、目标、阶段目标和相关的评测进行关联，企业可以了解到哪些服务贡献于相似的业务效能方面。此外，该图还为针对某一特定服务所形成的高效能的认定提供了定性的输入。</p>
<p>业务用例图（Business Use-Case Diagram）</p>
<p>业务用例图展示了业务服务的提供者和使用者之间的关系。业务服务被各个执行者或其他的业务服务所使用，而业务用例图则通过针对业务能力在何时以及如何被使用的描述，为业务能力的描述方面提供了额外的价值。此图形的目标是对各执行者和他们在各流程和功能中所担当的角色之间的交互关系进行描述和验证。随着架构过程的演进，这些用例图也将从业务级别发展至包括数据、应用和技术在内的更加详尽的级别。除此之外，业务用例图也可在系统设计工作中得到复用。</p>
<p>组织分解图（Organization Decomposition Diagram）</p>
<p>组织分解图描述了执行者、角色以及他们在组织树中所处位置之间的关系。一份组织分解图应提供了一条组织中决策者和业务拥有者的命令链。虽然组织分解图并不打算将组织与其目标联系在一起，但是在这张图中为最终目标与干系人之间建立直观的联系也是可以的。</p>
<p>流程图（Process Flow Diagram）</p>
<p>流程图的目标是对流程元模型实体相关的所有模型和映射进行描述，它展示了位于各个活动之间的顺序化控制流，并可借助于泳道技术来表达各个流程步骤的归属和实现。例如，用于支持一个流程步骤的应用就可以作为一条泳道来展示。除此之外，流程图也可以被用来细化赋予在流程之上的控制、触发某流程或产生于流程结束时的事件，以及由于流程执行所产生的各种输出产物。流程图在为主题专家描述架构时非常有用，它可以为这些专家描述一个特定功能的工作是如何被完成的。通过这样一个过程，每个流程步骤可以被细化为更小粒度的功能块，而且这些功能块在以后亦可以被当作一个流程来进行进一步的阐述。</p>
<p>事件图（Event Diagram）</p>
<p>事件图的目标是描述事件与流程之间的关系。诸如某些特定信息的到来，或者是某个特定的时间点这样的特定事件会致使业务中特定的工作和行为得以进行，同时也经常会有被称为业务事件（或简称事件）的信息被当作某个流程的触发者。</p>
<p>数据实体/数据组件目录（Data Entity/Data Component Catalog）</p>
<p>数据实体/数据组件目录的目标是明确和维护企业中使用的所有数据的列表，包括数据实体，以及用于存储数据实体的数据组件。一个经过批准的数据实体/数据组件目录支持对信息管理和数据治理策略的定义和应用，并且鼓励对数据进行有效地共享和重用。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>逻辑数据组件</li>
<li>物理数据组件</li>
</ul>
<p>数据实体/业务功能矩阵（Data Entity/Business Function Matrix）</p>
<p>此矩阵用来描述企业中数据实体和业务功能之间的关系。业务功能被具有明显边界的业务服务所支持，并通过业务流程加以实现。通过数据实体与业务功能之间的映射，企业可以得到：</p>
<ul>
<li>将数据实体的所有权分配给各个组织。</li>
<li>理解业务服务的数据和信息交换需求。</li>
<li>支持差距分析，并决定是否有需要被创建的数据实体被遗漏。</li>
<li>为数据实体定义源系统、记录系统和引用系统。</li>
<li>启动企业的数据治理程序的开发（建立数据管家、开发与业务功能相关的数据标准等）。</li>
</ul>
<p>此矩阵所涉及到的内容元模型实体包括：</p>
<ul>
<li>数据实体</li>
<li>业务功能</li>
<li>数据实体与其所属组织单位的“从属”关系</li>
</ul>
<p>系统/数据矩阵（System/Data Matrix）</p>
<p>此矩阵用于描述系统与系统所访问和更新的数据实体之间的关系（一张两维表，其中一个纬度对应逻辑应用组件，而另外一个则对应数据实体）。系统用于创建、读取、更新和删除与他们相关联的特定数据实体。例如，一个客户关系系统将创建、读取、更新和删除客户实体信息。处在一个被封包好的服务环境中的数据实体可以被分为主数据、引用数据、事务数据、内容数据和历史数据，而用于操作这些数据实体的应用则包括事务应用、信息管理应用和业务仓库应用。针对应用组件和数据实体之间映射是一个非常重要的步骤，因为它可以使得：</p>
<ul>
<li>针对数据的访问能力被分配给组织中的具体应用。</li>
<li>了解在不同应用中数据重复的程度，以及数据生命周期的规模。</li>
<li>了解在何处相同的数据会被不同的应用所更新。</li>
<li>支持差距分析，并确定是否本应存在的应用被遗漏了。</li>
</ul>
<p>类图（Class Diagram）</p>
<p>类图的主要目标是描述企业中重要数据实体（或类）之间的关系。此图用于清晰地展示数据之间的关系，并帮助干系人理解企业下层数据模型。</p>
<p>数据传播图（Data Dissemination Diagram）</p>
<p>数据传播图的目标是展示数据实体、业务服务和应用组件之间关系。此图展示了各个逻辑实体如何被应用组件所实现。它使得针对数据大小的调整得以被有效地执行，同时IT足迹也会得以改善。而且，通过为数据设置业务价值，应用组件的业务重要性的指标也能够在同时被获得。另外，此图还可以展示针对数据复制和主引用的所有权，即它可以展示数据的两个备份以及数据之间的主-备份关系。此图还能够包含服务，比如，封装数据并且驻留在应用之内的服务，或者驻留在应用之上并能够访问封装在应用中的数据的服务。</p>
<p>上面所说的IT footprint中，footprint，即足迹，的本意是由动物遗留下的包含了遗留者本身标识和信息的事物。在信息技术领域，根据哈佛商学院Andrew McAfee所述，技术足迹表示了其在地理、逻辑分区和/或功能方面所能延展到范围，是针对一个信息技术所期望的覆盖范围的描述（A technology's footprint is its geographic, divisional, and/or functional reach. It's a description of how much territory a piece of IT is intended to cover）。在TOGAF中并没有说明数据大小的调整与IT足迹改善之间的关系，也没有说明所谓的IT足迹改善的具体含义。不过通过互联网上的一个关于IT足迹改善的实例，即将原本有着十几台计算机的教室用一台中心计算机和若干终端来代替，笔者有感而发，粗浅的认为这里IT足迹改善意思是说由于数据尺寸得到了很好的调整，那么不必需的冗余信息被削减，因而数据和应用的“足迹”，即其涉及到的范围，将比冗余剔除前更加清晰有效</p>
<p>数据安全图（Data Security Diagram）</p>
<p>数据可以看作是企业的一项资产，简单的讲，数据安全可被认为是确保企业数据不被损害，并且针对数据的访问也要在适当的控制之下。数据安全图的目标是描述何执行者可以访问企业中的哪些数据。此外，此图也可以被用来阐述与数据隐私法规以及其他应用性法规的符合度。此图还需要考虑发生在企业合作伙伴或其他团体对企业系统进行访问之处的信任含义，例如在外包的情形下，信息可能会被企业之外的其他人员（甚至身处国门之外）所管理。</p>
<p>类层次结构图（Class HierarchyDiagram）</p>
<p>类层次结构图的目标是为技术方面的干系人展示一个有关类层次的视图。此图的优点是干系人可以得到一份关于数据实体在技术层面上如何被使用的图形描述，它使得干系人可以了解何人正在针对数据进行使用，以及他是在何时、如何以及为何进行这项活动。</p>
<p>数据迁移图（Data Migration Diagram）</p>
<p>在实现一个以封包服务为基础的解决方案时，数据迁移是非常重要的，特别是将现存的遗留系统替换为一个服务封包时，或者当企业将要迁移到一个更大的封包服务时。每个服务包都倾向于具有属于他们自己的数据模型，并且在数据迁移过程中，遗留的应用数据可能需要在载入到服务封包之前需要进行某种转化。数据迁移活动通常包含如下的步骤：</p>
<ul>
<li>从原有应用中抽取出数据。</li>
<li>配置源数据</li>
<li>执行数据转换，其中包括数据质量相关的各个过程：
<ul>
<li>对数据进行标准化、归一化，并消除数据的重复性（数据清洗）。</li>
<li>针对不同来源的数据进行比对、合并和整合。</li>
<li>进行自源头至目标的映射</li>
</ul>
</li>
<li>将数据加载到目标应用之中。</li>
</ul>
<p>数据迁移图的目标是展示数据如何从源头应用流入到目标应用之中。此图为数据从源头到目标过程的进行提供了一个可视化表达，并可在数据审计和追溯中作为辅助工具。此外，此图所展示的细节程度可以按照需要进行调整。例如，数据迁移图可以仅仅包含一个关于迁移情况的整体布置，也可以为单独的应用提供元数据元素级别的详细信息。</p>
<p>数据生命周期图（Data Lifecycle Diagram）</p>
<p>数据生命周期图是在业务流程的约束之下对业务数据在其整个生命周期（从概念阶段到最终退出）中对其进行管理的核心部分。数据从本质上讲是一个实体，并独立于业务流程和活动。数据状态的每个变化都被表现在这张图中，这也可以包括引起此状态变化事件或规则。数据与流程的分离使得通用数据需求可以被识别出来，从而使得资源共享得以有效达成。</p>
<p>应用组合目录（Application Por tfolio Catalog）</p>
<p>此目录的目标是明确和维护企业中所有应用的列表。一个经过批准的应用组合目录使得一系列应用得以被定义和治理。此目录为后面的矩阵和图形提供了基础，是应用架构开发阶段的起点。现有的应用注册表和资源库（比如SAP的解决方案管理和系统情况目录产品）也从基线和目标两个角度为这个目录的制定提供了输入。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>信息系统服务</li>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
</ul>
<p>接口目录（Interface Catalog）</p>
<p>接口目录用来界定应用之间接口的范围，并对这些接口进行文档化记录，从而使得应用间的所有依赖关系得以被尽可地界定。系统可以用来创建、读取、更新和删除其他系统内的数据。无论是通过循环载入的批处理文件、对其他系统数据库的直接连接，还是通过某种形式的应用程序接口或Web服务，这些行为都是通过接口来实现。针对应用组件之间关系的映射是一个非常重要的步骤，它使得如下情形得以实现：</p>
<ul>
<li>了解应用间交互程度的，从而可以站在应用与其他系统之间依赖性的角度识别出各个关键的交互。</li>
<li>了解应用之间接口的数量和类型。</li>
<li>了解应用之间接口的重复程度。</li>
<li>在考虑目标应用组合时明确各接口的简化潜力。</li>
<li>支持差距分析，并确定是存在本应建立的应用被遗漏了。</li>
</ul>
<p>此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>逻辑应用组件</li>
<li>物理应用组件</li>
<li>应用之间的通信关系</li>
</ul>
<p>系统/组织矩阵（System/Organization Matrix）</p>
<p>此矩阵用于描述企业中系统与组织单元之间的关系。业务功能由组织单元来执行，而一些由组织单元执行的功能和服务也将会被IT系统所支持。应用组件与组织单元之间的映射非常重要，它会使得：</p>
<ul>
<li>为执行业务功能的组织单元分配针对应用的使用。</li>
<li>理解由组织单元所执行的业务服务和流程对应用支持需求。</li>
<li>支持差距分析，并确定是否有需要被建立的应用被遗漏。</li>
<li>定义特定组织单元所使用的应用集合</li>
</ul>
<p>。<br>
此矩阵是一张两维表，其中逻辑/物理应用组件在一条坐标轴上，而组织单元在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
<ul>
<li>组织单位与服务之间的从属关系。</li>
<li>执行者与组织单位之间的从属关系，以及其与服务之间的使用关系。</li>
<li>服务与逻辑/物理应用组件之间的实现关系。</li>
</ul>
<p>角色/系统矩阵（Role/System Matrix）</p>
<p>此矩阵用来描述企业中系统与业务角色之间的关系。一个组织中的人们会与各种系统发生交互。在交互过程中，这些用户被假定成为执行一项任务的特定角色，例如，产品购买者。应用组件与角色之间的关系映射非常重要，它使得：</p>
<ul>
<li>
<p>在组织内为特定的角色分配针对应用的使用。</p>
</li>
<li>
<p>理解支持功能的业务服务和流程的应用安全需求，并检查是否与现有策略相符合。</p>
</li>
<li>
<p>支持差距分析，并确定是否有应该被创建的应用被遗漏。</p>
</li>
<li>
<p>定义被特定业务角色所使用的应用集合。<br>
此矩阵是一个两维表，其中逻辑应用组件在一条坐标轴上，而角色在另一条轴上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>角色与功能之间的访问关系。</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>系统/功能矩阵（System/Function Matrix）</p>
<p>此矩阵用于阐述企业中系统与业务功能之间的关系。业务功能由组织单元所执行。一些业务功能和服务将会被IT系统所支持。应用组件与功能之间的关系映射是非常重要的，它使得如下方面成为可能：</p>
<ul>
<li>
<p>为业务功能分配针对应用的使用</p>
</li>
<li>
<p>理解业务服务和流程的应用支持需求</p>
</li>
<li>
<p>支持差距分析，并确定是否有需要被创建的应用被遗漏</p>
</li>
<li>
<p>定义被特定业务功能所使用的应用集合<br>
此矩阵是一张两维表，其中逻辑应用组件位于一条坐标轴上，而功能处在另一条坐标轴之上。这两个实体之间的关系包含了一系列需要被验证的元模型关系：</p>
</li>
<li>
<p>功能与服务之间的绑定关系。</p>
</li>
<li>
<p>服务与逻辑/物理应用组件的实现关系。</p>
</li>
</ul>
<p>应用交互矩阵（Application Interaction Matrix）</p>
<p>应用交互矩阵的目标是阐述系统之间的沟通关系。在矩阵中展示的应用交互映射与接口目录或者应用通信图示相类似的，只不过以矩阵的形式来展示。此矩阵是一张两维表，其中的每一个维度都包含了应用服务、逻辑应用组件和物理应用组件这些概念。在此矩阵中所描述的关系包括：</p>
<ul>
<li>应用服务之间的使用关系。</li>
<li>逻辑应用组件之间的通信关系。</li>
<li>物理应用组件的通信关系。</li>
</ul>
<p>应用通信图（Application Communication Diagram）</p>
<p>此图的目标是描述所有与应用之间的沟通相关的模型和映射。应用通信图展示了应用的应用组件和接口，并且接口可以关联数据实体，而应用则可以关联业务服务。此图所表述的“通信”应该是符合逻辑的，并且仅用来展示与架构相关的中介技术。</p>
<p>应用和用户位置图（Application and User Location Diagram）</p>
<p>应用和用户位置图展示了应用的地理分布情况。它可以被用来展示：</p>
<ul>
<li>被最终用户所使用的各个应用的地点分布</li>
<li>被执行和/或交付（在客户端情形下）的各个主机应用程序的地点分布情况</li>
<li>被开发、测试和发布的应用所处位置的分布情况</li>
</ul>
<p>此图的目标在于清晰地描述与应用发生交互的业务用户所处的业务位置，而且还包括了应用基础设施的位置。通过此图，我们可以：</p>
<ul>
<li>
<p>识别出足以支持分散在各地的用户群的产品包的数量</p>
</li>
<li>
<p>估算产品或软件的用户许可的类型和数量</p>
</li>
<li>
<p>估算用户的支持等级和支持中心的位置</p>
</li>
<li>
<p>选择系统管理工具、结构，以及用于支持本地或远程的企业用户/客户/合作伙伴的管理系统</p>
</li>
<li>
<p>适当规划业务的技术组件，即服务规模、网络带宽等</p>
</li>
<li>
<p>在实施应用和技术架构解决方案时进行性能方面的考虑<br>
用户通常会采用多种方式与应用进行交互，例如：</p>
</li>
<li>
<p>支持日常业务的运营。</p>
</li>
<li>
<p>参与业务流程的执行过程。</p>
</li>
<li>
<p>访问信息（查询、读取等）。</p>
</li>
<li>
<p>开发应用。</p>
</li>
<li>
<p>管理、维护应用。</p>
</li>
</ul>
<p>系统用例图（System Use-Case Diagram）</p>
<p>系统用例图展示了客户与应用服务提供者之间的关系。应用服务被角色或其他应用服务所使用，并且通过描述功能是在何时被如何使用，应用用例图对应用功能的描述提供了更多意义。此图的目标是帮助描述和验证各个参与者与他们对应用所担当的角色之间的交互。随着架构的进展，这些用例能够从功能性信息演进到包含技术实现细节。架构系统用例还可以在更细节的系统设计工作中被复用。</p>
<p>企业管理能力图（Enterprise Manageability Diagram）</p>
<p>企业管理能力图展示了一个或多个应用是如何与用以支持一个解决方案的运营管理的应用和技术组件进行交互的。此图实际上是针对应用通信图的一个过滤，特别是针对企业管理类软件方面。基于此图的分析可以揭示组织的IT服务管理操作方面重复、差距和机遇。</p>
<p>流程/系统实现图（Process/System Realization Diagram）</p>
<p>流程/系统实现图的目标是清晰地阐述在业务流程执行过程中涉及到多个应用时所产生的事件的顺序。此图可以识别出能够被简化的复杂顺序，以及架构中各种可能的合理化点，从而为业务用户提供更加及时的信息。此外，此图还可被用来明确流程中能够通过减少应用之间的交互流量而进行效率改善的地方。</p>
<p>软件工程图（Software Engineering Diagram）</p>
<p>系统工程图从开发的角度将应用分解为包、模块、服务和操作，它使得在各规划迁移阶段和分析机会与解决方案时进行更加详细的影响分析成为可能。在管理复杂开发环境时，系统工程图对应用开发团队和应用管理团队是非常有用的。</p>
<p>应用迁移图（Application Migration Diagram）</p>
<p>应用迁移图表明了应用从基线到目标应用组件的迁移过程，它通过精确地展示哪些应用和接口在迁移各阶段中需要被映射，使得针对迁移成本的估算更加准确。应用迁移图确定了临时的应用、集结区域以及用于支持迁移的各项基础设施。</p>
<p>软件分布图（Software Distribution Diagram）</p>
<p>软件分布图展示了应用软件在整个组织内的结构和布局，它在系统升级或应用整合项目中是非常有用的。此外，软件分布图还展示了物理应用在整个物理技术领域中是如何分布的，以及这些物理技术的位置。软件分布图对软件是如何被托管的这一问题提供了一份清晰的视图，而且还使得管理操作人员能够了解应用软件在安装成功后是如何被维护的。</p>
<p>技术标准目录（Technology Standards Catalog）</p>
<p>技术标准目标记录了企业中被批准的各项技术标准，涵盖了技术、版本、技术生命周期，以及技术的更新周期。根据组织需要，也可能包括地点或者业务的特定领域的标准信息。此目录提供了一个当前或能够被部署的企业标准技术的快照，并有助于在整个企业内搜寻差异。如果当前已经存在了各种技术标准，那么把它们放入到技术组合目录中将会得到一张关于各技术标准符合性的基线视图。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>技术组合目录（Technology Por tfolio Catalog）</p>
<p>此目录的目标是识别和维护整个企业中在用技术的列表，包括硬件、技术设施软件，以及应用软件。一个经过批准的技术组合支持技术产品和版本的生命周期管理，而且还形成了技术标准定义的基础。技术组合目录为后续的矩阵和图形描述提供了基础，是技术架构开发阶段的起点。技术注册表和资源库从基线和目标的视角为此目录提供了输入。在此目录中的技术应该按照TOGAF技术参考模型（可以按照需要来对模型进行扩展，从而符合针对正在使用的技术产品的分类）进行分类。此目录所涉及到的内容元模型实体包括：</p>
<ul>
<li>平台服务</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>系统/技术矩阵（System/Technology Matrix）</p>
<p>系统/技术矩阵记录了业务系统与技术平台之间的映射关系。此矩阵应该是一张或多张平台分解图的补充，并应与这些图保持一致。此矩阵展示了：</p>
<ul>
<li>逻辑/物理应用组件。</li>
<li>服务、逻辑技术组件以及物理技术组件。</li>
<li>物理技术组件与物理应用组件之间的实现关系。</li>
</ul>
<p>环境和位置图（Environments and Locations Diagram）</p>
<p>环境和位置图描述了哪些应用处于哪些位置，并标识出什么技术和/或应用被用在了哪些地方，以及表示出业务用户一般在何处与应用进行交互。此图还展示了不同部署环境的存在和位置，包括非生产环境，例如开发和预生产。</p>
<p>平台分解图（Platform Decomposition Diagram）</p>
<p>平台分解图描述了用于支持信息系统架构运行的技术平台。此图涵盖了技术设施平台的所有方面，并提供了一个关于企业技术平台的概览。此图可以通过扩展来将技术平台映射到适当的处于特定功能或流程区域内的应用组件。此图还可以被用来展示规范说明的细节，例如产品版本、CPU数量等，或者只是用来提供技术环境概览的非正式的“过眼图”。</p>
<p>此图应该清楚的展示企业应用和针对每个应用区域的技术平台，它可以被进一步分解为：</p>
<ul>
<li>硬件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
<li>软件：</li>
<li>逻辑技术组件</li>
<li>物理技术组件</li>
</ul>
<p>处理图（Processing Diagram）</p>
<p>处理图关注于代码/配置的部署单元（针对业务功能、服务或应用组件的分组），以及这些单元是如何被部署到技术平台之上的。处理图表明了：</p>
<ul>
<li>
<p>哪些应用组件需要被组织起来，并形成部署单元。</p>
</li>
<li>
<p>部署单元之间是如何连接和交互的。</p>
</li>
<li>
<p>应用配置和使用模式是如何针对不同的技术组件而产生负载或容量方面需求。<br>
针对部署单元的组织和分组依赖于对组件的展示、业务逻辑以及数据存储层和服务水平需求这些方面关注点的分离。例如，展示层部署单元是基于如下方面进行分组的：</p>
</li>
<li>
<p>用于提供用户界面或用户访问功能的应用组件。</p>
</li>
<li>
<p>根据位置和用户角色来进行区分的应用组件。<br>
每个部署单元是由若干子单元所组成的，例如：</p>
</li>
<li>
<p>安装单元：包含可执行的代码或封包配置的部分。</p>
</li>
<li>
<p>执行单元：应用组件以及与其相关的运行时状态。</p>
</li>
<li>
<p>持久化单元：代表应用组件的持久化状态的数据。<br>
部署单元可以被部署到专用或共享的技术组件之上（工作站、Web服务器、应用服务器或数据库服务器等）。需要注意的是，技术处理对于服务的定义和粒度具有着较大的影响。</p>
</li>
</ul>
<p>网络计算/硬件图（Networked Computing/Hardware Diagram）</p>
<p>从大型机到客户端-服务器系统的改造开始，以及随后的电子商务和J2EE的出现，大型企业逐步进入到了一个高度网络化的分布式网络计算环境之中。当前，大多数应用都具有一个Web前端，并且就这些应用的部署架构来说，具备三个独立层次的情况还是非常常见的，亦即Web表现层、业务逻辑或应用层，以及一个后台数据存储层。将应用部署到一个共享的通用技术设施环境之中也是一种常见的做法。</p>
<p>由此可见，将逻辑应用与在开发和生产过程中对应用进行支持的技术组件之间的映射关系记录起来是非常重要的。网络计算/硬件图的目标是展示逻辑应用组件在一个分布式网络计算环境中部署的逻辑视图。此图之所以有用，是因为通过此图我们可以：</p>
<ul>
<li>了解应用部署在分布式网络计算环境中的什么地方。</li>
<li>建立针对这些技术组件的授权、安全和访问。</li>
<li>了解在问题解决和故障排除中用以支持应用的技术架构。</li>
<li>对应用所遇到的性能问题进行隔离，确定应用是代码相关的，还是技术平台相关的，并对具体的物理技术组件进行必要的升级。</li>
<li>当新的技术出现并能够因此带来成本缩减时，确定可通过此技术进行优化的区域。</li>
<li>使得应用/技术审计成为可能，并证明企业技术标准的符合性程度。</li>
<li>作为将变更引入到技术架构的用力工具，从而支持有效地变更管理。</li>
<li>当应用从一个共享环境迁移到一个专门的环境时，建立可追溯性和正在进行变化的应用的终端地址，反之亦然。</li>
</ul>
<p>通过适当的定义，网络计算/硬件图的范围可以涵盖某一个特定的应用、业务功能或者是整个企业，而如果选择在企业级别进行开发，那么组织就可以通过一种与应用无关的方式来对网络计算情况进行描述。</p>
<p>通信工程图（Communications Engineering Diagram）</p>
<p>通信工程图描述了处在技术架构中的各资产之间的通信方法（收发信息的方法）。此图展示了客户端和服务器组件之间的逻辑连接，并明确了用于对这些逻辑连接进行实现的网络边界和网络基础设施。需要注意的是，此图并不描述参与通信的信息格式或内容，但它可以对通信协议以及容量方面的问题进行阐述。</p>
<p>项目背景图（Project Context Diagram）</p>
<p>项目背景图展示了作为过渡路线图一部分而实现的工作包的范围。此图会将工作包与在项目中被增加、删除或影响的组织、功能、服务、流程、应用、数据以及技术连接在一起。此图对于项目组合管理和项目动员来说也是一个有价值的工具。</p>
<p>效益图（Benefits Diagram）</p>
<p>效益图展示了在架构定义中识别出来的各种机会，并通过他们的相对规模、效益和复杂度进行分类。此图可被干系人用来对这些识别出来的机会进行选择、对其优先级进行定义，并对他们的顺序进行确定。</p>
<p>需求目录（Requirements Catalog）</p>
<p>需求目录包含企业需要用来满足目标要求的种种事物。在架构行为中所产生的需求一般会通过变更措施来实现，并在机会和解决方案阶段中界定其范围。需求还可以被用来作为质量保证的工具，从而保证针对特定架构的使用始终处在其使用范围之内。</p>
<h3> 3、针对视图的开发</h3>
<p>如前所述，TOGAF中定义了一系列基本的架构制品来担当原子性视角，不同的组织可以根据自身的需要创建、改造或利用这些原子视角，并根据不同干系人的关注点将这些架构制品组合为适合于他们的视角定义，因而针对视图的开发需要明确其目标干系人、他们的关注点，以及所采用的各种基本架构制品和建模方法。TOGAF中针对多种视图的开发方法进行了建议，包括：</p>
<ul>
<li>业务架构视图：此视图是为用户而进行开发的，它从系统用户的角度对系统的功能性方面进行关注。</li>
<li>企业安全视图：此视图是为系统安全工程师而进行开发的，它从安全的角度对系统如何实现，以及安全如何影响系统特性这些方面进行关注，这其中最重要的是，相关干系人能够了解如何确保系统仅能被具有权限的人员或系统来进行访问，以及如何保护系统不受到非授权地侵扰。</li>
<li>软件工程视图：创建一个软件密集型系统是非常耗费资源和时间的，因而建立一个能够帮助最小化劳力付出和风险的导则是非常必要的，而这正是软件工程视图的目标。此视图应该是为开发系统的软件工程师而进行开发的。</li>
<li>系统工程视图：此视图应该是为系统的系统工程人员而进行开发的，并从硬件/软件和网络连接的角度对系统如何被实现进行关注。</li>
<li>通信工程视图：此视图应该是为系统的通信工程人员而进行开发的，并在通信工程师的角度关注于系统是如何被实现的。</li>
<li>数据流视图：此视图应该是为系统的数据库工程师而进行开发的。此视图的主要关注点在于了解如何为正确的人员和应用通过适当的接口并在合适的时间提供正确的数据。</li>
<li>企业管理能力视图：此视图应该是为系统的运营、行政和管理人员而进行开发的。此视图的主要关注点在于了解系统是如何做为一个整体而被管理的，以及系统的所有组件是如何被管理的，这其中关键之处在于管理系统变更，并对预防性维护措施进行预测。</li>
<li>采购视图：此视图应该是为在架构组件的采购过程中所牵涉的人员而进行开发的。此视图的主要关注点在于了解哪些架构的构建块是需要被采购的，以及与采购行为相关的各种约束。</li>
</ul>
<h3> 5、构建块（Building Blocks）</h3>
<p>架构构建块可以说是企业架构内容的核心，也是企业架构开发方法的最终产物。与此相比，架构交付物所面向的是企业架构开发过程，架构制品则可以看作是企业架构内容的表现形式和使用方式，而唯有构建块则是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些企业各个领域中的可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<p>构建块特性</p>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>构建块是为了达成整个组织的需要而定义的功能包。</li>
<li>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</li>
<li>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</li>
<li>构建块通常会与其他相互依存的构建块进行互操作。</li>
</ul>
<p>除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
<ul>
<li>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</li>
<li>一个好的构建块可以由其他构建块组合而成。</li>
<li>一个好的构建块可以是其他构建块的一个组件。</li>
<li>在理想的情况下，一个构建块应是可重用和可替换的，并具备详尽的描述。</li>
</ul>
<p>构建块分类</p>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的，也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者则在实现的层面对能够实现构建块的解决方案进行描述。需要注意的是，由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合，因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>①架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>②解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>解决方案与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<p>构建块的使用原则</p>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同，并且组织也应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用，因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>
<p>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</p>
</li>
<li>
<p>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</p>
</li>
<li>
<p>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并在之后将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</p>
</li>
<li>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
</li>
<li>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
</li>
</ul>
<p>构建块与架构开发方法</p>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，而包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<h2> 五、机构构建块（Building Blocks）</h2>
<p>架构构建块是企业架构内容的核心，也是企业架构开发方法的最终产物。架构交付物面向的是企业架构开发过程，架构制品则是企业架构内容的表现形式和使用方式，而唯有构建块是企业架构内容本身。企业架构的主要作用就是在企业中的各个领域内（业务、数据、应用和技术）寻找和定义可重用的资源模块，并将这些模块结合为一个有机的整体，从而使得各个干系人对于企业情况具有准确清晰的共识，并促进企业中的信息资源的共享和优化。这些可重用模块就是架构构建块，也是架构资源库中的各种架构制品所描述的本体。</p>
<h3> 1、构建块特性</h3>
<p>在TOGAF中，构建块所共有的特性被定义如下：</p>
<ul>
<li>
<p>构建块是为了达成整个组织的需要而定义的功能包。</p>
</li>
<li>
<p>构建块需要具有在TOGAF内容元模型中定义的类型，例如执行者（Actor）、业务服务（Business Service）、应用（Application）或数据实体（Data Entity）等。</p>
</li>
<li>
<p>需要为构建块定义一个边界，并且通常需要领域专家认可这一边界定义。</p>
</li>
<li>
<p>构建块通常会与其他相互依存的构建块进行互操作。<br>
除了上述通用的特性之外，作为一个良好的构建块还需要具有如下特点：</p>
</li>
<li>
<p>构建块的制定需要考虑其实现和使用方面，并通过逐渐演进而达成针对各种技术和标准的最大化利用。</p>
</li>
<li>
<p>一个好的构建块可以由其他构建块组合而成。</p>
</li>
<li>
<p>一个好的构建块可以是其他构建块的一个组件。</p>
</li>
<li>
<p>一个构建块应是可重用和可替换的，并具备详尽的描述。</p>
</li>
</ul>
<h3> 2、构建块分类</h3>
<p>与软件技术中的接口和实现类之间的关系相类似，构建块的边界定义和规范说明与其具体实现方式之间也是松耦合的。也就是说可以通过多种实现方式来针对一个构建块进行实现，而不会影响到构建块的边界定义和规范说明。为了达成这种灵活性，在TOGAF中构建块被分为架构构建块和解决方案构建块两类，其中前者用于对构建块的需求进行描述，而后者在实现层面对能够实现构建块的解决方案进行描述。由于构建块的独立存在是没有意义的，如果要发挥其作用往往需要其他构建块的配合。因而针对作为构建块“接口定义”的架构构建块应具有一定的稳定性，而更加倾向于实现的解决方案构建块则更加灵活和多样。</p>
<p>架构构建块（ABBs：Architecture Building Blocks）</p>
<p>架构构建块与架构连续体相关，并且通常作为架构开发方法的应用结果而被定义或选择。架构构建块应具备如下特性：</p>
<ul>
<li>
<p>捕捉架构需求，例如业务、数据、应用和技术方面的需求。</p>
</li>
<li>
<p>用以指导解决方案架构块的开发。<br>
架构构建块的内容至少应包括：</p>
</li>
<li>
<p>基本功能和属性说明：有关语义方面且明确的说明，包括安全能力和管理能力。</p>
</li>
<li>
<p>接口：提供的选择集合。</p>
</li>
<li>
<p>与其他构建块之间的互操作和关系。</p>
</li>
<li>
<p>所依赖的构建块，并附以针对所需功能和用户界面的描述。</p>
</li>
<li>
<p>业务和组织实体之间的映射和策略。</p>
</li>
</ul>
<p>解决方案构建块（SBBs：SolutionBuilding Blocks）</p>
<p>与解决方案连续体相关，并通过采购或开发的方式而获得。解决方案构建块应具备如下特性：</p>
<ul>
<li>
<p>对用于进行功能实现的产品和组件进行定义。</p>
</li>
<li>
<p>对实施进行了定义。</p>
</li>
<li>
<p>满足业务需求。</p>
</li>
<li>
<p>产品或厂商是明确的。<br>
解决方案构建块的内容至少应包括：</p>
</li>
<li>
<p>具体的功能和属性。</p>
</li>
<li>
<p>接口：具体实现集合。</p>
</li>
<li>
<p>被所需功能的使用而需要的解决方案构建块以及所用接口的名称。</p>
</li>
<li>
<p>解决方案构建块与IT技术和运用策略之间的映射。</p>
</li>
<li>
<p>环境中所共享属性的说明，例如安全性、可管理性、本地化和可扩展性。</p>
</li>
<li>
<p>性能以及可配置能力。</p>
</li>
<li>
<p>设计驱动力和约束，包括物理架构。</p>
</li>
<li>
<p>解决方案构建块与架构构建块之间的关系。</p>
</li>
</ul>
<h3> 3、构建块的使用原则</h3>
<p>虽然构建块是针对企业中各项资源和能力的组合，但针对这些内容的组合方式在不同的组织中却各不相同。组织应该按照各自的特点对各个构建块进行安置，从而使构建块能够得到最大化的利用。因为一个针对构建块的明智选择和使用将会使得企业改善其对遗留系统的整合、互操作性以及在新系统和软件的创建中灵活性。从某种意义上说，所谓架构就是一系列描述在架构模型之中的构建块，以及一份关于这些构建块是如何组合在一起来达成所有业务需求的说明，而这些架构中的构建块描述了用于解决特定业务问题的范围和方法。在具体架构的设计过程中，针对构建块的使用需要遵循如下几个通用原则：</p>
<ul>
<li>一个架构应该仅包含与此架构需要解决的业务问题相关的构建块。</li>
<li>构建块与其他构建块之间存在着复杂的关系。一个构建块可以用来支持其他多个构建块，或作为用以支持某一个构建块的一部分。</li>
<li>构建块应与其类型相关的标准相符合，并遵循企业中的其他相关原则和标准。<br>
通过上述原则，企业可以将构建块组合为用于解决业务问题的各个具体架构，而针对作为架构组成单位的构建块的确定也是非常重要的。针对构建块的识别过程包括寻找企业中进行相互交互的各个能力或资产，并将他们组合在一起，在这个过程中我们需要对如下几点进行考虑：</li>
</ul>
<p>从如下角度对企业中的能力或资产进行分类：</p>
<ul>
<li>可重用的构建块，例如遗留项。</li>
<li>需要被开发的构建块，例如新的应用。</li>
<li>需要被采购的构建块，例如从市场中可购得的应用。</li>
</ul>
<p>采用适当的整合水平将各个功能组合到构建块之中。例如，遗留下来的各个元素就可以被当作一个大型构建块来处理，而不用将其分解开来。</p>
<h3> 4、构建块与架构开发方法</h3>
<p>由于详细的功能需求、约束以及现实产品的可得性并不是在一开始就可以被定义清楚的，并且这些方面对于构建块的内容和选择也有着非常大的影响，因而构建块的定义过程必将是一个迭代过程，并伴随着架构开发方法的进行而逐步演进。总的来说，这一过程可以概括为：在架构开发方法的进行过程中，首先是架构构建块被确定出来，用以达成各项业务目标和阶段目标；接下来，这些架构构建块将会通过后续的迭代过程而得以改善，并最终形成一系列可由开发或购买而得的解决方案构建块。由此可见，构建块的详细程度与架构开发所处的阶段有着非常紧密的联系，但我们还需要注意，一个构建块的详细程度还与其所组成的架构所面对的目标有着关联，例如在呈现企业的能力时，一张清晰简洁的图片将胜过上百页的详细描述。</p>
<p>架构开发方法的各个阶段对于构建块的定义和确定有着紧密的联系，特别是架构愿景、业务架构、信息系统架构和技术架构这几个阶段，包含在这些企业架构开发方法阶段之中对构建块进行定义和演进的步骤总结如下：</p>
<figure><figcaption>img_31.png</figcaption></figure>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">设计时可使用的工具</title>
    <id>https://ujava.cn/synthesis/tool.html</id>
    <link href="https://ujava.cn/synthesis/tool.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<h2> JUnit test</h2>
<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>
<h2> EclEmma</h2>
<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>
<h2> Checkstyle</h2>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<h2> JUnit test</h2>
<p>JUnit是一个用于编写和运行Java单元测试的框架。它提供了一组注解和断言方法，使得编写和执行单元测试变得更加简单和方便。JUnit可以帮助开发人员验证代码的正确性，捕获和修复潜在的缺陷，并确保代码在修改过程中不会破坏现有的功能。</p>
<h2> EclEmma</h2>
<p>EclEmma是一个用于Java代码覆盖率分析的插件，可以与Eclipse集成使用。它可以显示代码中哪些部分被单元测试覆盖到，并生成可视化的报告。EclEmma帮助开发人员评估测试套件的覆盖范围，并确定哪些代码需要进一步测试。</p>
<h2> Checkstyle</h2>
<p>Checkstyle是一个静态代码分析工具，用于帮助开发团队遵循一致的编码规范。它可以检查代码中的格式错误、命名约定、代码风格和其他潜在的问题，并生成相应的报告。通过使用Checkstyle，团队可以提高代码质量、可读性和可维护性。</p>
<h2> SpotBugs</h2>
<p>SpotBugs是一个静态代码分析工具，用于检测Java程序中的潜在缺陷和错误。它可以发现常见的编程错误、空指针引用、资源泄漏、线程安全问题等。SpotBugs提供了详细的报告和建议，帮助开发人员改进代码质量和可靠性。</p>
<h2> VisualVM</h2>
<p>VisualVM是一个功能强大的Java虚拟机（JVM）监视和性能分析工具。它可以显示应用程序的内存使用情况、线程活动、垃圾收集行为等，并提供实时的性能监控和分析。VisualVM还支持插件和扩展，可以与其他工具集成以提供更丰富的功能。</p>
<h2> Git</h2>
<p>版本控制系统，用于管理和跟踪源代码的变更。可以查看历史提交记录、分支、合并代码等。</p>
<h2> Eclipse Memory Analyzer</h2>
<p>Eclipse Memory Analyzer (MAT) 是一个用于分析 Java<br>
应用程序的内存使用情况的工具。它可以通过分析堆转储文件（例如通过jmap生成的文件）来查找内存泄漏、大对象、过多的对象等问题，而无需执行正在开发的软件代码。MAT提供了强大的内存分析功能，可以帮助开发人员定位和解决内存相关的问题。</p>
<h2> JMap</h2>
<p>jmap是Java虚拟机（JVM）的一个诊断工具，它可以生成Java堆转储文件，其中包含了Java应用程序在运行时的内存使用情况。通过使用jmap生成堆转储文件，可以将其提供给Eclipse<br>
Memory Analyzer（MAT）等工具进行进一步的分析，而无需执行正在开发的软件代码。</p>
<h2> Jenkins</h2>
<p>jenkins：一个开源的持续集成和交付工具，可自动构建、测试和部署软件项目。它可以设置为监控代码库的变更，并在发生变更时触发自动构建和测试过程。</p>
<h2> 自动化测试架构</h2>
<h4> TestNG + Mocktio</h4>
<p>JUnit是Java单元测试的一站式解决方案，它把测试驱动的开发思想介绍给了Java开发人员，并教会他们如何有效地编写单元测试。但是在过去的几年中，JUnit的改进并不大，所以为当前复杂的环境编写测试任务已经变得越来越困难，即JUnit必须与其他一些补充性测试框架集成起来。TestNG是一个测试Java应用程序的新框架，功能十分强大。</p>
<p>EasyMock和Mockito可以极大地简化单元测试的编写过程，因而被许多程序员应用在日常工作中。这两个工具无法实现对静态函数、构造函数、私有函数、Final函数和系统函数的模拟，而这些函数在大型系统中必不可少。</p>
<h4> JUnit + JMock</h4>
<p>单元测试一般只测试某一个功能，但是由于类之间的耦合，往往难以把功能隔离开来。例如，想要测试某个业务逻辑处理数据的功能，但是数据是从Database取回的，这就涉及DAO层的类调用。但是很多时候，你不想让单元测试函数去访问数据库（，而是希望有一个假的DAO类刚好可以返回你需要的测试数据。此时即可使用Mock，它的作用是在单元测试里模拟类的行为和状态。</p>
<p>JMock与Mocktio都是提供Mock功能的框架。</p>
<h2> 自动化持续集成部署架构</h2>
<h4> Git/SVN + Jenkins</h4>
<p>Git和SVN都是版本控制器。Git是分布式管理的版本控制器，通常被用于分布式模式，也就是说，每个开发人员从中心版本库或服务器上检出代码后都会在自己的机器上克隆一个与中心版本库一模一样的本地版本库。而SVN是集中式管理的版本控制器。</p>
<p>Jenkins是一个开源的、提供友好操作界面的持续集成工具，主要用于持续、自动地构建或测试软件项目、监控外部任务的运行。Jenkins是用Java语言编写的，既可以在Tomcat等流行的Servlet容器中运行，也可以独立运行。Jenkins通常与版本管理工具（SCM）和构建工具结合使用。</p>
<p>常用的版本控制工具有SVN和Git等，常用的构建工具有Maven、Ant和Gradle等。</p>
<p>Jenkins涉及持续集成（Continuous Integration，CI）和持续交付（Continuous Delivery，CD）。持续集成强调开发人员在提交新代码之后，立刻进行构建和（单元）测试。根据测试结果，确定新代码和原有代码能否正确地集成在一起。持续交付是在持续集成的基础上，将集成后的代码部署到类生产环境中。</p>
<p>Jenkins可以把FTP、SVN或Git中存储的Java程序持续构建到生产与测试环境中。也就是说，在微服务分布式环境下，不需要每次更新都在各个服务器上上传代码。一个项目的服务器越多，Jenkins的优势越明显。与Jenkins类似的软件有Travis CI等，不再赘述。</p>
<h4> Puppet</h4>
<p>Puppet是Linux、UNIX和Windows操作系统的自动管理引擎，它根据集中式规范执行管理任务（例如，添加用户、安装软件包和更新服务器配置等）。Puppet的简单陈述规范语言的能力提供了强大的代理服务，制定了主机之间的相似之处，同时使它们能够提供尽可能具体的、必要的管理内容，它依赖的先决条件和对象之间的关系清楚且明确。</p>
<p>Puppet主要解决的是环境部署的难点，例如，需要给50台服务器安装JDK，或者给10台服务器的MongoDB升级版本。如果在升级过程中出现意外的Bug和错误，此时就可以通过Puppet编写相关配置文件，一键安装到所有服务器上。与Puppet类似的软件有Homebrew等。</p>
<h2> 高并发架构</h2>
<h4> FreeMaker/Thymeleaf + FastDFS</h4>
<p>页面静态化指将部分前端需要经常请求的内容，通过页面静态化引擎转换成独立的HTML页面进行缓存。也就是说，不再需要请求后端代码，即可直接返回独立的HTML页面，减轻后端的压力。例如，在某小说网站中如果对某本热门小说的每一章内容都去请求后端，则服务器和数据库的压力会过大，通过页面静态化技术，可以把该热门小说的每一章内容都制作成独立的HTML页面，当返回该页面时，服务器承受的压力几乎可以忽略不计。除小说网站外，门户网站、新闻网站、博客网站和视频网站都可以通过这样的技术进行架构。</p>
<p>FreeMaker/Thymeleaf + FastDFS是一种页面静态化+文件管理系统的高并发架构，多用于视频、电商、小说等网站。这里的FastDFS也可以换成其他软件，其目的是减少对数据库的读取，将静态化页面存储在某存储引擎或文件管理系统中。</p>
<p>传统SSM项目架构在上传静态文件时通常上传至SSM项目服务器的本地，无法针对存储进行加卷之类的扩展性操作，因而FastDFS应运而生。FastDFS是专门为了管理静态文件制作的独立运行的应用程序，静态文件可能包含图片、GIF、TXT等。</p>
<p>在Spring Boot + FastDFS + Thymeleaf架构中，FastDFS主要负责保存Thymeleaf生成的静态文件，并提供给Spring Boot进行读写操作。这是一种很常见的以空间换时间的架构模式。当文件管理系统中的数据量过大时，可以进行定时删除操作，极大地减少对MySQL的访问量。</p>
<p>当然，电商网站用Elasticsearch引擎或MongoDB缓存的也非常多，方便在读取页面时返回不同的数据，减少对MySQL数据库的访问量。页面静态化+文件管理系统的架构更加细致，返回速度更快，压力更小。</p>
<p>下面用一个简单的例子介绍Spring Boot + FastDFS + Thymeleaf架构的业务流程。假设前端需要请求一页新闻，首先，请求Redis查看缓存中是否包含Thymeleaf生成的静态页面标识。若没有，则通过MySQL请求静态页面标识。其次，在拿到静态页面标识后，即可通过FastDFS请求到HTML静态页面，并直接将其返回给前端进行处理。另外，管理员或定时任务可以定时修改FastDFS中的新闻（相当于更新FastDFS中的缓存）。</p>
<p>如果不使用该架构，仍假设前端需要请求一页一万字的新闻，则先在Redis中查询是否包含这一万字的新闻。若没有，再在MySQL中查询一万字的String字符串，转化速度极慢。这种架构相当于将大量的字符都缓存了起来 ， 减 少 了 后 端 的 压 力 。 但 是 将 N 篇 一 万 字 的 新 闻 都 缓 存 在 Redis 或Elasticsearch中并不是好的选择。</p>
<h4> Spring Boot +Netty+ gRpc + Protobuf</h4>
<p>Spring Boot + Netty + gRPC +Protobuf是一种多语言多协议的集成架构，多用于金融、医疗等网站。</p>
<p>Protobuf是一个与平台和语言无关，可扩展且轻便高效的序列化数据结构协议，可用于网络通信和数据存储。Protobuf像XML和JSON一样，可以让由不同语言编写并在不同平台上运行的应用程序交换数据。例如，用Go语言编写的发送程序可以在Protobuf中对用Go语言编写的销售订单数据进行编码，然后用Java语言编写的接收方对它进行解码，以获取所接收订单数据的Java表示方式。Protobuf传输的是二进制数据。Protobuf和其他编码系统对结构化数据进行序列化和反序列化。</p>
<p>远程过程调用（Remote Procedure Call，RPC）框架实际上是提供了一套机制，使得应用程序之间可以进行通信，而且遵从C/S模型。在使用时，客户端调用服务器端提供的接口就像调用本地的函数一样。</p>
<p>gRPC是Google公司针对远程过程调用提供的一种实现框架，通过gRPC框架配合ProtoBuf序列化传输协议，可以使数据如同本地调用一样轻松跨语言传输。例如，对于一些特定内容，若C++性能比Java性能更加优秀，则可以使用C++代码编写，之后再通过gRPC+ Protobuf架构让Java代码直接调用。</p>
<h4> Spring Batch + Quartz + Kettle</h4>
<p>Spring Batch是Spring全家桶的一个组件，是一个批处理应用框架。它不是调度框架，但需要和调度框架合作来构建并完成批处理任务。它只关注批处理任务相关的问题，如事务、并发、监控、执行等，并不提供相应的调度功能。如果需要使用调度框架，则可以使用Quartz、Tivoli、Control-M、Cron等企业级调度框架。Spring Batch擅长数据迁移、数据同步、数据批处理等工作。</p>
<p>Quartz是OpenSymphony开源组织在Job Scheduling领域的又一个开源项目，它既可以与J2EE和J2SE应用程序相结合，也可以单独使用。Quartz可以用来创建简单的或者可以运行上万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或EJBs。</p>
<p>Spring Batch + Quartz通常与Kettle、MySQL一起使用。Kettle是一款国外开源的ETL（Extract-Transform-Load）数据仓库技术工具，可以在Window、Linux、UNIX操作系统上运行，数据抽取高效稳定。Spring Batch +Quartz可将多个数据源的数据统一置入数据仓库中，由数据仓库导出各种所需要的数据。例如，原本的数据为用户表、购物车表和商品表，经数据仓库处理之后，可直接返回所需要的数据格式，而非多个表或多个值。除此之外，Kettle包含界面化导出Excel的功能，可以由非技术类人员导出相关数据。</p>
<h2> 响应式编程架构</h2>
<p>响应式编程（Reactive Programming）是一种面向数据流和变化传播的范式，可以在编程语言中很方便地表达静态或动态的数据流，相关的计算模型会自动将变化的值通过数据流进行传播。例如，c=a+b表示将a+b表达式的结果赋给c。在传统编程中，改变a或b的值不会影响c；但在响应式编程中，c的值会随着a或b值的变化而变化。</p>
<p>Reactor是一个基于JVM之上的异步应用框架。为Java、Groovy和其他JVM语言提供构建基于事件和数据驱动应用的抽象库。Reactor的性能相当高，在最新的硬件平台上，使用无堵塞分发器每秒可以处理1500万个事件。</p>
<p>Reactor框架是Spring之前的项目，实现了Reactive Programming思想，符合Reactive Streams规范。。Spring WebFlux是在Ractor框架基础上实现的响应式Web框架，完全无阻塞，支持Reactive Streams背压，并且可以在Netty、Undertow和Servlet 3.1+等服务器上运行。</p>
<p>Spring WebFlux的功能较多，下面通过代码展示部分功能：<br>
<br>
</p>
<p>此时分别调用controller1接口与controller2接口，后台日志输出如下所示：<br>
</p>
<h2> 负载均衡架构</h2>
<p>负载均衡的含义是通过多台服务器共同承载压力。例如，一个HTTP请求通过Nginx中间件转发给多台Tomcat的架构形式即为负载均衡架构。</p>
<p>负载均衡架构有多种表现形式，如下所示：</p>
<ul>
<li>服务器端静态反向代理负载均衡架构：Keepalived + Nginx + Java。该架构被负载的实际地址是在配置文件中直接编写的IP地址与端口。该架构形式无法在正在运行的过程中进行修改。</li>
<li>服务器端动态反向代理负载均衡架构：Nginx + UpSync + Consul +Java。该架构被负载的实际地址是通过Consul注册中心记录的。Nginx会通过UpSync插件获得到实际地址并进行负载均衡。该架构形式可以在系统正常运行时更新Java程序的节点。</li>
<li>客 户 端 负 载 均 衡 架 构 Spring Cloud + Consul + Spring BootRibbon。在该架构中，当Java1程序请求Java2程序时，Java1程序会通过Consul获取Java2程序的节点信息，若Java2程序在Consul中注册了N个节点，则Java1程序在获得所有Java2程序的节点信息之后，会通过算法请求Java2程序的其中一个节点，即以客户端请求直接进行分发的方式达到负载均衡的目的</li>
<li>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，以便将客户端的访问引导到不同的服务器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。这种负载均衡技术通常由云服务商提供。与DNS负载均衡类似的是CDN负载均衡，不再赘述。</li>
<li>硬件负载均衡技术：通常由硬件直接进行数据与请求分发，达到负载均衡的结果。市场上常见的硬件有NetScaler和Radware等。</li>
<li>协议性负载均衡架构。例如，通过HTTP协议的重定向功能进行负载均衡，或通过自研协议进行负载均衡。</li>
<li>混合型负载均衡架构。使用多种负载均衡架构的混合架构，不同的应用程序可以采用不同的负载均衡架构。</li>
</ul>
<h2> 监控工具与监控架构</h2>
<h4> 性能监控设计</h4>
<p>性能监控通常指监控Linux服务器的CPU、内存、I/O、硬盘、应用程序接口耗时等，常见的性能监控架构如下所示：</p>
<ul>
<li>Telegraf + InfluxDB + Chronograf + Kapacitor架构。</li>
<li>Prometheus + Grafana架构。</li>
<li>Elasticsearch + Logstash + Kibana + Filebeat架构。</li>
<li>Zabbix + Grafana架构。<br>
在Telegraf + InfluxDB + Chronograf + Kapacitor架构（简称TICK架构）中，InfluxDB为时序数据库，负责数据存储；Telegraf为独立运行的采集软件，负责数据采集；Chronograf负责数据可视化；Kapacitor负责告警、预警。Telegraf从Linux系统或相关文件中获取数据，通过HTTP接口传到InfluxDB数据库中，Chronograf会定时从InfluxDB数据库中获取相关数据并进行展示。</li>
</ul>
<p>TICK架构可转换成Telegraf + InfluxDB + Grafana架构（简称TIG架构），其中，Grafana提供数据可视化与报警、预警功能。TICK架构也可转换成Prometheus + Grafana架构（简称PG架构），即由Prometheus负责数据的采集与存储。</p>
<p>在 Elasticsearch + Logstash + Kibana 架 构 （ 简 称 ELK 架 构 ） 中 ，Logstash负责数据的采集，Elasticsearch负责数据的存储，Kibana负责数据的展示。当Logstash在大型项目中采集能力不足时，偶尔会增加Filebeat来采集数据，之后通过Logstash管道传输给Elasticsearch。</p>
<p>ELK架构与TICK架构、TIG架构和PG架构的相似之处在于各个角色的划分几乎相同，并且都可以采集CPU、内存等信息，与TICK架构、TIG架构和PG架构相比，ELK架构更着重于采集不同类型的数据，具有更丰富的生态，不过在构建一些监控图表时，较为费时费力。TICK架构、TIG架构和PG架构的监控图表更加美观，搭建与报警也更加简便，所以业内通常采用TICK架构和TIG架构作为性能监控设计，采集CPU、内存、硬盘等相关信息；采用ELK架构作为业务监控设计，采集程序日志、Nginx日志、接口请求等相关信息。采用TICK架构、TIG架构作为性能监控设计主要。采用PG架构采集MySQL相关的信息。</p>
<p>Zabbix与上面的软件都不同，它是一套自我完善的监控软件，也就是说，只使用Zabbix，也可以完成对CPU、内存等相关信息的监控。Zabbix是一个基于Web界面的提供分布式系统监视和网络监视功能的企业级的开源解决方案。Zabbix能控各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制，以便让系统管理员快速定位并解决存在的问题。</p>
<p>Zabbix由两部分组成，zabbix server与可选组件zabbix agent。zabbixserver可以通过SNMP、zabbix agent、ping、端口监视等实现对远程服务器或网络状态的监控、数据收集等功能，它可以运行在Linux、Solaris、OS X等平台上。</p>
<p>Zabbix自带图表功能，但图表并不美观，所以通常结合Grafana使用。</p>
<h2> 全链路监控</h2>
<p>Pinpoint是一款全链路分析工具，提供了无侵入式的调用链监控和方法执行详情查看、应用状态信息监控等功能，与另一款开源的全链路分析工具Zipkin类似。与Zipkin相比，Pinpoint提供了无侵入式等特性，支持的功能较为丰富，可以帮助分析系统的总体结构，以及分布式应用程序组件之间是如何进行数据互联的。</p>
<p>服务拓扑图：对整个系统中应用的调用关系进行了可视化的展示，单击某个服务节点，可以显示该节点的详细信息，比如当前节点状态、请求数量等</p>
<p>实时活跃线程图：监控应用内活跃线程的执行情况，可以直观地了解应用的线程执行性能。请求响应散点图：以时间维度进行请求计数和响应时间的展示，通过拖动图表可以选择对应的请求，查看执行的详细情况。</p>
<p>请求调用栈查看：对分布式环境中的每个请求都提供了代码维度的可见性，可以在页面中查看请求针对代码维度的执行详情，帮助查找请求的瓶颈和故障原因。</p>
<p>应用状态、机器状态检查：查看相关应用程序的其他详细信息，比如CPU的使用情况、内存状态、垃圾收集状态、TPS和JVM信息等参数。</p>
<p>与Pinpoint类似的还有Zorka和Scouter等。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:42:50.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Web</title>
    <id>https://ujava.cn/assembly/container.html</id>
    <link href="https://ujava.cn/assembly/container.html"/>
    <updated>2024-04-15T03:37:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>应用服务器：tomcat</p>
<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>
<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>
<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>
<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish<br>
v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5<br>
平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations<br>
1.0、StAX<br>
1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>应用服务器：tomcat</p>
<p>常用应用服务器：WebLogic、WebSphere、Apache、JBoss、GlassFish</p>
<p>Jboss作为Java EE应用服务器，它不但是Servlet容器，而且是EJB容器，从而受到企业级开发人员的欢迎，从而弥补了Tomcat只是一个Servlet容器的缺憾。</p>
<p>在商用应用服务器里主要有：Weblogic、Websphere，其中Weblogic我也使用过很长一段时间，当时也只用其当Servlet容器，然而就在同等条件下，在性能及易用性等方面，要比Tomcat优秀很多。</p>
<p>glassfish是Sun公司推出的Java EE服务器，一个比较活跃的开源社区，不断的通过社区的反馈来提高其的可用性，经过glassfish<br>
v1、glassfish v2 到今天的glassfish v3，它已经走向成熟。Glassfish是一个免费、开放源代码的应用服务，它实现了Java EE 5，Java EE 5<br>
平台包括了以下最新技术：EJB 3.0、JSF 1.2、Servlet 2.5、JSP 2.1、JAX-WS 2.0、JAXB 2.0、 Java Persistence 1.0、Common Annonations<br>
1.0、StAX<br>
1.0等。支持集群，通过内存中会话状态复制，增强了部署体系结构的可用性与可伸缩性，它对集群有着很好的支持，可以简单到通过添加机器，就可轻松的提高网站的带负载能力。在解析能力方面，它对html的吞吐能力与apache服务器不分上下，就是tomcat所不能比的，支持目录部署，热部署，解决了tomcat对热部署能力的缺陷。在版本方面做的更加人性化，有开发时用的简化版，专门用于部署web项目的版本，还要完全符合j2ee标准的版本。</p>
<h2> webSphere</h2>
<p>WebSphere是 IBM 的集成软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web<br>
应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的集成软件。</p>
<h2> JBoss</h2>
<p>JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3.0的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。2006年,Jboss公司被Redhat公司收购。</p>
<h2> Tomcat</h2>
<p>Tomcat是Apache 软件基金会的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun<br>
的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5 支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat<br>
技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
<p>JBoss与Tomcat的是完全开源的</p>
<p>WebLogic与WebSphere都是对业内多种标准的全面支持，包括EJB、JSB、JMS、JDBC、XML和WML，使Web应用系统的实施更为简单，并且保护了投资，同时也使基于标准的解决方案的开发更加简便。</p>
<h4> 扩展性的不同：</h4>
<p>WebLogic和WebSphere都是以其高扩展的架构体系闻名于业内，包括客户机连接的共享、资源 pooling以及动态网页和EJB组件群集。</p>
<h4> 应用范围的区别：</h4>
<p>Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。</p>
<p>WebLogic和WebSphere是商业软件，功能齐全强大，主要应用于大型企业的大型项目。</p>
<p>JBOSS 主要应用于EJB服务的中小型公司。</p>
<h4> JBoss还具有如下六大优点：</h4>
<p>1、JBoss是免费的，开放源代码J2EE的实现，它通过LGPL许可证进行发布。</p>
<p>2、JBoss需要的内存和硬盘空间比较小。</p>
<p>3、安装非常简单。先解压缩JBoss打包文件再配置一些环境变量就可以了。</p>
<p>4、JBoss能够"热部署"，部署BEAN只是简单拷贝BEAN的JAR文件到部署路径下就可以了。如果没有加载就加载它；如果已经加载了就卸载掉，然后LOAD这个新的。</p>
<p>5、JBoss与Web服务器在同一个Java虚拟机中运行，Servlet调用EJB不经过网络，从而大大提高运行效率，提升安全性能。</p>
<p>6、用户可以直接实施J2EE-EAR，而不是以前分别实施EJB-JAR和Web-WAR，非常方便。</p>
<p>JBoss的安装和配置可以直接拷贝使用，但是要改动 %JBoss-HOME%\bin\run.bat里JAVA-HOME的设置，改成本机JDK的目录。运行run.bat来启动JBoss</p>
<h2> Weblogic</h2>
<p>WebLogic是美国bea公司出品的一个application<br>
server确切的说是一个基于j2ee架构的中间件，webserver是用来构建网站的必要软件用来解析发布网页等功能，它是用纯java开发的。weblogic本来不是由bea发明的，是它从别人手中买过来，然后再加工扩展。目前weblogic在世界application<br>
server市场上占有最大的份额，其他还有象IBM的websphere，免费的tomcat、resin等中间件。</p>
<p>BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java<br>
Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<p>BEA WebLogic Server拥有处理关键Web应用系统问题所需的性能 、可扩展性和高可用性。</p>
<p>与BEA WebLogic Commerce ServerTM配合使用， BEA WebLogic Server可为部署适应性个性化电子商务应用系统提供完善的解决方案。</p>
<p>BEA WebLogic Server具有开发和部署关键任务电子商务Web应用系统 所需的多种特色和优势</p>
<p>WebLogic: WebLogic<br>
是一套基于JAVA功能强大的电子商务套件，提供了许多功能强大的中间件以方便编程人员编写的JSP、SERVLET等电子商务应用，可以为企业提供一个完整的商务应用解决方案。不适合开发阶段，太慢了，适合于运行环境（收费）。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:37:02.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Serverless</title>
    <id>https://ujava.cn/assembly/serverless.html</id>
    <link href="https://ujava.cn/assembly/serverless.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1 什么是severless ?</h2>
<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>
<figure><figcaption>img_58.png</figcaption></figure>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>
<ul>
<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>
就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1 什么是severless ?</h2>
<p>Serverless（无服务器架构）是指服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，其业务层面的状态则存储在数据库或其他介质中。</p>
<figure><figcaption>img_58.png</figcaption></figure>
<p>纵观云原生技术的发展过程， 体现出的一条脉络就是对底层实现、基础设施关心的越来越少，而把重心放在业务逻辑上。</p>
<p>那么serverless到底是什么呢？ 下引用serverless handbook给出通俗易懂和具体的定义。</p>
<ul>
<li>简单版：Serverless（无服务器架构）指的是服务端逻辑由开发者实现，运行在无状态的计算容器中，由事件触发，完全被第三方管理，而业务层面的状态则记录在数据库或存储资源中。</li>
<li>进阶定义: Serverless是由事件（event）驱动（例如 HTTP、pub/sub）的全托管计算服务。用户无需管理服务器等基础设施，只需编写代码和选择触发器（trigger)，比如 RPC 请求、定时器等并上传，其余的工作（如实例选择、扩缩容、部署、容灾、监控、日志、安全补丁等）全部由 serverless 系统托管。用户只需要为代码实际运行消耗的资源付费——代码未运行则不产生费用。<br>
就像无线互联网实际有的地方也需要用到有线连接一样，无服务器架构仍然在某处有服务器。开发者无需关注服务器，只需关注代码。erverless 相对于 serverful，对业务用户强调 noserver（serverless 并不是说没有服务器，只是业务人员无需关注服务器了，代码仍然是运行在真实存在的服务器上）的运维理念，业务人员只需要聚焦业务逻辑代码。</li>
</ul>
<h2> 2 有服务到无服务构架有哪些变化？</h2>
<ul>
<li>弱化了存储和计算之间的联系。服务的储存和计算被分开部署和收费，存储不再是服务本身的一部分，而是演变成了独立的云服务，这使得计算变得无状态化，更容易调度和扩缩容，同时也降低了数据丢失的风险。</li>
<li>代码的执行不再需要手动分配资源。不需要为服务的运行指定需要的资源（比如使用几台机器、多大的带宽、多大的磁盘等），只需要提供一份代码，剩下的交由 serverless 平台去处理就行了。当前阶段的实现平台分配资源时还需要用户方提供一些策略，例如单个实例的规格和最大并发数，单实例的最大 CPU 使用率。理想的情况是通过某些学习算法来进行完全自动的自适应分配。</li>
<li>按使用量计费。Serverless按照服务的使用量（调用次数、时长等）计费，而不是像传统的 serverful 服务那样，按照使用的资源（ECS 实例、VM 的规格等）计费。<br>
云改变了我们对操作系统的认知，原来一个系统的计算资源、存储和网络是可以分离配置的，而且还可以弹性扩展，但是长久以来，我们在开发应用时始终没有摆脱的服务器的束缚（或者说认知），应用必须运行在不论是实体还是虚拟的服务器上，必须经过部署、配置、初始化才可以运行，还需要对服务器和应用进行监控和管理，还需要保证数据的安全性，这些云能够帮我们简化吗？让我们只要关注自己代码的逻辑就好了，其它的东西让云帮我实现就好了。</li>
</ul>
<h2> 3 serverless发展历史</h2>
<p>serverless是云化的延伸，为了更好的理解, 回顾一下云计算的发展过程</p>
<ul>
<li>LaaS, 2006 年 AWS 推出 EC2（Elastic Compute Cloud），作为第一代 IaaS（Infrastructure as a Service），用户可以通过 AWS 快速的申请到计算资源，并在上面部署自己的互联网服务。IaaS 从本质上讲是服务器租赁并提供基础设施外包服务。就比如我们用的水和电一样，我们不会自己去引入自来水和发电，而是直接从自来水公司和电网公司购入，并根据实际使用付费。这使得极大降低了基础设施的成本，而且具有很好扩展性。</li>
<li>PaaS（Platform as a Service）是构建在 IaaS 之上的一种平台服务，提供操作系统安装、监控和服务发现等功能，用户只需要部署自己的应用即可。</li>
<li>历史上第一个 Serverless 平台可以追溯到 2006 年，名为 Zimki，这个平台提供服务端 JavaScript 应用，虽然他们没有使用Serverless 这个名词，但是他们是第一个“按照实际调用付费”的平台。第一个使用 Serverless 名词的是 <a href="http://iron.io" target="_blank" rel="noopener noreferrer">iron.io</a>。</li>
<li>Serverless 实际发展已经有 10 年之久，而随着以 Kubernetes 为基础的的云原生应用平台的兴起，serverless 再度成为人民追逐的焦点。</li>
</ul>
<h2> 4 severless 分类</h2>
<p>serverless通常分为两个领域，BaaS（Backend as a Service）和 FaaS（Function as a Service)。</p>
<ul>
<li>BaaS（Backend as a Service）后端即服务，一般是一个个的 API 调用后端或别人已经实现好的程序逻辑，比如身份验证服务 Auth0，这些 BaaS 通常会用来管理数据，还有很多公有云上提供的我们常用的开源软件的商用服务，比如亚马逊的 RDS 可以替代我们自己部署的 MySQL，还有各种其它数据库和存储服务。</li>
<li>FaaS（Functions as a Service）函数即服务，FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada。</li>
</ul>
<p>FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。传统的服务器端软件不同是经应用程序部署到拥有操作系统的虚拟机或者容器中，一般需要长时间驻留在操作系统中运行，而 FaaS 是直接将程序部署上到平台上即可，当有事件到来时触发执行，执行完了就可以卸载掉。</p>
<h2> 5 severles优缺点</h2>
<h3> 优点</h3>
<ul>
<li>降低运营成本， Serverless 是非常简单的外包解决方案。它可以让您委托服务提供商管理服务器、数据库和应用程序甚至逻辑，否则您就不得不自己来维护。由于这个服务使用者的数量会非常庞大，于是就会产生规模经济效应。在降低成本上包含了两个方面，即基础设施的成本和人员（运营/开发）的成本。</li>
<li>降低开发成本， aaS 和 PaaS 存在的前提是，服务器和操作系统管理可以商品化。Serverless 作为另一种服务的结果是整个应用程序组件被商品化。</li>
<li>扩展能力，Serverless 架构一个显而易见的优点即“横向扩展是完全自动的、有弹性的、且由服务提供者所管理”。从基本的基础设施方面受益最大的好处是，用户只需支付所需要的计算能力。</li>
<li>更简单的管理，Serverless 架构明显比其他架构更简单。更少的组件，就意味着您的管理开销会更少。</li>
<li>绿色的计算， 按照《福布斯》杂志的统计，在商业和企业数据中心的典型服务器仅提供 5%～15% 的平均最大处理能力的输出。这无疑是一种资源的巨大浪费。随着Serverless架构的出现，让服务提供商提供我们的计算能力最大限度满足实时需求。这将使我们更有效地利用计算资源。</li>
<li>在上面我们提到了使用 IaaS给 我们带来了五点好处，FaaS 当然也包括了这些好处，但是它给我们带来的最大的好处就是多快好省。减少从概念原型到实施的等待时间，比自己维护服务更省钱。</li>
<li>降低人力成本，不需要再自己维护服务器，操心服务器的各种性能指标和资源利用率，而是关心应用程序本身的状态和逻辑。而且 serverless 应用本身的部署也十分容易，我们只要上传基本的代码但愿，例如 Javascript 或 Python 的源代码的 zip 文件，以及基于JVM的语言的纯 JAR 文件。不需使用 Puppet、Chef、Ansible 或 Docker 来进行配置管理，降低了运维成本。同时，对于运维来说，也不再需要监控那些更底层的如磁盘使用量、CPU 使用率等底层和长期的指标信息，而是监控应用程序本身的度量，这将更加直观和有效。</li>
<li>降低风险，对于组件越多越复杂的系统，出故障的风险就越大。我们使用 BaaS 或 FaaS 将它们外包出去，让专业人员来处理这些故障，有时候比我们自己来修复更可靠，利用专业人员的知识来降低停机的风险，缩短故障修复的时间，让我们的系统稳定性更高。</li>
<li>减少资源开销，我们在申请主机资源一般会评估一个峰值最大开销来申请资源，往往导致过度的配置，这意味着即使在主机闲置的状态下也要始终支付峰值容量的开销。对于某些应用来说这是不得已的做法，比如数据库这种很难扩展的应用，而对于普通应用这就显得不太合理了，虽然我们都觉得即使浪费了资源也比当峰值到来时应用程序因为资源不足而挂掉好。解决这个问题的一个办法就是，不计划到底需要使用多少资源，而是根据实际需要来请求资源，当然前提必须是整个资源池是充足的（公有云显然更适合）。根据使用时间来付费，根据每次申请的计算资源来付费，让计费的粒度更小，将更有利于降低资源的开销。这是对应用程序本身的优化，例如让每次请求耗时更短，让每次消耗的资源更少将能够显著节省成本。</li>
<li>增加缩放的灵活性， 以 AWS Lamba 为例，当平台接收到第一个触发函数的事件时，它将启动一个容器来运行你的代码。如果此时收到了新的事件，而第一个容器仍在处理上一个事件，平台将启动第二个代码实例来处理第二个事件。AWS lambad 的这种自动的零管理水平缩放，将持续到有足够的代码实例来处理所有的工作负载。但是，AWS 仍然只会向您收取代码的执行时间，无论它需要启动多少个容器实例要满足你的负载请求。例如，假设所有事件的总执行时间是相同的，在一个容器中按顺序调用Lambda 100 次与在 100 个不同容器中同时调用 100 次 Lambda 的成本是 一样的。当然 AWS Lambada 也不会无限制的扩展实例个数，如果有人对你发起了 DDos 攻击怎么办，那么不就会产生高昂的成本吗？AWS 是有默认限制的，默认执行 Lambada 函数最大并发数是 1000。</li>
<li>缩短创新周期，小团队的开发人员正可以在几天之内从头开始开发应用程序并部署到生产。使用短而简单的函数和事件来粘合强大的驱动数据存储和服务的 API。完成的应用程序具有高度可用性和可扩展性，利用率高，成本低，部署速度快。以 Docker 为代表的容器技术仅仅是缩短了应用程序的迭代周期，而 serverless 技术是直接缩短了创新周期，从概念到最小可行性部署的时间，让初级开发人员也能在很短的时间内完成以前通常要经验丰富的工程师才能完成的项目。</li>
</ul>
<h3> 缺点</h3>
<ul>
<li>状态管理， 要实现自由的缩放，无状态是必须的，而对于有状态的服务，使用serverless这就是丧失了灵活性，有状态服务需要与存储交互就不可避免的增加了延迟和复杂性。</li>
<li>延迟，应用程序中不同组件的访问延迟是一个大问题，我们可以通过使用专有的网络协议、RPC 调用、数据格式来优化，或者是将实例放在同一个机架内或同一个主机实例上来优化以减少延迟。而 serverless 应用程序是高度分布式、低耦合的，这就意味着延迟将始终是一个问题，单纯使用 serverless 的应用程序是不太现实的。</li>
<li>本地测试，Serverless 应用的本地测试困难是一个很棘手的问题。虽然可以在测试环境下使用各种数据库和消息队列来模拟生产环境，但是对于无服务应用的集成或者端到端测试尤其困难，很难在本地模拟应用程序的各种连接，并与性能和缩放的特性结合起来测试，并且 serverless 应用本身也是分布式的，简单的将无数的 FaaS 和 BaaS 组件粘合起来也是有挑战性的。</li>
</ul>
<h2> 6 serverless使用场景</h2>
<p>了解Severless的应用优劣之后，我们看一下severless比较适合的场景。</p>
<ul>
<li>
<p>异步的并发，组件可独立部署和扩展</p>
</li>
<li>
<p>应对突发或服务使用量不可预测（主要是为了节约成本，因为 Serverless 应用在不运行时不收费）</p>
</li>
<li>
<p>短暂、无状态的应用，对冷启动时间不敏感</p>
</li>
<li>
<p>需要快速开发迭代的业务（因为无需提前申请资源，因此可以加快业务上线速度）<br>
Serverless 的使用场景示例如：</p>
</li>
<li>
<p>ETL</p>
</li>
<li>
<p>机器学习及 AI 模型处理</p>
</li>
<li>
<p>图片处理</p>
</li>
<li>
<p>IoT 传感器数据分析</p>
</li>
<li>
<p>流处理</p>
</li>
<li>
<p>聊天机器人<br>
示例：</p>
</li>
</ul>
<p>我们以一个游戏应用为例，来说明什么是 serverless 应用。</p>
<p>一款移动端游戏至少包含如下几个特性：</p>
<ul>
<li>移动端友好的用户体验</li>
<li>用户管理和权限认证</li>
<li>关卡、升级等游戏逻辑，游戏排行，玩家的等级、任务等信息<br>
传统的应用程序架构可能是这样的：</li>
</ul>
<figure><figcaption>img_59.png</figcaption></figure>
<ul>
<li>一个 app 前端，iOS 或者安卓</li>
<li>用 Java 写的后端，使用 JBoss 或者 Tomcat 做 server 运行</li>
<li>使用关系型数据库存储用户数据，如 MySQL<br>
这样的架构可以让前端十分轻便，不需要做什么应用逻辑，只是负责渲染用户界面，将请求通过 HTTP 发送给后端，而所有的数据操作都是有由后端的 Java 程序来完成的。</li>
</ul>
<p>这样的架构开发起来比较容易，但是维护起来确十分复杂，前端开发、后端的开发都需要十分专业的人员、环境的配置，还要有人专门维护数据库、应用的更新和升级。</p>
<figure><figcaption>img_60.png</figcaption></figure>
<p>而在 serverless 架构中，我们不再需要在服务器端代码中存储任何会话状态，而是直接将它们存储在 NoSQL 中，这样将使应用程序无状态，有助于弹性扩展。前端可以直接利用 BaaS 而减少后端的编码需求，这样架构的本质上是减少了应用程序开发的人力成本，降低了自己维护基础设施的风险，而且利用云的能力更便于扩展和快速迭代。</p>
<h2> 7 serverless核心技术</h2>
<p>Serverless 是由事件驱动的全托管计算服务，它的核心技术包括：</p>
<ul>
<li>函数的规范定义</li>
<li>函数部署流水线</li>
<li>Workflow 设置</li>
<li>0-m-n 扩缩容</li>
<li>快速冷启动</li>
</ul>
<h2> 总结</h2>
<p>云原生经过这么多年的发展，已经逐渐变成到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。serverless的发展这条路走的越来越远，因为这极大的提高了资源的使用效率，降低了成本。这就是生产力的体现。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的特性，对于开发者来说，吸引力是巨大的。</p>
]]></content>
    <category term="设计高频"/>
    <published>2024-04-15T03:37:02.000Z</published>
  </entry>
  <entry>
    <title type="text">架构分类</title>
    <id>https://ujava.cn/attention/attention1.html</id>
    <link href="https://ujava.cn/attention/attention1.html"/>
    <updated>2024-04-15T03:50:17.000Z</updated>
    <summary type="html"><![CDATA[<h2> 架构的本质</h2>
<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>
<p>分为三部分：</p>
<ul>
<li>整体：部分的组成，强调合力。</li>
<li>规则：强调部分之前有关联关系，有规则，有约束。</li>
<li>通信：强调部分之间有往来，有交互。</li>
</ul>
<figure><figcaption>img_18.png</figcaption></figure>
<h2> 架构的分类</h2>
<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 架构的本质</h2>
<p>其实总结下来就一句话：<strong>架构本质上其实就是一种指导型的约束，约定整体和部分、部分和部分之间的关系，以使整体更加稳定，更加可靠。</strong></p>
<p>分为三部分：</p>
<ul>
<li>整体：部分的组成，强调合力。</li>
<li>规则：强调部分之前有关联关系，有规则，有约束。</li>
<li>通信：强调部分之间有往来，有交互。</li>
</ul>
<figure><figcaption>img_18.png</figcaption></figure>
<h2> 架构的分类</h2>
<p>实际上架构有很多种类型，比如业务架构，应用架构，技术架构，数据架构等，甚至单个架构，我们站在不同的角度上，也会有不同的看法，其中的复杂度也是各不一样的。</p>
<h2> 业务架构</h2>
<p>业务架构是指企业或机构的业务逻辑、流程、组织结构等方面的设计。它着重于企业业务运营的需求和目标，将业务需求转化为技术解决方案。业务架构的设计需要考虑企业的战略规划、组织结构、业务流程、客户需求等多个方面。</p>
<p>例如：一个银行的业务架构设计需要考虑银行的基本业务逻辑、流程和组织结构，如存款、贷款、投资、支付等，以及银行的安全性、可靠性和效率等方面的需求。</p>
<h2> 应用架构</h2>
<p>应用架构是指企业或机构的信息系统中的应用程序、系统、服务等方面的设计。它着重于解决企业业务运营中的具体问题，将业务需求转化为具体的应用程序。应用架构的设计需要考虑企业的业务需求、用户体验、系统性能、安全风险等多个方面。</p>
<p>例如：一个电商网站的应用架构设计需要考虑用户购物、订单管理、库存管理、支付等多个应用程序的设计，以及这些应用程序之间的交互和集成。</p>
<h2> 技术架构</h2>
<p>技术架构是指企业或机构的信息系统中的技术实现、系统架构、软件设计等方面的设计。它着重于解决企业业务运营中的技术问题，如系统的稳定性、可扩展性、可维护性等。</p>
<p>例如：一个电商网站的技术架构设计需要考虑系统的负载均衡、容错容灾、CDN缓存、自动化部署等多个方面的技术实现。</p>
<h2> 数据架构</h2>
<p>数据架构是指企业或机构的信息系统中的数据存储、数据处理、数据安全等方面的设计。它着重于解决企业业务运营中的数据问题，如数据的一致性、完整性、安全性等。</p>
<p>例如：一个电商网站的数据架构设计需要考虑数据的分层存储、数据备份和恢复、数据加密和权限管理等多个方面的设计，以确保数据的安全和可靠性。</p>
<h2> 架构设计要考虑的因素</h2>
<p>架构设计过程中我们要考虑的因素，整体可以分为两大类，一类是功能性因素，一类是非功能性因素。</p>
<h2> 功能性因素</h2>
<p>无论什么架构设计，我们首先是要考虑必须满足我们的业务需求，否则我们的设计都是空中楼阁。功能需求会直接决定我们的业务架构设计。所以我们的架构必须完整性地，正确地对业务实现支撑。</p>
<h2> 非功能性因素</h2>
<p>满足了功能性因素以后，我们就得要考虑怎么能够稳定地，可靠地，可持续性地支持我们的业务功能，比如性能，可靠性，扩展性，兼容性等等。</p>
<ul>
<li>可靠性
<ul>
<li>为了更好的服务于功能，我们需要确保架构能够稳定、高效的运行。不会时不时的出现服务崩溃或者不可用的情况。</li>
</ul>
</li>
<li>可用性
<ul>
<li>同样的，服务对外要始终处于可用的状态，即使单个服务实例出现问题，我们依然可以正常的对外提供服务。</li>
</ul>
</li>
<li>扩展性
<ul>
<li>功能性需求不是一层不变的，尤其在当今盛行敏捷的时代，需求不是一次性提出的。我们需要对系统、服务的整体能力有全面的定位和把控。这就需要我们的架构在新的需求出现的时候，可以方便的进行扩展支持。</li>
</ul>
</li>
<li>治理能力
<ul>
<li>好的架构一定是方便运营、管理和监控的。甚至微观到工程管理，代码一定是易于维护、扩展、协同的。</li>
</ul>
</li>
<li>响应性能
<ul>
<li>一般的，功能性需求都会对性能有一定的预期。这个业务要我们在架构上做很多工作，比如读写分离、缓存、异步等等的介入，以满足整体架构的响应能力。</li>
</ul>
</li>
</ul>
<figure><figcaption>img_19.png</figcaption></figure>
<h2> 设计原则</h2>
<ul>
<li>价值为王：系统架构设计应该以实现业务价值为目标，始终关注用户需求和业务场景，确保设计出的系统能够满足用户需求和业务场景，为企业创造价值。</li>
<li>以终为始：在进行系统架构设计时，需要明确系统的目标和愿景，并以此为起点，进行设计和实现。以确保系统的设计和实现都是为了实现业务价值，满足用户需求。</li>
<li>分治原则：将系统划分为多个子系统或模块，每个子系统或模块都可以独立地进行开发、测试、部署和维护。这样可以降低系统的复杂度，提高系统的可维护性和可扩展性。</li>
<li>服务自治：每个服务都应该具备独立的能力，能够独立地进行开发、测试、部署和维护。这样可以提高服务的可用性和可靠性，降低系统的耦合度。</li>
<li>拥抱变化：系统架构设计应该能够适应业务需求的变化和市场的变化，具备快速响应和灵活应变的能力。</li>
<li>系统安全性：系统架构设计应该充分考虑系统的安全性，包括数据安全、应用安全、系统安全等方面，确保系统的安全性和稳定性。</li>
<li>不作不死：系统架构设计应该遵循“最小化变更范围”原则，避免过度设计和复杂度的出现，从而提高系统的可维护性和可扩展性。</li>
</ul>
<h2> 常见的架构设计方案</h2>
<p>之前比较流行的是MVC，MVC有很多的优点，但是缺点也不少：</p>
<ul>
<li>视图与控制器的连接过紧，视图如果不依赖控制器，那么它的应用就会十分有限，这妨碍了他们的独立。</li>
<li>模型对视图数据的访问效率较低，工作量大，并且有一些高级的界面工具或构造器不支持MVC框架。</li>
<li>MVC架构使得我们面向视图开发，但是视图的变化是不可控的，容易受到用户主观的影响。同时复杂系统必然存在纷繁复杂的依赖，依赖不可能存在于视图，最终表现为接口依赖。</li>
</ul>
<p>所以现在比较流行如下几种方案：</p>
<figure><figcaption>img_20.png</figcaption></figure>
<h2> 领域驱动架构</h2>
<p>领域驱动设计是通过将软件实现与核心业务概念的演进紧密相连，从而实现复杂需求的软件开发方法。</p>
<p>领域驱动设计包括三要素：</p>
<ul>
<li>专业知识：就是前期在与客户沟通需求过程中，学习到的关于业务方面的知识。 这类知识并不仅仅只是对需求的理解，更多的要思考业务需求实际要解决的是什么问题。</li>
<li>抽象能力：一般指发现核心业务对象，简化问题空间的能力。</li>
<li>细分问题：把业务问题细化为更小更容易处理的子问题。<br>
领域驱动设计，使得我们不再用数据进行驱动，而是使用领域进行驱动。遇到问题，我们先进行领域上的划分和拆解。这个问题属于哪个问题域，或者需要拆解到哪些问题域里面去，然后再通过领域的组合以及依赖，完成最终问题的解决。</li>
</ul>
<h2> 微服务架构</h2>
<p>微服务架构是一种软件开发架构，它将应用程序拆分成小型、独立的微服务，每个微服务都有自己的功能集，并运行在其独立的进程中。</p>
<p>微服务架构有以下优点：</p>
<ul>
<li>开发人员可以只关注整个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化。</li>
<li>有利于各层逻辑的复用，如PetShop可经过简单的配置实现Sqlserver和Oracle之间的转换。</li>
<li>扩展性强，不同层负责不同的层面，有利于系统的扩展和维护。</li>
<li>安全性高，用户端只能通过逻辑层来访问数据层，减少了入口点，把很多危险的系统功能都屏蔽了。</li>
<li>项目结构更清楚，分工更明确，有利于后期的维护和升级。</li>
</ul>
<h2> 云原生架构</h2>
<figure><figcaption>img_21.png</figcaption></figure>
<p>云原生架构是一种创新的软件开发方法，专为充分利用云计算模型而设计。</p>
<p>云原生架构通过结合使用云计算和各种云服务来创建具有更大可扩展性的可定制模块化基础架构，从而提高了团队的效率，生产力和协作能力。</p>
<p>云原生架构的核心原则：</p>
<ul>
<li>云原生架构是一种设计方法，利用AWS等EC2，S3，Lambda等云服务来支持动态，敏捷的应用程序开发技术，这些技术采用模块化方法通过一套基于云的套件来构建，运行和更新软件微服务与整体应用程序基础架构。</li>
<li>微服务和容器化通过简化云提供商之间的转移或独立地以不同的语言或框架部署服务而没有冲突或停机的情况，从而支持云本机应用程序的敏捷性和动态性。</li>
<li>将微服务架构集成到应用程序开发中可支持协作，效率和生产力，因为DevOps团队能够同时独立处理应用程序的不同组件或实现新功能而又不牺牲稳定性。</li>
</ul>
<h2> DevOps架构</h2>
<figure><figcaption>img_22.png</figcaption></figure>
<p>DevOps架构，它旨在加强软件产品开发与交付过程中的协作、自动化、持续性和监控等方面，以实现更高效、更迅速和更可靠的软件交付。</p>
<p>DevOps通常包括以下核心组成部分：</p>
<ul>
<li>持续集成：将代码频繁地集成到一个共享的代码库中，并对代码进行自动化测试，以确保代码质量和稳定性，并及时发现和解决错误。</li>
<li>持续交付：通过自动化测试、构建、部署和运行环节，实现快速、可靠和可重复的软件发布，从而减少手动操作和人工干预带来的错误和风险。</li>
<li>自动化运维：将基础设施的管理、配置和维护工作自动化，并将其作为代码、脚本或配置文件存储在版本控制系统中，以便快速搭建、复制和修改环境。</li>
<li>容器化技术：使用容器化技术（如Docker）将应用程序和其依赖项打包成独立的、可移植的容器，在不同的环境中快速部署和运行。</li>
<li>监控和日志分析：通过对软件运行时数据进行采集、储存、分析和可视化，监控系统状态、性能和安全等方面的指标，并及时发现和修复问题。</li>
</ul>
<h2> 大数据架构</h2>
<figure><figcaption>img_23.png</figcaption></figure>
<p>大数据架构是一种面向海量数据、高并发、高可靠、高性能的计算和存储系统架构，用于管理和处理大规模的结构化、半结构化和非结构化数据。它具有以下几个特点：</p>
<ul>
<li>高可扩展性：大数据架构应该能够轻松地扩展到海量数据和高并发请求下。</li>
<li>高容错性：大数据架构应该在硬件、网络和软件故障等异常情况下保证系统稳定性。</li>
<li>实时计算：大数据架构需要支持实时计算和流式处理，以满足复杂的业务场景。</li>
<li>数据安全：大数据架构需要保证数据的机密性、完整性和可用性，避免数据泄露和损坏。</li>
<li>成本效益：大数据架构应该充分考虑成本问题，尽可能利用开源技术和云平台来降低系统运维和资源开销。<br>
比如常见的大数据架构包括<code>Hadoop、Spark、Storm、Kafka</code><br>
等开源软件，它们可以被组合在一起形成一个完整的数据处理流水线。例如，Hadoop可以提供分布式文件系统HDFS和MapReduce计算模型，Spark可以提供内存计算和机器学习功能，Storm可以提供实时数据处理功能，Kafka可以提供高可靠的消息队列服务。使用这些开源软件和云平台，企业可以构建出适合自己场景的大数据处理系统，提升自身的业务竞争力。</li>
</ul>
]]></content>
    <category term="设计注意"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">架构原则</title>
    <id>https://ujava.cn/attention/attention2.html</id>
    <link href="https://ujava.cn/attention/attention2.html"/>
    <updated>2024-04-15T07:11:10.000Z</updated>
    <summary type="html"><![CDATA[<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>示例：</p>
<ul>
<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>
<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>
<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<p>架构设计我我们平时写代码不一样，两者的差异主要体现在“不确定性”上。对于编程来说，本质上是确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的；而对于架构设计来说，本质上是不确定，并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>示例：</p>
<ul>
<li>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？</li>
<li>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？</li>
<li>淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</li>
</ul>
<h4> 1.合适原则</h4>
<blockquote>
<p>合适优于业界领先。</p>
</blockquote>
<p>在进行架构设计的同时，需要考虑自身业务，而不是一味的去参照业界顶尖的规模，如：QQ、微信、淘宝架构。真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。</p>
<h4> 2.简单原则</h4>
<blockquote>
<p>简单优于复杂。</p>
</blockquote>
<p>软件架构设计是一门技术活，当我们进行架构设计时，会自然而然地想把架构做精美、做复杂，这样才能体现我们的技术实力，也才能够将架构做成一件艺术品。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>
<p>软件复杂度的体现，主要有以下两个方面：</p>
<p>结构的复杂性<br>
– 组成复杂系统的组件数量更多；<br>
– 组件之间的关系也更加复杂。</p>
<p>其问题主要有：</p>
<ul>
<li>（1）组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li>
<li>（2）某个组件改动，会影响关联的所有组件。</li>
<li>（3）定位一个复杂系统中的问题总是比简单系统更加困难。</li>
</ul>
<h4> 逻辑的复杂性</h4>
<p>逻辑的复杂性来源于一个组件集中了太多的功能，修改协作困难；并且，其中某些业务还可能使用了一些复杂的算法，导致难以理解、修改困难。</p>
<p>一个组件集中了太多功能，就会表现出一些逻辑复杂性的特征，为了解决这个问题，一般的手段是进行组件的拆分，但随着组件的细化，又会引入结构复杂性的一些特征，所以，在做结构设计的时候，需要权衡这两者。</p>
<h4> 3.演化原则</h4>
<blockquote>
<p>演化优于一步到位。</p>
</blockquote>
<p>维基百科对“软件架构”的定义如下：</p>
<blockquote>
<p>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</p>
</blockquote>
<p>这个定义中，将建筑和软件架构做了一个比较，但是，两者之间是有一个本质区别的：对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。<br>
也就是说，软件架构的本质是：软件架构需要根据业务发展不断变化，所以，我们在做软件架构设计的时候，不要试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p>
<p>架构设计的过程基本上可以总结为下面三个历程：</p>
<ul>
<li>首先，设计出来的架构要满足当时的业务需要。</li>
<li>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。--<br>
小重构</li>
<li>最后，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。--<br>
大重构</li>
</ul>
<p>我们在做架构设计的时候，切勿贪大求全，或者盲目的照搬大公司的做法，而是要牢记软件架构的本质（软件架构需要根据业务发展不断变化）。认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>
]]></content>
    <category term="设计注意"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件DevOps</title>
    <id>https://ujava.cn/assembly/devops.html</id>
    <link href="https://ujava.cn/assembly/devops.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1. DevOps</h2>
<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>
<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>
<p>项目管理模式的演变是受项目的规模大小影响的。</p>
<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>
<br>
后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 1. DevOps</h2>
<p>维基百科定义：DevOps是一组过程、方法与系统的统称，用于促进 开发、技术运营 和 质量保障（QA） 部门之间的沟通、协作与整合。我理解DevOps是一种软件管理思维模式。</p>
<p>为什么会有DevOps呢，或者说软件开发领域是怎么样演变出DevOps这个概念的呢？</p>
<p>项目管理模式的演变是受项目的规模大小影响的。</p>
<p>最初阶段，项目软件功能比较简单，工作量不大，程序员一个人可以完成规划、编码、构建、测试、发布、部署和维护所有阶段的工作。<br>
<br>
后来，项目扩大，软件的规模也在逐渐变得庞大，采有传统瀑布流模型。团队里面除了软件开发工程师之外，又有了软件测试工程师，软件运维工程师，各个工种分工合作，一个阶段所有工作完成之后，再进入下一个阶段。</p>
<p><br>
再后来，随着项目的再次扩大，用户对系统的需求不断增加，与此同时，用户给的时间周期却越来越少，时间周期比较长的瀑布流模式不再适用，于是就出现了“敏捷开发”，为的就是小步快跑，持续迭代，快速发现问题，快速解决问题，快速和用户、业主进行确认。<br>
<br>
再然后，在现今这个时代，对变化进行响应的要求越来越高，可以一个项目几天就要迭代上线一版。而从上面的图也可以看到，敏捷开发大幅提升了软件开发的效率和版本更新的速度，但是它的效果仅限于开发环节，运维部署成为瓶颈。运维的核心就是维稳，不出问题，这导致了开发快速迭代的版本很难快速正式上线。</p>
<p>这时候，DevOps这个概念才被提出和关注。从目标来看，DevOps就是让开发人员和运维人员更好地沟通合作，通过自动化流程来使得软件整体过程更加快捷和可靠。而从DevOps概念提出到现在，也不仅仅只是要打通开发和运维的壁垒了，而是扩大到整个项目团队涉及到所有角色，也包括了市场、需求等人员。</p>
<p><br>
DevOps 的三大支柱，即人（People）、流程（Process）和平台（Platform）。</p>
<ul>
<li>DevOps = 人 + 流程 + 平台</li>
<li>人 + 流程 = 文化</li>
<li>流程 + 平台 = 工具</li>
<li>平台 + 人 = 赋能</li>
</ul>
<p>这是这个行业演变过程，也是一个公司从成立，到发展壮大的过程，一个公司的项目管理模式演变过程是整个行业演变过程的缩影，不同阶段有不同阶段的模式，达到一定阶段才有改变的必要，不过我们如果提前有这些了解，提前有所准备，那边在转变的过程中就可以少些弯路和内耗。</p>
<p>DevOps要做就是使用技术工具按照标准化的流程统筹各个阶段的人和人的行为，实现快速交付。它的落地考验的不仅是一家企业的技术，更是管理水平和企业文化，需要一家公司从上到下进行思维转变，并且重新梳理全流程的规范和标准。技术（工具和平台）是最容易实现的，流程次之，思维转变反而最困难。</p>
<p>虽然思维转变是最重要的，但是思维转变没法凭空而来，不可能看一下概念，听一下别人的描述就可以转变过来。只有身处在那样的环境，体会到确切的痛点，如一个公司随着规模的扩大，项目变得复杂，发现按照以前的项目执行方式每次都是亏钱，这样才有可能引发思考，如果这时再体验到相关地技术带来的便利和好处，这样才有可能引发思维的转变。</p>
<p>对于开发人员个人而言，虽然DevOps实施落地中技术和工具是最简单的，但是我们还是要先了解技术和工具，从中体会它与我们日常工作流程的差别，引发思考，同时也为可能用到的时机进行准备积累。</p>
<h2> 2. CI/CD</h2>
<p>DevOps涉及开发的各个阶段，涉及到各个阶段的人，人的思维   转变是最难的，而标准的流程和规范是DevOps的基础，是将各个阶段的人和行为管理起来的根本，平台则是流程自动化的技术工具。其中，CI/CD是DevOps中最能体现流程化的一个阶段，旨在通过技术工具搭建标准自动化流水线过程，减少重复工作的资源浪费。</p>
<p><br>
CI/CD是伴随着DevOps出现的两个词汇，CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。所谓持续就是即时和反复，为的就是及时发现问题，及时响应。</p>
<p><strong>持续集成</strong>：</p>
<p>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起，然后进行自动化测试，并且不会相互影响工作。<br>
</p>
<p><strong>持续交付</strong>：</p>
<p>持续交付是指在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。<br>
</p>
<p><strong>持续部署</strong>：</p>
<p>在持续交付的基础上，把部署到生产环境的过程自动化。如果你对比上图持续部署就可以发现持续部署和持续交付的区别就是最终部署到生产环境是自动化的。<br>
</p>
<p>从上面的几个图可以看出，要实现CI/CD最起码需要一个固定的流程和三个工具。流程需要规定从代码开发到生产环境需要经过哪些阶段，每个阶段需要做什么，如果一个阶段没有达到预期应该怎么做，这个流程不同公司会有所不同，也是每个企业管理方式的体现。最基本的三个工具包括源代码管理工具（SCM）、自动化构建平台，消息通知工具。</p>
<p>平台工具各个公司各有不同，大家日常工作中也各有熟悉的工具，DevOps也不仅仅CI/CD需要平台工具，如项目管理、需求、原型和UI管理都需要工具，这里只是介绍CI/CD过程相关的。</p>
<p>源代码管理工具一般选择 GitLab，也可以用Gitbilit等其他的，这些大家都应该很熟悉，毕竟是日常工作中必不可少要接触的。</p>
<p>自动化构建平台成熟的有很多，GitLab也自带有CI/CD模块可以用，而这里要采有的是开源且发展历史长久，广泛使用和最好的CI/CD工具之一的Jenkins。</p>
<p>消息通知可以用邮件，也可以通知到钉钉等办公软件中。</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件ElasticSearch</title>
    <id>https://ujava.cn/assembly/elasticsearch.html</id>
    <link href="https://ujava.cn/assembly/elasticsearch.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、 简介</h2>
<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<h3> 1.ES优点</h3>
<ul>
<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>
<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 一、 简介</h2>
<p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene™ 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<h3> 1.ES优点</h3>
<ul>
<li>1.支持全文搜索，并基于倒排索引，检索速度特别快</li>
<li>2.高可用性，支持集群部署，任何节点失效系统自动调整。</li>
</ul>
<h3> 2.ES缺点</h3>
<ul>
<li>1.对硬件要求较高，es比较吃内存，需要存储资源来支持大量数据的处理。</li>
<li>2.不支持事务等ACID属性。</li>
</ul>
<h3> 3.ES使用场景</h3>
<p>1.聊天消息</p>
<ul>
<li>数据量大，业务关系简单，会通过关键字搜索聊天信息</li>
<li>非核心业务，不会频繁crud</li>
<li>没有事务的场景，可以不用支持事务</li>
</ul>
<p>2.日志纪录</p>
<p>Elasticsearch 一个典型应用就是 ELK 日志分析系统。如nginx接入请求的访问日志纪录。</p>
<p>3.热点数据搜索</p>
<p>如电商业务的商品搜索等。</p>
<h3> 4.DSL语言高级查询</h3>
<h4> 1.Query DSL概述</h4>
<p>Domain Specific Language 领域专用语言</p>
<ul>
<li>Elasticsearch provides a ful1 Query DSL based on JSON to define queries</li>
<li>Elasticsearch提供了基于JSON的DSL来定义查询。</li>
</ul>
<p>DSL由叶子查询子句和复合查询子句两种子句组成。</p>
<figure><figcaption>img_111.png</figcaption></figure>
<h4> 2.模糊匹配</h4>
<p>模糊匹配主要是针对文本类型的字段，文本类型的字段会对内容进行分词，对查询时，也会对搜索条件进行分词，然后通过倒排索引查找到匹配的数据，模糊匹配主要通过match等参数来实现</p>
<ul>
<li>match : 通过match关键词模糊匹配条件内容</li>
<li>prefix : 前缀匹配</li>
<li>regexp : 通过正则表达式来匹配数据</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.精确匹配</h4>
<ul>
<li>term : 单个条件相等</li>
<li>terms : 单个字段属于某个值数组内的值</li>
<li>range : 字段属于某个范围内的值</li>
<li>exists : 某个字段的值是否存在</li>
<li>ids : 通过ID批量查询</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4.聚合搜索</h4>
<p><strong>1.bucket和metric</strong></p>
<p>bucket就是一个聚合搜索时的数据分组。</p>
<p>如：销售部门有员工张三和李四，开发部门有员工王五和赵六。那么根据部门分组聚合得到结果就是两个bucket。销售部门bucket中有张三和李四，开发部门 bucket中有王五和赵六。</p>
<p>metric就是对一个bucket数据执行的统计分析。如上述案例中，开发部门有2个员工，销售部门有2个员工，这就是metric。</p>
<p>metric有多种统计，如：求和，最大值，最小值，平均值等。</p>
<p>用一个大家容易理解的SQL语法来解释，如：select count() from table group by column。那么group by column分组后的每组数据就是bucket。对每个分组执行的count()就是metric。</p>
<p>es最重要的核心功能是数据检索，统计分析我认为不是es最核心的功能，想这种离线统计应该由其他的替代方案去做，所以如果想了解更多es聚合搜索相关知识可以参考官网或者其他博客</p>
<h3> 5.文档映射</h3>
<p>ES中映射可以分为动态映射和静态映射</p>
<h4> 1.动态映射</h4>
<p>在关系数据库中，需要事先创建数据库，然后在该数据库下创建数据表，并创建表字段、类型、长度、主键等，最后才能基于表插入数据。而Elasticsearch中不需要定义Mapping映射（即关系型数据库的表、字段等），在文档写入Elasticsearch时，会根据文档字段自动识别类型，这种机制称之为动态映射。<br>
动态映射规则如下：</p>
<figure><figcaption>img_112.png</figcaption></figure>
<h4> 2.静态映射</h4>
<p>静态映射是在Elasticsearch中也可以事先定义好映射，包含文档的各字段类型、分词器等，这种方式称之为静态映射。</p>
<h4> 3.核心类型（Core datatype）</h4>
<ul>
<li>字符串：string，string类型包含 text 和 keyword。</li>
<li>text：该类型被用来索引长文本，在创建索引前会将这些文本进行分词，转化为词的组合，建立索引；允许es来检索这些词，text类型不能用来排序和聚合。</li>
<li>keyword：该类型不能分词，可以被用来检索过滤、排序和聚合，keyword类型不可用text进行分词模糊检索。</li>
<li>数值型：long、integer、short、byte、double、float</li>
<li>日期型：date</li>
<li>布尔型：boolean</li>
</ul>
<h4> 4.数据建模</h4>
<p>就是针对于关系型数据库的一对多数据模型，而我自己认为es的主要应用场景是全文搜索引擎，这种复杂的业务关系就应该由关系型数据库如mysql去完成数据建模和存储，而不是交给es去建模存储，当然es也是提供了Parent / Child相关机制继续数据建模，如果有场景使用到，自己去参考对应的官方文档了解即可，但我自己不建议这样做。</p>
<h4> 5.分页查询</h4>
<p>1.语法</p>
<p>在存在大量数据时，一般我们进行查询都需要进行分页查询。例如：我们指定页码、并指定每页显示多少条数据，然后Elasticsearch返回对应页码的数据。</p>
<p>在执行查询时，可以指定from（从第几条数据开始查起）和size（每页返回多少条）数据，就可以轻松完成分页。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.scroll解决深分页问题</p>
<p>前面使用from和size方式，查询在1W条数据以内都是OK的，但如果数据比较多的时候，会出现性能问题。Elasticsearch做了一个限制，不允许查询的是10000条以后的数据。如果要查询1W条以后的数据，需要使用Elasticsearch中提供的scroll游标来查询。</p>
<p>在进行大量分页时，每次分页都需要将要查询的数据进行重新排序，这样非常浪费性能。</p>
<p>使用scroll是将要用的数据一次性排序好，然后分批取出,性能要比from + size好得多。</p>
<p>使用scroll查询后，排序后的数据会保持一定的时间，后续的分页查询都从该快照取数据即可。</p>
<p>第一次使用scroll分页查询</p>
<p>此处，我们让排序的数据保持1分钟，所以设置scroll为1m</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行后，我们注意到，在响应结果中有一项：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后续，我们需要根据这个_scroll_id来进行查询</p>
<p>第二次直接使用scroll id进行查询</p>
<h3> 6.suggest search</h3>
<p>suggest search（completion suggest）：就是建议搜索或称为搜索建议，也可以叫做自动完成-auto completion。类似百度中的搜索联想提示功能。</p>
<p>ES实现suggest的时候，性能非常高，其构建的不是倒排索引，也不是正排索引，就是纯的用于进行前缀搜索的一种特殊的数据结构，而且会全部放在内存中，所以suggest search进行的前缀搜索提示，性能是非常高。</p>
<p>需要使用suggest的时候，必须在定义index时，为其mapping指定开启suggest。</p>
<p>具体如下:</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>suggest 搜索：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二、ES核心原理</h2>
<p>ES存储模型</p>
<p>Elasticsearch与关系数据库结构对应</p>
<figure><figcaption>img_113.png</figcaption></figure>
<p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p>
<h3> 1.索引（Index）</h3>
<p>相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</p>
<p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引<br>
一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字</p>
<h3> 2.文档类型（Type）</h3>
<p>相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</p>
<p>每一个字段都应该有一个对应的类型，例如：Text、Keyword、Byte等</p>
<h3> 3.文档（Document）</h3>
<p>相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；</p>
<p>一个文档是一个可被索引的基础信息单元，类似一条记录。文档以JSON（Javascript Object Notation）格式来表示；</p>
<h3> 4.字段（Field）</h3>
<p>文档的一个Key/Value对；</p>
<ul>
<li>词（Term）：表示文本中的一个单词；</li>
<li>标记（Token）：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li>
</ul>
<p>相当于是数据表的字段|列</p>
<h3> 5.倒排索引</h3>
<p>全文搜索引擎的技术原理被称为“倒排索引”（Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，其基本原理是建立单词到文档的索引。</p>
<p>之所以被称为“倒排”索引，是和“正排“索引相对的，“正排索引”的基本原理是建立文档到单词的索引。我们通过一个简单的样例来说明这两种索引的差异。</p>
<p>假设我们有一个技术文章的网站，里面收集了各种技术文章，用户可以在网站浏览或者搜索文章。</p>
<p>正排索引示例：</p>
<figure><figcaption>img_114.png</figcaption></figure>
<p>（注：文章内容仅为示范，文章内容实际上存储的是几千字的内容。）</p>
<p>正排索引适用于根据文档名称来查询文档内容。例如，用户在网站上单击了“面向对象葵花宝典是什么”，网站根据文章标题查询文章的内容展示给用户。</p>
<p>倒排索引示例：</p>
<figure><figcaption>img_115.png</figcaption></figure>
<p>（注：表格仅为示范，不是完整的倒排索引表格，实际上的倒排索引有成千上万行，因为每个单词就是一个索引。）</p>
<p>倒排索引适用于根据关键词来查询文档内容，它是根据文章内容中的关键字建立索引，而值对应于文档ID，而搜索出来的结果就是文档ID所在行的所有内容。</p>
<p>例如，用户只是想看“设计”相关的文章，网站需要将文章内容中包含“设计”一词的文章都搜索出来展示给用户。</p>
<p>要注意倒排索引的两个重要细节：</p>
<ul>
<li>倒排索引中的所有词项对应一个或多个文档；</li>
<li>倒排索引中的词项根据字典顺序升序排列<br>
Elasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。</li>
</ul>
<h3> 6.分词器</h3>
<p>对于英文来说，分词比较简单，只需要按照单词的空格来进行分词。<br>
如下所示<br>
</p>
<p>如果要搜索hello这个关键词，则匹配的结果将是下面两个内容</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES的默认分词设置是standard，这个在中文分词时就比较尴尬了，会单字拆分，比如我搜索关键词“清华大学”，这时候会按“清”，“华”，“大”，“学”去分词，然后搜出来的都是些“清清的河水”，“中华儿女”，“地大物博”，“学而不思则罔”之类的莫名其妙的结果。</p>
<p>这里我们就想把这个分词方式修改一下，于是呢，就想到了ik分词器，有两种ik_smart和ik_max_word。</p>
<p>ik_smart会将“清华大学”整个分为一个词，而ik_max_word会将“清华大学”分为“清华大学”，“清华”和“大学”，按需选其中之一就可以了。</p>
<p>修改默认分词方法(这里修改school_index索引的默认分词为：ik_max_word)：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分词器工作流程<br>
<br>
分词器由三部分组成：</p>
<ul>
<li>Character Filter：将文本中html标签剔除掉。</li>
<li>Tokenizer：按照规则进行分词，在英文中按照空格分词</li>
<li>Token Filter：将切分的单词进行加工，小写，删除 stopwords(停顿词，a、an、the、is等),增加同义词</li>
</ul>
<p>每个组件的作用，可参考下面的例子</p>
<p>character filter：在一段文本进行分词之前，先进行预处理，比如说最常见的就是，过滤html标签</p>
<p>tokenizer：分词，hello you and me --&gt; hello, you, and, me</p>
<p>token filter：lowercase，stop word，synonymom，liked --&gt; like，Tom --&gt; tom，a/the/an --&gt; 干掉，small --&gt; little</p>
<p>ES内置分词器</p>
<ul>
<li>Standard Analyzer - 默认分词器，按词切分，小写处理</li>
<li>Simple Analyzer - 按照非字母切分(符号被过滤), 小写处理</li>
<li>Stop Analyzer - 小写处理，停用词过滤(the,a,is)</li>
<li>Whitespace Analyzer - 按照空格切分，不转小写</li>
<li>Keyword Analyzer - 不分词，直接将输入当作输出</li>
<li>Patter Analyzer - 正则表达式，默认\W+(非字符分割)</li>
<li>Language - 提供了30多种常见语言的分词器</li>
<li>Customer Analyzer 自定义分词器</li>
</ul>
<p>每个内置分词器的作用，可参考下面的例子</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定制分词器</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定制化自己的分词器</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>IK热更新</p>
<p>每次都是在es的扩展词典中，手动添加新词语，很坑</p>
<p>（1）每次添加完，都要重启es才能生效，非常麻烦</p>
<p>（2）es是分布式的，可能有数百个节点，你不能每次都一个一个节点上面去修改</p>
<p>es不停机，直接我们在外部某个地方添加新的词语，es中立即热加载到这些新词语<br>
IKAnalyzer.cfg.xml</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 7.es评分机制</h3>
<p>当你通过关键字搜索相关文档时，可能会出现多个文档，这些文档的顺序是通过一个max_score属性的大小从高到低顺序展现出来的，max_score属性就是我们所说的评分。</p>
<p>打分算法</p>
<p>relevance score算法，简单来说，就是计算出，一个索引中的文本，与搜索文本，他们之间的关联匹配程度</p>
<p>Elasticsearch使用的是 term frequency/inverse document frequency算法，简称为TF/IDF算法</p>
<p>总公式</p>
<p>max_score = boost * idf * tf</p>
<figure><figcaption>img_118.png</figcaption></figure>
<p>对于查询权重我们可以自己定义</p>
<p>如下面所示：</p>
<figure><figcaption>img_119.png</figcaption></figure>
<p>TF算法</p>
<p>Term frequency：搜索文本中的各个词条在field文本中出现了多少次，出现次数越多，就越相关</p>
<ul>
<li>搜索请求：hello world</li>
<li>doc1：hello you, and world is very good</li>
<li>doc2：hello, how are you</li>
</ul>
<p>doc1这个文档匹配了2个单词，所以doc1的得分要高一些。</p>
<p>2.IDF算法<br>
Inverse document frequency：搜索文本中的各个词条在整个索引的所有文档中出现了多少次，出现的次数越多，就越不相关</p>
<ul>
<li>搜索请求：hello world</li>
<li>doc1：hello, tuling is very good</li>
<li>doc2：hi world, how are you</li>
</ul>
<p>比如说，在index中有1万条document，hello这个单词在所有的document中，一共出现了1000次；world这个单词在所有的document中，一共出现了100次，所以world这个单词得分就更高。</p>
<p>那么匹配world的doc得分就越高,越有可能排在搜索结果前面。</p>
<p>Field-length norm：field长度，field越长，相关度越弱<br>
搜索请求：hello world</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>hello world在整个index中出现的次数是一样多的，那么doc1更相关，title field更短</p>
<p><strong>2.空间向量模型（vector space model）</strong></p>
<p>每个doc vector计算出对query vector的弧度，最后基于这个弧度给出一个doc相对于query中多个term的总分数</p>
<p>弧度越大，分数月底; 弧度越小，分数越高</p>
<p>如果是多个term，那么就是线性代数来计算，无法用图表示</p>
<figure><figcaption>img_120.png</figcaption></figure>
<p>了解即可，掌握对应的打分算法我自己认为就足够了，不用砖牛角尖</p>
<h2> 三、ElasticSearch架构设计</h2>
<p>es集群架构</p>
<p>如下图 ，就是一个三个节点组成的es集群，p0、p1、p2表示一个节点中的分片，R0、R1、R2表示分片对应的副本<br>
<br>
在Elasticsearch主要分成两类节点，一类是Master，一类是DataNode。</p>
<h3> 1.Master节点</h3>
<p>在Elasticsearch启动时，会选举出来一个Master节点。</p>
<p>当某个节点启动后，然后使用Zen Discovery机制找到集群中的其他节点，并建立连接。</p>
<p>discovery.seed_hosts: [“192.168.21.130”, “192.168.21.131”, “192.168.21.132”]</p>
<p>并从候选主节点中选举出一个主节点。</p>
<p>cluster.initial_master_nodes: [“node1”, “node2”,“node3”]</p>
<p>Master节点主要负责</p>
<ul>
<li>管理索引（创建索引、删除索引）、分配分片</li>
<li>维护元数据</li>
<li>管理集群节点状态</li>
<li>不负责数据写入和查询，比较轻量级</li>
</ul>
<p>一个Elasticsearch集群中，只有一个Master节点。在生产环境中，内存可以相对小一点，但机器要稳定。</p>
<h3> 2.DataNode节点</h3>
<p>在Elasticsearch集群中，会有N个DataNode节点。</p>
<p>DataNode节点主要负责：</p>
<p>数据写入、数据检索，</p>
<p>大部分Elasticsearch的压力都在DataNode节点上在生产环境中，内存最好配置大一些</p>
<h3> 3.分片</h3>
<p>Elasticsearch是一个分布式的搜索引擎，索引的数据也是分成若干部分，分布在不同的服务器节点中，分布在不同服务器节点中的索引数据，就是分片（Shard）。</p>
<p>Elasticsearch会自动管理分片，如果发现分片分布不均衡，就会自动迁移一个索引（index）由多个shard（分片）组成，而分片是分布在不同的服务器上的.</p>
<h3> 4.副本</h3>
<p>为了对Elasticsearch的分片进行容错，假设某个节点不可用，会导致整个索引库都将不可用。所以，需要对分片进行副本容错，每一个分片都会有对应的副本。</p>
<p>在Elasticsearch中，默认创建的索引为1个分片、每个分片有1个主分片和1个副本分片。</p>
<p>每个分片都会有一个Primary Shard（主分片），也会有若干个Replica Shard（副本分片）</p>
<p>Primary Shard和Replica Shard不在同一个节点上</p>
<h3> 5.es集群读写流程</h3>
<p>es 写数据流程</p>
<figure><figcaption>img_122.png</figcaption></figure>
<p>1.选择任意一个DataNode发送请求，例如：node2。此时，node2就成为一个coordinating node（协调节点）</p>
<p>2.计算得到文档要写入的分片</p>
<p><code>shard = hash(routing) % number_of_primary_shards</code><br>
routing 是一个可变值，默认是文档的 _id</p>
<p>3.coordinating node会进行路由，将请求转发给对应的primary shard所在的DataNode（假设primary shard在node1、replica shard在node2）</p>
<p>4.node1节点上的Primary Shard处理请求，写入数据到索引库中，并将数据同步到Replica shard</p>
<p>5.Primary Shard和Replica Shard都保存好了文档，返回client</p>
<p>es 读数据流程</p>
<figure><figcaption>img_123.png</figcaption></figure>
<p>1.client发起查询请求，某个DataNode接收到请求，该DataNode就会成为协调节点（Coordinating Node）</p>
<p>2.协调节点（Coordinating Node）将查询请求广播到每一个数据节点，这些数据节点的分片会处理该查询请求</p>
<p>3.每个分片进行数据查询，将符合条件的数据放在一个优先队列中，并将这些数据的文档ID、节点信息、分片信息返回给协调节点</p>
<p>4.协调节点将所有的结果进行汇总，并进行全局排序</p>
<p>5.协调节点向包含这些文档ID的分片发送get请求，对应的分片将文档数据返回给协调节点，最后协调节点将数据返回给客户端</p>
<p>注意：写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p>
<p>自己总结：es的检索流程和mysql数据表查询非主键索引的思路有些相似，先从索引表查询出对应的主键索引值，在进行回表查询具体的行数据。</p>
<p>es删除/更新数据底层原理</p>
<p>如果是删除操作，commit 的时候会生成一个 .del 文件，里面将某个 doc 标识为 deleted 状态，那么搜索的时候根据 .del 文件就知道这个 doc 是否被删除了。</p>
<p>如果是更新操作，就是将原来的 doc 标识为 deleted 状态，然后新写入一条数据。</p>
<p>es 底层写数据原理</p>
<figure><figcaption>img_124.png</figcaption></figure>
<p>简述：先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；然后刷新到os cache中（同时将数据备份到translog日志文件），最后刷新到 segment file磁盘文件中</p>
<p>总结一下，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件作备份（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。最后存入到commit point磁盘文件中。</p>
<p>refresh到文件系统缓存</p>
<p>当数据写入到ES分片时，会首先写入到内存中，然后通过内存的buffer生成一个segment，并刷到文件系统缓存中。</p>
<p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 refresh 到一个新的 segment file中，但是此时数据不是直接进入 segment file 磁盘文件，而是先进入 os cache 。</p>
<p>这个过程就是 refresh 。</p>
<p>只要 buffer 中的数据被 refresh 操作刷入 os cache 中，这个数据就可以被搜索到了。</p>
<p>定时 refresh到文件系统缓存机制</p>
<p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的 segment file ，每秒钟会产生一个新的磁盘文件 segment file ，这个 segment file 中就存储最近 1 秒内 buffer 中写入的数据。<br>
但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p>
<p>segment file合并</p>
<p>buffer 每 refresh 一次，就会产生一个 segment file ，所以默认情况下是 1 秒钟一个 segment file ，这样下来 segment file 会越来越多，此时会定期执行 merge，减少索引查询时IO开销。<br>
每次 merge 的时候，会将多个 segment file 合并成一个，同时这里会将标识为 deleted 的 doc 给物理删除掉（之前执行过的delete的数据），然后将新的 segment file 写入到一个 commit point磁盘 。</p>
<p>知识扩展</p>
<p>操作系统里面，磁盘文件其实都有一个东西，叫做 os cache ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 os cache ，先进入操作系统级别的一个内存缓存中去。</p>
<p>备份到translog磁盘</p>
<p>刷新到translog文件以保障数据不丢失，translog的设计思想和mysql的redo log是相似的。</p>
<p>每隔5s,从os cache 中同步到translog磁盘里面去做备份。</p>
<p>那么translog 日志文件的作用是什么？</p>
<p>你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 translog 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p>
<p>flush到磁盘文件</p>
<p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 buffer 数据写入一个又一个新的 segment file文件系统缓存中去，每次 refresh 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 commit 操作。</p>
<p>数据最终被flush到磁盘文件就完成了数据的最终归宿。</p>
<figure><figcaption>img_125.png</figcaption></figure>
<p>commit操作流程</p>
<p>commit 操作首先就是将 buffer 中现有数据 refresh 到 os cache 中去，清空 buffer。<br>
然后，将一个 commit point 写入磁盘文件，里面标识着这个 commit point 对应的所有 segment file ，同时强行将 os cache 中目前所有的数据都 fsync 到磁盘文件中去。<br>
最后清空 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p>
<p>这个 commit 操作叫做 flush 。</p>
<p>默认 30 分钟自动执行一次 flush ，将文件系统缓存的数据刷入到磁盘。<br>
但如果 translog 过大，也会触发 flush 。</p>
<p>flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p>
<p>es准实时机制</p>
<p>为什么叫 es 是准实时的？</p>
<p>NRT ，全称 near real-time 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。</p>
<p>可以通过 es 的 restful api 或者 java api ，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 os cache 中，让数据立马就可以被搜索到。只要数据被输入 os cache 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p>
<p>es会数据丢失吗？</p>
<p>可能会丢失有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果备份到translog过程中宕机，会导致 5 秒的数据丢失。</p>
<p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。<br>
也可以将 translog 设置成每次写操作必须是直接 fsync 到磁盘，但是性能会差很多。</p>
<p>es集群脑裂</p>
<p>关于集群脑裂的定义请参考我的另一篇博文</p>
<p><a href="https://blog.csdn.net/sinat_34814635/article/details/129914369" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/sinat_34814635/article/details/129914369</a></p>
<p>那么es是如何解决脑裂问题的？</p>
<p>es是直到有足够的master候选节点时，才可以选举出一个master，否则就不要选举出一个master。</p>
<p>这个参数必须被设置为集群中master候选节点的quorum数量，也就是大多数，至于quorum的算法，就是：master候选节点数量 / 2 + 1。</p>
<p>综上所述，一个生产环境的es集群，至少要有3个节点，同时将这个参数设置为quorum，也就是2。discovery.zen.minimum_master_nodes设置为2</p>
<p>那么这个是参数是如何避免脑裂问题的产生的呢？比如我们有3个节点，quorum是2.现在网络故障，1个节点在一个网络区域，另外2个节点在另外一个网络区域，不同的网络区域内无法通信。</p>
<p>这个时候有两种情况情况：</p>
<p>（1）如果master是单独的那个节点，另外2个节点是master候选节点，那么此时那个单独的master节点因为没有指定数量的候选master node在自己当前所在的集群内，因此就会取消当前master的角色，尝试重新选举，但是无法选举成功。然后另外一个网络区域内的node因为无法连接到master，就会发起重新选举，因为有两个master候选节点，满足了quorum，因此可以成功选举出一个master。此时集群中就会还是只有一个master。</p>
<p>（2）如果master和另外一个node在一个网络区域内，然后一个node单独在一个网络区域内。那么此时那个单独的node因为连接不上master，会尝试发起选举，但是因为master候选节点数量不到quorum，因此无法选举出master。而另外一个网络区域内，原先的那个master还会继续工作。这也可以保证集群内只有一个master节点。</p>
<p>综上所述，集群中master节点的数量至少3台，三台主节点通过在elasticsearch.yml中配置discovery.zen.minimum_master_nodes: 2，就可以避免脑裂问题的产生。</p>
<h2> 四、ElasticSearch应用</h2>
<h3> 1.Elasticsearch SQL</h3>
<figure><figcaption>img_126.png</figcaption></figure>
<p>Elasticsearch SQL允许执行类SQL的查询，可以使用REST接口、命令行或者是JDBC，都可以使用SQL来进行数据的检索和数据的聚合。</p>
<p>Elasticsearch SQL特点：</p>
<p>本地集成</p>
<p>Elasticsearch SQL是专门为Elasticsearch构建的。每个SQL查询都根据底层存储对相关节点有效执行。</p>
<p>没有额外的要求</p>
<p>不依赖其他的硬件、进程、运行时库，Elasticsearch SQL可以直接运行在Elasticsearch集群上</p>
<p>轻量且高效</p>
<p>像SQL那样简洁、高效地完成查询</p>
<p>Elasticsearch SQL提供了sql转换的功能，但是只能满足一些简单的查询，例如：不支持JOIN、不支持较复杂的子查询。官方还是推荐使用DSL语句来实现</p>
<h3> 2.Java客户端</h3>
<p>这个就自己看官网吧</p>
<h3> 3.es和mysql的双写</h3>
<p>双写的流程：</p>
<ul>
<li>1.先写数据库，然后写es，es只存常搜索的索引字段。</li>
<li>2.读取时先读es，找到对应主键后，然后根据主键在读mysql。（这种场景主要出现在mysql是分表的，而主键配置的是分片键，非分片键的查询将扫描全表）<br>
首先不建议进行双写，因为会造成数据不一致这样新的问题。造成不一致的原因为写入es或者更新es字段失败，加上补充机制后也没有成功。</li>
</ul>
<p>双写的同步</p>
<p>分页查询mysql中的数据，放入mq中（放入mq中的原因，为读取mysql的线程会远比执行同步的线程速度快），同步线程从mq中拉起数据，然后和es对比，如果不同，与mysql中的数据为准，进行删除复制。</p>
<p>补偿机制</p>
<p>我认为任何对es写失败，更新失败，删除失败都应该纪录下来，然后去手动操作使其同步。</p>
<h2> 五、ElasticSearch安装配置</h2>
<h3> 1.安装ElasticSearch</h3>
<p>解压下载的压缩包，本次使用7.14.0版本</p>
<p>从v7开始，elasticsearch不用单独安装JDK，因为它在下载时会自动下载对应的jdk包。因此不用额外下载jdk和配置环境变量。</p>
<p>在终端cd到elasticsearch的bin目录，运行命令./elasticsearch即可开启es数据库服务（在终端通过按control + c可停止服务）。在网页中访问localhost:9200看到json结果即启动成功。</p>
<p>如下图所示：</p>
<figure><figcaption>img_127.png</figcaption></figure>
<h3> 2.安装Kibana</h3>
<p>下载可视化工具Kibanahttps://www.elastic.co/cn/downloads/kibana</p>
<p>解压下载的压缩包，并将其复制粘贴至自己想要存放的目录。Kibana的版本最好和es保持一致，如这次同样使用7.14.0版本</p>
<p>启动Kibana</p>
<p>在终端cd到Kibana目录下，运行命令./Kibana即可开启Kibana的端口访问。在网页中访问http://localhost:5601跳转到如下界面即访问成功。</p>
<p>访问下面地址：<a href="http://localhost:5601/app/dev_tools#/console" target="_blank" rel="noopener noreferrer">http://localhost:5601/app/dev_tools#/console</a> 可进入管理后台</p>
<figure><figcaption>img_128.png</figcaption></figure>
<p>ElasticSearch可视化工具之cerebro</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Jenkins</title>
    <id>https://ujava.cn/assembly/jenkins.html</id>
    <link href="https://ujava.cn/assembly/jenkins.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1.背景</h2>
<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>这些情况都会涉及到频繁的打包部署；</p>
<p>手动打包常规步骤：</p>
<ul>
<li>1.提交代码</li>
<li>2.问一下同组小伙伴有没有要提交的代码</li>
<li>3.拉取代码并打包（war包，或者jar包）</li>
<li>4.上传到Linux服务器</li>
<li>5.查看当前程序是否在运行</li>
<li>6.关闭当前程序</li>
<li>7.启动新的jar包</li>
<li>8.观察日志看是否启动成功</li>
<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1.背景</h2>
<p>在实际开发中，我们经常要一边开发一边测试，当然这里说的测试并不是程序员对自己代码的单元测试，而是同组程序员将代码提交后，由测试人员测试；</p>
<p>或者前后端分离后，经常会修改接口，然后重新部署；</p>
<p>这些情况都会涉及到频繁的打包部署；</p>
<p>手动打包常规步骤：</p>
<ul>
<li>1.提交代码</li>
<li>2.问一下同组小伙伴有没有要提交的代码</li>
<li>3.拉取代码并打包（war包，或者jar包）</li>
<li>4.上传到Linux服务器</li>
<li>5.查看当前程序是否在运行</li>
<li>6.关闭当前程序</li>
<li>7.启动新的jar包</li>
<li>8.观察日志看是否启动成功</li>
<li>9.如果有同事说，自己还有代码没有提交......再次重复1到8的步骤！！！！！（一上午没了）</li>
</ul>
<p>那么，有一种工具能够实现，将代码提交到git后就自动打包部署勒，答案是肯定的：Jenkins</p>
<p>当然除了Jenkins以外，也还有其他的工具可以实现自动化部署，如Hudson等</p>
<p>只是Jenkins相对来说，使用得更广泛。</p>
<h2> 2.Jenkins服务器搭建及基本配置</h2>
<h3> 2.1.简介</h3>
<p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h3> 2.2.Jenkins自动化部署实现原理</h3>
<figure><figcaption>img_70.png</figcaption></figure>
<h3> 2.3.Jenkins部署环境</h3>
<p>基本环境：</p>
<ul>
<li>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。</li>
<li>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。</li>
<li>3.maven客户端，因一般java程序是由maven工程，需要maven打包，当然也有其他打包方式，如：gradle</li>
</ul>
<p>以上是自动化部署java程序jenkins需要的基本环境，请自己提前安装好，下面着重讲解Jenkins的安装部署配置。</p>
<h3> 2.4.Jenkins安装</h3>
<ul>
<li>1.下载安装包jenkins.war；</li>
<li>2.在安装包根路径下，运行命令 java -jar jenkins.war --httpPort=8080，（linux环境、Windows环境都一样）； 补充:一个童鞋遇到的问题,反馈说,git自动触发时报错403,启动加如下参数可以解决问题 nohup java -jar -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true /usr/local/jenkins/jenkins.war --httpPort=8080 &amp;</li>
<li>3.打开浏览器进入链接 <a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a>.</li>
<li>4.填写初始密码，激活系统</li>
</ul>
<figure><figcaption>img_71.png</figcaption></figure>
<ul>
<li>5.进入插件安装选择</li>
</ul>
<p>这里建议选择，推荐安装的插件，保证基本常用的功能可以使用。</p>
<figure><figcaption>img_72.png</figcaption></figure>
<p>选择后，进入插件安装页面<br>
</p>
<ul>
<li>
<p>6.设置初始用户和密码<br>
</p>
</li>
<li>
<p>7.进入系统，安装完成<br>
</p>
</li>
</ul>
<p>注意，如果还是进入不了系统，需要稍等一下，或者刷新页面，如果还是进入不了，需要重新启动jenkinds服务器。</p>
<h3> 2.5.Jenkins基本配置</h3>
<h4> 2.5.1.系统初始化配置</h4>
<figure><figcaption>img_76.png</figcaption></figure>
<p><strong>1.Configure System (系统设置)</strong></p>
<p>在系统设置这里，我们只需要设置最后面的一项，配置远程服务器地址，</p>
<p>即我们代码最终运行的服务器地址信息，就像我们之前手动部署时使用xshell登录Linux服务器一样，</p>
<p>当然这里是可以配置多台远程Linux服务器的，配置完成后点击保存即可，为后面我们配置自动化部署做准备，配置如下图<br>
</p>
<p><strong>2.Configure Global Security (全局安全配置)</strong></p>
<p>a.配置用户相关的权限</p>
<figure><figcaption>img_78.png</figcaption></figure>
<p>b.配置钩子程序（当用代码更新时通知）访问权限，避免报403错误</p>
<p>默认是勾选上了的，这里去掉勾选</p>
<figure><figcaption>img_79.png</figcaption></figure>
<p><strong>3.Global Tool Configuration (全局工具配置 )</strong></p>
<p>a.配置maven的全局settings路径<br>
</p>
<p>b.配置jdk<br>
</p>
<p>c.配置git</p>
<figure><figcaption>img_82.png</figcaption></figure>
<p>d.配置maven的安装路径</p>
<figure><figcaption>img_83.png</figcaption></figure>
<p><strong>4.配置必要插件</strong></p>
<p>主要是检查如下这两个插件是否已安装</p>
<ul>
<li>插件1：Publish over SSH</li>
<li>插件2：Deploy to container Plugin</li>
</ul>
<figure><figcaption>img_84.png</figcaption></figure>
<p>添加图片注释，不超过 140 字（可选）</p>
<p>到这里，我们配置一个自动化部署的的java程序（springBoot+maven+gitHub），基本必要配置就差不多了，后面配置过程中如果需要在配置。</p>
<h2> 3.Jenkins自动化部署（springBoot+maven+gitHub）项目</h2>
<h3> 3.1.Jenkins服务器上创建项目和配置</h3>
<p>大体步骤：General(基础配置)--》源码管理--》构建触发器--》构建环境--》构建--》构建后操作</p>
<p><strong>1.创建一个工程</strong></p>
<figure><figcaption>img_85.png</figcaption></figure>
<p><strong>2.General(基础配置)</strong></p>
<p>仅需填写标准部分，其他可不填写</p>
<figure><figcaption>img_86.png</figcaption></figure>
<p><strong>3.源码管理</strong><br>
</p>
<p>上图中点击“添加”按钮添加一组账号和密码<br>
</p>
<p><strong>4.构建触发器</strong></p>
<figure><figcaption>img_89.png</figcaption></figure>
<p>如上图：当前项目的回调地址为：</p>
<p><a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>只要执行这个地址（在浏览器上访问改地址），该项目就会发起一次构建项目，即拉取代码打包部署操作，</p>
<p>在实际中，是由git服务器回调改地址，在后面讲git服务器配置时详细讲解 ，</p>
<p>值得注意的是，如果你是学习测试，使用的是GitHub服务，要确保你的回调地址已经试外网映射过的，即往外网可以访问</p>
<p><strong>5.构建环境（无需配置）</strong></p>
<p><strong>6.构建</strong></p>
<figure><figcaption>img_90.png</figcaption></figure>
<p><strong>7.构建后操作</strong></p>
<p>构建后操作的意思是，jar打包好后，要将jar发送到哪里去，发送后去和启动等</p>
<p>这里需要提前在需要部署的服务器上配置好路径，写好启动和停止项目的脚本，并设置为可以执行的脚本，</p>
<p>其实就是我们平时在Linux上手动部署项目操作的脚本<br>
</p>
<p>案例中给出的stop.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>案例中给出的start.sh脚本如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>到此，Jenkinds服务器配置完成，接下来我还有要配置Linux服务器和Git服务器。</p>
<h3> 3.2.Linux服务器配置</h3>
<p>在Liux服务上，上传上文中的两个脚本，用于启动和停止</p>
<figure><figcaption>img_92.png</figcaption></figure>
<h3> 3.3.GitHub服务器配置</h3>
<p>在GitHub服务器上的指定项目里面配置上文中提到的回调地址</p>
<p>特别注意：为了保证回调地址网可以使用，</p>
<p>我已经将地址：<a href="http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2%EF%BC%8C" target="_blank" rel="noopener noreferrer">http://localhost:8080/job/jenkinsSpringBootDemo/build?token=token_demo2，</a></p>
<p>通过花生壳进行外网映射为：<a href="http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2" target="_blank" rel="noopener noreferrer">http://zhishidi.imwork.net/job/jenkinsSpringBootDemo/build?token=token_demo2</a></p>
<p>所以，下面配置的是外网映射地址。</p>
<figure><figcaption>img_93.png</figcaption></figure>
<p>到这里所有配置搞定，只需修改代码，提交到git,然后访问程序看是否生效。</p>
<h2> 4.测试</h2>
<p><strong>1.测试代码</strong><br>
</p>
<p><strong>2.提交代码到git,触发构建</strong></p>
<p><strong>3.在GitHub服务器上去看，是否已经触发</strong><br>
</p>
<p><strong>4.在Jenkins的控制台查看是否，正在构建</strong></p>
<p>从下图中可以看出，正在构建</p>
<figure><figcaption>img_96.png</figcaption></figure>
<p><strong>5.查看当次构建的控制台日志</strong></p>
<figure><figcaption>img_97.png</figcaption></figure>
<p>说明已经启动成功</p>
<p><strong>6.查看Linux服务器，是否上传代码</strong></p>
<figure><figcaption>img_98.png</figcaption></figure>
<p><strong>7.在Linux上使用命令jps，查看是否启动</strong></p>
<figure><figcaption>img_99.png</figcaption></figure>
<p><strong>8.浏览器上访问，看是否能用</strong></p>
<figure><figcaption>img_100.png</figcaption></figure>
<p>说明，已经正常启动可以使用。</p>
<p><strong>9.再次确认是否能自动化部署</strong></p>
<p>修改代码，重新提交代码，循环1到8步查看。</p>
<p>如果测试结果是你预期的，那么自动化部署成功。</p>
<h2> 5.总结&amp;资料下载</h2>
<h3> 5.1.总结</h3>
<p>自动化部署Jenkins，作为一款工具，有着非常强大的功能，</p>
<p>上面我们只是讲了生产上做Java自动化部署的一个主要流程，</p>
<p>其他的功能，大家可以参看官方文档：Jenkins 用户手册</p>
<p>但是，本着学习是为了解决生产的原则，</p>
<p>个人建议，用到Jenkins的什么功能就学什么就可以了，</p>
<p>没必要把Jenkins的所有功能都学完在使用，</p>
<p>就如同我们使用word文档一样，并没有系统的他word文档学完后，在开始使用，而是用到什么功能就学习什么功能！</p>
<h3> 5.2.相关资料</h3>
<ul>
<li>1.案例中的源码地址：<a href="https://github.com/processfactory/demo01.git" target="_blank" rel="noopener noreferrer">https://github.com/processfactory/demo01.git</a></li>
<li>2.官方文档：Jenkins 用户手册</li>
</ul>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件K8S</title>
    <id>https://ujava.cn/assembly/k8s.html</id>
    <link href="https://ujava.cn/assembly/k8s.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 一、K8S简介</h2>
<p>Kubernetes中文官网：<a href="https://kubernetes.io/zh/" target="_blank" rel="noopener noreferrer">Kubernetes</a></p>
<p>GitHub：<a href="http://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreferrer">github.com/kubernetes/kubernetes</a></p>
<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 一、K8S简介</h2>
<p>Kubernetes中文官网：<a href="https://kubernetes.io/zh/" target="_blank" rel="noopener noreferrer">Kubernetes</a></p>
<p>GitHub：<a href="http://github.com/kubernetes/kubernetes" target="_blank" rel="noopener noreferrer">github.com/kubernetes/kubernetes</a></p>
<p>Kubernetes简称为K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统，起源于Google 集群管理工具Borg。</p>
<p>Kubernetes集群组件逻辑图<br>
</p>
<p>k8s集群属于Master-Slave主从架构，Master节点负责集群管理和资源调度，用于运行控制平面组件(Control Plane Components)，Slave节点就是工作负载节点，一般称为Node节点，也叫Worker节点，主要负责运行Pod，一个Pod里可以同时运行多个容器，而容器一般封装的就是基于Dokcer打包的应用，Pod英文叫豌豆荚，每个容器就像是一颗豌豆，简单来说Pod就是一组容器。</p>
<p>Master节点组件及功能<br>
</p>
<p>Slave节点组件及功能<br>
</p>
<p>安装部署</p>
<p>生产环境部署k8s主要有两种方式：</p>
<p>二进制包</p>
<p>Github下载稳定版的二进制包，手动部署每个组件组成k8s集群。</p>
<p>kubeadm工具</p>
<p>使用Kubeadm工具可以快速搭建一个k8s集群，主要包括初始化控制平面节点和加入Worker节点，提供的主要功能如下：</p>
<ul>
<li>kubeadm init：初始化一个Master节点</li>
<li>kubeadm join：将Worker节点加入集群</li>
<li>kubeadm upgrade：升级K8s版本</li>
<li>kubeadm token：管理 kubeadm join 使用的令牌</li>
<li>kubeadm reset：清空 kubeadm init 或者 kubeadm join 对主机所做的任何更改</li>
<li>kubeadm version：打印 kubeadm 版本</li>
<li>kubeadm alpha：预览可用的新功能</li>
</ul>
<h2> 二、准备工作</h2>
<p>软硬件要求</p>
<ul>
<li>Linux操作系统，Ubuntu 或 CentOS</li>
<li>每台节点至少2G</li>
<li>Master节点至少2C</li>
<li>集群节点网络互通</li>
</ul>
<p>集群规划</p>
<figure><figcaption>img_104.png</figcaption></figure>
<p>环境配置</p>
<p>修改hosts配置</p>
<p>配置所有节点的IP和域名映射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置SSH免密登录</p>
<p>先生成公钥对，再把公钥远程复制到所有节点。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关闭Swap分区</p>
<p>kubelet要求必须禁用交换分区，所以kubeadm初始化时回检测swap是否关闭，如果没有关闭会报错，如果不想关闭安装时命令行可以指定-ignore-preflight-errors=Swap，关闭Swap分区在所有节点上执行如下命令:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>禁用SELinux</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>关闭防火墙</p>
<p>所有节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改内核参数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置集群时钟同步</p>
<p>Centos7默认使用Chrony工具而非NTP进行时间同步，修改硬件时钟为UTC，时区为本地时区，所有节点执行如下修改：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置k8s的Yum源</p>
<p>国外yum源因为网络问题下载比较慢，此处修改为国内aliyun，用于安装k8s各个组件。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 三、安装Docker</h2>
<p>k8s运行需要容器运行环境，每个节点都需要安装Docker</p>
<h2> 四、安装K8S集群</h2>
<p>安装三大组件-kubeadm、kubelet、kubectl</p>
<ul>
<li>kubeadm：用来初始化k8s集群的指令。</li>
<li>kubelet：在集群的每个节点上用来启动 Pod 和容器等。</li>
<li>kubectl：用来与k8s集群通信的命令行工具，查看、创建、更新和删除各种资源。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化k8s集群</p>
<ul>
<li>apiserver-advertise-address：apiserver监听地址</li>
<li>control-plane-endpoint：控制平面的IP地址或DNS名称</li>
<li>image-repository：镜像仓库，此处为国内阿里云镜像仓库加速下载</li>
<li>service-cidr：为Service分配的IP地址段</li>
<li>pod-network-cidr：为pod分配的IP地址段</li>
</ul>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化需要下载多个镜像，可能时间比较久，最终安装的镜像如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>成功界面：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要使非root用户运行kubectl，请执行以下命令，这也是上面kubeadm init输出的一部分：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果是root用户，则可以执行以下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>记住上面输出的kubeadm join命令，下面用该命令将节点加入集群。</p>
<p>加入节点</p>
<p>所有Node节点执行如下命令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看token列表，可观察到每个token的剩余有效时间</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认token有效期为24小时，过期之后token失效，可重新生成token：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改角色：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装网络插件</p>
<p>Calico是一套开源的纯三层的虚拟化网络解决方案，是目前K8s主流的网络方案。它把每个节点都作为一个虚拟路由器，把Pod当做路由器上一个终端设备为其分配一个IP地址，通过BGP协议生成路由规则，实现不同节点上的Pod网络互通。<br>
</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、测试K8S集群</h2>
<p>创建nginx pod</p>
<p>默认会在默认命名空间default中创建一个名称为mynignx的deployment，同时会创建一个名称以myniginx为前缀，叫mynginx-5b686ccd46-wshz6的Pod。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对外暴露访问</p>
<p>基于第一步创建的deployment再创建一个名叫mynginx的Service，资源类型由--type=ClusterIP修改为--type=NodePort，会在每个Node节点上监听30161端口，用于接收集群外部访问。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问nginx</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><figcaption>img_106.png</figcaption></figure>
<h2> 六、安装Dashboard</h2>
<p>k8s官方提供了一个简单的Dashboard，主要提供工作负载，服务，配置和存储，集群等管理功能。</p>
<p>Github：<a href="http://github.com/kubernetes/dashboard" target="_blank" rel="noopener noreferrer">github.com/kubernetes/dashboard</a></p>
<p>通过kubectl命令安装</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对外暴露访问端口，由--type=ClusterIP修改为--type=NodePort</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看service</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器输入访问地址：<a href="https://192.168.5.10:31128/%EF%BC%8C%E9%9C%80%E8%A6%81token%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E3%80%82" target="_blank" rel="noopener noreferrer">https://192.168.5.10:31128/，需要token才能访问。</a></p>
<figure><figcaption>img_107.png</figcaption></figure>
<p>创建访问账号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取token</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>登录界面</p>
<p>输入上面的token，进入dashboard首页</p>
<figure><figcaption>img_108.png</figcaption></figure>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Mock</title>
    <id>https://ujava.cn/assembly/mock.html</id>
    <link href="https://ujava.cn/assembly/mock.html"/>
    <updated>2024-04-15T03:25:51.000Z</updated>
    <summary type="html"><![CDATA[<h2> 简介</h2>
<p>通过Mock方式，测试编写的程序</p>
<p>通用类定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> <span class="token class-name">Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringJUnit4ClassRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BaseTest</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@BeforeClass</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<h2> 简介</h2>
<p>通过Mock方式，测试编写的程序</p>
<p>通用类定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式一（直接操作库表）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式二（启动容器）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 方式三（不启动容器）</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mock静态数据</h2>
<p>在实际工作当中，我们经常会遇到需要对静态方法进行 mock 的情况。在 mockito 2.x 的时代，我们需要借助 powmock 才能实现。当<br>
mockito 进化到了 3.4.0 版本以后，也开始对静态方法 mock 进行了支持（主要是通过 mockito-inline 包）。</p>
<p>简单的介绍就到这里，下面让我们进入主题吧。</p>
<p>首先确保 pom 文件中 mockito 相关 jar 包的版本（这里我用的版本是 3.7.7），如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方式</p>
<p>Mockito.mockStatic(Class mockClass)，如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样基本上就 OK 了。唯一需要注意下的就是 httpClient.close()。</p>
<p>如果项目中未引入 mockito-inline，会出现如下错误信息：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>错误提示 static mocking is already registered in the current thread To create a new mock, the existing static mock<br>
registration must be deregistered</p>
<p>当多个单元测试都使用了同一个 static mock 对象，且使用完成后都没有进行 close。此时，若这几个单元测试用一起执行，第一个单元测试占用了<br>
static mock 对象，第二个单元测试就没有办法再占用了。</p>
<p>如果出现了这种情况，解决办法也很简单，就是关闭 static mock 对象，如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你的很多单元测试中都用到了 mockStatic(HTTPClient.class)，且觉得在每个单元测试当中都写一遍 mockStatic()…close()<br>
很低效，可以采用下边的方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Mock缓存数据</h2>
<p>在Mockito中，你可以使用Mockito.when配合相应的调用记录方法来模拟缓存场景。以下是一个简单的例子，展示了如何使用Mockito来模拟一个缓存方法的行为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们首先通过ConcurrentHashMap模拟了一个简单的缓存。然后我们使用Mockito.spy创建了一个被测试方法所在类的模拟实例。通过Mockito.doReturn我们配置了当调用getFromCache方法并传递特定的key时，模拟方法返回预先定义的值。最后，我们使用Mockito.verify来验证缓存访问方法是否被调用了。这个例子展示了如何使用Mockito来模拟和验证缓存相关的行为。</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件Reactor</title>
    <id>https://ujava.cn/assembly/reactor.html</id>
    <link href="https://ujava.cn/assembly/reactor.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<h2> 前言</h2>
<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>
<h2> 一、经典的同步阻塞模型</h2>
<figure><figcaption>img_46.png</figcaption></figure>
<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>]]></summary>
    <content type="html"><![CDATA[<h2> 前言</h2>
<p>说到NIO、Netty，Reactor模型一定是绕不开的，因为这种模式架构太经典了，但是好多人在学习的时候，往往会忽视基础的学习，一上来就是Netty，各种高大上，但是却没有静下心来好好看看Netty的基石——Reactor模型。本文就带着大家看看Reactor模型，让大家对Reactor模型有个浅显而又感性的认识。</p>
<h2> 一、经典的同步阻塞模型</h2>
<figure><figcaption>img_46.png</figcaption></figure>
<p>这是最为传统的Socket服务设计，有多个客户端连接服务端，服务端会开启很多线程，一个线程为一个客户端服务。</p>
<p>在绝大多数场景下，处理一个网络请求有如下几个步骤：</p>
<ul>
<li>read：从socket读取数据。</li>
<li>decode：解码，因为网络上的数据都是以byte的形式进行传输的，要想获取真正的请求，必定需要解码。</li>
<li>compute：计算，也就是业务处理，你想干啥就干啥。</li>
<li>encode：编码，同理，因为网络上的数据都是以byte的形式进行传输的，也就是socket只接收byte，所以必定需要编码。<br>
1.下面看传统的BIO代码：</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个设计的问题就是：需要开启大量的线程。因为一个客户端独占一个线程</p>
<p>我们的目标是：</p>
<ul>
<li>随着负载的增加可以优雅降级；</li>
<li>能够随着资源的改进，性能可以持续提升；</li>
<li>同时还要满足可用性和性能指标：</li>
<li>低延迟</li>
<li>满足高峰需求</li>
<li>可调节的服务质量</li>
</ul>
<p>阻塞 （针对的是被调用方）</p>
<p>不管是等待客户端的连接，还是等待客户的数据，都是阻塞的，一夫当关，万夫莫开，不管你什么时候连接我，不管你什么时候给我数据，我都依然等着你。<br>
让我们试想下：如果accept()、read()这两个方法都是不阻塞的，是不是传统的Socket问题就解决一半了？</p>
<p>同步 （针对的是调用方）</p>
<p>服务端是死死的盯着客户端，看客户端有没有连接我，有没有给我发数据。<br>
如果我可以喝着茶，打着农药，而你发了数据，连接了我，系统通知我一下，我再去处理，那该多好，这样传统的Socket问题又解决了一半。</p>
<p>NIO就很好的解决了传统Socket问题：</p>
<ul>
<li>一个线程可以监听多个Socket，不再是一夫当关，万夫莫开；</li>
<li>基于事件驱动：等发生了各种事件，系统可以通知我，我再去处理。</li>
</ul>
<p>2.client端代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.因此，我们要引出我们今日的主角: reactor</p>
<h2> 二、单reactor单线程设计</h2>
<figure><figcaption>img_47.png</figcaption></figure>
<p>这是最简单的Reactor模型，可以看到有多个客户端连接到Reactor，Reactor内部有一个dispatch（分发器）。</p>
<p>有连接请求后，Reactor会通过dispatch把请求交给Acceptor进行处理，有IO读写事件之后，又会通过dispatch交给具体的Handler进行处理。</p>
<p>此时一个Reactor既然负责处理连接请求，又要负责处理读写请求，一般来说处理连接请求是很快的，但是处理具体的读写请求就要涉及到业务逻辑处理了，相对慢太多了。Reactor正在处理读写请求的时候，其他请求只能等着，只有等处理完了，才可以处理下一个请求。</p>
<p>单线程Reactor模型编程简单，比较适用于每个请求都可以快速完成的场景，但是不能发挥出多核CPU的优势，在一般情况下，不会使用单Reactor单线程模型。</p>
<p>代码示例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义了一个Reactor类。</p>
<p>在构造方法中，注册了连接事件，并且在selectionKey对象附加了一个Acceptor对象，这是用来处理连接请求的类。</p>
<p>Reactor类实现了Runnable接口，并且实现了run方法，在run方法中，<br>
监听各种事件，有了事件后，调用dispatcher方法，在dispatcher方法中，拿到了selectionKey附加的对象，随后调用run方法，注意此时是调用run方法，并没有开启线程，只是一个普通的调用而已。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>目前如果有事件发生，那一定是连接事件，因为在Reactor类的构造方法中只注册了连接事件，还没有注册读写事件。</p>
<p>发生了连接事件后，Reactor类的dispatcher方法拿到了Acceptor附加对象，调用了Acceptor的run方法，在run方法中又注册了读事件，然后在selectionKey附加了一个WorkHandler对象。</p>
<p>Acceptor的run方法执行完毕后，就会继续回到Reactor类中的run方法，负责监听事件。</p>
<p>此时，Reactor监听了两个事件，一个是连接事件，一个是读事件。</p>
<p>当客户端写事件发生后，Reactor又会调用dispatcher方法，此时拿到的附加对象是WorkHandler，所以又跑到了WorkHandler中的run方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WorkHandler就是真正负责处理客户端写事件的了。</p>
<p>下面我们可以进行测试了：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道了单Reactor单线程模型有那么多缺点，就可以有针对性的去解决了。让我们再回顾下单Reactor单线程模型有什么缺点：<strong>在处理一个客户端的请求的时候，其他请求只能等着。</strong><br>
那么我们只要+上多线程的概念不就可以了吗？没错，这就是单Reactor多线程模型。</p>
<h2> 三、单reactor多线程设计</h2>
<figure><figcaption>img_48.png</figcaption></figure>
<p>可以看到，Reactor还是既要负责处理连接事件，又要负责处理客户端的写事件，不同的是，多了一个线程池的概念。</p>
<p>当客户端发起连接请求后，Reactor会把任务交给acceptor处理，如果客户端发起了写请求，Reactor会把任务交给线程池进行处理，这样一个服务端就可以同时为N个客户端服务了。</p>
<p>让我们继续敲敲键盘，实现一个单Reactor多线程模型把：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看测试结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到acceptor、workHandler还是主线程，但是到了process就开启多线程了。</p>
<p>单Reactor多线程模型看起来是很不错了，但是还是有缺点：一个Reactor还是既然负责连接请求，又要负责读写请求，连接请求是很快的，而且一个客户端一般只要连接一次就可以了，但是会发生很多次写请求，如果可以有多个Reactor，其中一个Reactor负责处理连接事件，多个Reactor负责处理客户端的写事件就好了，这样更符合单一职责，所以主从Reactor模型诞生了。</p>
<h2> 四、多reactor多线程设计</h2>
<figure><figcaption>img_49.png</figcaption></figure>
<p>这就是主从Reactor模型了，可以看到mainReactor只负责连接请求，而subReactor<br>
只负责处理客户端的写事件。</p>
<p>下面来实现一个主从Reactor模型，需要注意的是，我实现的主从Reactor模型和图片上有区别。图片上是一主一从，而我实现的是一主八从，图片上一个subReactor下面开了一个线程池，而我实现的subReactor之下没有线程池，虽然有所不同，但是核心思路是一样的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很清楚的看到，从始至终，acceptor都只有一个main线程，而负责处理客户端写请求的是不同的线程，而且还是不同的reactor、selector。</p>
<h2> 五、Reactor模型结构图</h2>
<figure><figcaption>img_50.png</figcaption></figure>
<ul>
<li>Synchronous Event Demultiplexer：同步事件分离器，用于监听各种事件，调用方调用监听方法的时候会被阻塞，直到有事件发生，才会返回。对于Linux来说，同步事件分离器指的就是IO多路复用模型，比如epoll，poll 等， 对于Java NIO来说， 同步事件分离器对应的组件就是selector，对应的阻塞方法就是select。</li>
<li>Handler：本质上是文件描述符，是一个抽象的概念，可以简单的理解为一个一个事件，该事件可以来自于外部，比如客户端连接事件，客户端的写事件等等，也可以是内部的事件，比如操作系统产生的定时器事件等等。</li>
<li>Event Handler：事件处理器，本质上是回调方法，当有事件发生后，框架会根据Handler调用对应的回调方法，在大多数情况下，是虚函数，需要用户自己实现接口，实现具体的方法。</li>
<li>Concrete Event Handler： 具体的事件处理器，是Event Handler的具体实现。</li>
<li>Initiation Dispatcher：初始分发器，实际上就是Reactor角色，提供了一系列方法，对Event Handler进行注册和移除；还会调用Synchronous Event Demultiplexer监听各种事件；当有事件发生后，还要调用对应的Event Handler。</li>
</ul>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件SpringCloud</title>
    <id>https://ujava.cn/assembly/springcloud.html</id>
    <link href="https://ujava.cn/assembly/springcloud.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>
<h2> 一、SpringCloud概述</h2>
<p>SpringCloud：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud官网</a></p>]]></summary>
    <content type="html"><![CDATA[<p>SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。</p>
<h2> 一、SpringCloud概述</h2>
<p>SpringCloud：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener noreferrer">SpringCloud官网</a></p>
<p>SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。</p>
<h2> 二、Spring Cloud 和 Dubbo 对比</h2>
<p>Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。<br>
Spring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。<br>
Dubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。<br>
下面是Spring Cloud和Dubbo的一些比较：<br>
</p>
<p>总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。</p>
<p>需要根据具体的业务需求来选择合适的微服务框架。</p>
<h2> 三、Spring Cloud 优缺点</h2>
<p>其主要优点有：</p>
<ul>
<li>
<p>集大成者，Spring Cloud 包含了微服务架构的方方面面。</p>
</li>
<li>
<p>约定优于配置，基于注解，没有配置文件。</p>
</li>
<li>
<p>轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。</p>
</li>
<li>
<p>开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。</p>
</li>
<li>
<p>开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。<br>
接下来，我们看下它的缺点：</p>
</li>
<li>
<p>项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。</p>
</li>
<li>
<p>部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。<br>
Spring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p>
</li>
</ul>
<h2> 四、SpringCloud组件</h2>
<h3> 1、Eureka</h3>
<p>Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、Feign</h3>
<p>Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、Ribbon</h3>
<p>Ribbon是一个负载均衡组件，它能够帮助我们将请求分配到不同的微服务中，从而实现负载均衡的目的。下面是一个简单的Ribbon负载均衡示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、Hystrix</h3>
<p>Hystrix是一个熔断器组件，在微服务架构中，一些服务可能出现故障或者超时，Hystrix能够帮助我们实现服务的熔断、降级等操作，从而保证服务的稳定性和可用性。下面是一个简单的Hystrix熔断器示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、Config</h3>
<p>Config是SpringCloud提供的配置中心，它能够将各个微服务的配置信息集中管理，并且能够进行动态刷新。下面是一个简单的Config配置中心示例：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 五、SpringCloud应用场景</h2>
<h3> 1、微服务架构</h3>
<p>SpringCloud提供了一系列的组件和工具，能够帮助我们实现微服务架构，从而将一个大型的应用系统拆分为多个小的服务单元，各个服务之间可以独立开发、部署、运行，从而提高开发效率和应用性能。</p>
<h3> 2、分布式配置中心</h3>
<p>Config组件能够将各个微服务的配置信息集中管理，这样一方面可以统一管理配置，同时也可以快速进行配置变更并将变更信息更新到各个微服务中，大大提高了系统的可维护性和可扩展性。</p>
<h3> 3、服务调用和负载均衡</h3>
<p>Ribbon和Feign组件能够帮助我们实现服务调用和负载均衡等操作，使得我们可以在不同的微服务之间进行数据交互和调用，从而实现整个系统的功能。</p>
<h3> 4、高可用和容错机制</h3>
<p>Hystrix组件能够帮助我们实现服务的熔断和降级等操作，从而实现系统的自愈能力，同时也可以增强系统的容错能力和高可用性，保证系统的稳定性和可用性。</p>
<h2> 六、结语</h2>
<p>本文详细介绍了SpringCloud的概述、主要组件和应用场景，并提供了相应的代码示例，希望能够帮助读者更好地理解和掌握SpringCloud的实际开发应用。在分布式系统的开发中，SpringCloud作为一个强大的分布式框架，为我们提供了不少有力的工具和支持，能够使得我们更加高效地开发分布式应用，提高开发效率和应用性能。</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">组件WebFlux</title>
    <id>https://ujava.cn/assembly/webflux.html</id>
    <link href="https://ujava.cn/assembly/webflux.html"/>
    <updated>2024-04-15T03:42:50.000Z</updated>
    <summary type="html"><![CDATA[<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>
<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>
<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>
<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>]]></summary>
    <content type="html"><![CDATA[<p>因为想学习 Spring Cloud Gateway 来着，然后发现它是基于 Spring5.0+SpringBoot2.0+WebFlux等技术开发的。所以学之前才要来简单了解下 WebFlux 技术。</p>
<p>然后要学习 WebFlux 时我发现又需要 Java 8 中的函数式编程、Stream 流等技术作为前置知识。环环相扣啊，套娃一样。</p>
<p>所以前面还有两篇学习的文章：来系统学习下 lambda 表达式吧和来一起学习下 Java 8 的 Stream 流。</p>
<p>我只是想学下 Spring Cloud Gateway 而已，作为前置知识，WebFlux 我暂时也不打算深深的研究了，就先简单学习下吧。</p>
<p>话说这么多，开始今天的学习吧。</p>
<h2> 什么是 WebFlux</h2>
<p>Spring Framework 中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器构建的。反应式堆栈 Web 框架 Spring WebFlux 是在 5.0 版的后期添加的。它是完全非阻塞的，支持反应式流(Reactive Stream)背压，并在Netty，Undertow和Servlet 3.1 +容器等服务器上运行。</p>
<figure><figcaption>img_51.png</figcaption></figure>
<p>上面的文字和图片都是来自官网的。从中我们可以大概知道 Spring WebFlux 是对标 Spring MVC 的。</p>
<p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问。底层使用的是 Netty 容器，这点也和传统的 SpringMVC 不一样，SpringMVC 是基于 Servlet 的。</p>
<p>接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</p>
<h2> 反应式库</h2>
<h3> 1. Reactive Stream</h3>
<p>相信你应该注意到上面的一个名词 反应式流(Reactive Stream)。是什么意思呐？</p>
<p>我们先看下这个概念：</p>
<p>反应式编程（Reactive Programming） ，这是微软为了应对 高并发环境下 的服务端编程，提出的一个实现 异步编程 的方案。</p>
<p>反应式流（Reactive Stream） 就是反应式编程相关的规范，在 Java 平台上，由Netflix（开发了 RxJava）、TypeSafe（开发了 Scala、Akka）、Pivatol（开发了 Spring、Reactor）共同制定。</p>
<p>它由以下几个组件组成：</p>
<ul>
<li>发布者：发布元素到订阅者</li>
<li>订阅者：消费元素</li>
<li>订阅：在发布者中，订阅被创建时，将与订阅者共享</li>
<li>处理器：发布者与订阅者之间处理数据</li>
</ul>
<h3> 2. Reactor</h3>
<p>Reactive Stream 是一套反应式编程的规范，但作为应用程序 API，应用程序肯定还是需要一个更高级、更丰富的功能 API 来编写异步逻辑。这就是 反应式库 所扮演的角色。</p>
<p>Reactor 框架是 Pivotal 基于 Reactive Programming 思想实现的。它符合 Reactive Streams 规范。它提供了Mono和Flux API 类型，通过一组与 ReactiveX 运算符词汇表一致的丰富运算符来处理 0…1 （） 和 0…N （）的数据序列。是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”。<br>
Reactor 就是 Spring WebFlux 的首选 反应式库。</p>
<p>在上面的概念中，大家最重要是要记住 Flux 和 Mono 这两个 Reactor 的核心类：</p>
<ul>
<li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li>
<li>Flux：实现发布者 Publisher，并返回 N 个元素。<br>
两个都是发布者 Publisher。</li>
</ul>
<h3> 3. Reactive Stream、Reactor 和 WebFlux 关系</h3>
<p>上面概念性的东西可能看起来有些头疼，说了这么多，Reactive Stream、Reactor 和 WebFlux 三者之间到底是什么关系呐？</p>
<ul>
<li>Reactive Stream 是一套反应式编程 标准 和 规范；</li>
<li>Reactor 是基于 Reactive Streams 一套 反应式编程框架；</li>
<li>WebFlux 以 Reactor 为基础，实现 Web 领域的 反应式编程框架。</li>
</ul>
<p>代码初体验</p>
<p>上面说了那么多的概念，终于到了代码环节了，就先来简单的体验下代码是什么样子的吧。</p>
<p>首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖:<br>
</p>
<ol>
<li>Mono</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动项目，浏览器访问这个<code> /hello</code> 接口，控制台输出如下：</p>
<ul>
<li>接口耗时：0</li>
<li>可以看到：在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li>
</ul>
<ol start="2">
<li>Flux</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Flux 也是一个 Publisher，它可以由一个数组产生，需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即<code> text/event-stream</code>。 <code>text/event-stream</code> 是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别。暂时先不写了。</p>
<h2> 操作数据库</h2>
<p>Spring Boot 2.3.0.RELEASE 开始才正式支持基于 R2DBC 的 MySQL 驱动。</p>
<p>R2DBC：R2DBC 是 Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，现在 MySQL也加入进来了。</p>
<p>今天就学习一下基于 R2DBC 来操作 MySQL 数据库。</p>
<h3> 1. 创建项目</h3>
<p>选择这几个依赖，创建新的 project:</p>
<figure><figcaption>img_53.png</figcaption></figure>
<p>pom.xml 文件里是这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后是 application.properties:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2. 创建数据库表</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建一个简单的 test_user 表。</p>
<h3> 3. 创建相关类</h3>
<p>实体类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserRepository，就相当于 DAO</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>UserController 控制器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大功告成，接下来就该启动项目，测试一下了。</p>
<h3> 4. 启动测试</h3>
<p>项目启动之后，我们使用 Postman 测试一下。</p>
<h3> 请求地址路由</h3>
<p>还使用上一步的数据库表和实体类，但这次我们不用 UserController，而是换成了 UserHandler 和 RouterConfiguration。</p>
<p>创建 Userhandler.java</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>创建 RouterConfiguration</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理。</li>
<li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li>
<li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li>
<li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li>
<li>通过 addRoute 方法可以配置多个路由策略。<br>
测试</li>
</ul>
<p>修改：</p>
<p>查询和前面一样：</p>
<h3> 适用性</h3>
<p>官网上是这样建议的：</p>
<ul>
<li>如果原先使用用SpringMVC好好的话，则没必要迁移。因为命令式编程是编写、理解和调试代码的最简单方法。因为老项目的类库与代码都是基于阻塞式的。</li>
<li>如果你的团队打算使用非阻塞式web框架，WebFlux确实是一个可考虑的技术路线，而且它支持类似于SpringMvc的Annotation的方式实现编程模式，也可以在微服务架构中让WebMvc与WebFlux共用Controller，切换使用的成本相当小。</li>
<li>在SpringMVC项目里如果需要调用远程服务的话，你不妨考虑一下使用WebClient，而且方法的返回值可以考虑使用Reactive Type类型的，当每个调用的延迟时间越长，或者调用之间的相互依赖程度越高，其好处就越大。</li>
<li>在微服务架构中，您可以混合使用Spring MVC或Spring WebFlux控制器或Spring WebFlux功能端点的应用程序。在两个框架中支持相同的基于注释的编程模型，可以更轻松地重用知识，同时为正确的工作选择正确的工具。</li>
</ul>
<p>Spring WebFlux 并不是让你的程序运行的更快(相对于SpringMVC来说)，而是在有限的资源下提高系统的伸缩性，因此当你对响应式编程非常熟练的情况下并将其应用于新的系统中，还是值得考虑的，否则还是老老实实的使用WebMVC。</p>
]]></content>
    <category term="设计组件"/>
    <published>2024-04-15T03:25:51.000Z</published>
  </entry>
  <entry>
    <title type="text">反应器(Reactor)模式</title>
    <id>https://ujava.cn/design/other/reactor.html</id>
    <link href="https://ujava.cn/design/other/reactor.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Reactor设计模式处理由一个或多个客户端并发传递到应用程序的服务请求。应用程序可以注册特定的处理程序以进行处理，这些处理程序由reactor在特定事件上调用。事件处理程序的调度由初始化调度器执行，该调度器管理已注册的事件处理程序。服务请求的多路分解由同步事件多路分解器执行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">读写锁模式</title>
    <id>https://ujava.cn/design/other/readerwriterlock.html</id>
    <link href="https://ujava.cn/design/other/readerwriterlock.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>
由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>
众所周知，读写器锁的存在解决了这个问题<br>
“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>
并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>
正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当访问数据结构模式时，常规锁不会区分“读锁”和“写锁”<br>
由许多读取数据的线程组成，每个线程都必须锁定数据，这会产生不必要的序列化。<br>
众所周知，读写器锁的存在解决了这个问题<br>
“多个并发读卡器，单个写入器锁”，用于由多个线程同时读取数据组成<br>
并且只允许一个线程写入或修改数据。所有其他人（读者或作者）将被阻止，而作者<br>
正在修改或写入数据，并被取消阻止，直到写入程序完成写入。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">注册(Registry)模式</title>
    <id>https://ujava.cn/design/other/registry.html</id>
    <link href="https://ujava.cn/design/other/registry.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>存储单个类的对象，并提供对它们的全局访问点。<br>
与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>存储单个类的对象，并提供对它们的全局访问点。<br>
与Multiton模式类似，唯一的区别是在注册表中对对象的数量没有限制。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">存储库(Repository)模式</title>
    <id>https://ujava.cn/design/other/repository.html</id>
    <link href="https://ujava.cn/design/other/repository.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>存储库层添加在域和数据映射层之间，以将域对象与<br>
数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>
存储库模式在域类数量很大或很重的系统中特别有用<br>
利用查询。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>存储库层添加在域和数据映射层之间，以将域对象与<br>
数据库访问代码的详细信息，并最大限度地减少查询代码的分散和重复。这个<br>
存储库模式在域类数量很大或很重的系统中特别有用<br>
利用查询。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">资源获取即初始化模式</title>
    <id>https://ujava.cn/design/other/resourceacquisitioninit.html</id>
    <link href="https://ujava.cn/design/other/resourceacquisitioninit.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>资源获取即初始化模式可用于实现异常安全的资源管理。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">重试(Retry)模式</title>
    <id>https://ujava.cn/design/other/retry.html</id>
    <link href="https://ujava.cn/design/other/retry.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>透明地重试涉及与外部资源通信的某些操作，<br>
特别是在网络上，将调用代码与重试实现细节隔离开来。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>透明地重试涉及与外部资源通信的某些操作，<br>
特别是在网络上，将调用代码与重试实现细节隔离开来。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">角色对象(Role Object)模式</title>
    <id>https://ujava.cn/design/other/roleobject.html</id>
    <link href="https://ujava.cn/design/other/roleobject.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>
对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>
单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过透明附加的角色对象使对象适应不同客户端的需求，每个对象代表一个角色<br>
对象必须在该客户端的上下文中播放。对象动态管理其角色集。通过将角色表示为<br>
单独的对象、不同的上下文是分开的，并且简化了系统配置。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务(Saga)模式</title>
    <id>https://ujava.cn/design/other/saga.html</id>
    <link href="https://ujava.cn/design/other/saga.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>
这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>
在分布式环境中</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>这种模式用于分布式服务，以原子方式执行一组操作。<br>
这是数据库中事务的模拟，但就微服务架构而言，这是执行的<br>
在分布式环境中</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">分离接口模式</title>
    <id>https://ujava.cn/design/other/separatedinterface.html</id>
    <link href="https://ujava.cn/design/other/separatedinterface.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在不同的包中分离接口定义和实现。这允许客户端<br>
完全不知道实现。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在不同的包中分离接口定义和实现。这允许客户端<br>
完全不知道实现。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">序列化实体模式</title>
    <id>https://ujava.cn/design/other/serializedentity.html</id>
    <link href="https://ujava.cn/design/other/serializedentity.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>序列化实体模式。<br>
序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>序列化实体模式。<br>
序列化实体模式使我们能够轻松地将Java对象持久化到数据库中。它使用Serializable接口和DAO模式。序列化实体模式将首先使用Serializable将Java对象转换为一组字节，然后使用DAO模式将这组字节作为BLOB存储到数据库中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">雇工(Servant)模式</title>
    <id>https://ujava.cn/design/other/servant.html</id>
    <link href="https://ujava.cn/design/other/servant.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务层模式</title>
    <id>https://ujava.cn/design/other/servicelayer.html</id>
    <link href="https://ujava.cn/design/other/servicelayer.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Servant用于为一组类提供一些行为。<br>
而不是在每个类中定义这种行为——或者当我们无法将其排除在外时<br>
公共父类中的这种行为-它在Servant中定义过一次。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务定位模式</title>
    <id>https://ujava.cn/design/other/servicelocator.html</id>
    <link href="https://ujava.cn/design/other/servicelocator.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用封装获取服务所涉及的过程<br>
强抽象层。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用封装获取服务所涉及的过程<br>
强抽象层。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">服务工作者模式</title>
    <id>https://ujava.cn/design/other/serviceworker.html</id>
    <link href="https://ujava.cn/design/other/serviceworker.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>将控制器和调度程序与视图和助手相结合，以处理客户端请求并准备一个动态演示作为响应。控制器将内容检索委托给助手，后者管理视图的中间模型的填充。调度器负责视图管理和导航，可以封装在控制器或单独的组件中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">分区(Sharding)模式</title>
    <id>https://ujava.cn/design/other/sharding.html</id>
    <link href="https://ujava.cn/design/other/sharding.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>
shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Sharding模式意味着将数据存储划分为水平分区或碎片。每个shard都有相同的模式，但拥有自己不同的数据子集。<br>
shard本身就是一个数据存储（它可以包含许多不同类型实体的数据），在充当存储节点的服务器上运行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">空间分区模式</title>
    <id>https://ujava.cn/design/other/spatialpartition.html</id>
    <link href="https://ujava.cn/design/other/spatialpartition.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>正如<a href="http://gameprogrammingpatterns.com/spatial-partition.html" target="_blank" rel="noopener noreferrer">《游戏编程模式》</a>一书中所解释的那样<br>
Bob Nystrom认为，空间分区模式通过将对象存储在<br>
按位置组织的数据结构。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>正如<a href="http://gameprogrammingpatterns.com/spatial-partition.html" target="_blank" rel="noopener noreferrer">《游戏编程模式》</a>一书中所解释的那样<br>
Bob Nystrom认为，空间分区模式通过将对象存储在<br>
按位置组织的数据结构。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">特殊例子模式</title>
    <id>https://ujava.cn/design/other/specialcase.html</id>
    <link href="https://ujava.cn/design/other/specialcase.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>定义一些特殊情况，并将它们封装到提供不同特殊行为的子类中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">规范(Specification)模式</title>
    <id>https://ujava.cn/design/other/specification.html</id>
    <link href="https://ujava.cn/design/other/specification.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>
与之匹配的。它不仅在选择中有用，而且对<br>
验证和按订单建造。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>规范模式将如何匹配候选对象的语句与候选对象分开<br>
与之匹配的。它不仅在选择中有用，而且对<br>
验证和按订单建造。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">步骤建立者模式</title>
    <id>https://ujava.cn/design/other/stepbuilder.html</id>
    <link href="https://ujava.cn/design/other/stepbuilder.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>
用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Builder模式的扩展，它完全指导用户创建对象，不会出现混淆。<br>
用户体验将得到更大的改善，因为他只会看到下一步可用的方法，在正确的时间构建对象之前没有构建方法。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">扼杀者(Strangler)模式</title>
    <id>https://ujava.cn/design/other/strangler.html</id>
    <link href="https://ujava.cn/design/other/strangler.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>
新的应用程序和服务。随着旧系统的功能被替换<br>
系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>
扼杀旧系统，让你退役。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过逐步替换特定的功能，逐步迁移遗留系统<br>
新的应用程序和服务。随着旧系统的功能被替换<br>
系统最终覆盖了旧系统的所有功能，并可能具有自己的新功能，然后<br>
扼杀旧系统，让你退役。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">子类沙盒模式</title>
    <id>https://ujava.cn/design/other/subclasssandbox.html</id>
    <link href="https://ujava.cn/design/other/subclasssandbox.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>子类沙盒模式描述了一个基本思想，但没有很多详细的机制。当您有几个类似的子类时，您将需要该模式。如果你必须做一个微小的改变，那么就改变基类，而所有的子类都不应该被触及。因此基类必须能够提供派生类需要执行的所有操作。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">表模块(Table Module)模式</title>
    <id>https://ujava.cn/design/other/tablemodule.html</id>
    <link href="https://ujava.cn/design/other/tablemodule.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>表模块通过数据库中每个表一个类来组织域逻辑，并且类的单个实例包含将对数据进行操作的各种过程。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">模版方法模式</title>
    <id>https://ujava.cn/design/other/templatemethod.html</id>
    <link href="https://ujava.cn/design/other/templatemethod.html"/>
    <updated>2024-03-04T07:22:04.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>
方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>
结构</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>在操作中定义算法的骨架，将一些步骤推迟到子类中。样板<br>
方法允许子类在不更改算法的情况下重新定义算法的某些步骤<br>
结构</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">本地线程存储模式</title>
    <id>https://ujava.cn/design/other/threadlocalstorage.html</id>
    <link href="https://ujava.cn/design/other/threadlocalstorage.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供为每个线程提供一个变量副本的功能，使其线程安全。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">线程池模式</title>
    <id>https://ujava.cn/design/other/threadpool.html</id>
    <link href="https://ujava.cn/design/other/threadpool.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>
为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>
线程而不是执行实际任务。线程池通过重用现有的<br>
线程，并消除创建新线程的延迟。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通常情况下，要执行的任务是短暂的，并且任务数量很大。<br>
为每个任务创建一个新线程会使系统花费更多的时间来创建和销毁<br>
线程而不是执行实际任务。线程池通过重用现有的<br>
线程，并消除创建新线程的延迟。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">节流(Throttling)模式</title>
    <id>https://ujava.cn/design/other/throttling.html</id>
    <link href="https://ujava.cn/design/other/throttling.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>确保给定的客户端访问服务资源的次数不能超过指定的限制。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">读者容错模式</title>
    <id>https://ujava.cn/design/other/tolerantreader.html</id>
    <link href="https://ujava.cn/design/other/tolerantreader.html"/>
    <updated>2024-03-04T07:22:04.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>
是在从另一个服务读取数据时尽可能宽容。这样，当<br>
交流模式发生变化，读者一定不能断。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Tolerant Reader是一种集成模式，有助于创建健壮的通信系统。这个想法<br>
是在从另一个服务读取数据时尽可能宽容。这样，当<br>
交流模式发生变化，读者一定不能断。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">蹦床(Trampoline)模式</title>
    <id>https://ujava.cn/design/other/trampoline.html</id>
    <link href="https://ujava.cn/design/other/trampoline.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>
并且交织功能的执行而不将它们硬编码在一起。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Trampoline模式用于在不破坏堆栈的情况下在Java中递归地实现算法<br>
并且交织功能的执行而不将它们硬编码在一起。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务脚本模式</title>
    <id>https://ujava.cn/design/other/transactionscript.html</id>
    <link href="https://ujava.cn/design/other/transactionscript.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>
来自演示文稿的请求。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>事务脚本按过程组织业务逻辑，其中每个过程处理一个<br>
来自演示文稿的请求。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">双(Twin)模式</title>
    <id>https://ujava.cn/design/other/twin.html</id>
    <link href="https://ujava.cn/design/other/twin.html"/>
    <updated>2024-03-04T06:36:55.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>
java中的继承</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>双模式是一种设计模式，它提供了一个标准的解决方案来模拟多个<br>
java中的继承</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">事务脚本模式</title>
    <id>https://ujava.cn/design/other/typeobject.html</id>
    <link href="https://ujava.cn/design/other/typeobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当创建基类并从中继承的OOP概念不适用于当前情况时，类型对象模式就是我们使用的模式。当我们不知道预先需要什么类型，或者希望能够在不重复重新编译的情况下方便地修改或添加新类型时，就会发生这种情况。该模式提供了一种解决方案，允许通过创建一个类来灵活地创建所需的对象，该类具有一个表示对象“类型”的字段。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">工作单元模式</title>
    <id>https://ujava.cn/design/other/unitofwork.html</id>
    <link href="https://ujava.cn/design/other/unitofwork.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>
一次性持久化，以最大限度地减少数据库往返。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>当业务事务完成时，所有更新都作为一个大的工作单元发送<br>
一次性持久化，以最大限度地减少数据库往返。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">更新方法模式</title>
    <id>https://ujava.cn/design/other/updatemethod.html</id>
    <link href="https://ujava.cn/design/other/updatemethod.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>更新方法模式通过告诉每个对象一次处理一帧行为来模拟独立对象的集合。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">值对象模式</title>
    <id>https://ujava.cn/design/other/valueobject.html</id>
    <link href="https://ujava.cn/design/other/valueobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>提供遵循值语义而不是引用语义的对象。<br>
这意味着值对象的相等性不是基于身份的。两个值对象是<br>
当它们具有相同的值时相等，而不一定是同一对象。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>提供遵循值语义而不是引用语义的对象。<br>
这意味着值对象的相等性不是基于身份的。两个值对象是<br>
当它们具有相同的值时相等，而不一定是同一对象。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">版本号模式</title>
    <id>https://ujava.cn/design/other/versionnumber.html</id>
    <link href="https://ujava.cn/design/other/versionnumber.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>版本号模式有助于解决应用程序中的并发冲突。通常，当多个客户端试图同时更新同一记录时，这些冲突会出现在数据库操作中。解决此类冲突需要确定对象是否已更改。因此，我们需要一个版本号，该版本号随着底层数据（例如数据库）的每次更改而递增。存储库可以使用版本号来检查外部更改并向用户报告并发问题。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T06:36:55.000Z</published>
  </entry>
  <entry>
    <title type="text">页面对象模式</title>
    <id>https://ujava.cn/design/other/pageobject.html</id>
    <link href="https://ujava.cn/design/other/pageobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>
组件。这样一来，它允许测试类本身专注于测试逻辑。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Page 对象封装 UI，隐藏应用程序（通常是 Web 应用程序）的基础 UI 小组件，并提供特定于应用程序的 API，以允许操作测试所需的 UI<br>
组件。这样一来，它允许测试类本身专注于测试逻辑。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">参数对象模式</title>
    <id>https://ujava.cn/design/other/parameterobject.html</id>
    <link href="https://ujava.cn/design/other/parameterobject.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Java 语言的语法不允许使用参数的预定义值声明方法。在 Java 中实现默认方法参数的最佳选择可能是使用方法重载。方法重载允许您声明多个具有相同名称但参数数量不同的方法。但是，当方法接受多个参数时，方法重载作为默认参数值解决方案的主要问题就会显现出来。为每个可能的参数组合创建重载方法可能很麻烦。为了解决此问题，使用了 Parameter Object 模式。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">部分响应模式</title>
    <id>https://ujava.cn/design/other/partialresponse.html</id>
    <link href="https://ujava.cn/design/other/partialresponse.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>根据需要将部分响应从服务器发送到客户端。客户端将指定它需要服务器的字段，而不是提供资源的所有详细信息。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">管道(Pipeline)模式</title>
    <id>https://ujava.cn/design/other/pipeline.html</id>
    <link href="https://ujava.cn/design/other/pipeline.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>通过提供初始输入并将处理后的输出传递给下一阶段使用，允许在一系列阶段中处理数据。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">毒丸(Poison Pill)模式</title>
    <id>https://ujava.cn/design/other/poisonpill.html</id>
    <link href="https://ujava.cn/design/other/poisonpill.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>毒丸（Poison Pill）是已知的预定义数据项，允许为单独的分布式消费过程提供正常关闭。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">演示模型模式</title>
    <id>https://ujava.cn/design/other/presentationmodel.html</id>
    <link href="https://ujava.cn/design/other/presentationmodel.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>演示模型将视图的状态和行为拉出到作为演示的一部分的模型类中。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">优先级队列模式</title>
    <id>https://ujava.cn/design/other/priorityqueue.html</id>
    <link href="https://ujava.cn/design/other/priorityqueue.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>对发送到服务的请求进行优先级排序，以便比优先级较低的请求更快地接收和处理优先级较高的请求。此模式在为各个客户端提供不同服务级别保证的应用程序中非常有用。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">私有类数据模式</title>
    <id>https://ujava.cn/design/other/privateclassdata.html</id>
    <link href="https://ujava.cn/design/other/privateclassdata.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>私有类数据设计模式旨在通过限制属性的可见性来减少属性的暴露。它通过将类属性封装在单个 Data 对象中来减少类属性的数量。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">生产者消费者模式</title>
    <id>https://ujava.cn/design/other/producerconsumer.html</id>
    <link href="https://ujava.cn/design/other/producerconsumer.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>生产者消费者设计模式是一种经典的并发模式，它通过将工作标识与工作执行分开来减少生产者和消费者之间的耦合。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">承诺(Promise)模式</title>
    <id>https://ujava.cn/design/other/promise.html</id>
    <link href="https://ujava.cn/design/other/promise.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>Promise 表示创建 Promise 时不一定知道的值的代理。它允许您将依赖承诺与异步操作的最终成功值或失败原因相关联。Promise 是一种编写异步代码的方法，该代码看起来仍然像是以同步方式执行。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">属性(Property)模式</title>
    <id>https://ujava.cn/design/other/property.html</id>
    <link href="https://ujava.cn/design/other/property.html"/>
    <updated>2024-03-04T03:06:02.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用现有对象作为父对象创建对象和新对象的层次结构。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">基于队列的负载均衡模式</title>
    <id>https://ujava.cn/design/other/queuebasedloadlevel.html</id>
    <link href="https://ujava.cn/design/other/queuebasedloadlevel.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>使用充当任务与其调用的服务之间的缓冲区的队列，以平滑可能导致服务失败或任务超时的间歇性重负载。此模式有助于最大程度地减少需求高峰对任务和服务的可用性和响应能力的影响。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T03:06:02.000Z</published>
  </entry>
  <entry>
    <title type="text">页面控制模式</title>
    <id>https://ujava.cn/design/other/pagecontroller.html</id>
    <link href="https://ujava.cn/design/other/pagecontroller.html"/>
    <updated>2024-03-04T07:11:24.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>这是一种一个页面通向一个逻辑文件的方法，该文件处理网站上的操作或请求。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T02:16:14.000Z</published>
  </entry>
  <entry>
    <title type="text">层模式</title>
    <id>https://ujava.cn/design/other/layers.html</id>
    <link href="https://ujava.cn/design/other/layers.html"/>
    <updated>2024-03-04T01:48:41.000Z</updated>
    <summary type="html"><![CDATA[<h2> 概述</h2>
<p>层是一种体系结构模式，其中软件职责在不同的</p>
<p>应用程序的层。</p>
]]></summary>
    <content type="html"><![CDATA[<h2> 概述</h2>
<p>层是一种体系结构模式，其中软件职责在不同的</p>
<p>应用程序的层。</p>
]]></content>
    <category term="设计模式"/>
    <published>2024-03-04T01:48:41.000Z</published>
  </entry>
</feed>